import { Derived } from "../Derived.js";
import { getDefaultPeers } from "../attachDefaultPeers.js";
import { tapMemo } from "@assistant-ui/tap";
/**
 * Splits a clients object into root clients and derived clients.
 *
 * @param clients - The clients input object to split
 * @returns An object with { rootClients, derivedClients }
 *
 * @example
 * ```typescript
 * const clients = {
 *   foo: RootClient({ ... }),
 *   bar: Derived({ ... }),
 * };
 *
 * const { rootClients, derivedClients } = splitClients(clients);
 * // rootClients = { foo: ... }
 * // derivedClients = { bar: ... }
 * ```
 */
function splitClients(clients, baseClient) {
    const rootClients = {};
    const derivedClients = {};
    for (const [key, clientElement] of Object.entries(clients)) {
        if (clientElement.type === Derived) {
            derivedClients[key] = clientElement;
        }
        else {
            rootClients[key] = clientElement;
        }
    }
    // Recursively gather all default peers, flattening nested ones
    const gatherDefaultPeers = (clientElement, visited = new Set()) => {
        // Prevent infinite loops
        if (visited.has(clientElement))
            return [];
        visited.add(clientElement);
        const defaultPeers = getDefaultPeers(clientElement.type);
        if (!defaultPeers)
            return [];
        const result = [];
        for (const [key, peerElement] of Object.entries(defaultPeers)) {
            result.push([key, peerElement]);
            // If this peer is a root client with its own default peers, recursively gather them
            if (peerElement.type !== (Derived)) {
                const nestedPeers = gatherDefaultPeers(peerElement, visited);
                result.push(...nestedPeers);
            }
        }
        return result;
    };
    // Apply flattened default peers for each root client
    for (const [_clientKey, clientElement] of Object.entries(rootClients)) {
        const allPeers = gatherDefaultPeers(clientElement);
        for (const [key, peerElement] of allPeers) {
            // Skip if already exists (first wins)
            if (key in rootClients ||
                key in derivedClients ||
                baseClient[key].source !== null)
                continue;
            if (peerElement.type === (Derived)) {
                derivedClients[key] = peerElement;
            }
            else {
                rootClients[key] = peerElement;
            }
        }
    }
    return { rootClients, derivedClients };
}
const tapShallowMemoObject = (object) => {
    // biome-ignore lint/correctness/useExhaustiveDependencies: shallow memo
    return tapMemo(() => object, [...Object.entries(object).flat()]);
};
export const tapSplitClients = (clients, baseClient) => {
    const { rootClients, derivedClients } = splitClients(clients, baseClient);
    return {
        rootClients: tapShallowMemoObject(rootClients),
        derivedClients: tapShallowMemoObject(derivedClients),
    };
};
//# sourceMappingURL=splitClients.js.map