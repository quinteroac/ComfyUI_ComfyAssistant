"use client";
import { useState, useMemo } from "react";
import { isToolUIPart } from "ai";
import { useExternalStoreRuntime, useRuntimeAdapters, INTERNAL, getExternalStoreMessages, } from "@assistant-ui/react";
import { sliceMessagesUntil } from "../utils/sliceMessagesUntil.js";
import { toCreateMessage } from "../utils/toCreateMessage.js";
import { vercelAttachmentAdapter } from "../utils/vercelAttachmentAdapter.js";
import { getVercelAIMessages } from "../getVercelAIMessages.js";
import { AISDKMessageConverter } from "../utils/convertMessage.js";
import { aiSDKV6FormatAdapter, } from "../adapters/aiSDKFormatAdapter.js";
import { useExternalHistory, toExportedMessageRepository, } from "./useExternalHistory.js";
export const useAISDKRuntime = (chatHelpers, { adapters, toCreateMessage: customToCreateMessage, cancelPendingToolCallsOnSend = true, } = {}) => {
    const contextAdapters = useRuntimeAdapters();
    const [toolStatuses, setToolStatuses] = useState({});
    const hasExecutingTools = Object.values(toolStatuses).some((s) => s?.type === "executing");
    const isRunning = chatHelpers.status === "submitted" ||
        chatHelpers.status === "streaming" ||
        hasExecutingTools;
    const messages = AISDKMessageConverter.useThreadMessages({
        isRunning,
        messages: chatHelpers.messages,
        metadata: useMemo(() => ({
            toolStatuses,
            ...(chatHelpers.error && { error: chatHelpers.error.message }),
        }), [toolStatuses, chatHelpers.error]),
    });
    const [runtimeRef] = useState(() => ({
        get current() {
            return runtime;
        },
    }));
    const toolInvocations = INTERNAL.useToolInvocations({
        state: {
            messages,
            isRunning,
        },
        getTools: () => runtimeRef.current.thread.getModelContext().tools,
        onResult: (command) => {
            if (command.type === "add-tool-result") {
                chatHelpers.addToolResult({
                    tool: command.toolName,
                    toolCallId: command.toolCallId,
                    output: command.result,
                });
            }
        },
        setToolStatuses,
    });
    const isLoading = useExternalHistory(runtimeRef, adapters?.history ?? contextAdapters?.history, AISDKMessageConverter.toThreadMessages, aiSDKV6FormatAdapter, (messages) => {
        chatHelpers.setMessages(messages);
    });
    const completePendingToolCalls = async () => {
        if (!cancelPendingToolCallsOnSend)
            return;
        await toolInvocations.abort();
        // Mark any tool without a result as cancelled (uses setMessages to avoid triggering sendAutomaticallyWhen)
        chatHelpers.setMessages((messages) => {
            const lastMessage = messages.at(-1);
            if (lastMessage?.role !== "assistant")
                return messages;
            let hasChanges = false;
            const parts = lastMessage.parts?.map((part) => {
                if (!isToolUIPart(part))
                    return part;
                if (part.state === "output-available" || part.state === "output-error")
                    return part;
                hasChanges = true;
                return {
                    ...part,
                    state: "output-error",
                    errorText: "User cancelled tool call by sending a new message.",
                };
            });
            if (!hasChanges)
                return messages;
            return [...messages.slice(0, -1), { ...lastMessage, parts }];
        });
    };
    const runtime = useExternalStoreRuntime({
        isRunning,
        messages,
        setMessages: (messages) => chatHelpers.setMessages(messages
            .map((getVercelAIMessages))
            .filter(Boolean)
            .flat()),
        onImport: (messages) => chatHelpers.setMessages(messages
            .map((getVercelAIMessages))
            .filter(Boolean)
            .flat()),
        onExportExternalState: () => {
            // Export the thread's MessageRepository
            const exported = runtimeRef.current.thread.export();
            // Convert each ThreadMessage back to its original UI_MESSAGE format
            const result = {
                messages: exported.messages.map((item) => ({
                    parentId: item.parentId,
                    message: getExternalStoreMessages(item.message)[0],
                })),
            };
            // Only include headId if it's defined
            if (exported.headId !== undefined) {
                result.headId = exported.headId;
            }
            return result;
        },
        onLoadExternalState: (repo) => {
            // Convert MessageFormatRepository to ExportedMessageRepository
            const exportedRepo = toExportedMessageRepository(AISDKMessageConverter.toThreadMessages, repo);
            // Import into the thread's MessageRepository
            runtimeRef.current.thread.import(exportedRepo);
        },
        onCancel: async () => {
            chatHelpers.stop();
            await toolInvocations.abort();
        },
        onNew: async (message) => {
            await completePendingToolCalls();
            const createMessage = (customToCreateMessage ?? toCreateMessage)(message);
            await chatHelpers.sendMessage(createMessage, {
                metadata: message.runConfig,
            });
        },
        onEdit: async (message) => {
            const newMessages = sliceMessagesUntil(chatHelpers.messages, message.parentId);
            chatHelpers.setMessages(newMessages);
            const createMessage = (customToCreateMessage ?? toCreateMessage)(message);
            await chatHelpers.sendMessage(createMessage, {
                metadata: message.runConfig,
            });
        },
        onReload: async (parentId, config) => {
            const newMessages = sliceMessagesUntil(chatHelpers.messages, parentId);
            chatHelpers.setMessages(newMessages);
            await chatHelpers.regenerate({ metadata: config.runConfig });
        },
        onAddToolResult: ({ toolCallId, result, isError }) => {
            if (isError) {
                chatHelpers.addToolOutput({
                    state: "output-error",
                    tool: toolCallId,
                    toolCallId,
                    errorText: typeof result === "string" ? result : JSON.stringify(result),
                });
            }
            else {
                chatHelpers.addToolOutput({
                    state: "output-available",
                    tool: toolCallId,
                    toolCallId,
                    output: result,
                });
            }
        },
        onResumeToolCall: (options) => toolInvocations.resume(options.toolCallId, options.payload),
        adapters: {
            attachments: vercelAttachmentAdapter,
            ...contextAdapters,
            ...adapters,
        },
        isLoading,
    });
    return runtime;
};
//# sourceMappingURL=useAISDKRuntime.js.map