import { createResourceFiber, unmountResourceFiber, renderResourceFiber, commitResourceFiber, } from "./ResourceFiber.js";
import { flushResourcesSync, UpdateScheduler } from "./scheduler.js";
import { tapRef } from "../hooks/tap-ref.js";
import { tapState } from "../hooks/tap-state.js";
import { tapMemo } from "../hooks/tap-memo.js";
import { tapEffect } from "../hooks/tap-effect.js";
import { resource } from "./resource.js";
import { tapResource } from "../hooks/tap-resource.js";
import { tapConst } from "../hooks/tap-const.js";
import { getDevStrictMode } from "./execution-context.js";
import { isDevelopment } from "./env.js";
const HandleWrapperResource = resource((state) => {
    const [, setElement] = tapState(state.elementRef.current);
    const output = tapResource(state.elementRef.current);
    const subscribers = tapConst(() => new Set(), []);
    const valueRef = tapRef(output);
    tapEffect(() => {
        if (output !== valueRef.current) {
            valueRef.current = output;
            subscribers.forEach((callback) => callback());
        }
    });
    const handle = tapMemo(() => ({
        getValue: () => valueRef.current,
        subscribe: (callback) => {
            subscribers.add(callback);
            return () => subscribers.delete(callback);
        },
        render: (el) => {
            const changed = state.elementRef.current !== el;
            state.elementRef.current = el;
            if (state.onRender(changed)) {
                setElement(el);
            }
        },
        unmount: state.onUnmount,
    }), [state]);
    return handle;
});
export const createResource = (element, { mount = true, devStrictMode = false, } = {}) => {
    let isMounted = mount;
    let render;
    const props = {
        elementRef: { current: element },
        onRender: (changed) => {
            if (isMounted)
                return changed;
            isMounted = true;
            if (isDevelopment &&
                fiber.isNeverMounted &&
                fiber.devStrictMode === "child") {
                if (changed) {
                    render = renderResourceFiber(fiber, props);
                }
                commitResourceFiber(fiber, render);
            }
            else {
                flushResourcesSync(() => {
                    if (changed) {
                        // In strict mode, render twice to detect side effects
                        if (isDevelopment && fiber.devStrictMode === "root") {
                            void renderResourceFiber(fiber, props);
                        }
                        render = renderResourceFiber(fiber, props);
                    }
                    if (scheduler.isDirty)
                        return;
                    commitResourceFiber(fiber, render);
                });
            }
            return false;
        },
        onUnmount: () => {
            if (!isMounted)
                throw new Error("Resource not mounted");
            isMounted = false;
            unmountResourceFiber(fiber);
        },
    };
    const scheduler = new UpdateScheduler(() => {
        // In strict mode, render twice to detect side effects
        if (isDevelopment &&
            (fiber.devStrictMode === "root" ||
                (fiber.devStrictMode && !fiber.isFirstRender))) {
            void renderResourceFiber(fiber, props);
        }
        render = renderResourceFiber(fiber, props);
        if (scheduler.isDirty || !isMounted)
            return;
        commitResourceFiber(fiber, render);
    });
    const fiber = createResourceFiber((HandleWrapperResource), (callback) => {
        if (callback())
            scheduler.markDirty();
    }, getDevStrictMode(devStrictMode));
    flushResourcesSync(() => {
        scheduler.markDirty();
    });
    return render.output;
};
//# sourceMappingURL=createResource.js.map