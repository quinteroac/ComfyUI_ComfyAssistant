import { isDevelopment } from "../core/env.js";
import { getCurrentResourceFiber } from "../core/execution-context.js";
const dispatchOnFiber = (fiber, callback) => {
    if (fiber.renderContext) {
        throw new Error("Resource updated during render");
    }
    if (fiber.isMounted) {
        // Only schedule rerender if currently mounted
        fiber.dispatchUpdate(callback);
    }
    else if (fiber.isNeverMounted) {
        throw new Error("Resource updated before mount");
    }
    // TODO mark dirty
};
function getStateCell(initialValue) {
    const fiber = getCurrentResourceFiber();
    const index = fiber.currentIndex++;
    // Check if we're trying to use more hooks than in previous renders
    if (!fiber.isFirstRender && index >= fiber.cells.length) {
        throw new Error("Rendered more hooks than during the previous render. " +
            "Hooks must be called in the exact same order in every render.");
    }
    const cell = fiber.cells[index];
    if (cell) {
        if (cell.type !== "state")
            throw new Error("Hook order changed between renders");
        return cell;
    }
    const value = typeof initialValue === "function"
        ? initialValue()
        : initialValue;
    if (isDevelopment &&
        fiber.devStrictMode &&
        typeof initialValue === "function") {
        void initialValue();
    }
    const newCell = {
        type: "state",
        value,
        set: (updater) => {
            dispatchOnFiber(fiber, () => {
                const currentValue = newCell.value;
                const nextValue = typeof updater === "function"
                    ? updater(currentValue)
                    : updater;
                if (isDevelopment &&
                    fiber.devStrictMode &&
                    typeof updater === "function") {
                    void updater(currentValue);
                }
                if (Object.is(currentValue, nextValue))
                    return false;
                newCell.value = nextValue;
                return true;
            });
        },
    };
    fiber.cells[index] = newCell;
    return newCell;
}
export function tapState(initial) {
    const cell = getStateCell(initial);
    return [cell.value, cell.set];
}
//# sourceMappingURL=tap-state.js.map