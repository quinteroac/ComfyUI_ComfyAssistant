import { resource, tapInlineResource, tapMemo, tapEffect, withKey, } from "@assistant-ui/tap";
import { tapAssistantEmit, tapClientLookup, tapClientResource, } from "@assistant-ui/store";
import { ComposerClient } from "./ComposerRuntimeClient.js";
import { MessageClient } from "./MessageRuntimeClient.js";
import { tapSubscribable } from "../util-hooks/tapSubscribable.js";
const MessageClientById = resource(({ runtime, id, threadIdRef, }) => {
    const messageRuntime = tapMemo(() => runtime.getMessageById(id), [runtime, id]);
    return tapInlineResource(MessageClient({ runtime: messageRuntime, threadIdRef }));
});
export const ThreadClient = resource(({ runtime }) => {
    const runtimeState = tapSubscribable(runtime);
    const emit = tapAssistantEmit();
    // Bind thread events to event manager
    tapEffect(() => {
        const unsubscribers = [];
        // Subscribe to thread events
        const threadEvents = [
            "runStart",
            "runEnd",
            "initialize",
            "modelContextUpdate",
        ];
        for (const event of threadEvents) {
            const unsubscribe = runtime.unstable_on(event, () => {
                const threadId = runtime.getState()?.threadId || "unknown";
                emit(`thread.${event}`, {
                    threadId,
                });
            });
            unsubscribers.push(unsubscribe);
        }
        return () => {
            for (const unsub of unsubscribers)
                unsub();
        };
    }, [runtime, emit]);
    const threadIdRef = tapMemo(() => ({
        get current() {
            return runtime.getState().threadId;
        },
    }), [runtime]);
    const composer = tapClientResource(ComposerClient({
        runtime: runtime.composer,
        threadIdRef,
    }));
    const messages = tapClientLookup(() => runtimeState.messages.map((m) => withKey(m.id, MessageClientById({ runtime, id: m.id, threadIdRef }))), [runtimeState.messages, runtime, threadIdRef]);
    const state = tapMemo(() => {
        return {
            isEmpty: messages.state.length === 0 && !runtimeState.isLoading,
            isDisabled: runtimeState.isDisabled,
            isLoading: runtimeState.isLoading,
            isRunning: runtimeState.isRunning,
            capabilities: runtimeState.capabilities,
            state: runtimeState.state,
            suggestions: runtimeState.suggestions,
            extras: runtimeState.extras,
            speech: runtimeState.speech,
            composer: composer.state,
            messages: messages.state,
        };
    }, [runtimeState, messages, composer.state]);
    return {
        state,
        methods: {
            getState: () => state,
            composer: composer.methods,
            append: runtime.append,
            startRun: runtime.startRun,
            unstable_resumeRun: runtime.unstable_resumeRun,
            cancelRun: runtime.cancelRun,
            getModelContext: runtime.getModelContext,
            export: runtime.export,
            import: runtime.import,
            reset: runtime.reset,
            stopSpeaking: runtime.stopSpeaking,
            startVoice: async () => {
                throw new Error("startVoice is not supported in this runtime");
            },
            stopVoice: async () => {
                throw new Error("stopVoice is not supported in this runtime");
            },
            message: (selector) => {
                if ("id" in selector) {
                    return messages.get({ key: selector.id });
                }
                else {
                    return messages.get(selector);
                }
            },
            __internal_getRuntime: () => runtime,
        },
    };
});
//# sourceMappingURL=ThreadRuntimeClient.js.map