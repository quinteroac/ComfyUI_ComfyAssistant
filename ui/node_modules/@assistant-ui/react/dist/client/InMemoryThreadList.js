import { resource, tapState, tapMemo } from "@assistant-ui/tap";
import { tapClientLookup, Derived, attachDefaultPeers, tapClientResource, } from "@assistant-ui/store";
import { withKey } from "@assistant-ui/tap";
import { Suggestions } from "./Suggestions.js";
import { ModelContext } from "./ModelContextClient.js";
import { Tools } from "./Tools.js";
// ThreadListItem Client
const ThreadListItemClient = resource((props) => {
    const { data, onSwitchTo, onArchive, onUnarchive, onDelete } = props;
    const state = tapMemo(() => ({
        id: data.id,
        remoteId: undefined,
        externalId: undefined,
        title: data.title,
        status: data.status,
    }), [data.id, data.title, data.status]);
    return {
        state,
        methods: {
            getState: () => state,
            switchTo: onSwitchTo,
            rename: () => { },
            archive: onArchive,
            unarchive: onUnarchive,
            delete: onDelete,
            generateTitle: () => { },
            initialize: async () => ({ remoteId: data.id, externalId: undefined }),
            detach: () => { },
        },
    };
});
// InMemoryThreadList Client
export const InMemoryThreadList = resource((props) => {
    const { thread: threadFactory, onSwitchToThread, onSwitchToNewThread, } = props;
    const [mainThreadId, setMainThreadId] = tapState("main");
    const [threads, setThreads] = tapState(() => [
        { id: "main", title: "Main Thread", status: "regular" },
    ]);
    const handleSwitchToThread = (threadId) => {
        setMainThreadId(threadId);
        onSwitchToThread?.(threadId);
    };
    const handleArchive = (threadId) => {
        setThreads((prev) => prev.map((t) => t.id === threadId ? { ...t, status: "archived" } : t));
    };
    const handleUnarchive = (threadId) => {
        setThreads((prev) => prev.map((t) => t.id === threadId ? { ...t, status: "regular" } : t));
    };
    const handleDelete = (threadId) => {
        setThreads((prev) => prev.filter((t) => t.id !== threadId));
        if (mainThreadId === threadId) {
            const remaining = threads.filter((t) => t.id !== threadId);
            setMainThreadId(remaining[0]?.id || "main");
        }
    };
    const handleSwitchToNewThread = () => {
        const newId = `thread-${Date.now()}`;
        setThreads((prev) => [
            ...prev,
            { id: newId, title: "New Thread", status: "regular" },
        ]);
        setMainThreadId(newId);
        onSwitchToNewThread?.();
    };
    const threadListItems = tapClientLookup(() => threads.map((t) => withKey(t.id, ThreadListItemClient({
        data: t,
        onSwitchTo: () => handleSwitchToThread(t.id),
        onArchive: () => handleArchive(t.id),
        onUnarchive: () => handleUnarchive(t.id),
        onDelete: () => handleDelete(t.id),
    }))), [threads]);
    // Create the main thread
    const mainThreadClient = tapClientResource(threadFactory(mainThreadId));
    const state = tapMemo(() => {
        const regularThreads = threads.filter((t) => t.status === "regular");
        const archivedThreads = threads.filter((t) => t.status === "archived");
        const mainThreadState = mainThreadClient.state;
        return {
            mainThreadId,
            newThreadId: null,
            isLoading: false,
            threadIds: regularThreads.map((t) => t.id),
            archivedThreadIds: archivedThreads.map((t) => t.id),
            threadItems: threadListItems.state,
            main: mainThreadState,
        };
    }, [mainThreadId, threads, threadListItems.state, mainThreadClient.state]);
    return {
        state,
        methods: {
            getState: () => state,
            switchToThread: handleSwitchToThread,
            switchToNewThread: handleSwitchToNewThread,
            item: (selector) => {
                if (selector === "main") {
                    const index = threads.findIndex((t) => t.id === mainThreadId);
                    return threadListItems.get({ index: index === -1 ? 0 : index });
                }
                if ("id" in selector) {
                    const index = threads.findIndex((t) => t.id === selector.id);
                    return threadListItems.get({ index });
                }
                return threadListItems.get(selector);
            },
            thread: () => mainThreadClient.methods,
        },
    };
});
attachDefaultPeers(InMemoryThreadList, {
    thread: Derived({
        source: "threads",
        query: { type: "main" },
        get: (aui) => aui.threads().thread("main"),
    }),
    threadListItem: Derived({
        source: "threads",
        query: { type: "main" },
        get: (aui) => aui.threads().item("main"),
    }),
    composer: Derived({
        source: "thread",
        query: {},
        get: (aui) => aui.threads().thread("main").composer,
    }),
    modelContext: ModelContext(),
    tools: Tools({}),
    suggestions: Suggestions(),
});
//# sourceMappingURL=InMemoryThreadList.js.map