"use client";
import { resource, tapMemo, tapState, tapInlineResource, withKey, } from "@assistant-ui/tap";
import { tapClientLookup } from "@assistant-ui/store";
import { NoOpComposerClient } from "./NoOpComposerClient.js";
const ThreadMessagePartClient = resource(({ part, }) => {
    const state = tapMemo(() => {
        return {
            ...part,
            status: { type: "complete" },
        };
    }, [part]);
    return {
        state,
        methods: {
            getState: () => state,
            addToolResult: () => {
                throw new Error("Not supported");
            },
            resumeToolCall: () => {
                throw new Error("Not supported");
            },
        },
    };
});
const ThreadMessageAttachmentClient = resource(({ attachment }) => {
    return {
        state: attachment,
        methods: {
            getState: () => attachment,
            remove: () => {
                throw new Error("Not supported");
            },
        },
    };
});
export const ThreadMessageClient = resource(({ message, index, isLast = true, branchNumber = 1, branchCount = 1, }) => {
    const [isCopiedState, setIsCopied] = tapState(false);
    const [isHoveringState, setIsHovering] = tapState(false);
    const parts = tapClientLookup(() => message.content.map((part, idx) => withKey("toolCallId" in part && part.toolCallId != null
        ? `toolCallId-${part.toolCallId}`
        : `index-${idx}`, ThreadMessagePartClient({ part }))), [message.content]);
    const attachments = tapClientLookup(() => (message.attachments ?? []).map((attachment) => withKey(attachment.id, ThreadMessageAttachmentClient({ attachment }))), [message.attachments]);
    const composer = tapInlineResource(NoOpComposerClient({ type: "edit" }));
    const state = tapMemo(() => {
        return {
            ...message,
            parts: parts.state,
            composer: composer.state,
            parentId: null,
            index,
            isLast,
            branchNumber,
            branchCount,
            speech: undefined,
            submittedFeedback: message.metadata.submittedFeedback,
            isCopied: isCopiedState,
            isHovering: isHoveringState,
        };
    }, [
        message,
        index,
        isCopiedState,
        isHoveringState,
        isLast,
        parts.state,
        composer.state,
        branchNumber,
        branchCount,
    ]);
    return {
        state,
        methods: {
            getState: () => state,
            composer: composer.methods,
            part: (selector) => {
                if ("index" in selector) {
                    return parts.get({ index: selector.index });
                }
                else {
                    return parts.get({ key: `toolCallId-${selector.toolCallId}` });
                }
            },
            attachment: (selector) => {
                if ("id" in selector) {
                    return attachments.get({ key: selector.id });
                }
                else {
                    return attachments.get(selector);
                }
            },
            reload: () => {
                throw new Error("Not supported in ThreadMessageProvider");
            },
            speak: () => {
                throw new Error("Not supported in ThreadMessageProvider");
            },
            stopSpeaking: () => {
                throw new Error("Not supported in ThreadMessageProvider");
            },
            submitFeedback: () => {
                throw new Error("Not supported in ThreadMessageProvider");
            },
            switchToBranch: () => {
                throw new Error("Not supported in ThreadMessageProvider");
            },
            getCopyText: () => {
                return message.content
                    .map((part) => {
                    if ("text" in part && typeof part.text === "string") {
                        return part.text;
                    }
                    return "";
                })
                    .join("\n");
            },
            setIsCopied,
            setIsHovering,
        },
    };
});
//# sourceMappingURL=ThreadMessageClient.js.map