import {
  withKey,
  resource,
  tapInlineResource,
  tapMemo,
  tapState,
} from "@assistant-ui/tap";
import {
  type ClientOutput,
  tapClientLookup,
  tapClientResource,
} from "@assistant-ui/store";
import { MessageRuntime } from "../runtime/MessageRuntime";
import { tapSubscribable } from "../util-hooks/tapSubscribable";
import { ComposerClient } from "./ComposerRuntimeClient";
import { MessagePartClient } from "./MessagePartRuntimeClient";
import { RefObject } from "react";
import { MessageState } from "../../types/scopes";
import { AttachmentRuntimeClient } from "./AttachmentRuntimeClient";

const MessageAttachmentClientByIndex = resource(
  ({ runtime, index }: { runtime: MessageRuntime; index: number }) => {
    const attachmentRuntime = tapMemo(
      () => runtime.getAttachmentByIndex(index),
      [runtime, index],
    );
    return tapInlineResource(
      AttachmentRuntimeClient({ runtime: attachmentRuntime }),
    );
  },
);

const MessagePartByIndex = resource(
  ({ runtime, index }: { runtime: MessageRuntime; index: number }) => {
    const partRuntime = tapMemo(
      () => runtime.getMessagePartByIndex(index),
      [runtime, index],
    );
    return tapInlineResource(MessagePartClient({ runtime: partRuntime }));
  },
);

export const MessageClient = resource(
  ({
    runtime,
    threadIdRef,
  }: {
    runtime: MessageRuntime;
    threadIdRef: RefObject<string>;
  }): ClientOutput<"message"> => {
    const runtimeState = tapSubscribable(runtime);

    const [isCopiedState, setIsCopied] = tapState(false);
    const [isHoveringState, setIsHovering] = tapState(false);

    const messageIdRef = tapMemo(
      () => ({
        get current() {
          return runtime.getState().id;
        },
      }),
      [runtime],
    );

    const composer = tapClientResource(
      ComposerClient({
        runtime: runtime.composer,
        threadIdRef,
        messageIdRef,
      }),
    );

    // Deduplicate by toolCallId for display so the same tool call is only shown once
    const displayIndices = tapMemo(() => {
      const content = runtimeState.content;
      const seenToolCallIds = new Set<string>();
      const indices: number[] = [];
      for (let idx = 0; idx < content.length; idx++) {
        const part = content[idx];
        if (
          part &&
          "toolCallId" in part &&
          part.toolCallId != null
        ) {
          if (seenToolCallIds.has(part.toolCallId)) continue;
          seenToolCallIds.add(part.toolCallId);
        }
        indices.push(idx);
      }
      return indices;
    }, [runtimeState.content]);

    const parts = tapClientLookup(
      () =>
        displayIndices.map((contentIdx, displayIdx) =>
          withKey(
            `index-${contentIdx}`,
            MessagePartByIndex({ runtime, index: contentIdx }),
          ),
        ),
      [displayIndices, runtime],
    );

    const attachments = tapClientLookup(
      () =>
        (runtimeState.attachments ?? []).map((attachment, idx) =>
          withKey(
            attachment.id,
            MessageAttachmentClientByIndex({ runtime, index: idx }),
          ),
        ),
      [runtimeState.attachments, runtime],
    );

    const state = tapMemo<MessageState>(() => {
      return {
        ...(runtimeState as MessageState),

        parts: parts.state,
        composer: composer.state,

        isCopied: isCopiedState,
        isHovering: isHoveringState,
      };
    }, [
      runtimeState,
      parts.state,
      composer.state,
      isCopiedState,
      isHoveringState,
    ]);

    return {
      state,
      methods: {
        getState: () => state,

        composer: composer.methods,

        reload: (config) => runtime.reload(config),
        speak: () => runtime.speak(),
        stopSpeaking: () => runtime.stopSpeaking(),
        submitFeedback: (feedback) => runtime.submitFeedback(feedback),
        switchToBranch: (options) => runtime.switchToBranch(options),
        getCopyText: () => runtime.unstable_getCopyText(),
        part: (selector) => {
          if ("index" in selector) {
            return parts.get({ index: selector.index });
          } else {
            const contentIdx = runtimeState.content.findIndex(
              (p) =>
                "toolCallId" in p &&
                p.toolCallId != null &&
                p.toolCallId === selector.toolCallId,
            );
            if (contentIdx === -1) {
              throw new Error(
                `tapClientLookup: Part with toolCallId "${selector.toolCallId}" not found`,
              );
            }
            const displayIdx = displayIndices.indexOf(contentIdx);
            if (displayIdx === -1) {
              throw new Error(
                `tapClientLookup: Part with toolCallId "${selector.toolCallId}" not found`,
              );
            }
            return parts.get({ index: displayIdx });
          }
        },

        attachment: (selector) => {
          if ("id" in selector) {
            return attachments.get({ key: selector.id });
          } else {
            return attachments.get(selector);
          }
        },

        setIsCopied,
        setIsHovering,

        __internal_getRuntime: () => runtime,
      },
    };
  },
);
