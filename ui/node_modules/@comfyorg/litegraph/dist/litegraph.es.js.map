{"version":3,"file":"litegraph.es.js","sources":["../src/utils/uuid.ts","../src/infrastructure/CustomEventTarget.ts","../src/LLink.ts","../src/types/globalEnums.ts","../src/canvas/FloatingRenderLink.ts","../src/canvas/MovingLinkBase.ts","../src/canvas/MovingInputLink.ts","../src/canvas/MovingOutputLink.ts","../src/canvas/ToInputRenderLink.ts","../src/canvas/ToOutputRenderLink.ts","../src/canvas/ToOutputFromRerouteLink.ts","../src/canvas/LinkConnector.ts","../src/measure.ts","../src/canvas/measureSlots.ts","../src/CanvasPointer.ts","../src/DragAndScale.ts","../src/draw.ts","../src/infrastructure/NullGraphError.ts","../src/LGraphIcon.ts","../src/LGraphBadge.ts","../src/node/SlotBase.ts","../src/node/NodeSlot.ts","../src/node/NodeInputSlot.ts","../src/node/NodeOutputSlot.ts","../src/node/slotUtils.ts","../src/strings.ts","../src/utils/collections.ts","../src/utils/feedback.ts","../src/utils/spaceDistribution.ts","../src/utils/type.ts","../src/infrastructure/Rectangle.ts","../src/widgets/BaseWidget.ts","../src/widgets/BooleanWidget.ts","../src/widgets/ButtonWidget.ts","../src/widgets/BaseSteppedWidget.ts","../src/widgets/ComboWidget.ts","../src/utils/widget.ts","../src/widgets/KnobWidget.ts","../src/widgets/LegacyWidget.ts","../src/widgets/NumberWidget.ts","../src/widgets/SliderWidget.ts","../src/widgets/TextWidget.ts","../src/widgets/widgetMap.ts","../src/LGraphNode.ts","../src/LGraphGroup.ts","../src/Reroute.ts","../src/utils/arrange.ts","../src/LGraphCanvas.ts","../src/MapProxyHandler.ts","../src/LGraph.ts","../src/subgraph/SubgraphSlotBase.ts","../src/subgraph/SubgraphInput.ts","../src/subgraph/SubgraphIONodeBase.ts","../src/subgraph/SubgraphInputNode.ts","../src/subgraph/SubgraphOutput.ts","../src/subgraph/SubgraphOutputNode.ts","../src/subgraph/Subgraph.ts","../src/canvas/InputIndicators.ts","../src/ContextMenu.ts","../src/CurveEditor.ts","../src/LiteGraphGlobal.ts","../src/polyfills.ts","../src/litegraph.ts"],"sourcesContent":["// Using a template string for this is resulting in complex type workarounds. No current benefit beyond dev reading.\nexport type UUID = string\n\n/** Special-case zero-UUID, consisting entirely of zeros. Used as a default value. */\nexport const zeroUuid = \"00000000-0000-0000-0000-000000000000\"\n\n/** Pre-allocated storage for uuid random values. */\nconst randomStorage = new Uint32Array(31)\n\n/**\n * Creates a UUIDv4 string.\n * @returns A new UUIDv4 string\n * @remarks\n * Original implementation from https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670\n *\n * Prefers the {@link crypto.randomUUID} method if available, falling back to\n * {@link crypto.getRandomValues}, then finally the legacy {@link Math.random} method.\n */\nexport function createUuidv4(): UUID {\n  if (typeof crypto?.randomUUID === \"function\") return crypto.randomUUID()\n  if (typeof crypto?.getRandomValues === \"function\") {\n    const random = crypto.getRandomValues(randomStorage)\n    let i = 0\n    return \"10000000-1000-4000-8000-100000000000\".replaceAll(/[018]/g, a =>\n      (Number(a) ^ ((random[i++] * 3.725_290_298_461_914e-9) >> (Number(a) * 0.25))).toString(16))\n  }\n  return \"10000000-1000-4000-8000-100000000000\".replaceAll(/[018]/g, a =>\n    (Number(a) ^ ((Math.random() * 16) >> (Number(a) * 0.25))).toString(16))\n}\n","import type { NeverNever, PickNevers } from \"@/types/utility\"\n\ntype EventListeners<T> = {\n  readonly [K in keyof T]: ((this: EventTarget, ev: CustomEvent<T[K]>) => any) | EventListenerObject | null\n}\n\n/**\n * Has strongly-typed overrides of {@link EventTarget.addEventListener} and {@link EventTarget.removeEventListener}.\n */\nexport interface ICustomEventTarget<\n  EventMap extends Record<Keys, unknown>,\n  Keys extends keyof EventMap & string = keyof EventMap & string,\n> {\n  addEventListener<K extends Keys>(\n    type: K,\n    listener: EventListeners<EventMap>[K],\n    options?: boolean | AddEventListenerOptions,\n  ): void\n\n  removeEventListener<K extends Keys>(\n    type: K,\n    listener: EventListeners<EventMap>[K],\n    options?: boolean | EventListenerOptions,\n  ): void\n\n  /** @deprecated Use {@link dispatch}. */\n  dispatchEvent(event: never): boolean\n}\n\n/**\n * Capable of dispatching strongly-typed events via {@link dispatch}.\n * Overloads are used to ensure detail param is correctly optional.\n */\nexport interface CustomEventDispatcher<\n  EventMap extends Record<Keys, unknown>,\n  Keys extends keyof EventMap & string = keyof EventMap & string,\n> {\n  dispatch<T extends keyof NeverNever<EventMap>>(type: T, detail: EventMap[T]): boolean\n  dispatch<T extends keyof PickNevers<EventMap>>(type: T): boolean\n}\n\n/**\n * A strongly-typed, custom {@link EventTarget} that can dispatch and listen for events.\n *\n * 1. Define an event map\n *    ```ts\n *    export interface CustomEventMap {\n *      \"my-event\": { message: string }\n *      \"simple-event\": never\n *    }\n *    ```\n *\n * 2. Create an event emitter\n *    ```ts\n *    // By subclassing\n *    class MyClass extends CustomEventTarget<CustomEventMap> {\n *      // ...\n *    }\n *\n *    // Or simply create an instance:\n *    const events = new CustomEventTarget<CustomEventMap>()\n *    ```\n *\n * 3. Dispatch events\n *    ```ts\n *    // Extended class\n *    const myClass = new MyClass()\n *    myClass.dispatch(\"my-event\", { message: \"Hello, world!\" })\n *    myClass.dispatch(\"simple-event\")\n *\n *    // Instance\n *    const events = new CustomEventTarget<CustomEventMap>()\n *    events.dispatch(\"my-event\", { message: \"Hello, world!\" })\n *    events.dispatch(\"simple-event\")\n *    ```\n */\nexport class CustomEventTarget<\n  EventMap extends Record<Keys, unknown>,\n  Keys extends keyof EventMap & string = keyof EventMap & string,\n>\n  extends EventTarget implements ICustomEventTarget<EventMap, Keys> {\n  /**\n   * Type-safe event dispatching.\n   * @see {@link EventTarget.dispatchEvent}\n   * @param type Name of the event to dispatch\n   * @param detail A custom object to send with the event\n   * @returns `true` if the event was dispatched successfully, otherwise `false`.\n   */\n  dispatch<T extends keyof NeverNever<EventMap>>(type: T, detail: EventMap[T]): boolean\n  dispatch<T extends keyof PickNevers<EventMap>>(type: T): boolean\n  dispatch<T extends keyof EventMap>(type: T, detail?: EventMap[T]) {\n    const event = new CustomEvent(type as string, { detail, cancelable: true })\n    return super.dispatchEvent(event)\n  }\n\n  override addEventListener<K extends Keys>(\n    type: K,\n    listener: EventListeners<EventMap>[K],\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    // Assertion: Contravariance on CustomEvent => Event\n    super.addEventListener(type as string, listener as EventListener, options)\n  }\n\n  override removeEventListener<K extends Keys>(\n    type: K,\n    listener: EventListeners<EventMap>[K],\n    options?: boolean | EventListenerOptions,\n  ): void {\n    // Assertion: Contravariance on CustomEvent => Event\n    super.removeEventListener(type as string, listener as EventListener, options)\n  }\n\n  /** @deprecated Use {@link dispatch}. */\n  override dispatchEvent(event: never): boolean {\n    return super.dispatchEvent(event)\n  }\n}\n","import type {\n  CanvasColour,\n  INodeInputSlot,\n  INodeOutputSlot,\n  ISlotType,\n  LinkNetwork,\n  LinkSegment,\n  ReadonlyLinkNetwork,\n} from \"./interfaces\"\nimport type { LGraphNode, NodeId } from \"./LGraphNode\"\nimport type { Reroute, RerouteId } from \"./Reroute\"\nimport type { Serialisable, SerialisableLLink } from \"./types/serialisation\"\n\nexport type LinkId = number\n\nexport type SerialisedLLinkArray = [\n  id: LinkId,\n  origin_id: NodeId,\n  origin_slot: number,\n  target_id: NodeId,\n  target_slot: number,\n  type: ISlotType,\n]\n\nexport interface ResolvedConnection {\n  inputNode: LGraphNode | undefined\n  outputNode: LGraphNode | undefined\n  input: INodeInputSlot | undefined\n  output: INodeOutputSlot | undefined\n  link: LLink\n}\n\ntype BasicReadonlyNetwork = Pick<ReadonlyLinkNetwork, \"getNodeById\" | \"links\" | \"getLink\">\n\n// this is the class in charge of storing link information\nexport class LLink implements LinkSegment, Serialisable<SerialisableLLink> {\n  /** Link ID */\n  id: LinkId\n  parentId?: RerouteId\n  type: ISlotType\n  /** Output node ID */\n  origin_id: NodeId\n  /** Output slot index */\n  origin_slot: number\n  /** Input node ID */\n  target_id: NodeId\n  /** Input slot index */\n  target_slot: number\n\n  data?: number | string | boolean | { toToolTip?(): string }\n  _data?: unknown\n  /** Centre point of the link, calculated during render only - can be inaccurate */\n  _pos: Float32Array\n  /** @todo Clean up - never implemented in comfy. */\n  _last_time?: number\n  /** The last canvas 2D path that was used to render this link */\n  path?: Path2D\n  /** @inheritdoc */\n  _centreAngle?: number\n\n  /** @inheritdoc */\n  _dragging?: boolean\n\n  #color?: CanvasColour | null\n  /** Custom colour for this link only */\n  public get color(): CanvasColour | null | undefined {\n    return this.#color\n  }\n\n  public set color(value: CanvasColour) {\n    this.#color = value === \"\" ? null : value\n  }\n\n  public get isFloatingOutput(): boolean {\n    return this.origin_id === -1 && this.origin_slot === -1\n  }\n\n  public get isFloatingInput(): boolean {\n    return this.target_id === -1 && this.target_slot === -1\n  }\n\n  public get isFloating(): boolean {\n    return this.isFloatingOutput || this.isFloatingInput\n  }\n\n  constructor(\n    id: LinkId,\n    type: ISlotType,\n    origin_id: NodeId,\n    origin_slot: number,\n    target_id: NodeId,\n    target_slot: number,\n    parentId?: RerouteId,\n  ) {\n    this.id = id\n    this.type = type\n    this.origin_id = origin_id\n    this.origin_slot = origin_slot\n    this.target_id = target_id\n    this.target_slot = target_slot\n    this.parentId = parentId\n\n    this._data = null\n    // center\n    this._pos = new Float32Array(2)\n  }\n\n  /** @deprecated Use {@link LLink.create} */\n  static createFromArray(data: SerialisedLLinkArray): LLink {\n    return new LLink(data[0], data[5], data[1], data[2], data[3], data[4])\n  }\n\n  /**\n   * LLink static factory: creates a new LLink from the provided data.\n   * @param data Serialised LLink data to create the link from\n   * @returns A new LLink\n   */\n  static create(data: SerialisableLLink): LLink {\n    return new LLink(\n      data.id,\n      data.type,\n      data.origin_id,\n      data.origin_slot,\n      data.target_id,\n      data.target_slot,\n      data.parentId,\n    )\n  }\n\n  /**\n   * Gets all reroutes from the output slot to this segment.  If this segment is a reroute, it will not be included.\n   * @returns An ordered array of all reroutes from the node output to\n   * this reroute or the reroute before it.  Otherwise, an empty array.\n   */\n  static getReroutes(\n    network: Pick<ReadonlyLinkNetwork, \"reroutes\">,\n    linkSegment: LinkSegment,\n  ): Reroute[] {\n    if (!linkSegment.parentId) return []\n    return network.reroutes\n      .get(linkSegment.parentId)\n      ?.getReroutes() ?? []\n  }\n\n  static getFirstReroute(\n    network: Pick<ReadonlyLinkNetwork, \"reroutes\">,\n    linkSegment: LinkSegment,\n  ): Reroute | undefined {\n    return LLink.getReroutes(network, linkSegment).at(0)\n  }\n\n  /**\n   * Finds the reroute in the chain after the provided reroute ID.\n   * @param network The network this link belongs to\n   * @param linkSegment The starting point of the search (input side).\n   * Typically the LLink object itself, but can be any link segment.\n   * @param rerouteId The matching reroute will have this set as its {@link parentId}.\n   * @returns The reroute that was found, `undefined` if no reroute was found, or `null` if an infinite loop was detected.\n   */\n  static findNextReroute(\n    network: Pick<ReadonlyLinkNetwork, \"reroutes\">,\n    linkSegment: LinkSegment,\n    rerouteId: RerouteId,\n  ): Reroute | null | undefined {\n    if (!linkSegment.parentId) return\n    return network.reroutes\n      .get(linkSegment.parentId)\n      ?.findNextReroute(rerouteId)\n  }\n\n  /**\n   * Gets the origin node of a link.\n   * @param network The network to search\n   * @param linkId The ID of the link to get the origin node of\n   * @returns The origin node of the link, or `undefined` if the link is not found or the origin node is not found\n   */\n  static getOriginNode(network: BasicReadonlyNetwork, linkId: LinkId): LGraphNode | undefined {\n    const id = network.links.get(linkId)?.origin_id\n    return network.getNodeById(id) ?? undefined\n  }\n\n  /**\n   * Gets the target node of a link.\n   * @param network The network to search\n   * @param linkId The ID of the link to get the target node of\n   * @returns The target node of the link, or `undefined` if the link is not found or the target node is not found\n   */\n  static getTargetNode(network: BasicReadonlyNetwork, linkId: LinkId): LGraphNode | undefined {\n    const id = network.links.get(linkId)?.target_id\n    return network.getNodeById(id) ?? undefined\n  }\n\n  /**\n   * Resolves a link ID to the link, node, and slot objects.\n   * @param linkId The {@link id} of the link to resolve\n   * @param network The link network to search\n   * @returns An object containing the input and output nodes, as well as the input and output slots.\n   * @remarks This method is heavier than others; it will always resolve all objects.\n   * Whilst the performance difference should in most cases be negligible,\n   * it is recommended to use simpler methods where appropriate.\n   */\n  static resolve(linkId: LinkId | null | undefined, network: BasicReadonlyNetwork): ResolvedConnection | undefined {\n    return network.getLink(linkId)?.resolve(network)\n  }\n\n  /**\n   * Resolves a list of link IDs to the link, node, and slot objects.\n   * Discards invalid link IDs.\n   * @param linkIds An iterable of link {@link id}s to resolve\n   * @param network The link network to search\n   * @returns An array of resolved connections.  If a link is not found, it is not included in the array.\n   * @see {@link LLink.resolve}\n   */\n  static resolveMany(linkIds: Iterable<LinkId>, network: BasicReadonlyNetwork): ResolvedConnection[] {\n    const resolved: ResolvedConnection[] = []\n    for (const id of linkIds) {\n      const r = network.getLink(id)?.resolve(network)\n      if (r) resolved.push(r)\n    }\n    return resolved\n  }\n\n  /**\n   * Resolves the primitive ID values stored in the link to the referenced objects.\n   * @param network The link network to search\n   * @returns An object containing the input and output nodes, as well as the input and output slots.\n   * @remarks This method is heavier than others; it will always resolve all objects.\n   * Whilst the performance difference should in most cases be negligible,\n   * it is recommended to use simpler methods where appropriate.\n   */\n  resolve(network: BasicReadonlyNetwork): ResolvedConnection {\n    const inputNode = this.target_id === -1 ? undefined : network.getNodeById(this.target_id) ?? undefined\n    const outputNode = this.origin_id === -1 ? undefined : network.getNodeById(this.origin_id) ?? undefined\n    const input = inputNode?.inputs[this.target_slot]\n    const output = outputNode?.outputs[this.origin_slot]\n    return { inputNode, outputNode, input, output, link: this }\n  }\n\n  configure(o: LLink | SerialisedLLinkArray) {\n    if (Array.isArray(o)) {\n      this.id = o[0]\n      this.origin_id = o[1]\n      this.origin_slot = o[2]\n      this.target_id = o[3]\n      this.target_slot = o[4]\n      this.type = o[5]\n    } else {\n      this.id = o.id\n      this.type = o.type\n      this.origin_id = o.origin_id\n      this.origin_slot = o.origin_slot\n      this.target_id = o.target_id\n      this.target_slot = o.target_slot\n      this.parentId = o.parentId\n    }\n  }\n\n  /**\n   * Checks if the specified node id and output index are this link's origin (output side).\n   * @param nodeId ID of the node to check\n   * @param outputIndex The array index of the node output\n   * @returns `true` if the origin matches, otherwise `false`.\n   */\n  hasOrigin(nodeId: NodeId, outputIndex: number): boolean {\n    return this.origin_id === nodeId && this.origin_slot === outputIndex\n  }\n\n  /**\n   * Checks if the specified node id and input index are this link's target (input side).\n   * @param nodeId ID of the node to check\n   * @param inputIndex The array index of the node input\n   * @returns `true` if the target matches, otherwise `false`.\n   */\n  hasTarget(nodeId: NodeId, inputIndex: number): boolean {\n    return this.target_id === nodeId && this.target_slot === inputIndex\n  }\n\n  /**\n   * Creates a floating link from this link.\n   * @param slotType The side of the link that is still connected\n   * @param parentId The parent reroute ID of the link\n   * @returns A new LLink that is floating\n   */\n  toFloating(slotType: \"input\" | \"output\", parentId: RerouteId): LLink {\n    const exported = this.asSerialisable()\n    exported.id = -1\n    exported.parentId = parentId\n\n    if (slotType === \"input\") {\n      exported.origin_id = -1\n      exported.origin_slot = -1\n    } else {\n      exported.target_id = -1\n      exported.target_slot = -1\n    }\n\n    return LLink.create(exported)\n  }\n\n  /**\n   * Disconnects a link and removes it from the graph, cleaning up any reroutes that are no longer used\n   * @param network The container (LGraph) where reroutes should be updated\n   * @param keepReroutes If `undefined`, reroutes will be automatically removed if no links remain.\n   * If `input` or `output`, reroutes will not be automatically removed, and retain a connection to the input or output, respectively.\n   */\n  disconnect(network: LinkNetwork, keepReroutes?: \"input\" | \"output\"): void {\n    const reroutes = LLink.getReroutes(network, this)\n\n    const lastReroute = reroutes.at(-1)\n\n    // When floating from output, 1-to-1 ratio of floating link to final reroute (tree-like)\n    const outputFloating = keepReroutes === \"output\" &&\n      lastReroute?.linkIds.size === 1 &&\n      lastReroute.floatingLinkIds.size === 0\n\n    // When floating from inputs, the final (input side) reroute may have many floating links\n    if (outputFloating || (keepReroutes === \"input\" && lastReroute)) {\n      const newLink = LLink.create(this)\n      newLink.id = -1\n\n      if (keepReroutes === \"input\") {\n        newLink.origin_id = -1\n        newLink.origin_slot = -1\n\n        lastReroute.floating = { slotType: \"input\" }\n      } else {\n        newLink.target_id = -1\n        newLink.target_slot = -1\n\n        lastReroute.floating = { slotType: \"output\" }\n      }\n\n      network.addFloatingLink(newLink)\n    }\n\n    for (const reroute of reroutes) {\n      reroute.linkIds.delete(this.id)\n      if (!keepReroutes && !reroute.totalLinks) {\n        network.reroutes.delete(reroute.id)\n      }\n    }\n    network.links.delete(this.id)\n  }\n\n  /**\n   * @deprecated Prefer {@link LLink.asSerialisable} (returns an object, not an array)\n   * @returns An array representing this LLink\n   */\n  serialize(): SerialisedLLinkArray {\n    return [\n      this.id,\n      this.origin_id,\n      this.origin_slot,\n      this.target_id,\n      this.target_slot,\n      this.type,\n    ]\n  }\n\n  asSerialisable(): SerialisableLLink {\n    const copy: SerialisableLLink = {\n      id: this.id,\n      origin_id: this.origin_id,\n      origin_slot: this.origin_slot,\n      target_id: this.target_id,\n      target_slot: this.target_slot,\n      type: this.type,\n    }\n    if (this.parentId) copy.parentId = this.parentId\n    return copy\n  }\n}\n","/** Node slot type - input or output */\nexport enum NodeSlotType {\n  INPUT = 1,\n  OUTPUT = 2,\n}\n\n/** Shape that an object will render as - used by nodes and slots */\nexport enum RenderShape {\n  /** Rectangle with square corners */\n  BOX = 1,\n  /** Rounded rectangle */\n  ROUND = 2,\n  /** Circle is circle */\n  CIRCLE = 3,\n  /** Two rounded corners: top left & bottom right */\n  CARD = 4,\n  /** Slot shape: Arrow */\n  ARROW = 5,\n  /** Slot shape: Grid */\n  GRID = 6,\n  /** Slot shape: Hollow circle  */\n  HollowCircle = 7,\n}\n\n/** Bit flags used to indicate what the pointer is currently hovering over. */\nexport enum CanvasItem {\n  /** No items / none */\n  Nothing = 0,\n  /** At least one node */\n  Node = 1,\n  /** At least one group */\n  Group = 1 << 1,\n  /** A reroute (not its path) */\n  Reroute = 1 << 2,\n  /** The path of a link */\n  Link = 1 << 3,\n  /** A resize in the bottom-right corner */\n  ResizeSe = 1 << 4,\n  /** A reroute slot */\n  RerouteSlot = 1 << 5,\n}\n\n/** The direction that a link point will flow towards - e.g. horizontal outputs are right by default */\nexport enum LinkDirection {\n  NONE = 0,\n  UP = 1,\n  DOWN = 2,\n  LEFT = 3,\n  RIGHT = 4,\n  CENTER = 5,\n}\n\n/** The path calculation that links follow */\nexport enum LinkRenderType {\n  HIDDEN_LINK = -1,\n  /** Juts out from the input & output a little @see LinkDirection, then a straight line between them */\n  STRAIGHT_LINK = 0,\n  /** 90Â° angles, clean and box-like */\n  LINEAR_LINK = 1,\n  /** Smooth curved links - default */\n  SPLINE_LINK = 2,\n}\n\n/** The marker in the middle of a link */\nexport enum LinkMarkerShape {\n  /** Do not display markers */\n  None = 0,\n  /** Circles (default) */\n  Circle = 1,\n  /** Directional arrows */\n  Arrow = 2,\n}\n\nexport enum TitleMode {\n  NORMAL_TITLE = 0,\n  NO_TITLE = 1,\n  TRANSPARENT_TITLE = 2,\n  AUTOHIDE_TITLE = 3,\n}\n\nexport enum LGraphEventMode {\n  ALWAYS = 0,\n  ON_EVENT = 1,\n  NEVER = 2,\n  ON_TRIGGER = 3,\n  BYPASS = 4,\n}\n\nexport enum EaseFunction {\n  LINEAR = \"linear\",\n  EASE_IN_QUAD = \"easeInQuad\",\n  EASE_OUT_QUAD = \"easeOutQuad\",\n  EASE_IN_OUT_QUAD = \"easeInOutQuad\",\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeOutputSlot, LinkNetwork } from \"@/interfaces\"\nimport type { INodeInputSlot } from \"@/interfaces\"\nimport type { Point } from \"@/interfaces\"\nimport type { LGraphNode, NodeId } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\n/**\n * Represents a floating link that is currently being dragged from one slot to another.\n *\n * This is a heavier, but short-lived convenience data structure. All refs to FloatingRenderLinks should be discarded on drop.\n * @remarks\n * At time of writing, Litegraph is using several different styles and methods to handle link dragging.\n *\n * Once the library has undergone more substantial changes to the way links are managed,\n * many properties of this class will be superfluous and removable.\n */\nexport class FloatingRenderLink implements RenderLink {\n  readonly node: LGraphNode\n  readonly fromSlot: INodeOutputSlot | INodeInputSlot\n  readonly fromPos: Point\n  readonly fromDirection: LinkDirection\n  readonly fromSlotIndex: number\n\n  readonly outputNodeId: NodeId = -1\n  readonly outputNode?: LGraphNode\n  readonly outputSlot?: INodeOutputSlot\n  readonly outputIndex: number = -1\n  readonly outputPos?: Point\n\n  readonly inputNodeId: NodeId = -1\n  readonly inputNode?: LGraphNode\n  readonly inputSlot?: INodeInputSlot\n  readonly inputIndex: number = -1\n  readonly inputPos?: Point\n\n  constructor(\n    readonly network: LinkNetwork,\n    readonly link: LLink,\n    readonly toType: \"input\" | \"output\",\n    readonly fromReroute: Reroute,\n    readonly dragDirection: LinkDirection = LinkDirection.CENTER,\n  ) {\n    const {\n      origin_id: outputNodeId,\n      target_id: inputNodeId,\n      origin_slot: outputIndex,\n      target_slot: inputIndex,\n    } = link\n\n    if (outputNodeId !== -1) {\n      // Output connected\n      const outputNode = network.getNodeById(outputNodeId) ?? undefined\n      if (!outputNode) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Output node [${outputNodeId}] not found.`)\n\n      const outputSlot = outputNode?.outputs.at(outputIndex)\n      if (!outputSlot) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Output slot [${outputIndex}] not found.`)\n\n      this.outputNodeId = outputNodeId\n      this.outputNode = outputNode\n      this.outputSlot = outputSlot\n      this.outputIndex = outputIndex\n      this.outputPos = outputNode.getOutputPos(outputIndex)\n\n      // RenderLink props\n      this.node = outputNode\n      this.fromSlot = outputSlot\n      this.fromPos = fromReroute?.pos ?? this.outputPos\n      this.fromDirection = LinkDirection.LEFT\n      this.dragDirection = LinkDirection.RIGHT\n      this.fromSlotIndex = outputIndex\n    } else {\n      // Input connected\n      const inputNode = network.getNodeById(inputNodeId) ?? undefined\n      if (!inputNode) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Input node [${inputNodeId}] not found.`)\n\n      const inputSlot = inputNode?.inputs.at(inputIndex)\n      if (!inputSlot) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Input slot [${inputIndex}] not found.`)\n\n      this.inputNodeId = inputNodeId\n      this.inputNode = inputNode\n      this.inputSlot = inputSlot\n      this.inputIndex = inputIndex\n      this.inputPos = inputNode.getInputPos(inputIndex)\n\n      // RenderLink props\n      this.node = inputNode\n      this.fromSlot = inputSlot\n      this.fromDirection = LinkDirection.RIGHT\n      this.fromSlotIndex = inputIndex\n    }\n    this.fromPos = fromReroute.pos\n  }\n\n  canConnectToInput(): boolean {\n    return this.toType === \"input\"\n  }\n\n  canConnectToOutput(): boolean {\n    return this.toType === \"output\"\n  }\n\n  canConnectToReroute(reroute: Reroute): boolean {\n    if (this.toType === \"input\") {\n      if (reroute.origin_id === this.inputNode?.id) return false\n    } else {\n      if (reroute.origin_id === this.outputNode?.id) return false\n    }\n    return true\n  }\n\n  connectToInput(node: LGraphNode, input: INodeInputSlot, _events?: CustomEventTarget<LinkConnectorEventMap>): void {\n    const floatingLink = this.link\n    floatingLink.target_id = node.id\n    floatingLink.target_slot = node.inputs.indexOf(input)\n\n    node.disconnectInput(node.inputs.indexOf(input))\n\n    this.fromSlot._floatingLinks?.delete(floatingLink)\n    input._floatingLinks ??= new Set()\n    input._floatingLinks.add(floatingLink)\n  }\n\n  connectToOutput(node: LGraphNode, output: INodeOutputSlot, _events?: CustomEventTarget<LinkConnectorEventMap>): void {\n    const floatingLink = this.link\n    floatingLink.origin_id = node.id\n    floatingLink.origin_slot = node.outputs.indexOf(output)\n\n    this.fromSlot._floatingLinks?.delete(floatingLink)\n    output._floatingLinks ??= new Set()\n    output._floatingLinks.add(floatingLink)\n  }\n\n  connectToRerouteInput(\n    reroute: Reroute,\n    { node: inputNode, input }: { node: LGraphNode, input: INodeInputSlot },\n    events: CustomEventTarget<LinkConnectorEventMap>,\n  ) {\n    const floatingLink = this.link\n    floatingLink.target_id = inputNode.id\n    floatingLink.target_slot = inputNode.inputs.indexOf(input)\n\n    this.fromSlot._floatingLinks?.delete(floatingLink)\n    input._floatingLinks ??= new Set()\n    input._floatingLinks.add(floatingLink)\n\n    events.dispatch(\"input-moved\", this)\n  }\n\n  connectToRerouteOutput(\n    reroute: Reroute,\n    outputNode: LGraphNode,\n    output: INodeOutputSlot,\n    events: CustomEventTarget<LinkConnectorEventMap>,\n  ) {\n    const floatingLink = this.link\n    floatingLink.origin_id = outputNode.id\n    floatingLink.origin_slot = outputNode.outputs.indexOf(output)\n\n    this.fromSlot._floatingLinks?.delete(floatingLink)\n    output._floatingLinks ??= new Set()\n    output._floatingLinks.add(floatingLink)\n\n    events.dispatch(\"output-moved\", this)\n  }\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode, NodeId } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\n/**\n * Represents an existing link that is currently being dragged by the user from one slot to another.\n *\n * This is a heavier, but short-lived convenience data structure.\n * All refs to {@link MovingInputLink} and {@link MovingOutputLink} should be discarded on drop.\n * @remarks\n * At time of writing, Litegraph is using several different styles and methods to handle link dragging.\n *\n * Once the library has undergone more substantial changes to the way links are managed,\n * many properties of this class will be superfluous and removable.\n */\n\nexport abstract class MovingLinkBase implements RenderLink {\n  abstract readonly node: LGraphNode\n  abstract readonly fromSlot: INodeOutputSlot | INodeInputSlot\n  abstract readonly fromPos: Point\n  abstract readonly fromDirection: LinkDirection\n  abstract readonly fromSlotIndex: number\n\n  readonly outputNodeId: NodeId\n  readonly outputNode: LGraphNode\n  readonly outputSlot: INodeOutputSlot\n  readonly outputIndex: number\n  readonly outputPos: Point\n\n  readonly inputNodeId: NodeId\n  readonly inputNode: LGraphNode\n  readonly inputSlot: INodeInputSlot\n  readonly inputIndex: number\n  readonly inputPos: Point\n\n  constructor(\n    readonly network: LinkNetwork,\n    readonly link: LLink,\n    readonly toType: \"input\" | \"output\",\n    readonly fromReroute?: Reroute,\n    readonly dragDirection: LinkDirection = LinkDirection.CENTER,\n  ) {\n    const {\n      origin_id: outputNodeId,\n      target_id: inputNodeId,\n      origin_slot: outputIndex,\n      target_slot: inputIndex,\n    } = link\n\n    // Store output info\n    const outputNode = network.getNodeById(outputNodeId) ?? undefined\n    if (!outputNode) throw new Error(`Creating MovingRenderLink for link [${link.id}] failed: Output node [${outputNodeId}] not found.`)\n\n    const outputSlot = outputNode.outputs.at(outputIndex)\n    if (!outputSlot) throw new Error(`Creating MovingRenderLink for link [${link.id}] failed: Output slot [${outputIndex}] not found.`)\n\n    this.outputNodeId = outputNodeId\n    this.outputNode = outputNode\n    this.outputSlot = outputSlot\n    this.outputIndex = outputIndex\n    this.outputPos = outputNode.getOutputPos(outputIndex)\n\n    // Store input info\n    const inputNode = network.getNodeById(inputNodeId) ?? undefined\n    if (!inputNode) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Input node [${inputNodeId}] not found.`)\n\n    const inputSlot = inputNode.inputs.at(inputIndex)\n    if (!inputSlot) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Input slot [${inputIndex}] not found.`)\n\n    this.inputNodeId = inputNodeId\n    this.inputNode = inputNode\n    this.inputSlot = inputSlot\n    this.inputIndex = inputIndex\n    this.inputPos = inputNode.getInputPos(inputIndex)\n  }\n\n  abstract connectToInput(node: LGraphNode, input: INodeInputSlot, events?: CustomEventTarget<LinkConnectorEventMap>): void\n  abstract connectToOutput(node: LGraphNode, output: INodeOutputSlot, events?: CustomEventTarget<LinkConnectorEventMap>): void\n  abstract connectToRerouteInput(reroute: Reroute, { node, input, link }: { node: LGraphNode, input: INodeInputSlot, link: LLink }, events: CustomEventTarget<LinkConnectorEventMap>, originalReroutes: Reroute[]): void\n  abstract connectToRerouteOutput(reroute: Reroute, outputNode: LGraphNode, output: INodeOutputSlot, events: CustomEventTarget<LinkConnectorEventMap>): void\n\n  abstract disconnect(): boolean\n}\n","import type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\nimport { MovingLinkBase } from \"./MovingLinkBase\"\n\nexport class MovingInputLink extends MovingLinkBase {\n  override readonly toType = \"input\"\n\n  readonly node: LGraphNode\n  readonly fromSlot: INodeOutputSlot\n  readonly fromPos: Point\n  readonly fromDirection: LinkDirection\n  readonly fromSlotIndex: number\n\n  constructor(network: LinkNetwork, link: LLink, fromReroute?: Reroute, dragDirection: LinkDirection = LinkDirection.CENTER) {\n    super(network, link, \"input\", fromReroute, dragDirection)\n\n    this.node = this.outputNode\n    this.fromSlot = this.outputSlot\n    this.fromPos = fromReroute?.pos ?? this.outputPos\n    this.fromDirection = LinkDirection.NONE\n    this.fromSlotIndex = this.outputIndex\n  }\n\n  canConnectToInput(inputNode: LGraphNode, input: INodeInputSlot): boolean {\n    return this.node.canConnectTo(inputNode, input, this.outputSlot)\n  }\n\n  canConnectToOutput(): false {\n    return false\n  }\n\n  canConnectToReroute(reroute: Reroute): boolean {\n    return reroute.origin_id !== this.inputNode.id\n  }\n\n  connectToInput(inputNode: LGraphNode, input: INodeInputSlot, events: CustomEventTarget<LinkConnectorEventMap>): LLink | null | undefined {\n    if (input === this.inputSlot) return\n\n    this.inputNode.disconnectInput(this.inputIndex, true)\n    const link = this.outputNode.connectSlots(this.outputSlot, inputNode, input, this.fromReroute?.id)\n    if (link) events.dispatch(\"input-moved\", this)\n    return link\n  }\n\n  connectToOutput(): never {\n    throw new Error(\"MovingInputLink cannot connect to an output.\")\n  }\n\n  connectToRerouteInput(\n    reroute: Reroute,\n    { node: inputNode, input, link: existingLink }: { node: LGraphNode, input: INodeInputSlot, link: LLink },\n    events: CustomEventTarget<LinkConnectorEventMap>,\n    originalReroutes: Reroute[],\n  ): void {\n    const { outputNode, outputSlot, fromReroute } = this\n\n    // Clean up reroutes\n    for (const reroute of originalReroutes) {\n      if (reroute.id === this.link.parentId) break\n\n      if (reroute.totalLinks === 1) reroute.remove()\n    }\n    // Set the parentId of the reroute we dropped on, to the reroute we dragged from\n    reroute.parentId = fromReroute?.id\n\n    const newLink = outputNode.connectSlots(outputSlot, inputNode, input, existingLink.parentId)\n    if (newLink) events.dispatch(\"input-moved\", this)\n  }\n\n  connectToRerouteOutput(): never {\n    throw new Error(\"MovingInputLink cannot connect to an output.\")\n  }\n\n  disconnect(): boolean {\n    return this.inputNode.disconnectInput(this.inputIndex, true)\n  }\n}\n","import type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\nimport { MovingLinkBase } from \"./MovingLinkBase\"\n\nexport class MovingOutputLink extends MovingLinkBase {\n  override readonly toType = \"output\"\n\n  readonly node: LGraphNode\n  readonly fromSlot: INodeInputSlot\n  readonly fromPos: Point\n  readonly fromDirection: LinkDirection\n  readonly fromSlotIndex: number\n\n  constructor(network: LinkNetwork, link: LLink, fromReroute?: Reroute, dragDirection: LinkDirection = LinkDirection.CENTER) {\n    super(network, link, \"output\", fromReroute, dragDirection)\n\n    this.node = this.inputNode\n    this.fromSlot = this.inputSlot\n    this.fromPos = fromReroute?.pos ?? this.inputPos\n    this.fromDirection = LinkDirection.LEFT\n    this.fromSlotIndex = this.inputIndex\n  }\n\n  canConnectToInput(): false {\n    return false\n  }\n\n  canConnectToOutput(outputNode: LGraphNode, output: INodeOutputSlot): boolean {\n    return outputNode.canConnectTo(this.node, this.inputSlot, output)\n  }\n\n  canConnectToReroute(reroute: Reroute): boolean {\n    return reroute.origin_id !== this.outputNode.id\n  }\n\n  connectToInput(): never {\n    throw new Error(\"MovingOutputLink cannot connect to an input.\")\n  }\n\n  connectToOutput(outputNode: LGraphNode, output: INodeOutputSlot, events: CustomEventTarget<LinkConnectorEventMap>): LLink | null | undefined {\n    if (output === this.outputSlot) return\n\n    const link = outputNode.connectSlots(output, this.inputNode, this.inputSlot, this.link.parentId)\n    if (link) events.dispatch(\"output-moved\", this)\n    return link\n  }\n\n  connectToRerouteInput(): never {\n    throw new Error(\"MovingOutputLink cannot connect to an input.\")\n  }\n\n  connectToRerouteOutput(\n    reroute: Reroute,\n    outputNode: LGraphNode,\n    output: INodeOutputSlot,\n    events: CustomEventTarget<LinkConnectorEventMap>,\n  ): void {\n    // Moving output side of links\n    const { inputNode, inputSlot, fromReroute } = this\n\n    // Creating a new link removes floating prop - check before connecting\n    const floatingTerminus = reroute?.floating?.slotType === \"output\"\n\n    // Connect the first reroute of the link being dragged to the reroute being dropped on\n    if (fromReroute) {\n      fromReroute.parentId = reroute.id\n    } else {\n      // If there are no reroutes, directly connect the link\n      this.link.parentId = reroute.id\n    }\n    // Use the last reroute id on the link to retain all reroutes\n    outputNode.connectSlots(output, inputNode, inputSlot, this.link.parentId)\n\n    // Connecting from the final reroute of a floating reroute chain\n    if (floatingTerminus) reroute.removeAllFloatingLinks()\n\n    events.dispatch(\"output-moved\", this)\n  }\n\n  disconnect(): boolean {\n    return this.outputNode.disconnectOutput(this.outputIndex, this.inputNode)\n  }\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\n/** Connecting TO an input slot. */\n\nexport class ToInputRenderLink implements RenderLink {\n  readonly toType = \"input\"\n  readonly fromPos: Point\n  readonly fromSlotIndex: number\n  fromDirection: LinkDirection = LinkDirection.RIGHT\n\n  constructor(\n    readonly network: LinkNetwork,\n    readonly node: LGraphNode,\n    readonly fromSlot: INodeOutputSlot,\n    readonly fromReroute?: Reroute,\n    public dragDirection: LinkDirection = LinkDirection.CENTER,\n  ) {\n    const outputIndex = node.outputs.indexOf(fromSlot)\n    if (outputIndex === -1) throw new Error(`Creating render link for node [${this.node.id}] failed: Slot index not found.`)\n\n    this.fromSlotIndex = outputIndex\n    this.fromPos = fromReroute\n      ? fromReroute.pos\n      : this.node.getOutputPos(outputIndex)\n  }\n\n  canConnectToInput(inputNode: LGraphNode, input: INodeInputSlot): boolean {\n    return this.node.canConnectTo(inputNode, input, this.fromSlot)\n  }\n\n  canConnectToOutput(): false {\n    return false\n  }\n\n  connectToInput(node: LGraphNode, input: INodeInputSlot, events: CustomEventTarget<LinkConnectorEventMap>) {\n    const { node: outputNode, fromSlot, fromReroute } = this\n    if (node === outputNode) return\n\n    const newLink = outputNode.connectSlots(fromSlot, node, input, fromReroute?.id)\n    events.dispatch(\"link-created\", newLink)\n  }\n\n  connectToRerouteInput(\n    reroute: Reroute,\n    {\n      node: inputNode,\n      input,\n      link,\n    }: { node: LGraphNode, input: INodeInputSlot, link: LLink },\n    events: CustomEventTarget<LinkConnectorEventMap>,\n    originalReroutes: Reroute[],\n  ) {\n    const { node: outputNode, fromSlot, fromReroute } = this\n\n    // Check before creating new link overwrites the value\n    const floatingTerminus = fromReroute?.floating?.slotType === \"output\"\n\n    // Set the parentId of the reroute we dropped on, to the reroute we dragged from\n    reroute.parentId = fromReroute?.id\n\n    const newLink = outputNode.connectSlots(fromSlot, inputNode, input, link.parentId)\n\n    // Connecting from the final reroute of a floating reroute chain\n    if (floatingTerminus) fromReroute.removeAllFloatingLinks()\n\n    // Clean up reroutes\n    for (const reroute of originalReroutes) {\n      if (reroute.id === fromReroute?.id) break\n\n      reroute.removeLink(link)\n      if (reroute.totalLinks === 0) {\n        if (link.isFloating) {\n          // Cannot float from both sides - remove\n          reroute.remove()\n        } else {\n          // Convert to floating\n          const cl = link.toFloating(\"output\", reroute.id)\n          this.network.addFloatingLink(cl)\n          reroute.floating = { slotType: \"output\" }\n        }\n      }\n    }\n    events.dispatch(\"link-created\", newLink)\n  }\n\n  connectToOutput() {\n    throw new Error(\"ToInputRenderLink cannot connect to an output.\")\n  }\n\n  connectToRerouteOutput() {\n    throw new Error(\"ToInputRenderLink cannot connect to an output.\")\n  }\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\n/** Connecting TO an output slot. */\n\nexport class ToOutputRenderLink implements RenderLink {\n  readonly toType = \"output\"\n  readonly fromPos: Point\n  readonly fromSlotIndex: number\n  fromDirection: LinkDirection = LinkDirection.LEFT\n\n  constructor(\n    readonly network: LinkNetwork,\n    readonly node: LGraphNode,\n    readonly fromSlot: INodeInputSlot,\n    readonly fromReroute?: Reroute,\n    public dragDirection: LinkDirection = LinkDirection.CENTER,\n  ) {\n    const inputIndex = node.inputs.indexOf(fromSlot)\n    if (inputIndex === -1) throw new Error(`Creating render link for node [${this.node.id}] failed: Slot index not found.`)\n\n    this.fromSlotIndex = inputIndex\n    this.fromPos = fromReroute\n      ? fromReroute.pos\n      : this.node.getInputPos(inputIndex)\n  }\n\n  canConnectToInput(): false {\n    return false\n  }\n\n  canConnectToOutput(outputNode: LGraphNode, output: INodeOutputSlot): boolean {\n    return this.node.canConnectTo(outputNode, this.fromSlot, output)\n  }\n\n  canConnectToReroute(reroute: Reroute): boolean {\n    if (reroute.origin_id === this.node.id) return false\n    return true\n  }\n\n  connectToOutput(node: LGraphNode, output: INodeOutputSlot, events: CustomEventTarget<LinkConnectorEventMap>) {\n    const { node: inputNode, fromSlot, fromReroute } = this\n    if (!inputNode) return\n\n    const newLink = node.connectSlots(output, inputNode, fromSlot, fromReroute?.id)\n    events.dispatch(\"link-created\", newLink)\n  }\n\n  connectToRerouteOutput(\n    reroute: Reroute,\n    outputNode: LGraphNode,\n    output: INodeOutputSlot,\n    events: CustomEventTarget<LinkConnectorEventMap>,\n  ): void {\n    const { node: inputNode, fromSlot } = this\n    const newLink = outputNode.connectSlots(output, inputNode, fromSlot, reroute?.id)\n    events.dispatch(\"link-created\", newLink)\n  }\n\n  connectToInput() {\n    throw new Error(\"ToOutputRenderLink cannot connect to an input.\")\n  }\n\n  connectToRerouteInput() {\n    throw new Error(\"ToOutputRenderLink cannot connect to an input.\")\n  }\n}\n","import type { LinkConnector } from \"./LinkConnector\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork } from \"@/litegraph\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { ToInputRenderLink } from \"./ToInputRenderLink\"\nimport { ToOutputRenderLink } from \"./ToOutputRenderLink\"\n\n/**\n * @internal A workaround class to support connecting to reroutes to node outputs.\n */\nexport class ToOutputFromRerouteLink extends ToOutputRenderLink {\n  constructor(\n    network: LinkNetwork,\n    node: LGraphNode,\n    fromSlot: INodeInputSlot,\n    override readonly fromReroute: Reroute,\n    readonly linkConnector: LinkConnector,\n  ) {\n    super(network, node, fromSlot, fromReroute)\n  }\n\n  override canConnectToReroute(): false {\n    return false\n  }\n\n  override connectToOutput(node: LGraphNode, output: INodeOutputSlot) {\n    const nuRenderLink = new ToInputRenderLink(this.network, node, output)\n    this.linkConnector._connectOutputToReroute(this.fromReroute, nuRenderLink)\n  }\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { ConnectingLink, ItemLocator, LinkNetwork, LinkSegment } from \"@/interfaces\"\nimport type { INodeInputSlot, INodeOutputSlot } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { Reroute } from \"@/Reroute\"\nimport type { CanvasPointerEvent } from \"@/types/events\"\nimport type { IBaseWidget } from \"@/types/widgets\"\n\nimport { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport { LLink } from \"@/LLink\"\nimport { LinkDirection } from \"@/types/globalEnums\"\n\nimport { FloatingRenderLink } from \"./FloatingRenderLink\"\nimport { MovingInputLink } from \"./MovingInputLink\"\nimport { MovingLinkBase } from \"./MovingLinkBase\"\nimport { MovingOutputLink } from \"./MovingOutputLink\"\nimport { ToInputRenderLink } from \"./ToInputRenderLink\"\nimport { ToOutputFromRerouteLink } from \"./ToOutputFromRerouteLink\"\nimport { ToOutputRenderLink } from \"./ToOutputRenderLink\"\n\n/**\n * A Litegraph state object for the {@link LinkConnector}.\n * References are only held atomically within a function, never passed.\n * The concrete implementation may be replaced or proxied without side-effects.\n */\nexport interface LinkConnectorState {\n  /**\n   * The type of slot that links are being connected **to**.\n   * - When `undefined`, no operation is being performed.\n   * - A change in this property indicates the start or end of dragging links.\n   */\n  connectingTo: \"input\" | \"output\" | undefined\n  multi: boolean\n  /** When `true`, existing links are being repositioned. Otherwise, new links are being created. */\n  draggingExistingLinks: boolean\n  /** When set, connecting links will all snap to this position. */\n  snapLinksPos?: [number, number]\n}\n\n/** Discriminated union to simplify type narrowing. */\ntype RenderLinkUnion = MovingInputLink | MovingOutputLink | FloatingRenderLink | ToInputRenderLink | ToOutputRenderLink\n\nexport interface LinkConnectorExport {\n  renderLinks: RenderLink[]\n  inputLinks: LLink[]\n  outputLinks: LLink[]\n  floatingLinks: LLink[]\n  state: LinkConnectorState\n  network: LinkNetwork\n}\n\n/**\n * Component of {@link LGraphCanvas} that handles connecting and moving links.\n * @see {@link LLink}\n */\nexport class LinkConnector {\n  /**\n   * Link connection state POJO. Source of truth for state of link drag operations.\n   *\n   * Can be replaced or proxied to allow notifications.\n   * Is always dereferenced at the start of an operation.\n   */\n  state: LinkConnectorState = {\n    connectingTo: undefined,\n    multi: false,\n    draggingExistingLinks: false,\n    snapLinksPos: undefined,\n  }\n\n  readonly events = new CustomEventTarget<LinkConnectorEventMap>()\n\n  /** Contains information for rendering purposes only. */\n  readonly renderLinks: RenderLinkUnion[] = []\n\n  /** Existing links that are being moved **to** a new input slot. */\n  readonly inputLinks: LLink[] = []\n  /** Existing links that are being moved **to** a new output slot. */\n  readonly outputLinks: LLink[] = []\n  /** Existing floating links that are being moved to a new slot. */\n  readonly floatingLinks: LLink[] = []\n\n  readonly hiddenReroutes: Set<Reroute> = new Set()\n\n  /** The widget beneath the pointer, if it is a valid connection target. */\n  overWidget?: IBaseWidget\n  /** The type (returned by downstream callback) for {@link overWidget} */\n  overWidgetType?: string\n\n  /** The reroute beneath the pointer, if it is a valid connection target. */\n  overReroute?: Reroute\n\n  readonly #setConnectingLinks: (value: ConnectingLink[]) => void\n\n  constructor(setConnectingLinks: (value: ConnectingLink[]) => void) {\n    this.#setConnectingLinks = setConnectingLinks\n  }\n\n  get isConnecting() {\n    return this.state.connectingTo !== undefined\n  }\n\n  get draggingExistingLinks() {\n    return this.state.draggingExistingLinks\n  }\n\n  /** Drag an existing link to a different input. */\n  moveInputLink(network: LinkNetwork, input: INodeInputSlot): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state, inputLinks, renderLinks } = this\n\n    const linkId = input.link\n    if (linkId == null) {\n      // No link connected, check for a floating link\n      const floatingLink = input._floatingLinks?.values().next().value\n      if (floatingLink?.parentId == null) return\n\n      try {\n        const reroute = network.reroutes.get(floatingLink.parentId)\n        if (!reroute) throw new Error(`Invalid reroute id: [${floatingLink.parentId}] for floating link id: [${floatingLink.id}].`)\n\n        const renderLink = new FloatingRenderLink(network, floatingLink, \"input\", reroute)\n        const mayContinue = this.events.dispatch(\"before-move-input\", renderLink)\n        if (mayContinue === false) return\n\n        renderLinks.push(renderLink)\n      } catch (error) {\n        console.warn(`Could not create render link for link id: [${floatingLink.id}].`, floatingLink, error)\n      }\n\n      floatingLink._dragging = true\n      this.floatingLinks.push(floatingLink)\n    } else {\n      const link = network.links.get(linkId)\n      if (!link) return\n\n      try {\n        const reroute = network.getReroute(link.parentId)\n        const renderLink = new MovingInputLink(network, link, reroute)\n\n        const mayContinue = this.events.dispatch(\"before-move-input\", renderLink)\n        if (mayContinue === false) return\n\n        renderLinks.push(renderLink)\n\n        this.listenUntilReset(\"input-moved\", (e) => {\n          e.detail.link.disconnect(network, \"output\")\n        })\n      } catch (error) {\n        console.warn(`Could not create render link for link id: [${link.id}].`, link, error)\n        return\n      }\n\n      link._dragging = true\n      inputLinks.push(link)\n    }\n\n    state.connectingTo = \"input\"\n    state.draggingExistingLinks = true\n\n    this.#setLegacyLinks(false)\n  }\n\n  /** Drag all links from an output to a new output. */\n  moveOutputLink(network: LinkNetwork, output: INodeOutputSlot): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state, renderLinks } = this\n\n    // Floating links\n    if (output._floatingLinks?.size) {\n      for (const floatingLink of output._floatingLinks.values()) {\n        try {\n          const reroute = LLink.getFirstReroute(network, floatingLink)\n          if (!reroute) throw new Error(`Invalid reroute id: [${floatingLink.parentId}] for floating link id: [${floatingLink.id}].`)\n\n          const renderLink = new FloatingRenderLink(network, floatingLink, \"output\", reroute)\n          const mayContinue = this.events.dispatch(\"before-move-output\", renderLink)\n          if (mayContinue === false) continue\n\n          renderLinks.push(renderLink)\n          this.floatingLinks.push(floatingLink)\n        } catch (error) {\n          console.warn(`Could not create render link for link id: [${floatingLink.id}].`, floatingLink, error)\n        }\n      }\n    }\n\n    // Normal links\n    if (output.links?.length) {\n      for (const linkId of output.links) {\n        const link = network.links.get(linkId)\n        if (!link) continue\n\n        const firstReroute = LLink.getFirstReroute(network, link)\n        if (firstReroute) {\n          firstReroute._dragging = true\n          this.hiddenReroutes.add(firstReroute)\n        } else {\n          link._dragging = true\n        }\n        this.outputLinks.push(link)\n\n        try {\n          const renderLink = new MovingOutputLink(network, link, firstReroute, LinkDirection.RIGHT)\n\n          const mayContinue = this.events.dispatch(\"before-move-output\", renderLink)\n          if (mayContinue === false) continue\n\n          renderLinks.push(renderLink)\n        } catch (error) {\n          console.warn(`Could not create render link for link id: [${link.id}].`, link, error)\n          continue\n        }\n      }\n    }\n\n    if (renderLinks.length === 0) return\n\n    state.draggingExistingLinks = true\n    state.multi = true\n    state.connectingTo = \"output\"\n\n    this.#setLegacyLinks(true)\n  }\n\n  /**\n   * Drags a new link from an output slot to an input slot.\n   * @param network The network that the link being connected belongs to\n   * @param node The node the link is being dragged from\n   * @param output The output slot that the link is being dragged from\n   */\n  dragNewFromOutput(network: LinkNetwork, node: LGraphNode, output: INodeOutputSlot, fromReroute?: Reroute): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state } = this\n    const renderLink = new ToInputRenderLink(network, node, output, fromReroute)\n    this.renderLinks.push(renderLink)\n\n    state.connectingTo = \"input\"\n\n    this.#setLegacyLinks(false)\n  }\n\n  /**\n   * Drags a new link from an input slot to an output slot.\n   * @param network The network that the link being connected belongs to\n   * @param node The node the link is being dragged from\n   * @param input The input slot that the link is being dragged from\n   */\n  dragNewFromInput(network: LinkNetwork, node: LGraphNode, input: INodeInputSlot, fromReroute?: Reroute): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state } = this\n    const renderLink = new ToOutputRenderLink(network, node, input, fromReroute)\n    this.renderLinks.push(renderLink)\n\n    state.connectingTo = \"output\"\n\n    this.#setLegacyLinks(true)\n  }\n\n  /**\n   * Drags a new link from a reroute to an input slot.\n   * @param network The network that the link being connected belongs to\n   * @param reroute The reroute that the link is being dragged from\n   */\n  dragFromReroute(network: LinkNetwork, reroute: Reroute): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const link = reroute.firstLink ?? reroute.firstFloatingLink\n    if (!link) {\n      console.warn(\"No link found for reroute.\")\n      return\n    }\n\n    const outputNode = network.getNodeById(link.origin_id)\n    if (!outputNode) {\n      console.warn(\"No output node found for link.\", link)\n      return\n    }\n\n    const outputSlot = outputNode.outputs.at(link.origin_slot)\n    if (!outputSlot) {\n      console.warn(\"No output slot found for link.\", link)\n      return\n    }\n\n    const renderLink = new ToInputRenderLink(network, outputNode, outputSlot, reroute)\n    renderLink.fromDirection = LinkDirection.NONE\n    this.renderLinks.push(renderLink)\n\n    this.state.connectingTo = \"input\"\n\n    this.#setLegacyLinks(false)\n  }\n\n  /**\n   * Drags a new link from a reroute to an output slot.\n   * @param network The network that the link being connected belongs to\n   * @param reroute The reroute that the link is being dragged from\n   */\n  dragFromRerouteToOutput(network: LinkNetwork, reroute: Reroute): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const link = reroute.firstLink ?? reroute.firstFloatingLink\n    if (!link) {\n      console.warn(\"No link found for reroute.\")\n      return\n    }\n\n    const inputNode = network.getNodeById(link.target_id)\n    if (!inputNode) {\n      console.warn(\"No input node found for link.\", link)\n      return\n    }\n\n    const inputSlot = inputNode.inputs.at(link.target_slot)\n    if (!inputSlot) {\n      console.warn(\"No input slot found for link.\", link)\n      return\n    }\n\n    const renderLink = new ToOutputFromRerouteLink(network, inputNode, inputSlot, reroute, this)\n    renderLink.fromDirection = LinkDirection.LEFT\n    this.renderLinks.push(renderLink)\n\n    this.state.connectingTo = \"output\"\n\n    this.#setLegacyLinks(true)\n  }\n\n  dragFromLinkSegment(network: LinkNetwork, linkSegment: LinkSegment): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state } = this\n    if (linkSegment.origin_id == null || linkSegment.origin_slot == null) return\n\n    const node = network.getNodeById(linkSegment.origin_id)\n    if (!node) return\n\n    const slot = node.outputs.at(linkSegment.origin_slot)\n    if (!slot) return\n\n    const reroute = network.getReroute(linkSegment.parentId)\n    const renderLink = new ToInputRenderLink(network, node, slot, reroute)\n    renderLink.fromDirection = LinkDirection.NONE\n    this.renderLinks.push(renderLink)\n\n    state.connectingTo = \"input\"\n\n    this.#setLegacyLinks(false)\n  }\n\n  /**\n   * Connects the links being droppe\n   * @param event Contains the drop location, in canvas space\n   */\n  dropLinks(locator: ItemLocator, event: CanvasPointerEvent): void {\n    if (!this.isConnecting) {\n      console.warn(\"Attempted to drop links when not connecting to anything.\")\n      return\n    }\n\n    const { renderLinks } = this\n    const mayContinue = this.events.dispatch(\"before-drop-links\", { renderLinks, event })\n    if (mayContinue === false) return\n\n    const { canvasX, canvasY } = event\n    const node = locator.getNodeOnPos(canvasX, canvasY) ?? undefined\n    if (node) {\n      this.dropOnNode(node, event)\n    } else {\n      // Get reroute if no node is found\n      const reroute = locator.getRerouteOnPos(canvasX, canvasY)\n      // Drop output->input link on reroute is not impl.\n      if (reroute && this.isRerouteValidDrop(reroute)) {\n        this.dropOnReroute(reroute, event)\n      } else {\n        this.dropOnNothing(event)\n      }\n    }\n\n    this.events.dispatch(\"after-drop-links\", { renderLinks, event })\n  }\n\n  dropOnNode(node: LGraphNode, event: CanvasPointerEvent) {\n    const { renderLinks, state } = this\n    const { connectingTo } = state\n    const { canvasX, canvasY } = event\n\n    // Do nothing if every connection would loop back\n    if (renderLinks.every(link => link.node === node)) return\n\n    // To output\n    if (connectingTo === \"output\") {\n      const output = node.getOutputOnPos([canvasX, canvasY])\n\n      if (output) {\n        this.#dropOnOutput(node, output)\n      } else {\n        this.connectToNode(node, event)\n      }\n    // To input\n    } else if (connectingTo === \"input\") {\n      const input = node.getInputOnPos([canvasX, canvasY])\n      const inputOrSocket = input ?? node.getSlotFromWidget(this.overWidget)\n\n      // Input slot\n      if (inputOrSocket) {\n        this.#dropOnInput(node, inputOrSocket)\n      } else {\n        // Node background / title\n        this.connectToNode(node, event)\n      }\n    }\n  }\n\n  dropOnReroute(reroute: Reroute, event: CanvasPointerEvent): void {\n    const mayContinue = this.events.dispatch(\"dropped-on-reroute\", { reroute, event })\n    if (mayContinue === false) return\n\n    // Connecting to input\n    if (this.state.connectingTo === \"input\") {\n      if (this.renderLinks.length !== 1) throw new Error(`Attempted to connect ${this.renderLinks.length} input links to a reroute.`)\n\n      const renderLink = this.renderLinks[0]\n      this._connectOutputToReroute(reroute, renderLink)\n\n      return\n    }\n\n    // Connecting to output\n    for (const link of this.renderLinks) {\n      if (link.toType !== \"output\") continue\n\n      const result = reroute.findSourceOutput()\n      if (!result) continue\n\n      const { node, output } = result\n      if (!link.canConnectToOutput(node, output)) continue\n\n      link.connectToRerouteOutput(reroute, node, output, this.events)\n    }\n  }\n\n  /** @internal Temporary workaround - requires refactor. */\n  _connectOutputToReroute(reroute: Reroute, renderLink: RenderLinkUnion): void {\n    const results = reroute.findTargetInputs()\n    if (!results?.length) return\n\n    const maybeReroutes = reroute.getReroutes()\n    if (maybeReroutes === null) throw new Error(\"Reroute loop detected.\")\n\n    const originalReroutes = maybeReroutes.slice(0, -1).reverse()\n\n    // From reroute to reroute\n    if (renderLink instanceof ToInputRenderLink) {\n      const { node, fromSlot, fromSlotIndex, fromReroute } = renderLink\n\n      reroute.setFloatingLinkOrigin(node, fromSlot, fromSlotIndex)\n\n      // Clean floating link IDs from reroutes about to be removed from the chain\n      if (fromReroute != null) {\n        for (const originalReroute of originalReroutes) {\n          if (originalReroute.id === fromReroute.id) break\n\n          for (const linkId of reroute.floatingLinkIds) {\n            originalReroute.floatingLinkIds.delete(linkId)\n          }\n        }\n      }\n    }\n\n    // Filter before any connections are re-created\n    const filtered = results.filter(result => renderLink.toType === \"input\" && canConnectInputLinkToReroute(renderLink, result.node, result.input, reroute))\n\n    for (const result of filtered) {\n      renderLink.connectToRerouteInput(reroute, result, this.events, originalReroutes)\n    }\n\n    return\n  }\n\n  dropOnNothing(event: CanvasPointerEvent): void {\n    // For external event only.\n    const mayContinue = this.events.dispatch(\"dropped-on-canvas\", event)\n    if (mayContinue === false) return\n\n    this.disconnectLinks()\n  }\n\n  /**\n   * Disconnects all moving links.\n   * @remarks This is called when the links are dropped on the canvas.\n   * May be called by consumers to e.g. drag links into a bin / void.\n   */\n  disconnectLinks(): void {\n    for (const link of this.renderLinks) {\n      if (link instanceof MovingLinkBase) {\n        link.disconnect()\n      }\n    }\n  }\n\n  /**\n   * Connects the links being dropped onto a node to the first matching slot.\n   * @param node The node that the links are being dropped on\n   * @param event Contains the drop location, in canvas space\n   */\n  connectToNode(node: LGraphNode, event: CanvasPointerEvent): void {\n    const { state: { connectingTo } } = this\n\n    const mayContinue = this.events.dispatch(\"dropped-on-node\", { node, event })\n    if (mayContinue === false) return\n\n    // Assume all links are the same type, disallow loopback\n    const firstLink = this.renderLinks[0]\n    if (!firstLink) return\n\n    // Use a single type check before looping; ensures all dropped links go to the same slot\n    if (connectingTo === \"output\") {\n      // Dropping new output link\n      const output = node.findOutputByType(firstLink.fromSlot.type)?.slot\n      if (!output) {\n        console.warn(`Could not find slot for link type: [${firstLink.fromSlot.type}].`)\n        return\n      }\n\n      this.#dropOnOutput(node, output)\n    } else if (connectingTo === \"input\") {\n      // Dropping new input link\n      const input = node.findInputByType(firstLink.fromSlot.type)?.slot\n      if (!input) {\n        console.warn(`Could not find slot for link type: [${firstLink.fromSlot.type}].`)\n        return\n      }\n\n      this.#dropOnInput(node, input)\n    }\n  }\n\n  #dropOnInput(node: LGraphNode, input: INodeInputSlot): void {\n    for (const link of this.renderLinks) {\n      if (!link.canConnectToInput(node, input)) continue\n\n      link.connectToInput(node, input, this.events)\n    }\n  }\n\n  #dropOnOutput(node: LGraphNode, output: INodeOutputSlot): void {\n    for (const link of this.renderLinks) {\n      if (!link.canConnectToOutput(node, output)) {\n        if (link instanceof MovingOutputLink && link.link.parentId !== undefined) {\n          // Reconnect link without reroutes\n          link.outputNode.connectSlots(link.outputSlot, link.inputNode, link.inputSlot, undefined!)\n        }\n        continue\n      }\n\n      link.connectToOutput(node, output, this.events)\n    }\n  }\n\n  isInputValidDrop(node: LGraphNode, input: INodeInputSlot): boolean {\n    return this.renderLinks.some(link => link.canConnectToInput(node, input))\n  }\n\n  isNodeValidDrop(node: LGraphNode): boolean {\n    if (this.state.connectingTo === \"output\") {\n      return node.outputs.some(output => this.renderLinks.some(link => link.canConnectToOutput(node, output)))\n    }\n\n    return node.inputs.some(input => this.renderLinks.some(link => link.canConnectToInput(node, input)))\n  }\n\n  /**\n   * Checks if a reroute is a valid drop target for any of the links being connected.\n   * @param reroute The reroute that would be dropped on.\n   * @returns `true` if any of the current links being connected are valid for the given reroute.\n   */\n  isRerouteValidDrop(reroute: Reroute): boolean {\n    if (this.state.connectingTo === \"input\") {\n      const results = reroute.findTargetInputs()\n      if (!results?.length) return false\n\n      for (const { node, input } of results) {\n        for (const renderLink of this.renderLinks) {\n          if (renderLink.toType !== \"input\") continue\n          if (canConnectInputLinkToReroute(renderLink, node, input, reroute)) return true\n        }\n      }\n    } else {\n      const result = reroute.findSourceOutput()\n      if (!result) return false\n\n      const { node, output } = result\n\n      for (const renderLink of this.renderLinks) {\n        if (renderLink.toType !== \"output\") continue\n        if (!renderLink.canConnectToReroute(reroute)) continue\n        if (renderLink.canConnectToOutput(node, output)) return true\n      }\n    }\n\n    return false\n  }\n\n  /** Sets connecting_links, used by some extensions still. */\n  #setLegacyLinks(fromSlotIsInput: boolean): void {\n    const links = this.renderLinks.map((link) => {\n      const input = fromSlotIsInput ? link.fromSlot as INodeInputSlot : null\n      const output = fromSlotIsInput ? null : link.fromSlot as INodeOutputSlot\n\n      const afterRerouteId = link instanceof MovingLinkBase ? link.link?.parentId : link.fromReroute?.id\n\n      return {\n        node: link.node,\n        slot: link.fromSlotIndex,\n        input,\n        output,\n        pos: link.fromPos,\n        afterRerouteId,\n      } satisfies ConnectingLink\n    })\n    this.#setConnectingLinks(links)\n  }\n\n  /**\n   * Exports the current state of the link connector.\n   * @param network The network that the links being connected belong to.\n   * @returns A POJO with the state of the link connector, links being connected, and their network.\n   * @remarks Other than {@link network}, all properties are shallow cloned.\n   */\n  export(network: LinkNetwork): LinkConnectorExport {\n    return {\n      renderLinks: [...this.renderLinks],\n      inputLinks: [...this.inputLinks],\n      outputLinks: [...this.outputLinks],\n      floatingLinks: [...this.floatingLinks],\n      state: { ...this.state },\n      network,\n    }\n  }\n\n  /**\n   * Adds an event listener that will be automatically removed when the reset event is fired.\n   * @param eventName The event to listen for.\n   * @param listener The listener to call when the event is fired.\n   */\n  listenUntilReset<K extends keyof LinkConnectorEventMap>(\n    eventName: K,\n    listener: Parameters<typeof this.events.addEventListener<K>>[1],\n    options?: Parameters<typeof this.events.addEventListener<K>>[2],\n  ) {\n    this.events.addEventListener(eventName, listener, options)\n    this.events.addEventListener(\"reset\", () => this.events.removeEventListener(eventName, listener), { once: true })\n  }\n\n  /**\n   * Resets everything to its initial state.\n   *\n   * Effectively cancels moving or connecting links.\n   */\n  reset(force = false): void {\n    const mayContinue = this.events.dispatch(\"reset\", force)\n    if (mayContinue === false) return\n\n    const { state, outputLinks, inputLinks, hiddenReroutes, renderLinks, floatingLinks } = this\n\n    if (!force && state.connectingTo === undefined) return\n    state.connectingTo = undefined\n\n    for (const link of outputLinks) delete link._dragging\n    for (const link of inputLinks) delete link._dragging\n    for (const link of floatingLinks) delete link._dragging\n    for (const reroute of hiddenReroutes) delete reroute._dragging\n\n    renderLinks.length = 0\n    inputLinks.length = 0\n    outputLinks.length = 0\n    floatingLinks.length = 0\n    hiddenReroutes.clear()\n    state.multi = false\n    state.draggingExistingLinks = false\n    state.snapLinksPos = undefined\n  }\n}\n\n/** Validates that a single {@link RenderLink} can be dropped on the specified reroute. */\nfunction canConnectInputLinkToReroute(\n  link: ToInputRenderLink | MovingInputLink | FloatingRenderLink,\n  inputNode: LGraphNode,\n  input: INodeInputSlot,\n  reroute: Reroute,\n): boolean {\n  const { fromReroute } = link\n\n  if (\n    !link.canConnectToInput(inputNode, input) ||\n    // Would result in no change\n    fromReroute?.id === reroute.id ||\n    // Cannot connect from child to parent reroute\n    fromReroute?.getReroutes()?.includes(reroute)\n  ) {\n    return false\n  }\n\n  // Would result in no change\n  if (link instanceof ToInputRenderLink) {\n    if (reroute.parentId == null) {\n      // Link would make no change - output to reroute\n      if (reroute.firstLink?.hasOrigin(link.node.id, link.fromSlotIndex)) return false\n    } else if (link.fromReroute?.id === reroute.parentId) {\n      return false\n    }\n  }\n  return true\n}\n","import type {\n  HasBoundingRect,\n  Point,\n  ReadOnlyPoint,\n  ReadOnlyRect,\n  Rect,\n} from \"./interfaces\"\n\nimport { LinkDirection } from \"./types/globalEnums\"\n\n/**\n * Calculates the distance between two points (2D vector)\n * @param a Point a as `x, y`\n * @param b Point b as `x, y`\n * @returns Distance between point {@link a} & {@link b}\n */\nexport function distance(a: ReadOnlyPoint, b: ReadOnlyPoint): number {\n  return Math.sqrt(\n    (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]),\n  )\n}\n\n/**\n * Calculates the distance2 (squared) between two points (2D vector).\n * Much faster when only comparing distances (closest/furthest point).\n * @param x1 Origin point X\n * @param y1 Origin point Y\n * @param x2 Destination point X\n * @param y2 Destination point Y\n * @returns Distance2 (squared) between point [{@link x1}, {@link y1}] & [{@link x2}, {@link y2}]\n */\nexport function dist2(x1: number, y1: number, x2: number, y2: number): number {\n  return ((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1))\n}\n\n/**\n * Determines whether a point is inside a rectangle.\n *\n * Otherwise identical to {@link isInsideRectangle}, it also returns `true` if `x` equals `left` or `y` equals `top`.\n * @param x Point x\n * @param y Point y\n * @param left Rect x\n * @param top Rect y\n * @param width Rect width\n * @param height Rect height\n * @returns `true` if the point is inside the rect, otherwise `false`\n */\nexport function isInRectangle(\n  x: number,\n  y: number,\n  left: number,\n  top: number,\n  width: number,\n  height: number,\n): boolean {\n  return x >= left &&\n    x < left + width &&\n    y >= top &&\n    y < top + height\n}\n\n/**\n * Determines whether a {@link Point} is inside a {@link Rect}.\n * @param point The point to check, as `x, y`\n * @param rect The rectangle, as `x, y, width, height`\n * @returns `true` if the point is inside the rect, otherwise `false`\n */\nexport function isPointInRect(point: ReadOnlyPoint, rect: ReadOnlyRect): boolean {\n  return point[0] >= rect[0] &&\n    point[0] < rect[0] + rect[2] &&\n    point[1] >= rect[1] &&\n    point[1] < rect[1] + rect[3]\n}\n\n/**\n * Determines whether the point represented by {@link x}, {@link y} is inside a {@link Rect}.\n * @param x X co-ordinate of the point to check\n * @param y Y co-ordinate of the point to check\n * @param rect The rectangle, as `x, y, width, height`\n * @returns `true` if the point is inside the rect, otherwise `false`\n */\nexport function isInRect(x: number, y: number, rect: ReadOnlyRect): boolean {\n  return x >= rect[0] &&\n    x < rect[0] + rect[2] &&\n    y >= rect[1] &&\n    y < rect[1] + rect[3]\n}\n\n/**\n * Determines whether a point (`x, y`) is inside a rectangle.\n *\n * This is the original litegraph implementation.  It returns `false` if `x` is equal to `left`, or `y` is equal to `top`.\n * @deprecated\n * Use {@link isInRectangle} to match inclusive of top left.\n * This function returns a false negative when an integer point (e.g. pixel) is on the leftmost or uppermost edge of a rectangle.\n * @param x Point x\n * @param y Point y\n * @param left Rect x\n * @param top Rect y\n * @param width Rect width\n * @param height Rect height\n * @returns `true` if the point is inside the rect, otherwise `false`\n */\nexport function isInsideRectangle(\n  x: number,\n  y: number,\n  left: number,\n  top: number,\n  width: number,\n  height: number,\n): boolean {\n  return left < x &&\n    left + width > x &&\n    top < y &&\n    top + height > y\n}\n\n/**\n * Determines if two rectangles have any overlap\n * @param a Rectangle A as `x, y, width, height`\n * @param b Rectangle B as `x, y, width, height`\n * @returns `true` if rectangles overlap, otherwise `false`\n */\nexport function overlapBounding(a: ReadOnlyRect, b: ReadOnlyRect): boolean {\n  const aRight = a[0] + a[2]\n  const aBottom = a[1] + a[3]\n  const bRight = b[0] + b[2]\n  const bBottom = b[1] + b[3]\n\n  return a[0] > bRight ||\n    a[1] > bBottom ||\n    aRight < b[0] ||\n    aBottom < b[1]\n    ? false\n    : true\n}\n\n/**\n * Returns the centre of a rectangle.\n * @param rect The rectangle, as `x, y, width, height`\n * @returns The centre of the rectangle, as `x, y`\n */\nexport function getCentre(rect: ReadOnlyRect): Point {\n  return [\n    rect[0] + (rect[2] * 0.5),\n    rect[1] + (rect[3] * 0.5),\n  ]\n}\n\n/**\n * Determines if rectangle {@link a} contains the centre point of rectangle {@link b}.\n * @param a Container rectangle A as `x, y, width, height`\n * @param b Sub-rectangle B as `x, y, width, height`\n * @returns `true` if {@link a} contains most of {@link b}, otherwise `false`\n */\nexport function containsCentre(a: ReadOnlyRect, b: ReadOnlyRect): boolean {\n  const centreX = b[0] + (b[2] * 0.5)\n  const centreY = b[1] + (b[3] * 0.5)\n  return isInRect(centreX, centreY, a)\n}\n\n/**\n * Determines if rectangle {@link a} wholly contains rectangle {@link b}.\n * @param a Container rectangle A as `x, y, width, height`\n * @param b Sub-rectangle B as `x, y, width, height`\n * @returns `true` if {@link a} wholly contains {@link b}, otherwise `false`\n */\nexport function containsRect(a: ReadOnlyRect, b: ReadOnlyRect): boolean {\n  const aRight = a[0] + a[2]\n  const aBottom = a[1] + a[3]\n  const bRight = b[0] + b[2]\n  const bBottom = b[1] + b[3]\n\n  const identical = a[0] === b[0] &&\n    a[1] === b[1] &&\n    aRight === bRight &&\n    aBottom === bBottom\n\n  return !identical &&\n    a[0] <= b[0] &&\n    a[1] <= b[1] &&\n    aRight >= bRight &&\n    aBottom >= bBottom\n}\n\n/**\n * Adds an offset in the specified direction to {@link out}\n * @param amount Amount of offset to add\n * @param direction Direction to add the offset to\n * @param out The {@link Point} to add the offset to\n */\nexport function addDirectionalOffset(\n  amount: number,\n  direction: LinkDirection,\n  out: Point,\n): void {\n  switch (direction) {\n  case LinkDirection.LEFT:\n    out[0] -= amount\n    return\n  case LinkDirection.RIGHT:\n    out[0] += amount\n    return\n  case LinkDirection.UP:\n    out[1] -= amount\n    return\n  case LinkDirection.DOWN:\n    out[1] += amount\n    return\n    // LinkDirection.CENTER: Nothing to do.\n  }\n}\n\n/**\n * Rotates an offset in 90Â° increments.\n *\n * Swaps/flips axis values of a 2D vector offset - effectively rotating\n * {@link offset} by 90Â°\n * @param offset The zero-based offset to rotate\n * @param from Direction to rotate from\n * @param to Direction to rotate to\n */\nexport function rotateLink(\n  offset: Point,\n  from: LinkDirection,\n  to: LinkDirection,\n): void {\n  let x: number\n  let y: number\n\n  // Normalise to left\n  switch (from) {\n  case to:\n  case LinkDirection.CENTER:\n  case LinkDirection.NONE:\n  default:\n    // Nothing to do\n    return\n\n  case LinkDirection.LEFT:\n    x = offset[0]\n    y = offset[1]\n    break\n  case LinkDirection.RIGHT:\n    x = -offset[0]\n    y = -offset[1]\n    break\n  case LinkDirection.UP:\n    x = -offset[1]\n    y = offset[0]\n    break\n  case LinkDirection.DOWN:\n    x = offset[1]\n    y = -offset[0]\n    break\n  }\n\n  // Apply new direction\n  switch (to) {\n  case LinkDirection.CENTER:\n  case LinkDirection.NONE:\n    // Nothing to do\n    return\n\n  case LinkDirection.LEFT:\n    offset[0] = x\n    offset[1] = y\n    break\n  case LinkDirection.RIGHT:\n    offset[0] = -x\n    offset[1] = -y\n    break\n  case LinkDirection.UP:\n    offset[0] = y\n    offset[1] = -x\n    break\n  case LinkDirection.DOWN:\n    offset[0] = -y\n    offset[1] = x\n    break\n  }\n}\n\n/**\n * Check if a point is to to the left or right of a line.\n * Project a line from lineStart -> lineEnd.  Determine if point is to the left\n * or right of that projection.\n * {@link https://www.geeksforgeeks.org/orientation-3-ordered-points/}\n * @param lineStart The start point of the line\n * @param lineEnd The end point of the line\n * @param x X co-ordinate of the point to check\n * @param y Y co-ordinate of the point to check\n * @returns 0 if all three points are in a straight line, a negative value if\n * point is to the left of the projected line, or positive if the point is to\n * the right\n */\nexport function getOrientation(\n  lineStart: ReadOnlyPoint,\n  lineEnd: ReadOnlyPoint,\n  x: number,\n  y: number,\n): number {\n  return ((lineEnd[1] - lineStart[1]) * (x - lineEnd[0])) -\n    ((lineEnd[0] - lineStart[0]) * (y - lineEnd[1]))\n}\n\n/**\n * @param out The array to store the point in\n * @param a Start point\n * @param b End point\n * @param controlA Start curve control point\n * @param controlB End curve control point\n * @param t Time: factor of distance to travel along the curve (e.g 0.25 is 25% along the curve)\n */\nexport function findPointOnCurve(\n  out: Point,\n  a: ReadOnlyPoint,\n  b: ReadOnlyPoint,\n  controlA: ReadOnlyPoint,\n  controlB: ReadOnlyPoint,\n  t: number = 0.5,\n): void {\n  const iT = 1 - t\n\n  const c1 = iT * iT * iT\n  const c2 = 3 * (iT * iT) * t\n  const c3 = 3 * iT * (t * t)\n  const c4 = t * t * t\n\n  out[0] = (c1 * a[0]) + (c2 * controlA[0]) + (c3 * controlB[0]) + (c4 * b[0])\n  out[1] = (c1 * a[1]) + (c2 * controlA[1]) + (c3 * controlB[1]) + (c4 * b[1])\n}\n\nexport function createBounds(\n  objects: Iterable<HasBoundingRect>,\n  padding: number = 10,\n): ReadOnlyRect | null {\n  const bounds = new Float32Array([Infinity, Infinity, -Infinity, -Infinity])\n\n  for (const obj of objects) {\n    const rect = obj.boundingRect\n    bounds[0] = Math.min(bounds[0], rect[0])\n    bounds[1] = Math.min(bounds[1], rect[1])\n    bounds[2] = Math.max(bounds[2], rect[0] + rect[2])\n    bounds[3] = Math.max(bounds[3], rect[1] + rect[3])\n  }\n  if (!bounds.every(x => isFinite(x))) return null\n\n  return [\n    bounds[0] - padding,\n    bounds[1] - padding,\n    bounds[2] - bounds[0] + (2 * padding),\n    bounds[3] - bounds[1] + (2 * padding),\n  ]\n}\n\n/**\n * Snaps the provided {@link Point} or {@link Rect} ({@link pos}) to a grid of size {@link snapTo}.\n * @param pos The point that will be snapped\n * @param snapTo The value to round up/down by (multiples thereof)\n * @returns `true` if snapTo is truthy, otherwise `false`\n * @remarks `NaN` propagates through this function and does not affect return value.\n */\nexport function snapPoint(pos: Point | Rect, snapTo: number): boolean {\n  if (!snapTo) return false\n\n  pos[0] = snapTo * Math.round(pos[0] / snapTo)\n  pos[1] = snapTo * Math.round(pos[1] / snapTo)\n  return true\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return value < min ? min : (value > max ? max : value)\n}\n","import type { INodeInputSlot, INodeOutputSlot, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\n\nimport { isInRectangle } from \"@/measure\"\n\nexport function getNodeInputOnPos(node: LGraphNode, x: number, y: number): { index: number, input: INodeInputSlot, pos: Point } | undefined {\n  const { inputs } = node\n  if (!inputs) return\n\n  for (const [index, input] of inputs.entries()) {\n    const pos = node.getInputPos(index)\n\n    // TODO: Find a cheap way to measure text, and do it on node label change instead of here\n    // Input icon width + text approximation\n    const nameLength = input.label?.length ?? input.localized_name?.length ?? input.name?.length\n    const width = 20 + (nameLength || 3) * 7\n\n    if (isInRectangle(\n      x,\n      y,\n      pos[0] - 10,\n      pos[1] - 10,\n      width,\n      20,\n    )) {\n      return { index, input, pos }\n    }\n  }\n}\n\nexport function getNodeOutputOnPos(node: LGraphNode, x: number, y: number): { index: number, output: INodeOutputSlot, pos: Point } | undefined {\n  const { outputs } = node\n  if (!outputs) return\n\n  for (const [index, output] of outputs.entries()) {\n    const pos = node.getOutputPos(index)\n\n    if (isInRectangle(\n      x,\n      y,\n      pos[0] - 10,\n      pos[1] - 10,\n      40,\n      20,\n    )) {\n      return { index, output, pos }\n    }\n  }\n}\n\n/**\n * Returns the input slot index if the given position (in graph space) is on top of a node input slot.\n * A helper function - originally on the prototype of LGraphCanvas.\n */\nexport function isOverNodeInput(\n  node: LGraphNode,\n  canvasx: number,\n  canvasy: number,\n  slot_pos?: Point,\n): number {\n  const result = getNodeInputOnPos(node, canvasx, canvasy)\n  if (!result) return -1\n\n  if (slot_pos) {\n    slot_pos[0] = result.pos[0]\n    slot_pos[1] = result.pos[1]\n  }\n  return result.index\n}\n\n/**\n * Returns the output slot index if the given position (in graph space) is on top of a node output slot.\n * A helper function - originally on the prototype of LGraphCanvas.\n */\nexport function isOverNodeOutput(\n  node: LGraphNode,\n  canvasx: number,\n  canvasy: number,\n  slot_pos?: Point,\n): number {\n  const result = getNodeOutputOnPos(node, canvasx, canvasy)\n  if (!result) return -1\n\n  if (slot_pos) {\n    slot_pos[0] = result.pos[0]\n    slot_pos[1] = result.pos[1]\n  }\n  return result.index\n}\n","import type { CanvasPointerEvent } from \"./types/events\"\n\nimport { dist2 } from \"./measure\"\n\n/**\n * Allows click and drag actions to be declared ahead of time during a pointerdown event.\n *\n * By default, it retains the most recent event of each type until it is reset (on pointerup).\n * - {@link eDown}\n * - {@link eMove}\n * - {@link eUp}\n *\n * Depending on whether the user clicks or drags the pointer, only the appropriate callbacks are called:\n * - {@link onClick}\n * - {@link onDoubleClick}\n * - {@link onDragStart}\n * - {@link onDrag}\n * - {@link onDragEnd}\n * - {@link finally}\n * @see\n * - {@link LGraphCanvas.processMouseDown}\n * - {@link LGraphCanvas.processMouseMove}\n * - {@link LGraphCanvas.processMouseUp}\n */\nexport class CanvasPointer {\n  /** Maximum time in milliseconds to ignore click drift */\n  static bufferTime = 150\n\n  /** Maximum gap between pointerup and pointerdown events to be considered as a double click */\n  static doubleClickTime = 300\n\n  /** Maximum offset from click location */\n  static get maxClickDrift() {\n    return this.#maxClickDrift\n  }\n\n  static set maxClickDrift(value) {\n    this.#maxClickDrift = value\n    this.#maxClickDrift2 = value * value\n  }\n\n  static #maxClickDrift = 6\n  /** {@link maxClickDrift} squared.  Used to calculate click drift without `sqrt`. */\n  static #maxClickDrift2 = this.#maxClickDrift ** 2\n\n  /** The element this PointerState should capture input against when dragging. */\n  element: Element\n  /** Pointer ID used by drag capture. */\n  pointerId?: number\n\n  /** Set to true when if the pointer moves far enough after a down event, before the corresponding up event is fired. */\n  dragStarted: boolean = false\n\n  /** The {@link eUp} from the last successful click */\n  eLastDown?: CanvasPointerEvent\n\n  /** Used downstream for touch event support. */\n  isDouble: boolean = false\n  /** Used downstream for touch event support. */\n  isDown: boolean = false\n\n  /**\n   * If `true`, {@link eDown}, {@link eMove}, and {@link eUp} will be set to\n   * `undefined` when {@link reset} is called.\n   *\n   * Default: `true`\n   */\n  clearEventsOnReset: boolean = true\n\n  /** The last pointerdown event for the primary button */\n  eDown?: CanvasPointerEvent\n  /** The last pointermove event for the primary button */\n  eMove?: CanvasPointerEvent\n  /** The last pointerup event for the primary button */\n  eUp?: CanvasPointerEvent\n\n  /**\n   * If set, as soon as the mouse moves outside the click drift threshold, this action is run once.\n   * @param pointer [DEPRECATED] This parameter will be removed in a future release.\n   * @param eMove The pointermove event of this ongoing drag action.\n   *\n   * It is possible for no `pointermove` events to occur, but still be far from\n   * the original `pointerdown` event. In this case, {@link eMove} will be null, and\n   * {@link onDragEnd} will be called immediately after {@link onDragStart}.\n   */\n  onDragStart?(pointer: this, eMove?: CanvasPointerEvent): unknown\n\n  /**\n   * Called on pointermove whilst dragging.\n   * @param eMove The pointermove event of this ongoing drag action\n   */\n  onDrag?(eMove: CanvasPointerEvent): unknown\n\n  /**\n   * Called on pointerup after dragging (i.e. not called if clicked).\n   * @param upEvent The pointerup or pointermove event that triggered this callback\n   */\n  onDragEnd?(upEvent: CanvasPointerEvent): unknown\n\n  /**\n   * Callback that will be run once, the next time a pointerup event appears to be a normal click.\n   * @param upEvent The pointerup or pointermove event that triggered this callback\n   */\n  onClick?(upEvent: CanvasPointerEvent): unknown\n\n  /**\n   * Callback that will be run once, the next time a pointerup event appears to be a normal click.\n   * @param upEvent The pointerup or pointermove event that triggered this callback\n   */\n  onDoubleClick?(upEvent: CanvasPointerEvent): unknown\n\n  /**\n   * Run-once callback, called at the end of any click or drag, whether or not it was successful in any way.\n   *\n   * The setter of this callback will call the existing value before replacing it.\n   * Therefore, simply setting this value twice will execute the first callback.\n   */\n  get finally() {\n    return this.#finally\n  }\n\n  set finally(value) {\n    try {\n      this.#finally?.()\n    } finally {\n      this.#finally = value\n    }\n  }\n\n  #finally?: () => unknown\n\n  constructor(element: Element) {\n    this.element = element\n  }\n\n  /**\n   * Callback for `pointerdown` events.  To be used as the event handler (or called by it).\n   * @param e The `pointerdown` event\n   */\n  down(e: CanvasPointerEvent): void {\n    this.reset()\n    this.eDown = e\n    this.pointerId = e.pointerId\n    this.element.setPointerCapture(e.pointerId)\n  }\n\n  /**\n   * Callback for `pointermove` events.  To be used as the event handler (or called by it).\n   * @param e The `pointermove` event\n   */\n  move(e: CanvasPointerEvent): void {\n    const { eDown } = this\n    if (!eDown) return\n\n    // No buttons down, but eDown exists - clean up & leave\n    if (!e.buttons) {\n      this.reset()\n      return\n    }\n\n    // Primary button released - treat as pointerup.\n    if (!(e.buttons & eDown.buttons)) {\n      this.#completeClick(e)\n      this.reset()\n      return\n    }\n    this.eMove = e\n    this.onDrag?.(e)\n\n    // Dragging, but no callback to run\n    if (this.dragStarted) return\n\n    const longerThanBufferTime = e.timeStamp - eDown.timeStamp > CanvasPointer.bufferTime\n    if (longerThanBufferTime || !this.#hasSamePosition(e, eDown)) {\n      this.#setDragStarted(e)\n    }\n  }\n\n  /**\n   * Callback for `pointerup` events.  To be used as the event handler (or called by it).\n   * @param e The `pointerup` event\n   */\n  up(e: CanvasPointerEvent): boolean {\n    if (e.button !== this.eDown?.button) return false\n\n    this.#completeClick(e)\n    const { dragStarted } = this\n    this.reset()\n    return !dragStarted\n  }\n\n  #completeClick(e: CanvasPointerEvent): void {\n    const { eDown } = this\n    if (!eDown) return\n\n    this.eUp = e\n\n    if (this.dragStarted) {\n      // A move event already started drag\n      this.onDragEnd?.(e)\n    } else if (!this.#hasSamePosition(e, eDown)) {\n      // Teleport without a move event (e.g. tab out, move, tab back)\n      this.#setDragStarted()\n      this.onDragEnd?.(e)\n    } else if (this.onDoubleClick && this.#isDoubleClick()) {\n      // Double-click event\n      this.onDoubleClick(e)\n      this.eLastDown = undefined\n    } else {\n      // Normal click event\n      this.onClick?.(e)\n      this.eLastDown = eDown\n    }\n  }\n\n  /**\n   * Checks if two events occurred near each other - not further apart than the maximum click drift.\n   * @param a The first event to compare\n   * @param b The second event to compare\n   * @param tolerance2 The maximum distance (squared) before the positions are considered different\n   * @returns `true` if the two events were no more than {@link maxClickDrift} apart, otherwise `false`\n   */\n  #hasSamePosition(\n    a: PointerEvent,\n    b: PointerEvent,\n    tolerance2 = CanvasPointer.#maxClickDrift2,\n  ): boolean {\n    const drift = dist2(a.clientX, a.clientY, b.clientX, b.clientY)\n    return drift <= tolerance2\n  }\n\n  /**\n   * Checks whether the pointer is currently past the max click drift threshold.\n   * @returns `true` if the latest pointer event is past the the click drift threshold\n   */\n  #isDoubleClick(): boolean {\n    const { eDown, eLastDown } = this\n    if (!eDown || !eLastDown) return false\n\n    // Use thrice the drift distance for double-click gap\n    const tolerance2 = (3 * CanvasPointer.#maxClickDrift) ** 2\n    const diff = eDown.timeStamp - eLastDown.timeStamp\n    return diff > 0 &&\n      diff < CanvasPointer.doubleClickTime &&\n      this.#hasSamePosition(eDown, eLastDown, tolerance2)\n  }\n\n  #setDragStarted(eMove?: CanvasPointerEvent): void {\n    this.dragStarted = true\n    this.onDragStart?.(this, eMove)\n    delete this.onDragStart\n  }\n\n  /**\n   * Resets the state of this {@link CanvasPointer} instance.\n   *\n   * The {@link finally} callback is first executed, then all callbacks and intra-click\n   * state is cleared.\n   */\n  reset(): void {\n    // The setter executes the callback before clearing it\n    this.finally = undefined\n    delete this.onClick\n    delete this.onDoubleClick\n    delete this.onDragStart\n    delete this.onDrag\n    delete this.onDragEnd\n\n    this.isDown = false\n    this.isDouble = false\n    this.dragStarted = false\n\n    if (this.clearEventsOnReset) {\n      this.eDown = undefined\n      this.eMove = undefined\n      this.eUp = undefined\n    }\n\n    const { element, pointerId } = this\n    this.pointerId = undefined\n    if (typeof pointerId === \"number\" && element.hasPointerCapture(pointerId)) {\n      element.releasePointerCapture(pointerId)\n    }\n  }\n}\n","import type { Point, ReadOnlyRect, Rect } from \"./interfaces\"\n\nimport { EaseFunction, Rectangle } from \"./litegraph\"\n\nexport interface DragAndScaleState {\n  /**\n   * The offset from the top-left of the current canvas viewport to `[0, 0]` in graph space.\n   * Or said another way, the inverse offset of the viewport.\n   */\n  offset: [number, number]\n  /** The scale of the graph. */\n  scale: number\n}\n\nexport type AnimationOptions = {\n  /** Duration of the animation in milliseconds. */\n  duration?: number\n  /** Relative target zoom level. 1 means the view is fit exactly on the bounding box. */\n  zoom?: number\n  /** The animation easing function (curve) */\n  easing?: EaseFunction\n}\n\nexport class DragAndScale {\n  /**\n   * The state of this DragAndScale instance.\n   *\n   * Implemented as a POCO that can be proxied without side-effects.\n   */\n  state: DragAndScaleState\n  lastState: DragAndScaleState = {\n    offset: [0, 0],\n    scale: 0,\n  }\n\n  /** Maximum scale (zoom in) */\n  max_scale: number\n  /** Minimum scale (zoom out) */\n  min_scale: number\n  enabled: boolean\n  last_mouse: Point\n  element: HTMLCanvasElement\n  visible_area: Rectangle\n  dragging?: boolean\n  viewport?: Rect\n\n  onredraw?(das: DragAndScale): void\n  onChanged?(scale: number, offset: Point): void\n\n  get offset(): [number, number] {\n    return this.state.offset\n  }\n\n  set offset(value: Point) {\n    this.state.offset[0] = value[0]\n    this.state.offset[1] = value[1]\n  }\n\n  get scale(): number {\n    return this.state.scale\n  }\n\n  set scale(value: number) {\n    this.state.scale = value\n  }\n\n  constructor(element: HTMLCanvasElement) {\n    this.state = {\n      offset: [0, 0],\n      scale: 1,\n    }\n    this.max_scale = 10\n    this.min_scale = 0.1\n    this.enabled = true\n    this.last_mouse = [0, 0]\n    this.visible_area = new Rectangle()\n\n    this.element = element\n  }\n\n  /**\n   * Returns `true` if the current state has changed from the previous state.\n   * @returns `true` if the current state has changed from the previous state, otherwise `false`.\n   */\n  #stateHasChanged(): boolean {\n    const current = this.state\n    const previous = this.lastState\n\n    return current.scale !== previous.scale ||\n      current.offset[0] !== previous.offset[0] ||\n      current.offset[1] !== previous.offset[1]\n  }\n\n  computeVisibleArea(viewport: Rect | undefined): void {\n    const { scale, offset } = this\n\n    if (this.#stateHasChanged()) {\n      this.onChanged?.(scale, offset)\n      copyState(this.state, this.lastState)\n    }\n\n    if (!this.element) {\n      this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0\n      return\n    }\n    let width = this.element.width\n    let height = this.element.height\n    let startx = -offset[0]\n    let starty = -offset[1]\n    if (viewport) {\n      startx += viewport[0] / scale\n      starty += viewport[1] / scale\n      width = viewport[2]\n      height = viewport[3]\n    }\n    const endx = startx + width / scale\n    const endy = starty + height / scale\n    this.visible_area[0] = startx\n    this.visible_area[1] = starty\n    this.visible_area[2] = endx - startx\n    this.visible_area[3] = endy - starty\n  }\n\n  toCanvasContext(ctx: CanvasRenderingContext2D): void {\n    ctx.scale(this.scale, this.scale)\n    ctx.translate(this.offset[0], this.offset[1])\n  }\n\n  convertOffsetToCanvas(pos: Point): Point {\n    return [\n      (pos[0] + this.offset[0]) * this.scale,\n      (pos[1] + this.offset[1]) * this.scale,\n    ]\n  }\n\n  convertCanvasToOffset(pos: Point, out?: Point): Point {\n    out = out || [0, 0]\n    out[0] = pos[0] / this.scale - this.offset[0]\n    out[1] = pos[1] / this.scale - this.offset[1]\n    return out\n  }\n\n  /** @deprecated Has not been kept up to date */\n  mouseDrag(x: number, y: number): void {\n    this.offset[0] += x / this.scale\n    this.offset[1] += y / this.scale\n\n    this.onredraw?.(this)\n  }\n\n  changeScale(value: number, zooming_center?: Point, roundToScaleOne = true): void {\n    if (value < this.min_scale) {\n      value = this.min_scale\n    } else if (value > this.max_scale) {\n      value = this.max_scale\n    }\n    if (value == this.scale) return\n\n    const rect = this.element.getBoundingClientRect()\n    if (!rect) return\n\n    zooming_center = zooming_center ?? [rect.width * 0.5, rect.height * 0.5]\n\n    const normalizedCenter: Point = [\n      zooming_center[0] - rect.x,\n      zooming_center[1] - rect.y,\n    ]\n    const center = this.convertCanvasToOffset(normalizedCenter)\n    this.scale = value\n    if (roundToScaleOne && Math.abs(this.scale - 1) < 0.01) this.scale = 1\n    const new_center = this.convertCanvasToOffset(normalizedCenter)\n    const delta_offset = [\n      new_center[0] - center[0],\n      new_center[1] - center[1],\n    ]\n\n    this.offset[0] += delta_offset[0]\n    this.offset[1] += delta_offset[1]\n\n    this.onredraw?.(this)\n  }\n\n  changeDeltaScale(value: number, zooming_center?: Point): void {\n    this.changeScale(this.scale * value, zooming_center)\n  }\n\n  /**\n   * Fits the view to the specified bounds.\n   * @param bounds The bounds to fit the view to, defined by a rectangle.\n   */\n  fitToBounds(bounds: ReadOnlyRect, { zoom = 0.75 }: { zoom?: number } = {}): void {\n    const cw = this.element.width / window.devicePixelRatio\n    const ch = this.element.height / window.devicePixelRatio\n    let targetScale = this.scale\n\n    if (zoom > 0) {\n      const targetScaleX = (zoom * cw) / Math.max(bounds[2], 300)\n      const targetScaleY = (zoom * ch) / Math.max(bounds[3], 300)\n\n      // Choose the smaller scale to ensure the node fits into the viewport\n      // Ensure we don't go over the max scale\n      targetScale = Math.min(targetScaleX, targetScaleY, this.max_scale)\n    }\n\n    const scaledWidth = cw / targetScale\n    const scaledHeight = ch / targetScale\n\n    // Calculate the target position to center the bounds in the viewport\n    const targetX = -bounds[0] - (bounds[2] * 0.5) + (scaledWidth * 0.5)\n    const targetY = -bounds[1] - (bounds[3] * 0.5) + (scaledHeight * 0.5)\n\n    // Apply the changes immediately\n    this.offset[0] = targetX\n    this.offset[1] = targetY\n    this.scale = targetScale\n  }\n\n  /**\n   * Starts an animation to fit the view around the specified selection of nodes.\n   * @param bounds The bounds to animate the view to, defined by a rectangle.\n   */\n  animateToBounds(\n    bounds: ReadOnlyRect,\n    setDirty: () => void,\n    {\n      duration = 350,\n      zoom = 0.75,\n      easing = EaseFunction.EASE_IN_OUT_QUAD,\n    }: AnimationOptions = {},\n  ) {\n    if (!(duration > 0)) throw new RangeError(\"Duration must be greater than 0\")\n\n    const easeFunctions = {\n      linear: (t: number) => t,\n      easeInQuad: (t: number) => t * t,\n      easeOutQuad: (t: number) => t * (2 - t),\n      easeInOutQuad: (t: number) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),\n    }\n    const easeFunction = easeFunctions[easing] ?? easeFunctions.linear\n\n    const startTimestamp = performance.now()\n    const cw = this.element.width / window.devicePixelRatio\n    const ch = this.element.height / window.devicePixelRatio\n    const startX = this.offset[0]\n    const startY = this.offset[1]\n    const startX2 = startX - (cw / this.scale)\n    const startY2 = startY - (ch / this.scale)\n    const startScale = this.scale\n    let targetScale = startScale\n\n    if (zoom > 0) {\n      const targetScaleX = (zoom * cw) / Math.max(bounds[2], 300)\n      const targetScaleY = (zoom * ch) / Math.max(bounds[3], 300)\n\n      // Choose the smaller scale to ensure the node fits into the viewport\n      // Ensure we don't go over the max scale\n      targetScale = Math.min(targetScaleX, targetScaleY, this.max_scale)\n    }\n    const scaledWidth = cw / targetScale\n    const scaledHeight = ch / targetScale\n\n    const targetX = -bounds[0] - (bounds[2] * 0.5) + (scaledWidth * 0.5)\n    const targetY = -bounds[1] - (bounds[3] * 0.5) + (scaledHeight * 0.5)\n    const targetX2 = targetX - scaledWidth\n    const targetY2 = targetY - scaledHeight\n\n    const animate = (timestamp: number) => {\n      const elapsed = timestamp - startTimestamp\n      const progress = Math.min(elapsed / duration, 1)\n      const easedProgress = easeFunction(progress)\n\n      const currentX = startX + ((targetX - startX) * easedProgress)\n      const currentY = startY + ((targetY - startY) * easedProgress)\n      this.offset[0] = currentX\n      this.offset[1] = currentY\n\n      if (zoom > 0) {\n        const currentX2 = startX2 + ((targetX2 - startX2) * easedProgress)\n        const currentY2 = startY2 + ((targetY2 - startY2) * easedProgress)\n        const currentWidth = Math.abs(currentX2 - currentX)\n        const currentHeight = Math.abs(currentY2 - currentY)\n\n        this.scale = Math.min(cw / currentWidth, ch / currentHeight)\n      }\n\n      setDirty()\n\n      if (progress < 1) {\n        animationId = requestAnimationFrame(animate)\n      } else {\n        cancelAnimationFrame(animationId)\n      }\n    }\n    let animationId = requestAnimationFrame(animate)\n  }\n\n  reset(): void {\n    this.scale = 1\n    this.offset[0] = 0\n    this.offset[1] = 0\n  }\n}\n\n/**\n * Copies the values of one state into another, preserving references.\n * @param from The state to copy values from.\n * @param to The state to copy values into.\n */\nfunction copyState(from: DragAndScaleState, to: DragAndScaleState): void {\n  to.scale = from.scale\n  to.offset[0] = from.offset[0]\n  to.offset[1] = from.offset[1]\n}\n","import type { Rectangle } from \"./infrastructure/Rectangle\"\nimport type { CanvasColour, Rect } from \"./interfaces\"\n\nimport { LiteGraph } from \"./litegraph\"\nimport { LinkDirection, RenderShape, TitleMode } from \"./types/globalEnums\"\n\nconst ELLIPSIS = \"\\u2026\"\nconst TWO_DOT_LEADER = \"\\u2025\"\nconst ONE_DOT_LEADER = \"\\u2024\"\n\nexport enum SlotType {\n  Array = \"array\",\n  Event = -1,\n}\n\n/** @see RenderShape */\nexport enum SlotShape {\n  Box = RenderShape.BOX,\n  Arrow = RenderShape.ARROW,\n  Grid = RenderShape.GRID,\n  Circle = RenderShape.CIRCLE,\n  HollowCircle = RenderShape.HollowCircle,\n}\n\n/** @see LinkDirection */\nexport enum SlotDirection {\n  Up = LinkDirection.UP,\n  Right = LinkDirection.RIGHT,\n  Down = LinkDirection.DOWN,\n  Left = LinkDirection.LEFT,\n}\n\nexport enum LabelPosition {\n  Left = \"left\",\n  Right = \"right\",\n}\n\nexport interface IDrawBoundingOptions {\n  /** The shape to render */\n  shape?: RenderShape\n  /** The radius of the rounded corners for {@link RenderShape.ROUND} and {@link RenderShape.CARD} */\n  round_radius?: number\n  /** Shape will extend above the Y-axis 0 by this amount @deprecated This is node-specific: it should be removed entirely, and behaviour defined by the caller more explicitly */\n  title_height?: number\n  /** @deprecated This is node-specific: it should be removed entirely, and behaviour defined by the caller more explicitly */\n  title_mode?: TitleMode\n  /** The color that should be drawn */\n  color?: CanvasColour\n  /** The distance between the edge of the {@link area} and the middle of the line */\n  padding?: number\n  /** @deprecated This is node-specific: it should be removed entirely, and behaviour defined by the caller more explicitly */\n  collapsed?: boolean\n  /** Thickness of the line drawn (`lineWidth`) */\n  lineWidth?: number\n}\n\nexport interface IDrawTextInAreaOptions {\n  /** The canvas to draw the text on. */\n  ctx: CanvasRenderingContext2D\n  /** The text to draw. */\n  text: string\n  /** The area the text will be drawn in. */\n  area: Rectangle\n  /** The alignment of the text. */\n  align?: \"left\" | \"right\" | \"center\"\n}\n\n/**\n * Draws only the path of a shape on the canvas, without filling.\n * Used to draw indicators for node status, e.g. \"selected\".\n * @param ctx The 2D context to draw on\n * @param area The position and size of the shape to render\n */\nexport function strokeShape(\n  ctx: CanvasRenderingContext2D,\n  area: Rect,\n  {\n    shape = RenderShape.BOX,\n    round_radius,\n    title_height,\n    title_mode = TitleMode.NORMAL_TITLE,\n    color,\n    padding = 6,\n    collapsed = false,\n    lineWidth: thickness = 1,\n  }: IDrawBoundingOptions = {},\n): void {\n  // These param defaults are not compile-time static, and must be re-evaluated at runtime\n  round_radius ??= LiteGraph.ROUND_RADIUS\n  color ??= LiteGraph.NODE_BOX_OUTLINE_COLOR\n\n  // Adjust area if title is transparent\n  if (title_mode === TitleMode.TRANSPARENT_TITLE) {\n    const height = title_height ?? LiteGraph.NODE_TITLE_HEIGHT\n    area[1] -= height\n    area[3] += height\n  }\n\n  // Set up context\n  const { lineWidth, strokeStyle } = ctx\n  ctx.lineWidth = thickness\n  ctx.globalAlpha = 0.8\n  ctx.strokeStyle = color\n  ctx.beginPath()\n\n  // Draw shape based on type\n  const [x, y, width, height] = area\n  switch (shape) {\n  case RenderShape.BOX: {\n    ctx.rect(\n      x - padding,\n      y - padding,\n      width + 2 * padding,\n      height + 2 * padding,\n    )\n    break\n  }\n  case RenderShape.ROUND:\n  case RenderShape.CARD: {\n    const radius = round_radius + padding\n    const isCollapsed = shape === RenderShape.CARD && collapsed\n    const cornerRadii =\n        isCollapsed || shape === RenderShape.ROUND\n          ? [radius]\n          : [radius, 2, radius, 2]\n    ctx.roundRect(\n      x - padding,\n      y - padding,\n      width + 2 * padding,\n      height + 2 * padding,\n      cornerRadii,\n    )\n    break\n  }\n  case RenderShape.CIRCLE: {\n    const centerX = x + width / 2\n    const centerY = y + height / 2\n    const radius = Math.max(width, height) / 2 + padding\n    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2)\n    break\n  }\n  }\n\n  // Stroke the shape\n  ctx.stroke()\n\n  // Reset context\n  ctx.lineWidth = lineWidth\n  ctx.strokeStyle = strokeStyle\n\n  // TODO: Store and reset value properly.  Callers currently expect this behaviour (e.g. muted nodes).\n  ctx.globalAlpha = 1\n}\n\n/**\n * Truncates text using binary search to fit within a given width, appending an ellipsis if needed.\n * @param ctx The canvas rendering context.\n * @param text The text to truncate.\n * @param maxWidth The maximum width the text (plus ellipsis) can occupy.\n * @returns The truncated text, or the original text if it fits.\n */\nfunction truncateTextToWidth(ctx: CanvasRenderingContext2D, text: string, maxWidth: number): string {\n  if (!(maxWidth > 0)) return \"\"\n\n  // Text fits\n  const fullWidth = ctx.measureText(text).width\n  if (fullWidth <= maxWidth) return text\n\n  const ellipsisWidth = ctx.measureText(ELLIPSIS).width * 0.75\n\n  // Can't even fit ellipsis\n  if (ellipsisWidth > maxWidth) {\n    const twoDotsWidth = ctx.measureText(TWO_DOT_LEADER).width * 0.75\n    if (twoDotsWidth < maxWidth) return TWO_DOT_LEADER\n\n    const oneDotWidth = ctx.measureText(ONE_DOT_LEADER).width * 0.75\n    return oneDotWidth < maxWidth ? ONE_DOT_LEADER : \"\"\n  }\n\n  let min = 0\n  let max = text.length\n  let bestLen = 0\n\n  // Binary search for the longest substring that fits with the ellipsis\n  while (min <= max) {\n    const mid = Math.floor((min + max) * 0.5)\n\n    // Avoid measuring empty string + ellipsis\n    if (mid === 0) {\n      min = mid + 1\n      continue\n    }\n\n    const sub = text.substring(0, mid)\n    const currentWidth = ctx.measureText(sub).width + ellipsisWidth\n\n    if (currentWidth <= maxWidth) {\n      // This length fits, try potentially longer\n      bestLen = mid\n      min = mid + 1\n    } else {\n      // Too long, try shorter\n      max = mid - 1\n    }\n  }\n\n  return bestLen === 0\n    ? ELLIPSIS\n    : text.substring(0, bestLen) + ELLIPSIS\n}\n\n/**\n * Draws text within an area, truncating it and adding an ellipsis if necessary.\n */\nexport function drawTextInArea({ ctx, text, area, align = \"left\" }: IDrawTextInAreaOptions) {\n  const { left, right, bottom, width, centreX } = area\n\n  // Text already fits\n  const fullWidth = ctx.measureText(text).width\n  if (fullWidth <= width) {\n    ctx.textAlign = align\n    const x = align === \"left\" ? left : (align === \"right\" ? right : centreX)\n    ctx.fillText(text, x, bottom)\n    return\n  }\n\n  // Need to truncate text\n  const truncated = truncateTextToWidth(ctx, text, width)\n  if (truncated.length === 0) return\n\n  // Draw text - left-aligned to prevent bouncing during resize\n  ctx.textAlign = \"left\"\n  ctx.fillText(truncated.slice(0, -1), left, bottom)\n  ctx.rect(left, bottom, width, 1)\n\n  // Draw the ellipsis, right-aligned to the button\n  ctx.textAlign = \"right\"\n  const ellipsis = truncated.at(-1)!\n  ctx.fillText(ellipsis, right, bottom, ctx.measureText(ellipsis).width * 0.75)\n}\n","export class NullGraphError extends Error {\n  constructor(message: string = \"Attempted to access LGraph reference that was null or undefined.\", cause?: Error) {\n    super(message, { cause })\n    this.name = \"NullGraphError\"\n  }\n}\n","export interface LGraphIconOptions {\n  unicode: string\n  fontFamily?: string\n  color?: string\n  bgColor?: string\n  fontSize?: number\n  circlePadding?: number\n  xOffset?: number\n  yOffset?: number\n}\n\nexport class LGraphIcon {\n  unicode: string\n  fontFamily: string\n  color: string\n  bgColor?: string\n  fontSize: number\n  circlePadding: number\n  xOffset: number\n  yOffset: number\n\n  constructor({\n    unicode,\n    fontFamily = \"PrimeIcons\",\n    color = \"#e6c200\",\n    bgColor,\n    fontSize = 16,\n    circlePadding = 2,\n    xOffset = 0,\n    yOffset = 0,\n  }: LGraphIconOptions) {\n    this.unicode = unicode\n    this.fontFamily = fontFamily\n    this.color = color\n    this.bgColor = bgColor\n    this.fontSize = fontSize\n    this.circlePadding = circlePadding\n    this.xOffset = xOffset\n    this.yOffset = yOffset\n  }\n\n  draw(ctx: CanvasRenderingContext2D, x: number, y: number) {\n    x += this.xOffset\n    y += this.yOffset\n\n    const { font, textBaseline, textAlign, fillStyle } = ctx\n\n    ctx.font = `${this.fontSize}px '${this.fontFamily}'`\n    ctx.textBaseline = \"middle\"\n    ctx.textAlign = \"center\"\n    const iconRadius = this.fontSize / 2 + this.circlePadding\n    // Draw icon background circle if bgColor is set\n    if (this.bgColor) {\n      ctx.beginPath()\n      ctx.arc(x + iconRadius, y, iconRadius, 0, 2 * Math.PI)\n      ctx.fillStyle = this.bgColor\n      ctx.fill()\n    }\n    // Draw icon\n    ctx.fillStyle = this.color\n    ctx.fillText(this.unicode, x + iconRadius, y)\n\n    ctx.font = font\n    ctx.textBaseline = textBaseline\n    ctx.textAlign = textAlign\n    ctx.fillStyle = fillStyle\n  }\n}\n","import { LGraphIcon, type LGraphIconOptions } from \"./LGraphIcon\"\n\nexport enum BadgePosition {\n  TopLeft = \"top-left\",\n  TopRight = \"top-right\",\n}\n\nexport interface LGraphBadgeOptions {\n  text: string\n  fgColor?: string\n  bgColor?: string\n  fontSize?: number\n  padding?: number\n  height?: number\n  cornerRadius?: number\n  iconOptions?: LGraphIconOptions\n  xOffset?: number\n  yOffset?: number\n}\n\nexport class LGraphBadge {\n  text: string\n  fgColor: string\n  bgColor: string\n  fontSize: number\n  padding: number\n  height: number\n  cornerRadius: number\n  icon?: LGraphIcon\n  xOffset: number\n  yOffset: number\n\n  constructor({\n    text,\n    fgColor = \"white\",\n    bgColor = \"#0F1F0F\",\n    fontSize = 12,\n    padding = 6,\n    height = 20,\n    cornerRadius = 5,\n    iconOptions,\n    xOffset = 0,\n    yOffset = 0,\n  }: LGraphBadgeOptions) {\n    this.text = text\n    this.fgColor = fgColor\n    this.bgColor = bgColor\n    this.fontSize = fontSize\n    this.padding = padding\n    this.height = height\n    this.cornerRadius = cornerRadius\n    if (iconOptions) {\n      this.icon = new LGraphIcon(iconOptions)\n    }\n    this.xOffset = xOffset\n    this.yOffset = yOffset\n  }\n\n  get visible() {\n    return this.text.length > 0 || !!this.icon\n  }\n\n  getWidth(ctx: CanvasRenderingContext2D) {\n    if (!this.visible) return 0\n    const { font } = ctx\n    let iconWidth = 0\n    if (this.icon) {\n      ctx.font = `${this.icon.fontSize}px '${this.icon.fontFamily}'`\n      iconWidth = ctx.measureText(this.icon.unicode).width + this.padding\n    }\n    ctx.font = `${this.fontSize}px sans-serif`\n    const textWidth = this.text ? ctx.measureText(this.text).width : 0\n    ctx.font = font\n    return iconWidth + textWidth + this.padding * 2\n  }\n\n  draw(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n  ): void {\n    if (!this.visible) return\n\n    x += this.xOffset\n    y += this.yOffset\n\n    const { font, fillStyle, textBaseline, textAlign } = ctx\n\n    ctx.font = `${this.fontSize}px sans-serif`\n    const badgeWidth = this.getWidth(ctx)\n    const badgeX = 0\n\n    // Draw badge background\n    ctx.fillStyle = this.bgColor\n    ctx.beginPath()\n    if (ctx.roundRect) {\n      ctx.roundRect(x + badgeX, y, badgeWidth, this.height, this.cornerRadius)\n    } else {\n      // Fallback for browsers that don't support roundRect\n      ctx.rect(x + badgeX, y, badgeWidth, this.height)\n    }\n    ctx.fill()\n\n    let drawX = x + badgeX + this.padding\n    const centerY = y + this.height / 2\n\n    // Draw icon if present\n    if (this.icon) {\n      this.icon.draw(ctx, drawX, centerY)\n      drawX += this.icon.fontSize + this.padding / 2 + 4\n    }\n\n    // Draw badge text\n    if (this.text) {\n      ctx.fillStyle = this.fgColor\n      ctx.textBaseline = \"middle\"\n      ctx.textAlign = \"left\"\n      ctx.fillText(this.text, drawX, centerY + 1)\n    }\n\n    ctx.font = font\n    ctx.fillStyle = fillStyle\n    ctx.textBaseline = textBaseline\n    ctx.textAlign = textAlign\n  }\n}\n","import type { CanvasColour, DefaultConnectionColors, INodeSlot, ISlotType, IWidgetLocator, Point, Rect } from \"@/interfaces\"\nimport type { LLink } from \"@/LLink\"\nimport type { RenderShape } from \"@/types/globalEnums\"\nimport type { LinkDirection } from \"@/types/globalEnums\"\n\n/** Base class for all input & output slots. */\n\nexport abstract class SlotBase implements INodeSlot {\n  name: string\n  localized_name?: string\n  label?: string\n  type: ISlotType\n  dir?: LinkDirection\n  removable?: boolean\n  shape?: RenderShape\n  color_off?: CanvasColour\n  color_on?: CanvasColour\n  locked?: boolean\n  nameLocked?: boolean\n  widget?: IWidgetLocator\n  _floatingLinks?: Set<LLink>\n  hasErrors?: boolean\n\n  /** The centre point of the slot. */\n  abstract pos?: Point\n  readonly boundingRect: Rect\n\n  constructor(name: string, type: ISlotType, boundingRect: Rect) {\n    this.name = name\n    this.type = type\n    this.boundingRect = boundingRect\n  }\n\n  abstract get isConnected(): boolean\n\n  renderingColor(colorContext: DefaultConnectionColors): CanvasColour {\n    return this.isConnected\n      ? this.color_on || colorContext.getConnectedColor(this.type)\n      : this.color_off || colorContext.getDisconnectedColor(this.type)\n  }\n}\n","import type { CanvasColour, DefaultConnectionColors, INodeInputSlot, INodeOutputSlot, INodeSlot, OptionalProps, Point, ReadOnlyPoint } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\n\nimport { LabelPosition, SlotShape, SlotType } from \"@/draw\"\nimport { LiteGraph } from \"@/litegraph\"\nimport { getCentre } from \"@/measure\"\nimport { LinkDirection, RenderShape } from \"@/types/globalEnums\"\n\nimport { NodeInputSlot } from \"./NodeInputSlot\"\nimport { SlotBase } from \"./SlotBase\"\n\nexport interface IDrawOptions {\n  colorContext: DefaultConnectionColors\n  labelPosition?: LabelPosition\n  lowQuality?: boolean\n  doStroke?: boolean\n  highlight?: boolean\n}\n\n/** Shared base class for {@link LGraphNode} input and output slots. */\nexport abstract class NodeSlot extends SlotBase implements INodeSlot {\n  pos?: Point\n\n  /** The offset from the parent node to the centre point of this slot. */\n  get #centreOffset(): ReadOnlyPoint {\n    const nodePos = this.node.pos\n    const { boundingRect } = this\n\n    // Use height; widget input slots may be thinner.\n    const diameter = boundingRect[3]\n\n    return getCentre([\n      boundingRect[0] - nodePos[0],\n      boundingRect[1] - nodePos[1],\n      diameter,\n      diameter,\n    ])\n  }\n\n  /** The center point of this slot when the node is collapsed. */\n  abstract get collapsedPos(): ReadOnlyPoint\n\n  #node: LGraphNode\n  get node(): LGraphNode {\n    return this.#node\n  }\n\n  get highlightColor(): CanvasColour {\n    return LiteGraph.NODE_TEXT_HIGHLIGHT_COLOR ?? LiteGraph.NODE_SELECTED_TITLE_COLOR ?? LiteGraph.NODE_TEXT_COLOR\n  }\n\n  abstract get isWidgetInputSlot(): boolean\n\n  constructor(slot: OptionalProps<INodeSlot, \"boundingRect\">, node: LGraphNode) {\n    super(slot.name, slot.type, slot.boundingRect ?? [0, 0, 0, 0])\n\n    Object.assign(this, slot)\n    this.#node = node\n  }\n\n  /**\n   * Whether this slot is a valid target for a dragging link.\n   * @param fromSlot The slot that the link is being connected from.\n   */\n  abstract isValidTarget(fromSlot: INodeInputSlot | INodeOutputSlot): boolean\n\n  /**\n   * The label to display in the UI.\n   */\n  get renderingLabel(): string {\n    return this.label || this.localized_name || this.name || \"\"\n  }\n\n  draw(\n    ctx: CanvasRenderingContext2D,\n    {\n      colorContext,\n      labelPosition = LabelPosition.Right,\n      lowQuality = false,\n      highlight = false,\n      doStroke = false,\n    }: IDrawOptions,\n  ) {\n    // Save the current fillStyle and strokeStyle\n    const originalFillStyle = ctx.fillStyle\n    const originalStrokeStyle = ctx.strokeStyle\n    const originalLineWidth = ctx.lineWidth\n\n    const labelColor = highlight\n      ? this.highlightColor\n      : LiteGraph.NODE_TEXT_COLOR\n\n    const pos = this.#centreOffset\n    const slot_type = this.type\n    const slot_shape = (\n      slot_type === SlotType.Array ? SlotShape.Grid : this.shape\n    ) as SlotShape\n\n    ctx.beginPath()\n    let doFill = true\n\n    ctx.fillStyle = this.renderingColor(colorContext)\n    ctx.lineWidth = 1\n    if (slot_type === SlotType.Event || slot_shape === SlotShape.Box) {\n      ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10)\n    } else if (slot_shape === SlotShape.Arrow) {\n      ctx.moveTo(pos[0] + 8, pos[1] + 0.5)\n      ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5)\n      ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5)\n      ctx.closePath()\n    } else if (slot_shape === SlotShape.Grid) {\n      const gridSize = 3\n      const cellSize = 2\n      const spacing = 3\n\n      for (let x = 0; x < gridSize; x++) {\n        for (let y = 0; y < gridSize; y++) {\n          ctx.rect(\n            pos[0] - 4 + x * spacing,\n            pos[1] - 4 + y * spacing,\n            cellSize,\n            cellSize,\n          )\n        }\n      }\n      doStroke = false\n    } else {\n      // Default rendering for circle, hollow circle.\n      if (lowQuality) {\n        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8)\n      } else {\n        let radius: number\n        if (slot_shape === SlotShape.HollowCircle) {\n          doFill = false\n          doStroke = true\n          ctx.lineWidth = 3\n          ctx.strokeStyle = ctx.fillStyle\n          radius = highlight ? 4 : 3\n        } else {\n          // Normal circle\n          radius = highlight ? 5 : 4\n        }\n        ctx.arc(pos[0], pos[1], radius, 0, Math.PI * 2)\n      }\n    }\n\n    if (doFill) ctx.fill()\n    if (!lowQuality && doStroke) ctx.stroke()\n\n    // render slot label\n    const hideLabel = lowQuality || this.isWidgetInputSlot\n    if (!hideLabel) {\n      const text = this.renderingLabel\n      if (text) {\n        // TODO: Finish impl.  Highlight text on mouseover unless we're connecting links.\n        ctx.fillStyle = labelColor\n\n        if (labelPosition === LabelPosition.Right) {\n          if (this.dir == LinkDirection.UP) {\n            ctx.fillText(text, pos[0], pos[1] - 10)\n          } else {\n            ctx.fillText(text, pos[0] + 10, pos[1] + 5)\n          }\n        } else {\n          if (this.dir == LinkDirection.DOWN) {\n            ctx.fillText(text, pos[0], pos[1] - 8)\n          } else {\n            ctx.fillText(text, pos[0] - 10, pos[1] + 5)\n          }\n        }\n      }\n    }\n\n    // Draw a red circle if the slot has errors.\n    if (this.hasErrors) {\n      ctx.lineWidth = 2\n      ctx.strokeStyle = \"red\"\n      ctx.beginPath()\n      ctx.arc(pos[0], pos[1], 12, 0, Math.PI * 2)\n      ctx.stroke()\n    }\n\n    // Restore the original fillStyle and strokeStyle\n    ctx.fillStyle = originalFillStyle\n    ctx.strokeStyle = originalStrokeStyle\n    ctx.lineWidth = originalLineWidth\n  }\n\n  drawCollapsed(ctx: CanvasRenderingContext2D) {\n    const [x, y] = this.collapsedPos\n\n    // Save original styles\n    const { fillStyle } = ctx\n\n    ctx.fillStyle = \"#686\"\n    ctx.beginPath()\n\n    if (this.type === SlotType.Event || this.shape === RenderShape.BOX) {\n      ctx.rect(x - 7 + 0.5, y - 4, 14, 8)\n    } else if (this.shape === RenderShape.ARROW) {\n      // Adjust arrow direction based on whether this is an input or output slot\n      const isInput = this instanceof NodeInputSlot\n      if (isInput) {\n        ctx.moveTo(x + 8, y)\n        ctx.lineTo(x - 4, y - 4)\n        ctx.lineTo(x - 4, y + 4)\n      } else {\n        ctx.moveTo(x + 6, y)\n        ctx.lineTo(x - 6, y - 4)\n        ctx.lineTo(x - 6, y + 4)\n      }\n      ctx.closePath()\n    } else {\n      ctx.arc(x, y, 4, 0, Math.PI * 2)\n    }\n    ctx.fill()\n\n    // Restore original styles\n    ctx.fillStyle = fillStyle\n  }\n}\n","import type { INodeInputSlot, INodeOutputSlot, OptionalProps, ReadOnlyPoint } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LinkId } from \"@/LLink\"\n\nimport { LabelPosition } from \"@/draw\"\nimport { LiteGraph } from \"@/litegraph\"\nimport { type IDrawOptions, NodeSlot } from \"@/node/NodeSlot\"\n\nexport class NodeInputSlot extends NodeSlot implements INodeInputSlot {\n  link: LinkId | null\n\n  get isWidgetInputSlot(): boolean {\n    return !!this.widget\n  }\n\n  get collapsedPos(): ReadOnlyPoint {\n    return [0, LiteGraph.NODE_TITLE_HEIGHT * -0.5]\n  }\n\n  constructor(slot: OptionalProps<INodeInputSlot, \"boundingRect\">, node: LGraphNode) {\n    super(slot, node)\n    this.link = slot.link\n  }\n\n  override get isConnected(): boolean {\n    return this.link != null\n  }\n\n  override isValidTarget(fromSlot: INodeInputSlot | INodeOutputSlot): boolean {\n    return \"links\" in fromSlot && LiteGraph.isValidConnection(this.type, fromSlot.type)\n  }\n\n  override draw(ctx: CanvasRenderingContext2D, options: Omit<IDrawOptions, \"doStroke\" | \"labelPosition\">) {\n    const { textAlign } = ctx\n    ctx.textAlign = \"left\"\n\n    super.draw(ctx, {\n      ...options,\n      labelPosition: LabelPosition.Right,\n      doStroke: false,\n    })\n\n    ctx.textAlign = textAlign\n  }\n}\n","import type { INodeInputSlot, INodeOutputSlot, OptionalProps, ReadOnlyPoint } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LinkId } from \"@/LLink\"\n\nimport { LabelPosition } from \"@/draw\"\nimport { LiteGraph } from \"@/litegraph\"\nimport { type IDrawOptions, NodeSlot } from \"@/node/NodeSlot\"\n\nexport class NodeOutputSlot extends NodeSlot implements INodeOutputSlot {\n  #node: LGraphNode\n\n  links: LinkId[] | null\n  _data?: unknown\n  slot_index?: number\n\n  get isWidgetInputSlot(): false {\n    return false\n  }\n\n  get collapsedPos(): ReadOnlyPoint {\n    return [\n      this.#node._collapsed_width ?? LiteGraph.NODE_COLLAPSED_WIDTH,\n      LiteGraph.NODE_TITLE_HEIGHT * -0.5,\n    ]\n  }\n\n  constructor(slot: OptionalProps<INodeOutputSlot, \"boundingRect\">, node: LGraphNode) {\n    super(slot, node)\n    this.links = slot.links\n    this._data = slot._data\n    this.slot_index = slot.slot_index\n    this.#node = node\n  }\n\n  override isValidTarget(fromSlot: INodeInputSlot | INodeOutputSlot): boolean {\n    return \"link\" in fromSlot && LiteGraph.isValidConnection(this.type, fromSlot.type)\n  }\n\n  override get isConnected(): boolean {\n    return this.links != null && this.links.length > 0\n  }\n\n  override draw(ctx: CanvasRenderingContext2D, options: Omit<IDrawOptions, \"doStroke\" | \"labelPosition\">) {\n    const { textAlign, strokeStyle } = ctx\n    ctx.textAlign = \"right\"\n    ctx.strokeStyle = \"black\"\n\n    super.draw(ctx, {\n      ...options,\n      labelPosition: LabelPosition.Left,\n      doStroke: true,\n    })\n\n    ctx.textAlign = textAlign\n    ctx.strokeStyle = strokeStyle\n  }\n}\n","import type { IWidgetInputSlot, SharedIntersection } from \"@/interfaces\"\nimport type { INodeInputSlot, INodeOutputSlot, INodeSlot, IWidget } from \"@/litegraph\"\nimport type { ISerialisableNodeInput, ISerialisableNodeOutput } from \"@/types/serialisation\"\n\ntype CommonIoSlotProps = SharedIntersection<ISerialisableNodeInput, ISerialisableNodeOutput>\n\nexport function shallowCloneCommonProps(slot: CommonIoSlotProps): CommonIoSlotProps {\n  const { color_off, color_on, dir, label, localized_name, locked, name, nameLocked, removable, shape, type } = slot\n  return { color_off, color_on, dir, label, localized_name, locked, name, nameLocked, removable, shape, type }\n}\n\nexport function inputAsSerialisable(slot: INodeInputSlot): ISerialisableNodeInput {\n  const { link } = slot\n  const widgetOrPos = slot.widget\n    ? { widget: { name: slot.widget.name } }\n    : { pos: slot.pos }\n\n  return {\n    ...shallowCloneCommonProps(slot),\n    ...widgetOrPos,\n    link,\n  }\n}\n\nexport function outputAsSerialisable(slot: INodeOutputSlot & { widget?: IWidget }): ISerialisableNodeOutput {\n  const { pos, slot_index, links, widget } = slot\n  // Output widgets do not exist in Litegraph; this is a temporary downstream workaround.\n  const outputWidget = widget\n    ? { widget: { name: widget.name } }\n    : null\n\n  return {\n    ...shallowCloneCommonProps(slot),\n    ...outputWidget,\n    pos,\n    slot_index,\n    links,\n  }\n}\n\nexport function isINodeInputSlot(slot: INodeSlot): slot is INodeInputSlot {\n  return \"link\" in slot\n}\n\nexport function isINodeOutputSlot(slot: INodeSlot): slot is INodeOutputSlot {\n  return \"links\" in slot\n}\n\n/**\n * Type guard: Whether this input slot is attached to a widget.\n * @param slot The slot to check.\n */\n\nexport function isWidgetInputSlot(slot: INodeInputSlot): slot is IWidgetInputSlot {\n  return !!slot.widget\n}\n","import type { ISlotType } from \"./litegraph\"\n\n/**\n * Uses the standard String() function to coerce to string, unless the value is null or undefined - then null.\n * @param value The value to convert\n * @returns String(value) or null\n */\nexport function stringOrNull(value: unknown): string | null {\n  return value == null ? null : String(value)\n}\n\n/**\n * Uses the standard String() function to coerce to string, unless the value is null or undefined - then an empty string\n * @param value The value to convert\n * @returns String(value) or \"\"\n */\nexport function stringOrEmpty(value: unknown): string {\n  return value == null ? \"\" : String(value)\n}\n\nexport function parseSlotTypes(type: ISlotType): string[] {\n  return type == \"\" || type == \"0\" ? [\"*\"] : String(type).toLowerCase().split(\",\")\n}\n","import type { ConnectingLink, INodeInputSlot, INodeOutputSlot, ISlotType, Positionable } from \"../interfaces\"\nimport type { LinkId } from \"@/LLink\"\n\nimport { type IGenericLinkOrLinks, LGraphNode } from \"@/LGraphNode\"\nimport { parseSlotTypes } from \"@/strings\"\n\n/**\n * Creates a flat set of all positionable items by recursively iterating through all child items.\n *\n * Does not include or recurse into pinned items.\n * @param items The original set of items to iterate through\n * @returns All unpinned items in the original set, and recursively, their children\n */\nexport function getAllNestedItems(items: ReadonlySet<Positionable>): Set<Positionable> {\n  const allItems = new Set<Positionable>()\n  if (items) {\n    for (const item of items) addRecursively(item, allItems)\n  }\n  return allItems\n\n  function addRecursively(item: Positionable, flatSet: Set<Positionable>): void {\n    if (flatSet.has(item) || item.pinned) return\n    flatSet.add(item)\n    if (item.children) {\n      for (const child of item.children) addRecursively(child, flatSet)\n    }\n  }\n}\n\n/**\n * Iterates through a collection of {@link Positionable} items, returning the first {@link LGraphNode}.\n * @param items The items to search through\n * @returns The first node found in {@link items}, otherwise `undefined`\n */\nexport function findFirstNode(items: Iterable<Positionable>): LGraphNode | undefined {\n  for (const item of items) {\n    if (item instanceof LGraphNode) return item\n  }\n}\n\n/** @returns `true` if the provided link ID is currently being dragged. */\nexport function isDraggingLink(linkId: LinkId, connectingLinks: ConnectingLink[] | null | undefined): ConnectingLink | undefined {\n  if (connectingLinks == null) return\n\n  for (const connectingLink of connectingLinks) {\n    if (connectingLink.link == null) continue\n    if (linkId === connectingLink.link.id) return connectingLink\n  }\n}\n\ntype InputOrOutput = (INodeInputSlot | INodeOutputSlot) & IGenericLinkOrLinks\ntype FreeSlotResult<T extends InputOrOutput> = { index: number, slot: T } | undefined\n\n/**\n * Finds the first free in/out slot with any of the comma-delimited types in {@link type}.\n *\n * If no slots are free, falls back in order to:\n * - The first free wildcard slot\n * - The first occupied slot\n * - The first occupied wildcard slot\n * @param slots The iterable of node slots slots to search through\n * @param type The {@link ISlotType type} of slot to find\n * @returns The index and slot if found, otherwise `undefined`.\n */\nexport function findFreeSlotOfType<T extends InputOrOutput>(\n  slots: T[],\n  type: ISlotType,\n): FreeSlotResult<T> {\n  if (!slots?.length) return\n\n  let occupiedSlot: FreeSlotResult<T>\n  let wildSlot: FreeSlotResult<T>\n  let occupiedWildSlot: FreeSlotResult<T>\n\n  const validTypes = parseSlotTypes(type)\n\n  for (const [index, slot] of slots.entries()) {\n    const slotTypes = parseSlotTypes(slot.type)\n\n    for (const validType of validTypes) {\n      for (const slotType of slotTypes) {\n        if (slotType === validType) {\n          if (slot.link == null && !slot.links?.length) {\n            // Exact match - short circuit\n            return { index, slot }\n          }\n          // In case we can't find a free slot.\n          occupiedSlot ??= { index, slot }\n        } else if (!wildSlot && (validType === \"*\" || slotType === \"*\")) {\n          // Save the first free wildcard slot as a fallback\n          if (slot.link == null && !slot.links?.length) {\n            wildSlot = { index, slot }\n          } else {\n            occupiedWildSlot ??= { index, slot }\n          }\n        }\n      }\n    }\n  }\n  return wildSlot ?? occupiedSlot ?? occupiedWildSlot\n}\n","import { LiteGraph } from \"@/litegraph\"\n\n/** Guard against unbound allocation. */\nconst UNIQUE_MESSAGE_LIMIT = 10_000\nconst sentWarnings: Set<string> = new Set()\n\n/**\n * Warns that a deprecated function has been used via the public\n * {@link onDeprecationWarning} / {@link onEveryDeprecationWarning} callback arrays.\n * @param message Plain-language detail about what has been deprecated. This **should not** include unique data; use {@link source}.\n * @param source A reference object to include alongside the message, e.g. `this`.\n */\nexport function warnDeprecated(message: string, source?: object): void {\n  if (!LiteGraph.alwaysRepeatWarnings) {\n    // Do not repeat\n    if (sentWarnings.has(message)) return\n\n    // Hard limit of unique messages per session\n    if (sentWarnings.size > UNIQUE_MESSAGE_LIMIT) return\n\n    sentWarnings.add(message)\n  }\n\n  for (const callback of LiteGraph.onDeprecationWarning) {\n    callback(message, source)\n  }\n}\n","export interface SpaceRequest {\n  minSize: number\n  maxSize?: number\n}\n\n/**\n * Distributes available space among items with min/max size constraints\n * @param totalSpace Total space available to distribute\n * @param requests Array of space requests with size constraints\n * @returns Array of space allocations\n */\nexport function distributeSpace(\n  totalSpace: number,\n  requests: SpaceRequest[],\n): number[] {\n  // Handle edge cases\n  if (requests.length === 0) return []\n\n  // Calculate total minimum space needed\n  const totalMinSize = requests.reduce((sum, req) => sum + req.minSize, 0)\n\n  // If we can't meet minimum requirements, return the minimum sizes\n  if (totalSpace < totalMinSize) {\n    return requests.map(req => req.minSize)\n  }\n\n  // Initialize allocations with minimum sizes\n  let allocations = requests.map(req => ({\n    computedSize: req.minSize,\n    maxSize: req.maxSize ?? Infinity,\n    remaining: (req.maxSize ?? Infinity) - req.minSize,\n  }))\n\n  // Calculate remaining space to distribute\n  let remainingSpace = totalSpace - totalMinSize\n\n  // Distribute remaining space iteratively\n  while (\n    remainingSpace > 0 &&\n    allocations.some(alloc => alloc.remaining > 0)\n  ) {\n    // Count items that can still grow\n    const growableItems = allocations.filter(\n      alloc => alloc.remaining > 0,\n    ).length\n\n    if (growableItems === 0) break\n\n    // Calculate fair share per item\n    const sharePerItem = remainingSpace / growableItems\n\n    // Track how much space was actually used in this iteration\n    let spaceUsedThisRound = 0\n\n    // Distribute space\n    allocations = allocations.map((alloc) => {\n      if (alloc.remaining <= 0) return alloc\n\n      const growth = Math.min(sharePerItem, alloc.remaining)\n      spaceUsedThisRound += growth\n\n      return {\n        ...alloc,\n        computedSize: alloc.computedSize + growth,\n        remaining: alloc.remaining - growth,\n      }\n    })\n\n    remainingSpace -= spaceUsedThisRound\n\n    // Break if we couldn't distribute any more space\n    if (spaceUsedThisRound === 0) break\n  }\n\n  // Return only the computed sizes\n  return allocations.map(({ computedSize }) => computedSize)\n}\n","import type { IColorable } from \"@/interfaces\"\n\n/**\n * Converts a plain object to a class instance if it is not already an instance of the class.\n *\n * Requires specific constructor signature; first parameter must be the object to convert.\n * @param cls The class to convert to\n * @param args The object to convert, followed by any other constructor arguments\n * @returns The class instance\n */\nexport function toClass<P, C extends P, Args extends unknown[]>(\n  cls: new (instance: P, ...args: Args) => C,\n  ...args: [P, ...Args]\n): C {\n  return args[0] instanceof cls ? args[0] : new cls(...args)\n}\n\n/**\n * Checks if an object is an instance of {@link IColorable}.\n */\nexport function isColorable(obj: unknown): obj is IColorable {\n  return typeof obj === \"object\" && obj !== null && \"setColorOption\" in obj && \"getColorOption\" in obj\n}\n","import type { Point, ReadOnlyPoint, ReadOnlyRect, ReadOnlySize, Size } from \"@/interfaces\"\n\n/**\n * A rectangle, represented as a float64 array of 4 numbers: [x, y, width, height].\n *\n * This class is a subclass of Float64Array, and so has all the methods of that class.  Notably,\n * {@link Rectangle.from} can be used to convert a {@link ReadOnlyRect}.\n *\n * Sub-array properties ({@link Float64Array.subarray}):\n * - {@link pos}: The position of the top-left corner of the rectangle.\n * - {@link size}: The size of the rectangle.\n */\nexport class Rectangle extends Float64Array {\n  #pos: Point | undefined\n  #size: Size | undefined\n\n  constructor(x: number = 0, y: number = 0, width: number = 0, height: number = 0) {\n    super(4)\n\n    this[0] = x\n    this[1] = y\n    this[2] = width\n    this[3] = height\n  }\n\n  override subarray(begin: number = 0, end?: number): Float64Array<ArrayBuffer> {\n    const byteOffset = begin << 3\n    const length = end === undefined ? end : end - begin\n    return new Float64Array(this.buffer, byteOffset, length)\n  }\n\n  /**\n   * A reference to the position of the top-left corner of this rectangle.\n   *\n   * Updating the values of the returned object will update this rectangle.\n   */\n  get pos(): Point {\n    this.#pos ??= this.subarray(0, 2)\n    return this.#pos\n  }\n\n  set pos(value: ReadOnlyPoint) {\n    this[0] = value[0]\n    this[1] = value[1]\n  }\n\n  /**\n   * A reference to the size of this rectangle.\n   *\n   * Updating the values of the returned object will update this rectangle.\n   */\n  get size(): Size {\n    this.#size ??= this.subarray(2, 4)\n    return this.#size\n  }\n\n  set size(value: ReadOnlySize) {\n    this[2] = value[0]\n    this[3] = value[1]\n  }\n\n  // #region Property accessors\n  /** The x co-ordinate of the top-left corner of this rectangle. */\n  get x() {\n    return this[0]\n  }\n\n  set x(value: number) {\n    this[0] = value\n  }\n\n  /** The y co-ordinate of the top-left corner of this rectangle. */\n  get y() {\n    return this[1]\n  }\n\n  set y(value: number) {\n    this[1] = value\n  }\n\n  /** The width of this rectangle. */\n  get width() {\n    return this[2]\n  }\n\n  set width(value: number) {\n    this[2] = value\n  }\n\n  /** The height of this rectangle. */\n  get height() {\n    return this[3]\n  }\n\n  set height(value: number) {\n    this[3] = value\n  }\n\n  /** The x co-ordinate of the left edge of this rectangle. */\n  get left() {\n    return this[0]\n  }\n\n  set left(value: number) {\n    this[0] = value\n  }\n\n  /** The y co-ordinate of the top edge of this rectangle. */\n  get top() {\n    return this[1]\n  }\n\n  set top(value: number) {\n    this[1] = value\n  }\n\n  /** The x co-ordinate of the right edge of this rectangle. */\n  get right() {\n    return this[0] + this[2]\n  }\n\n  set right(value: number) {\n    this[0] = value - this[2]\n  }\n\n  /** The y co-ordinate of the bottom edge of this rectangle. */\n  get bottom() {\n    return this[1] + this[3]\n  }\n\n  set bottom(value: number) {\n    this[1] = value - this[3]\n  }\n\n  /** The x co-ordinate of the centre of this rectangle. */\n  get centreX() {\n    return this[0] + (this[2] * 0.5)\n  }\n\n  /** The y co-ordinate of the centre of this rectangle. */\n  get centreY() {\n    return this[1] + (this[3] * 0.5)\n  }\n  // #endregion Property accessors\n\n  /**\n   * Updates the rectangle to the values of {@link rect}.\n   * @param rect The rectangle to update to.\n   */\n  updateTo(rect: ReadOnlyRect) {\n    this[0] = rect[0]\n    this[1] = rect[1]\n    this[2] = rect[2]\n    this[3] = rect[3]\n  }\n\n  /**\n   * Checks if the point [{@link x}, {@link y}] is inside this rectangle.\n   * @param x The x-coordinate to check\n   * @param y The y-coordinate to check\n   * @returns `true` if the point is inside this rectangle, otherwise `false`.\n   */\n  containsXy(x: number, y: number): boolean {\n    const { x: left, y: top, width, height } = this\n    return left <= x &&\n      top <= y &&\n      left + width >= x &&\n      top + height >= y\n  }\n\n  /**\n   * Checks if {@link point} is inside this rectangle.\n   * @param point The point to check\n   * @returns `true` if {@link point} is inside this rectangle, otherwise `false`.\n   */\n  containsPoint(point: ReadOnlyPoint): boolean {\n    return this.x <= point[0] &&\n      this.y <= point[1] &&\n      this.x + this.width >= point[0] &&\n      this.y + this.height >= point[1]\n  }\n\n  /**\n   * Checks if {@link rect} is inside this rectangle.\n   * @param rect The rectangle to check\n   * @returns `true` if {@link rect} is inside this rectangle, otherwise `false`.\n   */\n  containsRect(rect: ReadOnlyRect): boolean {\n    return this.x <= rect[0] &&\n      this.y <= rect[1] &&\n      this.x + this.width >= rect[0] + rect[2] &&\n      this.y + this.height >= rect[1] + rect[3]\n  }\n\n  /**\n   * Checks if {@link rect} overlaps with this rectangle.\n   * @param rect The rectangle to check\n   * @returns `true` if {@link rect} overlaps with this rectangle, otherwise `false`.\n   */\n  overlaps(rect: ReadOnlyRect): boolean {\n    return this.x < rect[0] + rect[2] &&\n      this.y < rect[1] + rect[3] &&\n      this.x + this.width > rect[0] &&\n      this.y + this.height > rect[1]\n  }\n\n  /** @returns The centre point of this rectangle, as a new {@link Point}. */\n  getCentre(): Point {\n    return [this.centreX, this.centreY]\n  }\n\n  /** @returns The area of this rectangle. */\n  getArea(): number {\n    return this.width * this.height\n  }\n\n  /** @returns The perimeter of this rectangle. */\n  getPerimeter(): number {\n    return 2 * (this.width + this.height)\n  }\n\n  /** @returns The top-left corner of this rectangle, as a new {@link Point}. */\n  getTopLeft(): Point {\n    return [this[0], this[1]]\n  }\n\n  /** @returns The bottom-right corner of this rectangle, as a new {@link Point}. */\n  getBottomRight(): Point {\n    return [this.right, this.bottom]\n  }\n\n  /** @returns The width and height of this rectangle, as a new {@link Size}. */\n  getSize(): Size {\n    return [this[2], this[3]]\n  }\n\n  /** @returns The offset from the top-left of this rectangle to the point [{@link x}, {@link y}], as a new {@link Point}. */\n  getOffsetTo([x, y]: ReadOnlyPoint): Point {\n    return [x - this[0], y - this[1]]\n  }\n\n  /** @returns The offset from the point [{@link x}, {@link y}] to the top-left of this rectangle, as a new {@link Point}. */\n  getOffsetFrom([x, y]: ReadOnlyPoint): Point {\n    return [this[0] - x, this[1] - y]\n  }\n\n  /** Sets the width without moving the right edge (changes position) */\n  setWidthRightAnchored(width: number) {\n    const currentWidth = this[2]\n    this[2] = width\n    this[0] += currentWidth - width\n  }\n\n  /** Sets the height without moving the bottom edge (changes position) */\n  setHeightBottomAnchored(height: number) {\n    const currentHeight = this[3]\n    this[3] = height\n    this[1] += currentHeight - height\n  }\n\n  /** Alias of {@link export}. */\n  toArray() { return this.export() }\n\n  /** @returns A new, untyped array (serializable) containing the values of this rectangle. */\n  export(): [number, number, number, number] {\n    return [this[0], this[1], this[2], this[3]]\n  }\n\n  /** Draws a debug outline of this rectangle. */\n  _drawDebug(ctx: CanvasRenderingContext2D, colour = \"red\") {\n    const { strokeStyle, lineWidth } = ctx\n    try {\n      ctx.strokeStyle = colour\n      ctx.lineWidth = 0.5\n      ctx.beginPath()\n      ctx.strokeRect(this[0], this[1], this[2], this[3])\n    } finally {\n      ctx.strokeStyle = strokeStyle\n      ctx.lineWidth = lineWidth\n    }\n  }\n}\n","import type { Point } from \"@/interfaces\"\nimport type { CanvasPointer, LGraphCanvas, LGraphNode, Size } from \"@/litegraph\"\nimport type { CanvasMouseEvent, CanvasPointerEvent } from \"@/types/events\"\nimport type { IBaseWidget } from \"@/types/widgets\"\n\nimport { drawTextInArea } from \"@/draw\"\nimport { Rectangle } from \"@/infrastructure/Rectangle\"\nimport { LiteGraph } from \"@/litegraph\"\n\nexport interface DrawWidgetOptions {\n  /** The width of the node where this widget will be displayed. */\n  width: number\n  /** Synonym for \"low quality\". */\n  showText?: boolean\n}\n\nexport interface DrawTruncatingTextOptions extends DrawWidgetOptions {\n  /** The canvas context to draw the text on. */\n  ctx: CanvasRenderingContext2D\n  /** The amount of padding to add to the left of the text. */\n  leftPadding?: number\n  /** The amount of padding to add to the right of the text. */\n  rightPadding?: number\n}\n\nexport interface WidgetEventOptions {\n  e: CanvasMouseEvent\n  node: LGraphNode\n  canvas: LGraphCanvas\n}\n\nexport abstract class BaseWidget<TWidget extends IBaseWidget = IBaseWidget> implements IBaseWidget {\n  /** From node edge to widget edge */\n  static margin = 15\n  /** From widget edge to tip of arrow button */\n  static arrowMargin = 6\n  /** Arrow button width */\n  static arrowWidth = 10\n  /** Absolute minimum display width of widget values */\n  static minValueWidth = 42\n  /** Minimum gap between label and value */\n  static labelValueGap = 5\n\n  declare computedHeight?: number\n  declare serialize?: boolean\n  computeLayoutSize?(node: LGraphNode): {\n    minHeight: number\n    maxHeight?: number\n    minWidth: number\n    maxWidth?: number\n  }\n\n  #node: LGraphNode\n  /** The node that this widget belongs to. */\n  get node() {\n    return this.#node\n  }\n\n  linkedWidgets?: IBaseWidget[]\n  name: string\n  options: TWidget[\"options\"]\n  label?: string\n  type: TWidget[\"type\"]\n  y: number = 0\n  last_y?: number\n  width?: number\n  disabled?: boolean\n  computedDisabled?: boolean\n  hidden?: boolean\n  advanced?: boolean\n  tooltip?: string\n  element?: HTMLElement\n  callback?(\n    value: any,\n    canvas?: LGraphCanvas,\n    node?: LGraphNode,\n    pos?: Point,\n    e?: CanvasMouseEvent,\n  ): void\n  mouse?(event: CanvasPointerEvent, pointerOffset: Point, node: LGraphNode): boolean\n  computeSize?(width?: number): Size\n  onPointerDown?(pointer: CanvasPointer, node: LGraphNode, canvas: LGraphCanvas): boolean\n\n  #value?: TWidget[\"value\"]\n  get value(): TWidget[\"value\"] {\n    return this.#value\n  }\n\n  set value(value: TWidget[\"value\"]) {\n    this.#value = value\n  }\n\n  constructor(widget: TWidget & { node: LGraphNode })\n  constructor(widget: TWidget, node: LGraphNode)\n  constructor(widget: TWidget & { node: LGraphNode }, node?: LGraphNode) {\n    // Private fields\n    this.#node = node ?? widget.node\n\n    // The set and get functions for DOM widget values are hacked on to the options object;\n    // attempting to set value before options will throw.\n    // https://github.com/Comfy-Org/ComfyUI_frontend/blob/df86da3d672628a452baed3df3347a52c0c8d378/src/scripts/domWidget.ts#L125\n    this.name = widget.name\n    this.options = widget.options\n    this.type = widget.type\n\n    // `node` has no setter - Object.assign will throw.\n    // TODO: Resolve this workaround. Ref: https://github.com/Comfy-Org/litegraph.js/issues/1022\n    // @ts-expect-error Prevent naming conflicts with custom nodes.\n    // eslint-disable-next-line unused-imports/no-unused-vars\n    const { node: _, outline_color, background_color, height, text_color, secondary_text_color, disabledTextColor, displayName, displayValue, labelBaseline, ...safeValues } = widget\n\n    Object.assign(this, safeValues)\n  }\n\n  get outline_color() {\n    return this.advanced ? LiteGraph.WIDGET_ADVANCED_OUTLINE_COLOR : LiteGraph.WIDGET_OUTLINE_COLOR\n  }\n\n  get background_color() {\n    return LiteGraph.WIDGET_BGCOLOR\n  }\n\n  get height() {\n    return LiteGraph.NODE_WIDGET_HEIGHT\n  }\n\n  get text_color() {\n    return LiteGraph.WIDGET_TEXT_COLOR\n  }\n\n  get secondary_text_color() {\n    return LiteGraph.WIDGET_SECONDARY_TEXT_COLOR\n  }\n\n  get disabledTextColor() {\n    return LiteGraph.WIDGET_DISABLED_TEXT_COLOR\n  }\n\n  get displayName() {\n    return this.label || this.name\n  }\n\n  // TODO: Resolve this workaround. Ref: https://github.com/Comfy-Org/litegraph.js/issues/1022\n  get _displayValue(): string {\n    return String(this.value)\n  }\n\n  get labelBaseline() {\n    return this.y + this.height * 0.7\n  }\n\n  /**\n   * Draws the widget\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   * @remarks Not naming this `draw` as `draw` conflicts with the `draw` method in\n   * custom widgets.\n   */\n  abstract drawWidget(ctx: CanvasRenderingContext2D, options: DrawWidgetOptions): void\n\n  /**\n   * Draws the standard widget shape - elongated capsule. The path of the widget shape is not\n   * cleared, and may be used for further drawing.\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   * @remarks Leaves {@link ctx} dirty.\n   */\n  protected drawWidgetShape(ctx: CanvasRenderingContext2D, { width, showText }: DrawWidgetOptions): void {\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    ctx.textAlign = \"left\"\n    ctx.strokeStyle = this.outline_color\n    ctx.fillStyle = this.background_color\n    ctx.beginPath()\n\n    if (showText) {\n      ctx.roundRect(margin, y, width - margin * 2, height, [height * 0.5])\n    } else {\n      ctx.rect(margin, y, width - margin * 2, height)\n    }\n    ctx.fill()\n    if (showText && !this.computedDisabled) ctx.stroke()\n  }\n\n  /**\n   * A shared routine for drawing a label and value as text, truncated\n   * if they exceed the available width.\n   */\n  protected drawTruncatingText({\n    ctx,\n    width,\n    leftPadding = 5,\n    rightPadding = 20,\n  }: DrawTruncatingTextOptions): void {\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    // Measure label and value\n    const { displayName, _displayValue } = this\n    const labelWidth = ctx.measureText(displayName).width\n    const valueWidth = ctx.measureText(_displayValue).width\n\n    const gap = BaseWidget.labelValueGap\n    const x = margin * 2 + leftPadding\n\n    const totalWidth = width - x - 2 * margin - rightPadding\n    const requiredWidth = labelWidth + gap + valueWidth\n\n    const area = new Rectangle(x, y, totalWidth, height * 0.7)\n\n    ctx.fillStyle = this.secondary_text_color\n\n    if (requiredWidth <= totalWidth) {\n      // Draw label & value normally\n      drawTextInArea({ ctx, text: displayName, area, align: \"left\" })\n    } else if (LiteGraph.truncateWidgetTextEvenly) {\n      // Label + value will not fit - scale evenly to fit\n      const scale = (totalWidth - gap) / (requiredWidth - gap)\n      area.width = labelWidth * scale\n\n      drawTextInArea({ ctx, text: displayName, area, align: \"left\" })\n\n      // Move the area to the right to render the value\n      area.right = x + totalWidth\n      area.setWidthRightAnchored(valueWidth * scale)\n    } else if (LiteGraph.truncateWidgetValuesFirst) {\n      // Label + value will not fit - use legacy scaling of value first\n      const cappedLabelWidth = Math.min(labelWidth, totalWidth)\n\n      area.width = cappedLabelWidth\n      drawTextInArea({ ctx, text: displayName, area, align: \"left\" })\n\n      area.right = x + totalWidth\n      area.setWidthRightAnchored(Math.max(totalWidth - gap - cappedLabelWidth, 0))\n    } else {\n      // Label + value will not fit - scale label first\n      const cappedValueWidth = Math.min(valueWidth, totalWidth)\n\n      area.width = Math.max(totalWidth - gap - cappedValueWidth, 0)\n      drawTextInArea({ ctx, text: displayName, area, align: \"left\" })\n\n      area.right = x + totalWidth\n      area.setWidthRightAnchored(cappedValueWidth)\n    }\n    ctx.fillStyle = this.text_color\n    drawTextInArea({ ctx, text: _displayValue, area, align: \"right\" })\n  }\n\n  /**\n   * Handles the click event for the widget\n   * @param options The options for handling the click event\n   */\n  abstract onClick(options: WidgetEventOptions): void\n\n  /**\n   * Handles the drag event for the widget\n   * @param options The options for handling the drag event\n   */\n  onDrag?(options: WidgetEventOptions): void\n\n  /**\n   * Sets the value of the widget\n   * @param value The value to set\n   * @param options The options for setting the value\n   */\n  setValue(value: TWidget[\"value\"], { e, node, canvas }: WidgetEventOptions): void {\n    const oldValue = this.value\n    if (value === this.value) return\n\n    const v = this.type === \"number\" ? Number(value) : value\n    this.value = v\n    if (\n      this.options?.property &&\n      node.properties[this.options.property] !== undefined\n    ) {\n      node.setProperty(this.options.property, v)\n    }\n    const pos = canvas.graph_mouse\n    this.callback?.(this.value, canvas, node, pos, e)\n\n    node.onWidgetChanged?.(this.name ?? \"\", v, oldValue, this)\n    if (node.graph) node.graph._version++\n  }\n}\n","import type { IBooleanWidget } from \"@/types/widgets\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class BooleanWidget extends BaseWidget<IBooleanWidget> implements IBooleanWidget {\n  override type = \"toggle\" as const\n\n  override drawWidget(ctx: CanvasRenderingContext2D, {\n    width,\n    showText = true,\n  }: DrawWidgetOptions) {\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    this.drawWidgetShape(ctx, { width, showText })\n\n    ctx.fillStyle = this.value ? \"#89A\" : \"#333\"\n    ctx.beginPath()\n    ctx.arc(\n      width - margin * 2,\n      y + height * 0.5,\n      height * 0.36,\n      0,\n      Math.PI * 2,\n    )\n    ctx.fill()\n\n    if (showText) {\n      this.drawLabel(ctx, margin * 2)\n      this.drawValue(ctx, width - 40)\n    }\n  }\n\n  drawLabel(ctx: CanvasRenderingContext2D, x: number): void {\n    // Draw label\n    ctx.fillStyle = this.secondary_text_color\n    const { displayName } = this\n    if (displayName) ctx.fillText(displayName, x, this.labelBaseline)\n  }\n\n  drawValue(ctx: CanvasRenderingContext2D, x: number): void {\n    // Draw value\n    ctx.fillStyle = this.value ? this.text_color : this.secondary_text_color\n    ctx.textAlign = \"right\"\n    const value = this.value ? this.options.on || \"true\" : this.options.off || \"false\"\n    ctx.fillText(value, x, this.labelBaseline)\n  }\n\n  override onClick(options: WidgetEventOptions) {\n    this.setValue(!this.value, options)\n  }\n}\n","import type { LGraphNode } from \"@/LGraphNode\"\nimport type { IButtonWidget } from \"@/types/widgets\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class ButtonWidget extends BaseWidget<IButtonWidget> implements IButtonWidget {\n  override type = \"button\" as const\n  clicked: boolean\n\n  constructor(widget: IButtonWidget, node: LGraphNode) {\n    super(widget, node)\n    this.clicked ??= false\n  }\n\n  /**\n   * Draws the widget\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   */\n  override drawWidget(ctx: CanvasRenderingContext2D, {\n    width,\n    showText = true,\n  }: DrawWidgetOptions) {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    // Draw button background\n    ctx.fillStyle = this.background_color\n    if (this.clicked) {\n      ctx.fillStyle = \"#AAA\"\n      this.clicked = false\n    }\n    ctx.fillRect(margin, y, width - margin * 2, height)\n\n    // Draw button outline if not disabled\n    if (showText && !this.computedDisabled) {\n      ctx.strokeStyle = this.outline_color\n      ctx.strokeRect(margin, y, width - margin * 2, height)\n    }\n\n    // Draw button text\n    if (showText) this.drawLabel(ctx, width * 0.5)\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n\n  drawLabel(ctx: CanvasRenderingContext2D, x: number): void {\n    ctx.textAlign = \"center\"\n    ctx.fillStyle = this.text_color\n    ctx.fillText(this.displayName, x, this.y + this.height * 0.7)\n  }\n\n  override onClick({ e, node, canvas }: WidgetEventOptions) {\n    const pos = canvas.graph_mouse\n\n    // Set clicked state and mark canvas as dirty\n    this.clicked = true\n    canvas.setDirty(true)\n\n    // Call the callback with widget instance and other context\n    this.callback?.(this, canvas, node, pos, e)\n  }\n}\n","import type { IBaseWidget } from \"@/types/widgets\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\n/**\n * Base class for widgets that have increment and decrement buttons.\n */\nexport abstract class BaseSteppedWidget<TWidget extends IBaseWidget = IBaseWidget> extends BaseWidget<TWidget> {\n  /**\n   * Whether the widget can increment its value\n   * @returns `true` if the widget can increment its value, otherwise `false`\n   */\n  abstract canIncrement(): boolean\n  /**\n   * Whether the widget can decrement its value\n   * @returns `true` if the widget can decrement its value, otherwise `false`\n   */\n  abstract canDecrement(): boolean\n  /**\n   * Increment the value of the widget\n   * @param options The options for the widget event\n   */\n  abstract incrementValue(options: WidgetEventOptions): void\n  /**\n   * Decrement the value of the widget\n   * @param options The options for the widget event\n   */\n  abstract decrementValue(options: WidgetEventOptions): void\n\n  /**\n   * Draw the arrow buttons for the widget\n   * @param ctx The canvas rendering context\n   * @param width The width of the widget\n   */\n  drawArrowButtons(ctx: CanvasRenderingContext2D, width: number) {\n    const { height, text_color, disabledTextColor, y } = this\n    const { arrowMargin, arrowWidth, margin } = BaseWidget\n    const arrowTipX = margin + arrowMargin\n    const arrowInnerX = arrowTipX + arrowWidth\n\n    // Draw left arrow\n    ctx.fillStyle = this.canDecrement() ? text_color : disabledTextColor\n    ctx.beginPath()\n    ctx.moveTo(arrowInnerX, y + 5)\n    ctx.lineTo(arrowTipX, y + height * 0.5)\n    ctx.lineTo(arrowInnerX, y + height - 5)\n    ctx.fill()\n\n    // Draw right arrow\n    ctx.fillStyle = this.canIncrement() ? text_color : disabledTextColor\n    ctx.beginPath()\n    ctx.moveTo(width - arrowInnerX, y + 5)\n    ctx.lineTo(width - arrowTipX, y + height * 0.5)\n    ctx.lineTo(width - arrowInnerX, y + height - 5)\n    ctx.fill()\n  }\n\n  override drawWidget(ctx: CanvasRenderingContext2D, options: DrawWidgetOptions) {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    this.drawWidgetShape(ctx, options)\n    if (options.showText) {\n      if (!this.computedDisabled) this.drawArrowButtons(ctx, options.width)\n\n      this.drawTruncatingText({ ctx, width: options.width })\n    }\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n}\n","import type { WidgetEventOptions } from \"./BaseWidget\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { IComboWidget, IStringComboWidget } from \"@/types/widgets\"\n\nimport { clamp, LiteGraph } from \"@/litegraph\"\nimport { warnDeprecated } from \"@/utils/feedback\"\n\nimport { BaseSteppedWidget } from \"./BaseSteppedWidget\"\n\n/**\n * This is used as an (invalid) assertion to resolve issues with legacy duck-typed values.\n *\n * Function style in use by:\n * https://github.com/kijai/ComfyUI-KJNodes/blob/c3dc82108a2a86c17094107ead61d63f8c76200e/web/js/setgetnodes.js#L401-L404\n */\ntype Values = string[] | Record<string, string> | ((widget?: ComboWidget, node?: LGraphNode) => string[])\n\nfunction toArray(values: Values): string[] {\n  return Array.isArray(values) ? values : Object.keys(values)\n}\n\nexport class ComboWidget extends BaseSteppedWidget<IStringComboWidget | IComboWidget> implements IComboWidget {\n  override type = \"combo\" as const\n\n  override get _displayValue() {\n    const { values: rawValues } = this.options\n    if (rawValues) {\n      const values = typeof rawValues === \"function\" ? rawValues() : rawValues\n\n      if (values && !Array.isArray(values)) {\n        return values[this.value]\n      }\n    }\n    return typeof this.value === \"number\" ? String(this.value) : this.value\n  }\n\n  #getValues(node: LGraphNode): Values {\n    const { values } = this.options\n    if (values == null) throw new Error(\"[ComboWidget]: values is required\")\n\n    return typeof values === \"function\"\n      ? values(this, node)\n      : values\n  }\n\n  /**\n   * Checks if the value is {@link Array.at at} the given index in the combo list.\n   * @param increment `true` if checking the use of the increment button, `false` for decrement\n   * @returns `true` if the value is at the given index, otherwise `false`.\n   */\n  #canUseButton(increment: boolean): boolean {\n    const { values } = this.options\n    // If using legacy duck-typed method, false is the most permissive return value\n    if (typeof values === \"function\") return false\n\n    const valuesArray = toArray(values)\n    if (!(valuesArray.length > 1)) return false\n\n    // Edge case where the value is both the first and last item in the list\n    const firstValue = valuesArray.at(0)\n    const lastValue = valuesArray.at(-1)\n    if (firstValue === lastValue) return true\n\n    return this.value !== (increment ? lastValue : firstValue)\n  }\n\n  /**\n   * Returns `true` if the current value is not the last value in the list.\n   * Handles edge case where the value is both the first and last item in the list.\n   */\n  override canIncrement(): boolean {\n    return this.#canUseButton(true)\n  }\n\n  override canDecrement(): boolean {\n    return this.#canUseButton(false)\n  }\n\n  override incrementValue(options: WidgetEventOptions): void {\n    this.#tryChangeValue(1, options)\n  }\n\n  override decrementValue(options: WidgetEventOptions): void {\n    this.#tryChangeValue(-1, options)\n  }\n\n  #tryChangeValue(delta: number, options: WidgetEventOptions): void {\n    const values = this.#getValues(options.node)\n    const indexedValues = toArray(values)\n\n    // avoids double click event\n    options.canvas.last_mouseclick = 0\n\n    const foundIndex = typeof values === \"object\"\n      ? indexedValues.indexOf(String(this.value)) + delta\n      // @ts-expect-error handle non-string values\n      : indexedValues.indexOf(this.value) + delta\n\n    const index = clamp(foundIndex, 0, indexedValues.length - 1)\n\n    const value = Array.isArray(values)\n      ? values[index]\n      : index\n    this.setValue(value, options)\n  }\n\n  override onClick({ e, node, canvas }: WidgetEventOptions) {\n    const x = e.canvasX - node.pos[0]\n    const width = this.width || node.size[0]\n\n    // Deprecated functionality (warning as of v0.14.5)\n    if (typeof this.options.values === \"function\") {\n      warnDeprecated(\"Using a function for values is deprecated. Use an array of unique values instead.\")\n    }\n\n    // Determine if clicked on left/right arrows\n    if (x < 40) return this.decrementValue({ e, node, canvas })\n    if (x > width - 40) return this.incrementValue({ e, node, canvas })\n\n    // Otherwise, show dropdown menu\n    const values = this.#getValues(node)\n    const values_list = toArray(values)\n\n    // Handle center click - show dropdown menu\n    const text_values = values != values_list ? Object.values(values) : values\n    new LiteGraph.ContextMenu(text_values, {\n      scale: Math.max(1, canvas.ds.scale),\n      event: e,\n      className: \"dark\",\n      callback: (value: string) => {\n        this.setValue(\n          values != values_list\n            ? text_values.indexOf(value)\n            : value,\n          { e, node, canvas },\n        )\n      },\n    })\n  }\n}\n","import type { IWidgetOptions } from \"@/types/widgets\"\n\n/**\n * The step value for numeric widgets.\n * Use {@link IWidgetOptions.step2} if available, otherwise fallback to\n * {@link IWidgetOptions.step} which is scaled up by 10x in the legacy frontend logic.\n */\nexport function getWidgetStep(options: IWidgetOptions<unknown>): number {\n  return options.step2 || ((options.step || 10) * 0.1)\n}\n","import type { IKnobWidget } from \"@/types/widgets\"\n\nimport { clamp } from \"@/litegraph\"\nimport { getWidgetStep } from \"@/utils/widget\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class KnobWidget extends BaseWidget<IKnobWidget> implements IKnobWidget {\n  override type = \"knob\" as const\n\n  /**\n   * Compute the layout size of the widget.\n   * @returns The layout size of the widget.\n   */\n  override computeLayoutSize(): {\n    minHeight: number\n    maxHeight?: number\n    minWidth: number\n    maxWidth?: number\n  } {\n    return {\n      minHeight: 60,\n      minWidth: 20,\n      maxHeight: 1_000_000,\n      maxWidth: 1_000_000,\n    }\n  }\n\n  override get height(): number {\n    return this.computedHeight || super.height\n  }\n\n  drawWidget(\n    ctx: CanvasRenderingContext2D,\n    {\n      width,\n      showText = true,\n    }: DrawWidgetOptions,\n  ): void {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    const { y } = this\n    const { margin } = BaseWidget\n\n    const { gradient_stops = \"rgb(14, 182, 201); rgb(0, 216, 72)\" } = this.options\n    const effective_height = this.computedHeight || this.height\n    // Draw background\n    const size_modifier =\n      Math.min(this.computedHeight || this.height, this.width || 20) / 20 // TODO: replace magic numbers\n    const arc_center = { x: width / 2, y: effective_height / 2 + y }\n    ctx.lineWidth =\n      (Math.min(width, effective_height) - margin * size_modifier) / 6\n    const arc_size =\n      (Math.min(width, effective_height) -\n        margin * size_modifier -\n        ctx.lineWidth) / 2\n    {\n      const gradient = ctx.createRadialGradient(\n        arc_center.x,\n        arc_center.y,\n        arc_size + ctx.lineWidth,\n        0,\n        0,\n        arc_size + ctx.lineWidth,\n      )\n      gradient.addColorStop(0, \"rgb(29, 29, 29)\")\n      gradient.addColorStop(1, \"rgb(116, 116, 116)\")\n      ctx.fillStyle = gradient\n    }\n    ctx.beginPath()\n\n    {\n      ctx.arc(\n        arc_center.x,\n        arc_center.y,\n        arc_size + ctx.lineWidth / 2,\n        0,\n        Math.PI * 2,\n        false,\n      )\n      ctx.fill()\n      ctx.closePath()\n    }\n\n    // Draw knob's background\n    const arc = {\n      start_angle: Math.PI * 0.6,\n      end_angle: Math.PI * 2.4,\n    }\n    ctx.beginPath()\n    {\n      const gradient = ctx.createRadialGradient(\n        arc_center.x,\n        arc_center.y,\n        arc_size + ctx.lineWidth,\n        0,\n        0,\n        arc_size + ctx.lineWidth,\n      )\n      gradient.addColorStop(0, \"rgb(99, 99, 99)\")\n      gradient.addColorStop(1, \"rgb(36, 36, 36)\")\n      ctx.strokeStyle = gradient\n    }\n    ctx.arc(\n      arc_center.x,\n      arc_center.y,\n      arc_size,\n      arc.start_angle,\n      arc.end_angle,\n      false,\n    )\n    ctx.stroke()\n    ctx.closePath()\n\n    const range = this.options.max - this.options.min\n    let nvalue = (this.value - this.options.min) / range\n    nvalue = clamp(nvalue, 0, 1)\n\n    // Draw value\n    ctx.beginPath()\n    const gradient = ctx.createConicGradient(\n      arc.start_angle,\n      arc_center.x,\n      arc_center.y,\n    )\n    const gs = gradient_stops.split(\";\")\n    for (const [index, stop] of gs.entries()) {\n      gradient.addColorStop(index, stop.trim())\n    }\n\n    ctx.strokeStyle = gradient\n    const value_end_angle =\n      (arc.end_angle - arc.start_angle) * nvalue + arc.start_angle\n    ctx.arc(\n      arc_center.x,\n      arc_center.y,\n      arc_size,\n      arc.start_angle,\n      value_end_angle,\n      false,\n    )\n    ctx.stroke()\n    ctx.closePath()\n\n    // Draw outline if not disabled\n    if (showText && !this.computedDisabled) {\n      ctx.strokeStyle = this.outline_color\n      // Draw value\n      ctx.beginPath()\n      ctx.strokeStyle = this.outline_color\n      ctx.arc(\n        arc_center.x,\n        arc_center.y,\n        arc_size + ctx.lineWidth / 2,\n        0,\n        Math.PI * 2,\n        false,\n      )\n      ctx.lineWidth = 1\n      ctx.stroke()\n      ctx.closePath()\n    }\n\n    // Draw marker if present\n    // TODO: TBD later when options work\n\n    // Draw text\n    if (showText) {\n      ctx.textAlign = \"center\"\n      ctx.fillStyle = this.text_color\n      const fixedValue = Number(this.value).toFixed(this.options.precision ?? 3)\n      ctx.fillText(\n        `${this.label || this.name}\\n${fixedValue}`,\n        width * 0.5,\n        y + effective_height * 0.5,\n      )\n    }\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n\n  onClick(): void {\n    this.current_drag_offset = 0\n  }\n\n  current_drag_offset = 0\n  override onDrag(options: WidgetEventOptions): void {\n    if (this.options.read_only) return\n    const { e } = options\n    const step = getWidgetStep(this.options)\n    // Shift to move by 10% increments\n    const range = (this.options.max - this.options.min)\n    const range_10_percent = range / 10\n    const range_1_percent = range / 100\n    const step_for = {\n      delta_x: step,\n      shift: range_10_percent > step ? range_10_percent - (range_10_percent % step) : step,\n      delta_y: range_1_percent > step ? range_1_percent - (range_1_percent % step) : step, // 1% increments\n    }\n\n    const use_y = Math.abs(e.movementY) > Math.abs(e.movementX)\n    const delta = use_y ? -e.movementY : e.movementX // Y is inverted so that UP increases the value\n    const drag_threshold = 15\n    // Calculate new value based on drag movement\n    this.current_drag_offset += delta\n    let adjustment = 0\n    if (this.current_drag_offset > drag_threshold) {\n      adjustment += 1\n      this.current_drag_offset -= drag_threshold\n    } else if (this.current_drag_offset < -drag_threshold) {\n      adjustment -= 1\n      this.current_drag_offset += drag_threshold\n    }\n\n    const step_with_shift_modifier = e.shiftKey\n      ? step_for.shift\n      : (use_y\n        ? step_for.delta_y\n        : step)\n\n    const deltaValue = adjustment * step_with_shift_modifier\n    const newValue = clamp(\n      this.value + deltaValue,\n      this.options.min,\n      this.options.max,\n    )\n    if (newValue !== this.value) {\n      this.setValue(newValue, options)\n    }\n  }\n}\n","import type { LGraphNode } from \"@/LGraphNode\"\nimport type { IBaseWidget } from \"@/types/widgets\"\n\nimport { LiteGraph } from \"@/litegraph\"\n\nimport { BaseWidget, type DrawWidgetOptions } from \"./BaseWidget\"\n\n/**\n * Wraps a legacy POJO custom widget, so that all widgets may be called via the same internal interface.\n *\n * Support will eventually be removed.\n * @remarks Expect this class to undergo breaking changes without warning.\n */\nexport class LegacyWidget<TWidget extends IBaseWidget = IBaseWidget> extends BaseWidget<TWidget> implements IBaseWidget {\n  draw?(\n    ctx: CanvasRenderingContext2D,\n    node: LGraphNode,\n    widget_width: number,\n    y: number,\n    H: number,\n    lowQuality?: boolean,\n  ): void\n\n  override drawWidget(ctx: CanvasRenderingContext2D, options: DrawWidgetOptions) {\n    const H = LiteGraph.NODE_WIDGET_HEIGHT\n    this.draw?.(ctx, this.node, options.width, this.y, H, !!options.showText)\n  }\n\n  override onClick() {\n    console.warn(\"Custom widget wrapper onClick was just called. Handling for third party widgets is done via LGraphCanvas - the mouse callback.\")\n  }\n}\n","import type { WidgetEventOptions } from \"./BaseWidget\"\nimport type { INumericWidget } from \"@/types/widgets\"\n\nimport { getWidgetStep } from \"@/utils/widget\"\n\nimport { BaseSteppedWidget } from \"./BaseSteppedWidget\"\n\nexport class NumberWidget extends BaseSteppedWidget<INumericWidget> implements INumericWidget {\n  override type = \"number\" as const\n\n  override get _displayValue() {\n    return Number(this.value).toFixed(\n      this.options.precision !== undefined\n        ? this.options.precision\n        : 3,\n    )\n  }\n\n  override canIncrement(): boolean {\n    const { max } = this.options\n    return max == null || this.value < max\n  }\n\n  override canDecrement(): boolean {\n    const { min } = this.options\n    return min == null || this.value > min\n  }\n\n  override incrementValue(options: WidgetEventOptions): void {\n    this.setValue(this.value + getWidgetStep(this.options), options)\n  }\n\n  override decrementValue(options: WidgetEventOptions): void {\n    this.setValue(this.value - getWidgetStep(this.options), options)\n  }\n\n  override setValue(value: number, options: WidgetEventOptions) {\n    let newValue = value\n    if (this.options.min != null && newValue < this.options.min) {\n      newValue = this.options.min\n    }\n    if (this.options.max != null && newValue > this.options.max) {\n      newValue = this.options.max\n    }\n    super.setValue(newValue, options)\n  }\n\n  override onClick({ e, node, canvas }: WidgetEventOptions) {\n    const x = e.canvasX - node.pos[0]\n    const width = this.width || node.size[0]\n\n    // Determine if clicked on left/right arrows\n    const delta = x < 40\n      ? -1\n      : (x > width - 40\n        ? 1\n        : 0)\n\n    if (delta) {\n      // Handle left/right arrow clicks\n      this.setValue(this.value + delta * getWidgetStep(this.options), { e, node, canvas })\n      return\n    }\n\n    // Handle center click - show prompt\n    canvas.prompt(\"Value\", this.value, (v: string) => {\n      // Check if v is a valid equation or a number\n      if (/^[\\d\\s()*+/-]+|\\d+\\.\\d+$/.test(v)) {\n        // Solve the equation if possible\n        try {\n          v = eval(v)\n        } catch {}\n      }\n      const newValue = Number(v)\n      if (!isNaN(newValue)) {\n        this.setValue(newValue, { e, node, canvas })\n      }\n    }, e)\n  }\n\n  /**\n   * Handles drag events for the number widget\n   * @param options The options for handling the drag event\n   */\n  override onDrag({ e, node, canvas }: WidgetEventOptions) {\n    const width = this.width || node.width\n    const x = e.canvasX - node.pos[0]\n    const delta = x < 40\n      ? -1\n      : (x > width - 40\n        ? 1\n        : 0)\n\n    if (delta && (x > -3 && x < width + 3)) return\n    this.setValue(this.value + (e.deltaX ?? 0) * getWidgetStep(this.options), { e, node, canvas })\n  }\n}\n","import type { ISliderWidget } from \"@/types/widgets\"\n\nimport { clamp } from \"@/litegraph\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class SliderWidget extends BaseWidget<ISliderWidget> implements ISliderWidget {\n  override type = \"slider\" as const\n\n  marker?: number\n\n  /**\n   * Draws the widget\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   */\n  override drawWidget(ctx: CanvasRenderingContext2D, {\n    width,\n    showText = true,\n  }: DrawWidgetOptions) {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    // Draw background\n    ctx.fillStyle = this.background_color\n    ctx.fillRect(margin, y, width - margin * 2, height)\n\n    // Calculate normalized value\n    const range = this.options.max - this.options.min\n    let nvalue = (this.value - this.options.min) / range\n    nvalue = clamp(nvalue, 0, 1)\n\n    // Draw slider bar\n    ctx.fillStyle = this.options.slider_color ?? \"#678\"\n    ctx.fillRect(margin, y, nvalue * (width - margin * 2), height)\n\n    // Draw outline if not disabled\n    if (showText && !this.computedDisabled) {\n      ctx.strokeStyle = this.outline_color\n      ctx.strokeRect(margin, y, width - margin * 2, height)\n    }\n\n    // Draw marker if present\n    if (this.marker != null) {\n      let marker_nvalue = (this.marker - this.options.min) / range\n      marker_nvalue = clamp(marker_nvalue, 0, 1)\n      ctx.fillStyle = this.options.marker_color ?? \"#AA9\"\n      ctx.fillRect(\n        margin + marker_nvalue * (width - margin * 2),\n        y,\n        2,\n        height,\n      )\n    }\n\n    // Draw text\n    if (showText) {\n      ctx.textAlign = \"center\"\n      ctx.fillStyle = this.text_color\n      const fixedValue = Number(this.value).toFixed(this.options.precision ?? 3)\n      ctx.fillText(\n        `${this.label || this.name}  ${fixedValue}`,\n        width * 0.5,\n        y + height * 0.7,\n      )\n    }\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n\n  /**\n   * Handles click events for the slider widget\n   */\n  override onClick(options: WidgetEventOptions) {\n    if (this.options.read_only) return\n\n    const { e, node } = options\n    const width = this.width || node.size[0]\n    const x = e.canvasX - node.pos[0]\n\n    // Calculate new value based on click position\n    const slideFactor = clamp((x - 15) / (width - 30), 0, 1)\n    const newValue = this.options.min + (this.options.max - this.options.min) * slideFactor\n\n    if (newValue !== this.value) {\n      this.setValue(newValue, options)\n    }\n  }\n\n  /**\n   * Handles drag events for the slider widget\n   */\n  override onDrag(options: WidgetEventOptions) {\n    if (this.options.read_only) return false\n\n    const { e, node } = options\n    const width = this.width || node.size[0]\n    const x = e.canvasX - node.pos[0]\n\n    // Calculate new value based on drag position\n    const slideFactor = clamp((x - 15) / (width - 30), 0, 1)\n    const newValue = this.options.min + (this.options.max - this.options.min) * slideFactor\n\n    if (newValue !== this.value) {\n      this.setValue(newValue, options)\n    }\n  }\n}\n","import type { LGraphNode } from \"@/LGraphNode\"\nimport type { IStringWidget } from \"@/types/widgets\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class TextWidget extends BaseWidget<IStringWidget> implements IStringWidget {\n  constructor(widget: IStringWidget, node: LGraphNode) {\n    super(widget, node)\n    this.type ??= \"string\"\n    this.value = widget.value?.toString() ?? \"\"\n  }\n\n  /**\n   * Draws the widget\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   */\n  override drawWidget(ctx: CanvasRenderingContext2D, {\n    width,\n    showText = true,\n  }: DrawWidgetOptions) {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    this.drawWidgetShape(ctx, { width, showText })\n\n    if (showText) {\n      this.drawTruncatingText({ ctx, width, leftPadding: 0, rightPadding: 0 })\n    }\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n\n  override onClick({ e, node, canvas }: WidgetEventOptions) {\n    // Show prompt dialog for text input\n    canvas.prompt(\n      \"Value\",\n      this.value,\n      (v: string) => {\n        if (v !== null) {\n          this.setValue(v, { e, node, canvas })\n        }\n      },\n      e,\n      this.options?.multiline ?? false,\n    )\n  }\n}\n","import type { LGraphNode } from \"@/LGraphNode\"\nimport type {\n  IBaseWidget,\n  IBooleanWidget,\n  IButtonWidget,\n  IComboWidget,\n  ICustomWidget,\n  IKnobWidget,\n  INumericWidget,\n  ISliderWidget,\n  IStringWidget,\n  IWidget,\n  TWidgetType,\n} from \"@/types/widgets\"\n\nimport { toClass } from \"@/utils/type\"\n\nimport { BaseWidget } from \"./BaseWidget\"\nimport { BooleanWidget } from \"./BooleanWidget\"\nimport { ButtonWidget } from \"./ButtonWidget\"\nimport { ComboWidget } from \"./ComboWidget\"\nimport { KnobWidget } from \"./KnobWidget\"\nimport { LegacyWidget } from \"./LegacyWidget\"\nimport { NumberWidget } from \"./NumberWidget\"\nimport { SliderWidget } from \"./SliderWidget\"\nimport { TextWidget } from \"./TextWidget\"\n\nexport type WidgetTypeMap = {\n  button: ButtonWidget\n  toggle: BooleanWidget\n  slider: SliderWidget\n  knob: KnobWidget\n  combo: ComboWidget\n  number: NumberWidget\n  string: TextWidget\n  text: TextWidget\n  custom: LegacyWidget\n  [key: string]: BaseWidget\n}\n\n/**\n * Convert a widget POJO to a proper widget instance.\n * @param widget The POJO to convert.\n * @param node The node the widget belongs to.\n * @param wrapLegacyWidgets Whether to wrap legacy widgets in a `LegacyWidget` instance.\n * @returns A concrete widget instance.\n */\nexport function toConcreteWidget<TWidget extends IWidget | IBaseWidget>(\n  widget: TWidget,\n  node: LGraphNode,\n  wrapLegacyWidgets?: true,\n): WidgetTypeMap[TWidget[\"type\"]]\nexport function toConcreteWidget<TWidget extends IWidget | IBaseWidget>(\n  widget: TWidget,\n  node: LGraphNode,\n  wrapLegacyWidgets: false): WidgetTypeMap[TWidget[\"type\"]] | undefined\nexport function toConcreteWidget<TWidget extends IWidget | IBaseWidget>(\n  widget: TWidget,\n  node: LGraphNode,\n  wrapLegacyWidgets = true,\n): WidgetTypeMap[TWidget[\"type\"]] | undefined {\n  // Assertion: TypeScript has no concept of \"all strings except X\"\n  type RemoveBaseWidgetType<T> = T extends { type: TWidgetType } ? T : never\n  const narrowedWidget = widget as RemoveBaseWidgetType<TWidget>\n\n  switch (narrowedWidget.type) {\n  case \"button\": return toClass(ButtonWidget, narrowedWidget, node)\n  case \"toggle\": return toClass(BooleanWidget, narrowedWidget, node)\n  case \"slider\": return toClass(SliderWidget, narrowedWidget, node)\n  case \"knob\": return toClass(KnobWidget, narrowedWidget, node)\n  case \"combo\": return toClass(ComboWidget, narrowedWidget, node)\n  case \"number\": return toClass(NumberWidget, narrowedWidget, node)\n  case \"string\": return toClass(TextWidget, narrowedWidget, node)\n  case \"text\": return toClass(TextWidget, narrowedWidget, node)\n  default: {\n    if (wrapLegacyWidgets) return toClass(LegacyWidget, widget, node)\n  }\n  }\n}\n\n// #region Type Guards\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IButtonWidget}. */\nexport function isButtonWidget(widget: IBaseWidget): widget is IButtonWidget {\n  return widget.type === \"button\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IBooleanWidget}. */\nexport function isBooleanWidget(widget: IBaseWidget): widget is IBooleanWidget {\n  return widget.type === \"toggle\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link ISliderWidget}. */\nexport function isSliderWidget(widget: IBaseWidget): widget is ISliderWidget {\n  return widget.type === \"slider\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IKnobWidget}. */\nexport function isKnobWidget(widget: IBaseWidget): widget is IKnobWidget {\n  return widget.type === \"knob\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IComboWidget}. */\nexport function isComboWidget(widget: IBaseWidget): widget is IComboWidget {\n  return widget.type === \"combo\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link INumericWidget}. */\nexport function isNumberWidget(widget: IBaseWidget): widget is INumericWidget {\n  return widget.type === \"number\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IStringWidget}. */\nexport function isStringWidget(widget: IBaseWidget): widget is IStringWidget {\n  return widget.type === \"string\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link ITextWidget}. */\nexport function isTextWidget(widget: IBaseWidget): widget is IStringWidget {\n  return widget.type === \"text\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link ICustomWidget}. */\nexport function isCustomWidget(widget: IBaseWidget): widget is ICustomWidget {\n  return widget.type === \"custom\"\n}\n\n// #endregion Type Guards\n","import type { DragAndScale } from \"./DragAndScale\"\nimport type { IDrawBoundingOptions } from \"./draw\"\nimport type {\n  ColorOption,\n  DefaultConnectionColors,\n  Dictionary,\n  IColorable,\n  IContextMenuValue,\n  IFoundSlot,\n  INodeFlags,\n  INodeInputSlot,\n  INodeOutputSlot,\n  INodeSlot,\n  INodeSlotContextItem,\n  IPinnable,\n  ISlotType,\n  Point,\n  Positionable,\n  ReadOnlyRect,\n  Rect,\n  Size,\n} from \"./interfaces\"\nimport type { LGraph } from \"./LGraph\"\nimport type { Reroute, RerouteId } from \"./Reroute\"\nimport type { CanvasMouseEvent } from \"./types/events\"\nimport type { ISerialisedNode } from \"./types/serialisation\"\nimport type { IBaseWidget, IWidgetOptions, TWidgetType, TWidgetValue } from \"./types/widgets\"\n\nimport { getNodeInputOnPos, getNodeOutputOnPos } from \"./canvas/measureSlots\"\nimport { NullGraphError } from \"./infrastructure/NullGraphError\"\nimport { BadgePosition, LGraphBadge } from \"./LGraphBadge\"\nimport { LGraphCanvas } from \"./LGraphCanvas\"\nimport { type LGraphNodeConstructor, LiteGraph } from \"./litegraph\"\nimport { LLink } from \"./LLink\"\nimport { createBounds, isInRect, isInRectangle, isPointInRect, snapPoint } from \"./measure\"\nimport { NodeInputSlot } from \"./node/NodeInputSlot\"\nimport { NodeOutputSlot } from \"./node/NodeOutputSlot\"\nimport { inputAsSerialisable, isINodeInputSlot, isWidgetInputSlot, outputAsSerialisable } from \"./node/slotUtils\"\nimport {\n  LGraphEventMode,\n  NodeSlotType,\n  RenderShape,\n  TitleMode,\n} from \"./types/globalEnums\"\nimport { findFreeSlotOfType } from \"./utils/collections\"\nimport { warnDeprecated } from \"./utils/feedback\"\nimport { distributeSpace } from \"./utils/spaceDistribution\"\nimport { toClass } from \"./utils/type\"\nimport { BaseWidget } from \"./widgets/BaseWidget\"\nimport { toConcreteWidget, type WidgetTypeMap } from \"./widgets/widgetMap\"\n\n// #region Types\n\nexport type NodeId = number | string\n\nexport type NodeProperty = string | number | boolean | object\n\nexport interface INodePropertyInfo {\n  name: string\n  type?: string\n  default_value: NodeProperty | undefined\n}\n\nexport interface IMouseOverData {\n  inputId?: number\n  outputId?: number\n  overWidget?: IBaseWidget\n}\n\nexport interface ConnectByTypeOptions {\n  /** @deprecated Events */\n  createEventInCase?: boolean\n  /** Allow our wildcard slot to connect to typed slots on remote node. Default: true */\n  wildcardToTyped?: boolean\n  /** Allow our typed slot to connect to wildcard slots on remote node. Default: true */\n  typedToWildcard?: boolean\n  /** The {@link Reroute.id} that the connection is being dragged from. */\n  afterRerouteId?: RerouteId\n}\n\n/** Internal type used for type safety when implementing generic checks for inputs & outputs */\nexport interface IGenericLinkOrLinks {\n  links?: INodeOutputSlot[\"links\"]\n  link?: INodeInputSlot[\"link\"]\n}\n\nexport interface FindFreeSlotOptions {\n  /** Slots matching these types will be ignored.  Default: [] */\n  typesNotAccepted?: ISlotType[]\n  /** If true, the slot itself is returned instead of the index.  Default: false */\n  returnObj?: boolean\n}\n\ninterface DrawSlotsOptions {\n  fromSlot?: INodeInputSlot | INodeOutputSlot\n  colorContext: DefaultConnectionColors\n  editorAlpha: number\n  lowQuality: boolean\n}\n\ninterface DrawWidgetsOptions {\n  lowQuality?: boolean\n  editorAlpha?: number\n}\n\ninterface DrawTitleOptions {\n  scale: number\n  title_height?: number\n  low_quality?: boolean\n}\n\ninterface DrawTitleTextOptions extends DrawTitleOptions {\n  default_title_color: string\n}\n\ninterface DrawTitleBoxOptions extends DrawTitleOptions {\n  box_size?: number\n}\n\n/*\ntitle: string\npos: [x,y]\nsize: [x,y]\n\ninput|output: every connection\n    +  { name:string, type:string, pos: [x,y]=Optional, direction: \"input\"|\"output\", links: Array });\n\ngeneral properties:\n    + clip_area: if you render outside the node, it will be clipped\n    + unsafe_execution: not allowed for safe execution\n    + skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected\n    + resizable: if set to false it wont be resizable with the mouse\n    + widgets_start_y: widgets start at y distance from the top of the node\n\nflags object:\n    + collapsed: if it is collapsed\n\nsupported callbacks:\n    + onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)\n    + onRemoved: when removed from graph\n    + onStart: when the graph starts playing\n    + onStop: when the graph stops playing\n    + onDrawForeground: render the inside widgets inside the node\n    + onDrawBackground: render the background area inside the node (only in edit mode)\n    + onMouseDown\n    + onMouseMove\n    + onMouseUp\n    + onMouseEnter\n    + onMouseLeave\n    + onExecute: execute the node\n    + onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)\n    + onGetInputs: returns an array of possible inputs\n    + onGetOutputs: returns an array of possible outputs\n    + onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])\n    + onDblClick: double clicked in the node\n    + onNodeTitleDblClick: double clicked in the node title\n    + onInputDblClick: input slot double clicked (can be used to automatically create a node connected)\n    + onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)\n    + onConfigure: called after the node has been configured\n    + onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)\n    + onSelected\n    + onDeselected\n    + onDropItem : DOM item dropped over the node\n    + onDropFile : file dropped over the node\n    + onConnectInput : if returns false the incoming connection will be canceled\n    + onConnectionsChange : a connection changed (new one or removed) (NodeSlotType.INPUT or NodeSlotType.OUTPUT, slot, true if connected, link_info, input_info )\n    + onAction: action slot triggered\n    + getExtraMenuOptions: to add option to context menu\n*/\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface LGraphNode {\n  constructor: LGraphNodeConstructor\n}\n\n// #endregion Types\n\n/**\n * Base class for all nodes\n * @param title a name for the node\n * @param type a type for the node\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class LGraphNode implements Positionable, IPinnable, IColorable {\n  // Static properties used by dynamic child classes\n  static title?: string\n  static MAX_CONSOLE?: number\n  static type?: string\n  static category?: string\n  static filter?: string\n  static skip_list?: boolean\n\n  /** Default setting for {@link LGraphNode.connectInputToOutput}. @see {@link INodeFlags.keepAllLinksOnBypass} */\n  static keepAllLinksOnBypass: boolean = false\n\n  /** The title text of the node. */\n  title: string\n  /**\n   * The font style used to render the node's title text.\n   */\n  get titleFontStyle(): string {\n    return `${LiteGraph.NODE_TEXT_SIZE}px ${LiteGraph.NODE_FONT}`\n  }\n\n  get innerFontStyle(): string {\n    return `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px ${LiteGraph.NODE_FONT}`\n  }\n\n  graph: LGraph | null = null\n  id: NodeId\n  type: string = \"\"\n  inputs: INodeInputSlot[] = []\n  outputs: INodeOutputSlot[] = []\n\n  #concreteInputs: NodeInputSlot[] = []\n  #concreteOutputs: NodeOutputSlot[] = []\n\n  properties: Dictionary<NodeProperty | undefined> = {}\n  properties_info: INodePropertyInfo[] = []\n  flags: INodeFlags = {}\n  widgets?: IBaseWidget[]\n  /**\n   * The amount of space available for widgets to grow into.\n   * @see {@link layoutWidgets}\n   */\n  freeWidgetSpace?: number\n\n  locked?: boolean\n\n  /** Execution order, automatically computed during run @see {@link LGraph.computeExecutionOrder} */\n  order: number = 0\n  mode: LGraphEventMode = LGraphEventMode.ALWAYS\n  last_serialization?: ISerialisedNode\n  serialize_widgets?: boolean\n  /**\n   * The overridden fg color used to render the node.\n   * @see {@link renderingColor}\n   */\n  color?: string\n  /**\n   * The overridden bg color used to render the node.\n   * @see {@link renderingBgColor}\n   */\n  bgcolor?: string\n  /**\n   * The overridden box color used to render the node.\n   * @see {@link renderingBoxColor}\n   */\n  boxcolor?: string\n\n  /** The fg color used to render the node. */\n  get renderingColor(): string {\n    return this.color || this.constructor.color || LiteGraph.NODE_DEFAULT_COLOR\n  }\n\n  /** The bg color used to render the node. */\n  get renderingBgColor(): string {\n    return this.bgcolor || this.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR\n  }\n\n  /** The box color used to render the node. */\n  get renderingBoxColor(): string {\n    if (this.boxcolor) return this.boxcolor\n\n    if (LiteGraph.node_box_coloured_when_on) {\n      if (this.action_triggered) return \"#FFF\"\n      if (this.execute_triggered) return \"#AAA\"\n    }\n\n    if (LiteGraph.node_box_coloured_by_mode) {\n      const modeColour = LiteGraph.NODE_MODES_COLORS[this.mode ?? LGraphEventMode.ALWAYS]\n      if (modeColour) return modeColour\n    }\n    return LiteGraph.NODE_DEFAULT_BOXCOLOR\n  }\n\n  /** @inheritdoc {@link IColorable.setColorOption} */\n  setColorOption(colorOption: ColorOption | null): void {\n    if (colorOption == null) {\n      delete this.color\n      delete this.bgcolor\n    } else {\n      this.color = colorOption.color\n      this.bgcolor = colorOption.bgcolor\n    }\n  }\n\n  /** @inheritdoc {@link IColorable.getColorOption} */\n  getColorOption(): ColorOption | null {\n    return Object.values(LGraphCanvas.node_colors).find(\n      colorOption =>\n        colorOption.color === this.color && colorOption.bgcolor === this.bgcolor,\n    ) ?? null\n  }\n\n  /**\n   * The stroke styles that should be applied to the node.\n   */\n  strokeStyles: Record<string, (this: LGraphNode) => IDrawBoundingOptions | undefined>\n\n  /**\n   * The progress of node execution. Used to render a progress bar. Value between 0 and 1.\n   */\n  progress?: number\n\n  exec_version?: number\n  action_call?: string\n  execute_triggered?: number\n  action_triggered?: number\n  widgets_up?: boolean\n  widgets_start_y?: number\n  lostFocusAt?: number\n  gotFocusAt?: number\n  badges: (LGraphBadge | (() => LGraphBadge))[] = []\n  badgePosition: BadgePosition = BadgePosition.TopLeft\n  onOutputRemoved?(this: LGraphNode, slot: number): void\n  onInputRemoved?(this: LGraphNode, slot: number, input: INodeInputSlot): void\n  /**\n   * The width of the node when collapsed.\n   * Updated by {@link LGraphCanvas.drawNode}\n   */\n  _collapsed_width?: number\n  /** Called once at the start of every frame.  Caller may change the values in {@link out}, which will be reflected in {@link boundingRect}. */\n  onBounding?(this: LGraphNode, out: Rect): void\n  console?: string[]\n  _level?: number\n  _shape?: RenderShape\n  mouseOver?: IMouseOverData\n  redraw_on_mouse?: boolean\n  resizable?: boolean\n  clonable?: boolean\n  _relative_id?: number\n  clip_area?: boolean\n  ignore_remove?: boolean\n  has_errors?: boolean\n  removable?: boolean\n  block_delete?: boolean\n  selected?: boolean\n  showAdvanced?: boolean\n\n  /** @inheritdoc {@link renderArea} */\n  #renderArea: Float32Array = new Float32Array(4)\n  /**\n   * Rect describing the node area, including shadows and any protrusions.\n   * Determines if the node is visible.  Calculated once at the start of every frame.\n   */\n  get renderArea(): ReadOnlyRect {\n    return this.#renderArea\n  }\n\n  /** @inheritdoc {@link boundingRect} */\n  #boundingRect: Float32Array = new Float32Array(4)\n  /**\n   * Cached node position & area as `x, y, width, height`.  Includes changes made by {@link onBounding}, if present.\n   *\n   * Determines the node hitbox and other rendering effects.  Calculated once at the start of every frame.\n   */\n  get boundingRect(): ReadOnlyRect {\n    return this.#boundingRect\n  }\n\n  /** {@link pos} and {@link size} values are backed by this {@link Rect}. */\n  _posSize: Float32Array = new Float32Array(4)\n  _pos: Point = this._posSize.subarray(0, 2)\n  _size: Size = this._posSize.subarray(2, 4)\n\n  public get pos() {\n    return this._pos\n  }\n\n  /** Node position does not necessarily correlate to the top-left corner. */\n  public set pos(value) {\n    if (!value || value.length < 2) return\n\n    this._pos[0] = value[0]\n    this._pos[1] = value[1]\n  }\n\n  public get size() {\n    return this._size\n  }\n\n  public set size(value) {\n    if (!value || value.length < 2) return\n\n    this._size[0] = value[0]\n    this._size[1] = value[1]\n  }\n\n  /**\n   * The size of the node used for rendering.\n   */\n  get renderingSize(): Size {\n    return this.flags.collapsed ? [this._collapsed_width ?? 0, 0] : this._size\n  }\n\n  get shape(): RenderShape | undefined {\n    return this._shape\n  }\n\n  set shape(v: RenderShape | \"default\" | \"box\" | \"round\" | \"circle\" | \"card\") {\n    switch (v) {\n    case \"default\":\n      delete this._shape\n      break\n    case \"box\":\n      this._shape = RenderShape.BOX\n      break\n    case \"round\":\n      this._shape = RenderShape.ROUND\n      break\n    case \"circle\":\n      this._shape = RenderShape.CIRCLE\n      break\n    case \"card\":\n      this._shape = RenderShape.CARD\n      break\n    default:\n      this._shape = v\n    }\n  }\n\n  /**\n   * The shape of the node used for rendering. @see {@link RenderShape}\n   */\n  get renderingShape(): RenderShape {\n    return this._shape || this.constructor.shape || LiteGraph.NODE_DEFAULT_SHAPE\n  }\n\n  public get is_selected(): boolean | undefined {\n    return this.selected\n  }\n\n  public set is_selected(value: boolean) {\n    this.selected = value\n  }\n\n  public get title_mode(): TitleMode {\n    return this.constructor.title_mode ?? TitleMode.NORMAL_TITLE\n  }\n\n  onConnectInput?(\n    this: LGraphNode,\n    target_slot: number,\n    type: unknown,\n    output: INodeOutputSlot,\n    node: LGraphNode,\n    slot: number,\n  ): boolean\n  onConnectOutput?(\n    this: LGraphNode,\n    slot: number,\n    type: unknown,\n    input: INodeInputSlot,\n    target_node: number | LGraphNode,\n    target_slot: number,\n  ): boolean\n  onResize?(this: LGraphNode, size: Size): void\n  onPropertyChanged?(\n    this: LGraphNode,\n    name: string,\n    value: unknown,\n    prev_value?: unknown,\n  ): boolean\n  /** Called for each connection that is created, updated, or removed. This includes \"restored\" connections when deserialising. */\n  onConnectionsChange?(\n    this: LGraphNode,\n    type: ISlotType,\n    index: number,\n    isConnected: boolean,\n    link_info: LLink | null | undefined,\n    inputOrOutput: INodeInputSlot | INodeOutputSlot,\n  ): void\n  onInputAdded?(this: LGraphNode, input: INodeInputSlot): void\n  onOutputAdded?(this: LGraphNode, output: INodeOutputSlot): void\n  onConfigure?(this: LGraphNode, serialisedNode: ISerialisedNode): void\n  onSerialize?(this: LGraphNode, serialised: ISerialisedNode): any\n  onExecute?(\n    this: LGraphNode,\n    param?: unknown,\n    options?: { action_call?: any },\n  ): void\n  onAction?(\n    this: LGraphNode,\n    action: string,\n    param: unknown,\n    options: { action_call?: string },\n  ): void\n  onDrawBackground?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n  ): void\n  onNodeCreated?(this: LGraphNode): void\n  /**\n   * Callback invoked by {@link connect} to override the target slot index.\n   * Its return value overrides the target index selection.\n   * @param target_slot The current input slot index\n   * @param requested_slot The originally requested slot index - could be negative, or if using (deprecated) name search, a string\n   * @returns {number | null} If a number is returned, the connection will be made to that input index.\n   * If an invalid index or non-number (false, null, NaN etc) is returned, the connection will be cancelled.\n   */\n  onBeforeConnectInput?(\n    this: LGraphNode,\n    target_slot: number,\n    requested_slot?: number | string,\n  ): number | false | null\n  onShowCustomPanelInfo?(this: LGraphNode, panel: any): void\n  onAddPropertyToPanel?(this: LGraphNode, pName: string, panel: any): boolean\n  onWidgetChanged?(\n    this: LGraphNode,\n    name: string,\n    value: unknown,\n    old_value: unknown,\n    w: IBaseWidget,\n  ): void\n  onDeselected?(this: LGraphNode): void\n  onKeyUp?(this: LGraphNode, e: KeyboardEvent): void\n  onKeyDown?(this: LGraphNode, e: KeyboardEvent): void\n  onSelected?(this: LGraphNode): void\n  getExtraMenuOptions?(\n    this: LGraphNode,\n    canvas: LGraphCanvas,\n    options: (IContextMenuValue<unknown> | null)[],\n  ): (IContextMenuValue<unknown> | null)[]\n  getMenuOptions?(this: LGraphNode, canvas: LGraphCanvas): IContextMenuValue[]\n  onAdded?(this: LGraphNode, graph: LGraph): void\n  onDrawCollapsed?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    cavnas: LGraphCanvas,\n  ): boolean\n  onDrawForeground?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    canvas: LGraphCanvas,\n    canvasElement: HTMLCanvasElement,\n  ): void\n  onMouseLeave?(this: LGraphNode, e: CanvasMouseEvent): void\n  /**\n   * Override the default slot menu options.\n   */\n  getSlotMenuOptions?(this: LGraphNode, slot: IFoundSlot): IContextMenuValue[]\n  /**\n   * Add extra menu options to the slot context menu.\n   */\n  getExtraSlotMenuOptions?(this: LGraphNode, slot: IFoundSlot): IContextMenuValue[]\n\n  // FIXME: Re-typing\n  onDropItem?(this: LGraphNode, event: Event): boolean\n  onDropData?(\n    this: LGraphNode,\n    data: string | ArrayBuffer,\n    filename: any,\n    file: any,\n  ): void\n  onDropFile?(this: LGraphNode, file: any): void\n  onInputClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void\n  onInputDblClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void\n  onOutputClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void\n  onOutputDblClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void\n  // TODO: Return type\n  onGetPropertyInfo?(this: LGraphNode, property: string): any\n  onNodeOutputAdd?(this: LGraphNode, value: unknown): void\n  onNodeInputAdd?(this: LGraphNode, value: unknown): void\n  onMenuNodeInputs?(\n    this: LGraphNode,\n    entries: (IContextMenuValue<INodeSlotContextItem> | null)[],\n  ): (IContextMenuValue<INodeSlotContextItem> | null)[]\n  onMenuNodeOutputs?(\n    this: LGraphNode,\n    entries: (IContextMenuValue<INodeSlotContextItem> | null)[],\n  ): (IContextMenuValue<INodeSlotContextItem> | null)[]\n  onMouseUp?(this: LGraphNode, e: CanvasMouseEvent, pos: Point): void\n  onMouseEnter?(this: LGraphNode, e: CanvasMouseEvent): void\n  /** Blocks drag if return value is truthy. @param pos Offset from {@link LGraphNode.pos}. */\n  onMouseDown?(\n    this: LGraphNode,\n    e: CanvasMouseEvent,\n    pos: Point,\n    canvas: LGraphCanvas,\n  ): boolean\n  /** @param pos Offset from {@link LGraphNode.pos}. */\n  onDblClick?(\n    this: LGraphNode,\n    e: CanvasMouseEvent,\n    pos: Point,\n    canvas: LGraphCanvas,\n  ): void\n  /** @param pos Offset from {@link LGraphNode.pos}. */\n  onNodeTitleDblClick?(\n    this: LGraphNode,\n    e: CanvasMouseEvent,\n    pos: Point,\n    canvas: LGraphCanvas,\n  ): void\n  onDrawTitle?(this: LGraphNode, ctx: CanvasRenderingContext2D): void\n  onDrawTitleText?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    title_height: number,\n    size: Size,\n    scale: number,\n    title_text_font: string,\n    selected?: boolean,\n  ): void\n  onDrawTitleBox?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    title_height: number,\n    size: Size,\n    scale: number,\n  ): void\n  onDrawTitleBar?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    title_height: number,\n    size: Size,\n    scale: number,\n    fgcolor: any,\n  ): void\n  onRemoved?(this: LGraphNode): void\n  onMouseMove?(\n    this: LGraphNode,\n    e: MouseEvent,\n    pos: Point,\n    arg2: LGraphCanvas,\n  ): void\n  onPropertyChange?(this: LGraphNode): void\n  updateOutputData?(this: LGraphNode, origin_slot: number): void\n\n  #getErrorStrokeStyle(this: LGraphNode): IDrawBoundingOptions | undefined {\n    if (this.has_errors) {\n      return {\n        padding: 12,\n        lineWidth: 10,\n        color: LiteGraph.NODE_ERROR_COLOUR,\n      }\n    }\n  }\n\n  #getSelectedStrokeStyle(this: LGraphNode): IDrawBoundingOptions | undefined {\n    if (this.selected) {\n      return {\n        padding: this.has_errors ? 20 : undefined,\n      }\n    }\n  }\n\n  constructor(title: string, type?: string) {\n    this.id = LiteGraph.use_uuids ? LiteGraph.uuidv4() : -1\n    this.title = title || \"Unnamed\"\n    this.type = type ?? \"\"\n    this.size = [LiteGraph.NODE_WIDTH, 60]\n    this.pos = [10, 10]\n    this.strokeStyles = {\n      error: this.#getErrorStrokeStyle,\n      selected: this.#getSelectedStrokeStyle,\n    }\n  }\n\n  /**\n   * configure a node from an object containing the serialized info\n   */\n  configure(info: ISerialisedNode): void {\n    if (this.graph) {\n      this.graph._version++\n    }\n    for (const j in info) {\n      if (j == \"properties\") {\n        // i don't want to clone properties, I want to reuse the old container\n        for (const k in info.properties) {\n          this.properties[k] = info.properties[k]\n          this.onPropertyChanged?.(k, info.properties[k])\n        }\n        continue\n      }\n\n      // @ts-expect-error #594\n      if (info[j] == null) {\n        continue\n      // @ts-expect-error #594\n      } else if (typeof info[j] == \"object\") {\n        // @ts-expect-error #594\n        if (this[j]?.configure) {\n          // @ts-expect-error #594\n          this[j]?.configure(info[j])\n        } else {\n          // @ts-expect-error #594\n          this[j] = LiteGraph.cloneObject(info[j], this[j])\n        }\n      } else {\n        // value\n        // @ts-expect-error #594\n        this[j] = info[j]\n      }\n    }\n\n    if (!info.title) {\n      this.title = this.constructor.title\n    }\n\n    this.inputs ??= []\n    this.inputs = this.inputs.map(input => toClass(NodeInputSlot, input, this))\n    for (const [i, input] of this.inputs.entries()) {\n      const link = this.graph && input.link != null\n        ? this.graph._links.get(input.link)\n        : null\n      this.onConnectionsChange?.(NodeSlotType.INPUT, i, true, link, input)\n      this.onInputAdded?.(input)\n    }\n\n    this.outputs ??= []\n    this.outputs = this.outputs.map(output => toClass(NodeOutputSlot, output, this))\n    for (const [i, output] of this.outputs.entries()) {\n      if (!output.links) continue\n\n      for (const linkId of output.links) {\n        const link = this.graph\n          ? this.graph._links.get(linkId)\n          : null\n        this.onConnectionsChange?.(NodeSlotType.OUTPUT, i, true, link, output)\n      }\n      this.onOutputAdded?.(output)\n    }\n\n    if (this.widgets) {\n      for (const w of this.widgets) {\n        if (!w) continue\n\n        if (w.options?.property && this.properties[w.options.property] != undefined)\n          w.value = JSON.parse(JSON.stringify(this.properties[w.options.property]))\n      }\n\n      if (info.widgets_values) {\n        const widgetsWithValue = this.widgets.filter(w => w.serialize !== false)\n        for (let i = 0; i < info.widgets_values.length; ++i) {\n          const widget = widgetsWithValue[i]\n          if (widget) {\n            widget.value = info.widgets_values[i]\n          }\n        }\n      }\n    }\n\n    // Sync the state of this.resizable.\n    if (this.pinned) this.resizable = false\n\n    this.onConfigure?.(info)\n  }\n\n  /**\n   * serialize the content\n   */\n  serialize(): ISerialisedNode {\n    // create serialization object\n    const o: ISerialisedNode = {\n      id: this.id,\n      type: this.type,\n      pos: [this.pos[0], this.pos[1]],\n      size: [this.size[0], this.size[1]],\n      flags: LiteGraph.cloneObject(this.flags),\n      order: this.order,\n      mode: this.mode,\n      showAdvanced: this.showAdvanced,\n    }\n\n    // special case for when there were errors\n    if (this.constructor === LGraphNode && this.last_serialization)\n      return this.last_serialization\n\n    if (this.inputs) o.inputs = this.inputs.map(input => inputAsSerialisable(input))\n    if (this.outputs) o.outputs = this.outputs.map(output => outputAsSerialisable(output))\n\n    if (this.title && this.title != this.constructor.title) o.title = this.title\n\n    if (this.properties) o.properties = LiteGraph.cloneObject(this.properties)\n\n    const { widgets } = this\n    if (widgets && this.serialize_widgets) {\n      o.widgets_values = []\n      for (const [i, widget] of widgets.entries()) {\n        if (widget.serialize === false) continue\n        // @ts-expect-error #595 No-null\n        o.widgets_values[i] = widget ? widget.value : null\n      }\n    }\n\n    if (!o.type) o.type = this.constructor.type\n\n    if (this.color) o.color = this.color\n    if (this.bgcolor) o.bgcolor = this.bgcolor\n    if (this.boxcolor) o.boxcolor = this.boxcolor\n    if (this.shape) o.shape = this.shape\n\n    if (this.onSerialize?.(o)) console.warn(\"node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter\")\n\n    return o\n  }\n\n  /* Creates a clone of this node */\n  clone(): LGraphNode | null {\n    if (this.type == null) return null\n    const node = LiteGraph.createNode(this.type)\n    if (!node) return null\n\n    // we clone it because serialize returns shared containers\n    const data = LiteGraph.cloneObject(this.serialize())\n    const { inputs, outputs } = data\n\n    // remove links\n    if (inputs) {\n      for (const input of inputs) {\n        input.link = null\n      }\n    }\n\n    if (outputs) {\n      for (const { links } of outputs) {\n        if (links) links.length = 0\n      }\n    }\n\n    // @ts-expect-error Exceptional case: id is removed so that the graph can assign a new one on add.\n    delete data.id\n\n    if (LiteGraph.use_uuids) data.id = LiteGraph.uuidv4()\n\n    node.configure(data)\n\n    return node\n  }\n\n  /**\n   * serialize and stringify\n   */\n  toString(): string {\n    return JSON.stringify(this.serialize())\n  }\n\n  /**\n   * get the title string\n   */\n  getTitle(): string {\n    return this.title || this.constructor.title\n  }\n\n  /**\n   * sets the value of a property\n   * @param name\n   * @param value\n   */\n  setProperty(name: string, value: TWidgetValue): void {\n    this.properties ||= {}\n    if (value === this.properties[name]) return\n\n    const prev_value = this.properties[name]\n    this.properties[name] = value\n    // abort change\n    if (this.onPropertyChanged?.(name, value, prev_value) === false)\n      this.properties[name] = prev_value\n\n    if (this.widgets) {\n      for (const w of this.widgets) {\n        if (!w) continue\n\n        if (w.options.property == name) {\n          w.value = value\n          break\n        }\n      }\n    }\n  }\n\n  /**\n   * sets the output data\n   * @param slot\n   * @param data\n   */\n  setOutputData(slot: number, data: number | string | boolean | { toToolTip?(): string }): void {\n    const { outputs } = this\n    if (!outputs) return\n\n    // this maybe slow and a niche case\n    if (slot == -1 || slot >= outputs.length) return\n\n    const output_info = outputs[slot]\n    if (!output_info) return\n\n    // store data in the output itself in case we want to debug\n    output_info._data = data\n\n    if (!this.graph) throw new NullGraphError()\n\n    // if there are connections, pass the data to the connections\n    const { links } = outputs[slot]\n    if (links) {\n      for (const id of links) {\n        const link = this.graph._links.get(id)\n        if (link) link.data = data\n      }\n    }\n  }\n\n  /**\n   * sets the output data type, useful when you want to be able to overwrite the data type\n   */\n  setOutputDataType(slot: number, type: ISlotType): void {\n    const { outputs } = this\n    if (!outputs || (slot == -1 || slot >= outputs.length)) return\n\n    const output_info = outputs[slot]\n    if (!output_info) return\n    // store data in the output itself in case we want to debug\n    output_info.type = type\n\n    if (!this.graph) throw new NullGraphError()\n\n    // if there are connections, pass the data to the connections\n    const { links } = outputs[slot]\n    if (links) {\n      for (const id of links) {\n        const link = this.graph._links.get(id)\n        if (link) link.type = type\n      }\n    }\n  }\n\n  /**\n   * Retrieves the input data (data traveling through the connection) from one slot\n   * @param slot\n   * @param force_update if set to true it will force the connected node of this slot to output data into this link\n   * @returns data or if it is not connected returns undefined\n   */\n  getInputData(slot: number, force_update?: boolean): unknown {\n    if (!this.inputs) return\n\n    if (slot >= this.inputs.length || this.inputs[slot].link == null) return\n    if (!this.graph) throw new NullGraphError()\n\n    const link_id = this.inputs[slot].link\n    const link = this.graph._links.get(link_id)\n    // bug: weird case but it happens sometimes\n    if (!link) return null\n\n    if (!force_update) return link.data\n\n    // special case: used to extract data from the incoming connection before the graph has been executed\n    const node = this.graph.getNodeById(link.origin_id)\n    if (!node) return link.data\n\n    if (node.updateOutputData) {\n      node.updateOutputData(link.origin_slot)\n    } else {\n      node.onExecute?.()\n    }\n\n    return link.data\n  }\n\n  /**\n   * Retrieves the input data type (in case this supports multiple input types)\n   * @param slot\n   * @returns datatype in string format\n   */\n  getInputDataType(slot: number): ISlotType | null {\n    if (!this.inputs) return null\n    if (slot >= this.inputs.length || this.inputs[slot].link == null) return null\n    if (!this.graph) throw new NullGraphError()\n\n    const link_id = this.inputs[slot].link\n    const link = this.graph._links.get(link_id)\n    // bug: weird case but it happens sometimes\n    if (!link) return null\n\n    const node = this.graph.getNodeById(link.origin_id)\n    if (!node) return link.type\n\n    const output_info = node.outputs[link.origin_slot]\n    return output_info\n      ? output_info.type\n      : null\n  }\n\n  /**\n   * Retrieves the input data from one slot using its name instead of slot number\n   * @param slot_name\n   * @param force_update if set to true it will force the connected node of this slot to output data into this link\n   * @returns data or if it is not connected returns null\n   */\n  getInputDataByName(slot_name: string, force_update: boolean): unknown {\n    const slot = this.findInputSlot(slot_name)\n    return slot == -1\n      ? null\n      : this.getInputData(slot, force_update)\n  }\n\n  /**\n   * tells you if there is a connection in one input slot\n   * @param slot The 0-based index of the input to check\n   * @returns `true` if the input slot has a link ID (does not perform validation)\n   */\n  isInputConnected(slot: number): boolean {\n    if (!this.inputs) return false\n    return slot < this.inputs.length && this.inputs[slot].link != null\n  }\n\n  /**\n   * tells you info about an input connection (which node, type, etc)\n   * @returns object or null { link: id, name: string, type: string or 0 }\n   */\n  getInputInfo(slot: number): INodeInputSlot | null {\n    return !this.inputs || !(slot < this.inputs.length)\n      ? null\n      : this.inputs[slot]\n  }\n\n  /**\n   * Returns the link info in the connection of an input slot\n   * @returns object or null\n   */\n  getInputLink(slot: number): LLink | null {\n    if (!this.inputs) return null\n\n    if (slot < this.inputs.length) {\n      if (!this.graph) throw new NullGraphError()\n\n      const input = this.inputs[slot]\n      if (input.link != null) {\n        return this.graph._links.get(input.link) ?? null\n      }\n    }\n    return null\n  }\n\n  /**\n   * returns the node connected in the input slot\n   * @returns node or null\n   */\n  getInputNode(slot: number): LGraphNode | null {\n    if (!this.inputs) return null\n    if (slot >= this.inputs.length) return null\n\n    const input = this.inputs[slot]\n    if (!input || input.link === null) return null\n    if (!this.graph) throw new NullGraphError()\n\n    const link_info = this.graph._links.get(input.link)\n    if (!link_info) return null\n\n    return this.graph.getNodeById(link_info.origin_id)\n  }\n\n  /**\n   * returns the value of an input with this name, otherwise checks if there is a property with that name\n   * @returns value\n   */\n  getInputOrProperty(name: string): unknown {\n    const { inputs } = this\n    if (!inputs?.length) {\n      return this.properties ? this.properties[name] : null\n    }\n    if (!this.graph) throw new NullGraphError()\n\n    for (const input of inputs) {\n      if (name == input.name && input.link != null) {\n        const link = this.graph._links.get(input.link)\n        if (link) return link.data\n      }\n    }\n    return this.properties[name]\n  }\n\n  /**\n   * tells you the last output data that went in that slot\n   * @returns object or null\n   */\n  getOutputData(slot: number): unknown {\n    if (!this.outputs) return null\n    if (slot >= this.outputs.length) return null\n\n    const info = this.outputs[slot]\n    return info._data\n  }\n\n  /**\n   * tells you info about an output connection (which node, type, etc)\n   * @returns object or null { name: string, type: string, links: [ ids of links in number ] }\n   */\n  getOutputInfo(slot: number): INodeOutputSlot | null {\n    return !this.outputs || !(slot < this.outputs.length)\n      ? null\n      : this.outputs[slot]\n  }\n\n  /**\n   * tells you if there is a connection in one output slot\n   */\n  isOutputConnected(slot: number): boolean {\n    if (!this.outputs) return false\n    return slot < this.outputs.length && Number(this.outputs[slot].links?.length) > 0\n  }\n\n  /**\n   * tells you if there is any connection in the output slots\n   */\n  isAnyOutputConnected(): boolean {\n    const { outputs } = this\n    if (!outputs) return false\n\n    for (const output of outputs) {\n      if (output.links?.length) return true\n    }\n    return false\n  }\n\n  /**\n   * retrieves all the nodes connected to this output slot\n   */\n  getOutputNodes(slot: number): LGraphNode[] | null {\n    const { outputs } = this\n    if (!outputs || outputs.length == 0) return null\n\n    if (slot >= outputs.length) return null\n\n    const { links } = outputs[slot]\n    if (!links || links.length == 0) return null\n    if (!this.graph) throw new NullGraphError()\n\n    const r: LGraphNode[] = []\n    for (const id of links) {\n      const link = this.graph._links.get(id)\n      if (link) {\n        const target_node = this.graph.getNodeById(link.target_id)\n        if (target_node) {\n          r.push(target_node)\n        }\n      }\n    }\n    return r\n  }\n\n  addOnTriggerInput(): number {\n    const trigS = this.findInputSlot(\"onTrigger\")\n    if (trigS == -1) {\n      this.addInput(\"onTrigger\", LiteGraph.EVENT, {\n        nameLocked: true,\n      })\n      return this.findInputSlot(\"onTrigger\")\n    }\n    return trigS\n  }\n\n  addOnExecutedOutput(): number {\n    const trigS = this.findOutputSlot(\"onExecuted\")\n    if (trigS == -1) {\n      this.addOutput(\"onExecuted\", LiteGraph.ACTION, {\n        nameLocked: true,\n      })\n      return this.findOutputSlot(\"onExecuted\")\n    }\n    return trigS\n  }\n\n  onAfterExecuteNode(param: unknown, options?: { action_call?: any }) {\n    const trigS = this.findOutputSlot(\"onExecuted\")\n    if (trigS != -1) {\n      this.triggerSlot(trigS, param, null, options)\n    }\n  }\n\n  changeMode(modeTo: number): boolean {\n    switch (modeTo) {\n    case LGraphEventMode.ON_EVENT:\n      break\n\n    case LGraphEventMode.ON_TRIGGER:\n      this.addOnTriggerInput()\n      this.addOnExecutedOutput()\n      break\n\n    case LGraphEventMode.NEVER:\n      break\n\n    case LGraphEventMode.ALWAYS:\n      break\n\n      // @ts-expect-error Not impl.\n    case LiteGraph.ON_REQUEST:\n      break\n\n    default:\n      return false\n      break\n    }\n    this.mode = modeTo\n    return true\n  }\n\n  /**\n   * Triggers the node code execution, place a boolean/counter to mark the node as being executed\n   */\n  doExecute(param?: unknown, options?: { action_call?: any }): void {\n    options = options || {}\n    if (this.onExecute) {\n      // enable this to give the event an ID\n      options.action_call ||= `${this.id}_exec_${Math.floor(Math.random() * 9999)}`\n      if (!this.graph) throw new NullGraphError()\n\n      // @ts-expect-error Technically it works when id is a string. Array gets props.\n      this.graph.nodes_executing[this.id] = true\n      this.onExecute(param, options)\n      // @ts-expect-error deprecated\n      this.graph.nodes_executing[this.id] = false\n\n      // save execution/action ref\n      this.exec_version = this.graph.iteration\n      if (options?.action_call) {\n        this.action_call = options.action_call\n        // @ts-expect-error deprecated\n        this.graph.nodes_executedAction[this.id] = options.action_call\n      }\n    }\n    // the nFrames it will be used (-- each step), means \"how old\" is the event\n    this.execute_triggered = 2\n    this.onAfterExecuteNode?.(param, options)\n  }\n\n  /**\n   * Triggers an action, wrapped by logics to control execution flow\n   * @param action name\n   */\n  actionDo(\n    action: string,\n    param: unknown,\n    options: { action_call?: string },\n  ): void {\n    options = options || {}\n    if (this.onAction) {\n      // enable this to give the event an ID\n      options.action_call ||= `${this.id}_${action || \"action\"}_${Math.floor(Math.random() * 9999)}`\n      if (!this.graph) throw new NullGraphError()\n\n      // @ts-expect-error deprecated\n      this.graph.nodes_actioning[this.id] = action || \"actioning\"\n      this.onAction(action, param, options)\n      // @ts-expect-error deprecated\n      this.graph.nodes_actioning[this.id] = false\n\n      // save execution/action ref\n      if (options?.action_call) {\n        this.action_call = options.action_call\n        // @ts-expect-error deprecated\n        this.graph.nodes_executedAction[this.id] = options.action_call\n      }\n    }\n    // the nFrames it will be used (-- each step), means \"how old\" is the event\n    this.action_triggered = 2\n    this.onAfterExecuteNode?.(param, options)\n  }\n\n  /**\n   * Triggers an event in this node, this will trigger any output with the same name\n   * @param action name ( \"on_play\", ... ) if action is equivalent to false then the event is send to all\n   */\n  trigger(\n    action: string,\n    param: unknown,\n    options: { action_call?: any },\n  ): void {\n    const { outputs } = this\n    if (!outputs || !outputs.length) {\n      return\n    }\n\n    if (this.graph) this.graph._last_trigger_time = LiteGraph.getTime()\n\n    for (const [i, output] of outputs.entries()) {\n      if (\n        !output ||\n        output.type !== LiteGraph.EVENT ||\n        (action && output.name != action)\n      ) {\n        continue\n      }\n      this.triggerSlot(i, param, null, options)\n    }\n  }\n\n  /**\n   * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes\n   * @param slot the index of the output slot\n   * @param link_id [optional] in case you want to trigger and specific output link in a slot\n   */\n  triggerSlot(\n    slot: number,\n    param: unknown,\n    link_id: number | null,\n    options?: { action_call?: any },\n  ): void {\n    options = options || {}\n    if (!this.outputs) return\n\n    if (slot == null) {\n      console.error(\"slot must be a number\")\n      return\n    }\n\n    if (typeof slot !== \"number\")\n      console.warn(\"slot must be a number, use node.trigger('name') if you want to use a string\")\n\n    const output = this.outputs[slot]\n    if (!output) return\n\n    const links = output.links\n    if (!links || !links.length) return\n\n    if (!this.graph) throw new NullGraphError()\n    this.graph._last_trigger_time = LiteGraph.getTime()\n\n    // for every link attached here\n    for (const id of links) {\n      // to skip links\n      if (link_id != null && link_id != id) continue\n\n      const link_info = this.graph._links.get(id)\n      // not connected\n      if (!link_info) continue\n\n      link_info._last_time = LiteGraph.getTime()\n      const node = this.graph.getNodeById(link_info.target_id)\n      // node not found?\n      if (!node) continue\n\n      if (node.mode === LGraphEventMode.ON_TRIGGER) {\n        // generate unique trigger ID if not present\n        if (!options.action_call)\n          options.action_call = `${this.id}_trigg_${Math.floor(Math.random() * 9999)}`\n        // -- wrapping node.onExecute(param); --\n        node.doExecute?.(param, options)\n      } else if (node.onAction) {\n        // generate unique action ID if not present\n        if (!options.action_call)\n          options.action_call = `${this.id}_act_${Math.floor(Math.random() * 9999)}`\n        // pass the action name\n        const target_connection = node.inputs[link_info.target_slot]\n        node.actionDo(target_connection.name, param, options)\n      }\n    }\n  }\n\n  /**\n   * clears the trigger slot animation\n   * @param slot the index of the output slot\n   * @param link_id [optional] in case you want to trigger and specific output link in a slot\n   */\n  clearTriggeredSlot(slot: number, link_id: number): void {\n    if (!this.outputs) return\n\n    const output = this.outputs[slot]\n    if (!output) return\n\n    const links = output.links\n    if (!links || !links.length) return\n\n    if (!this.graph) throw new NullGraphError()\n\n    // for every link attached here\n    for (const id of links) {\n      // to skip links\n      if (link_id != null && link_id != id) continue\n\n      const link_info = this.graph._links.get(id)\n      // not connected\n      if (!link_info) continue\n\n      link_info._last_time = 0\n    }\n  }\n\n  /**\n   * changes node size and triggers callback\n   */\n  setSize(size: Size): void {\n    this.size = size\n    this.onResize?.(this.size)\n  }\n\n  /**\n   * Expands the node size to fit its content.\n   */\n  expandToFitContent(): void {\n    const newSize = this.computeSize()\n    this.setSize([\n      Math.max(this.size[0], newSize[0]),\n      Math.max(this.size[1], newSize[1]),\n    ])\n  }\n\n  /**\n   * add a new property to this node\n   * @param type string defining the output type (\"vec3\",\"number\",...)\n   * @param extra_info this can be used to have special properties of the property (like values, etc)\n   */\n  addProperty(\n    name: string,\n    default_value: NodeProperty | undefined,\n    type?: string,\n    extra_info?: Partial<INodePropertyInfo>,\n  ): INodePropertyInfo {\n    const o: INodePropertyInfo = { name, type, default_value }\n    if (extra_info) Object.assign(o, extra_info)\n\n    this.properties_info ||= []\n    this.properties_info.push(o)\n    this.properties ||= {}\n    this.properties[name] = default_value\n    return o\n  }\n\n  /**\n   * add a new output slot to use in this node\n   * @param type string defining the output type (\"vec3\",\"number\",...)\n   * @param extra_info this can be used to have special properties of an output (label, special color, position, etc)\n   */\n  addOutput<TProperties extends Partial<INodeOutputSlot>>(\n    name: string,\n    type: ISlotType,\n    extra_info?: TProperties,\n  ): INodeOutputSlot & TProperties {\n    const output = Object.assign(\n      new NodeOutputSlot({ name, type, links: null }, this),\n      extra_info,\n    )\n\n    this.outputs ||= []\n    this.outputs.push(output)\n    this.onOutputAdded?.(output)\n\n    if (LiteGraph.auto_load_slot_types)\n      LiteGraph.registerNodeAndSlotType(this, type, true)\n\n    this.expandToFitContent()\n    this.setDirtyCanvas(true, true)\n    return output\n  }\n\n  /**\n   * remove an existing output slot\n   */\n  removeOutput(slot: number): void {\n    this.disconnectOutput(slot)\n    const { outputs } = this\n    outputs.splice(slot, 1)\n\n    for (let i = slot; i < outputs.length; ++i) {\n      const output = outputs[i]\n      if (!output || !output.links) continue\n\n      for (const linkId of output.links) {\n        if (!this.graph) throw new NullGraphError()\n\n        const link = this.graph._links.get(linkId)\n        if (link) link.origin_slot--\n      }\n    }\n\n    this.onOutputRemoved?.(slot)\n    this.setDirtyCanvas(true, true)\n  }\n\n  /**\n   * add a new input slot to use in this node\n   * @param type string defining the input type (\"vec3\",\"number\",...), it its a generic one use 0\n   * @param extra_info this can be used to have special properties of an input (label, color, position, etc)\n   */\n  addInput<TProperties extends Partial<INodeInputSlot>>(name: string, type: ISlotType, extra_info?: TProperties): INodeInputSlot & TProperties {\n    type ||= 0\n\n    const input = Object.assign(\n      new NodeInputSlot({ name, type, link: null }, this),\n      extra_info,\n    )\n\n    this.inputs ||= []\n    this.inputs.push(input)\n    this.expandToFitContent()\n\n    this.onInputAdded?.(input)\n    LiteGraph.registerNodeAndSlotType(this, type)\n\n    this.setDirtyCanvas(true, true)\n    return input\n  }\n\n  /**\n   * remove an existing input slot\n   */\n  removeInput(slot: number): void {\n    this.disconnectInput(slot, true)\n    const { inputs } = this\n    const slot_info = inputs.splice(slot, 1)\n\n    for (let i = slot; i < inputs.length; ++i) {\n      const input = inputs[i]\n      if (!input?.link) continue\n\n      if (!this.graph) throw new NullGraphError()\n      const link = this.graph._links.get(input.link)\n      if (link) link.target_slot--\n    }\n    this.onInputRemoved?.(slot, slot_info[0])\n    this.setDirtyCanvas(true, true)\n  }\n\n  /**\n   * computes the minimum size of a node according to its inputs and output slots\n   * @returns the total size\n   */\n  computeSize(out?: Size): Size {\n    const ctorSize = this.constructor.size\n    if (ctorSize) return [ctorSize[0], ctorSize[1]]\n\n    const { inputs, outputs, widgets } = this\n    let rows = Math.max(\n      inputs ? inputs.filter(input => !isWidgetInputSlot(input)).length : 1,\n      outputs ? outputs.length : 1,\n    )\n    const size = out || new Float32Array([0, 0])\n    rows = Math.max(rows, 1)\n    // although it should be graphcanvas.inner_text_font size\n    const font_size = LiteGraph.NODE_TEXT_SIZE\n\n    const padLeft = LiteGraph.NODE_TITLE_HEIGHT\n    const padRight = padLeft * 0.33\n    const title_width = padLeft + compute_text_size(this.title, this.titleFontStyle) + padRight\n    let input_width = 0\n    let widgetWidth = 0\n    let output_width = 0\n\n    if (inputs) {\n      for (const input of inputs) {\n        const text = input.label || input.localized_name || input.name || \"\"\n        const text_width = compute_text_size(text, this.innerFontStyle)\n        if (isWidgetInputSlot(input)) {\n          const widget = this.getWidgetFromSlot(input)\n          if (widget && !this.isWidgetVisible(widget)) continue\n\n          if (text_width > widgetWidth) widgetWidth = text_width\n        } else {\n          if (text_width > input_width) input_width = text_width\n        }\n      }\n    }\n\n    if (outputs) {\n      for (const output of outputs) {\n        const text = output.label || output.localized_name || output.name || \"\"\n        const text_width = compute_text_size(text, this.innerFontStyle)\n        if (output_width < text_width)\n          output_width = text_width\n      }\n    }\n\n    const minWidth = LiteGraph.NODE_WIDTH * (widgets?.length ? 1.5 : 1)\n    // Text + slot width + centre padding\n    const centrePadding = input_width && output_width ? 5 : 0\n    const slotsWidth = input_width + output_width + (2 * LiteGraph.NODE_SLOT_HEIGHT) + centrePadding\n\n    // Total distance from edge of node to the inner edge of the widget 'previous' arrow button\n    const widgetMargin = BaseWidget.margin + BaseWidget.arrowMargin + BaseWidget.arrowWidth\n    const widgetPadding = BaseWidget.minValueWidth + (2 * widgetMargin)\n    if (widgetWidth) widgetWidth += widgetPadding\n\n    size[0] = Math.max(slotsWidth, widgetWidth, title_width, minWidth)\n    size[1] = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT\n\n    // Get widget height & expand size if necessary\n    let widgets_height = 0\n    if (widgets?.length) {\n      for (const widget of widgets) {\n        if (!this.isWidgetVisible(widget)) continue\n\n        let widget_height = 0\n        if (widget.computeSize) {\n          widget_height += widget.computeSize(size[0])[1]\n        } else if (widget.computeLayoutSize) {\n          // Expand widget width if necessary\n          const { minHeight, minWidth } = widget.computeLayoutSize(this)\n          const widgetWidth = minWidth + widgetPadding\n          if (widgetWidth > size[0]) size[0] = widgetWidth\n\n          widget_height += minHeight\n        } else {\n          widget_height += LiteGraph.NODE_WIDGET_HEIGHT\n        }\n        widgets_height += widget_height + 4\n      }\n      widgets_height += 8\n    }\n\n    // compute height using widgets height\n    if (this.widgets_up)\n      size[1] = Math.max(size[1], widgets_height)\n    else if (this.widgets_start_y != null)\n      size[1] = Math.max(size[1], widgets_height + this.widgets_start_y)\n    else\n      size[1] += widgets_height\n\n    function compute_text_size(text: string, fontStyle: string) {\n      return LGraphCanvas._measureText?.(text, fontStyle) ??\n        font_size * (text?.length ?? 0) * 0.6\n    }\n\n    if (this.constructor.min_height && size[1] < this.constructor.min_height) {\n      size[1] = this.constructor.min_height\n    }\n\n    // margin\n    size[1] += 6\n\n    return size\n  }\n\n  inResizeCorner(canvasX: number, canvasY: number): boolean {\n    const rows = this.outputs ? this.outputs.length : 1\n    const outputs_offset = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT\n    return isInRectangle(\n      canvasX,\n      canvasY,\n      this.pos[0] + this.size[0] - 15,\n      this.pos[1] + Math.max(this.size[1] - 15, outputs_offset),\n      20,\n      20,\n    )\n  }\n\n  /**\n   * returns all the info available about a property of this node.\n   * @param property name of the property\n   * @returns the object with all the available info\n   */\n  getPropertyInfo(property: string) {\n    let info = null\n\n    // there are several ways to define info about a property\n    // legacy mode\n    const { properties_info } = this\n    if (properties_info) {\n      for (const propInfo of properties_info) {\n        if (propInfo.name == property) {\n          info = propInfo\n          break\n        }\n      }\n    }\n    // litescene mode using the constructor\n    // @ts-expect-error deprecated https://github.com/Comfy-Org/litegraph.js/issues/639\n    if (this.constructor[`@${property}`]) info = this.constructor[`@${property}`]\n\n    if (this.constructor.widgets_info?.[property])\n      info = this.constructor.widgets_info[property]\n\n    // litescene mode using the constructor\n    if (!info && this.onGetPropertyInfo) {\n      info = this.onGetPropertyInfo(property)\n    }\n\n    info ||= {}\n    info.type ||= typeof this.properties[property]\n    if (info.widget == \"combo\") info.type = \"enum\"\n\n    return info\n  }\n\n  /**\n   * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties\n   * @param type the widget type\n   * @param name the text to show on the widget\n   * @param value the default value\n   * @param callback function to call when it changes (optionally, it can be the name of the property to modify)\n   * @param options the object that contains special properties of this widget\n   * @returns the created widget object\n   */\n  addWidget<Type extends TWidgetType, TValue extends WidgetTypeMap[Type][\"value\"]>(\n    type: Type,\n    name: string,\n    value: TValue,\n    callback: IBaseWidget[\"callback\"] | string | null,\n    options?: IWidgetOptions | string,\n  ): WidgetTypeMap[Type] | IBaseWidget {\n    this.widgets ||= []\n\n    if (!options && callback && typeof callback === \"object\") {\n      options = callback\n      callback = null\n    }\n\n    // options can be the property name\n    options ||= {}\n    if (typeof options === \"string\")\n      options = { property: options }\n\n    // callback can be the property name\n    if (callback && typeof callback === \"string\") {\n      options.property = callback\n      callback = null\n    }\n\n    const w: IBaseWidget & { type: Type } = {\n      // @ts-expect-error\n      type: type.toLowerCase(),\n      name: name,\n      value: value,\n      callback: typeof callback !== \"function\" ? undefined : callback,\n      options,\n      y: 0,\n    }\n\n    if (w.options.y !== undefined) {\n      w.y = w.options.y\n    }\n\n    if (!callback && !w.options.callback && !w.options.property) {\n      console.warn(\"LiteGraph addWidget(...) without a callback or property assigned\")\n    }\n    if (type == \"combo\" && !w.options.values) {\n      throw \"LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }\"\n    }\n\n    const widget = this.addCustomWidget(w)\n    this.expandToFitContent()\n    return widget\n  }\n\n  addCustomWidget<TPlainWidget extends IBaseWidget>(\n    custom_widget: TPlainWidget,\n  ): TPlainWidget | WidgetTypeMap[TPlainWidget[\"type\"]] {\n    this.widgets ||= []\n    const widget = toConcreteWidget(custom_widget, this, false) ?? custom_widget\n    this.widgets.push(widget)\n    return widget\n  }\n\n  move(deltaX: number, deltaY: number): void {\n    if (this.pinned) return\n\n    this.pos[0] += deltaX\n    this.pos[1] += deltaY\n  }\n\n  /**\n   * Internal method to measure the node for rendering.  Prefer {@link boundingRect} where possible.\n   *\n   * Populates {@link out} with the results in graph space.\n   * Populates {@link _collapsed_width} with the collapsed width if the node is collapsed.\n   * Adjusts for title and collapsed status, but does not call {@link onBounding}.\n   * @param out `x, y, width, height` are written to this array.\n   * @param ctx The canvas context to use for measuring text.\n   */\n  measure(out: Rect, ctx: CanvasRenderingContext2D): void {\n    const titleMode = this.title_mode\n    const renderTitle =\n      titleMode != TitleMode.TRANSPARENT_TITLE &&\n      titleMode != TitleMode.NO_TITLE\n    const titleHeight = renderTitle ? LiteGraph.NODE_TITLE_HEIGHT : 0\n\n    out[0] = this.pos[0]\n    out[1] = this.pos[1] + -titleHeight\n    if (!this.flags?.collapsed) {\n      out[2] = this.size[0]\n      out[3] = this.size[1] + titleHeight\n    } else {\n      ctx.font = this.innerFontStyle\n      this._collapsed_width = Math.min(\n        this.size[0],\n        ctx.measureText(this.getTitle() ?? \"\").width + LiteGraph.NODE_TITLE_HEIGHT * 2,\n      )\n      out[2] = (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH)\n      out[3] = LiteGraph.NODE_TITLE_HEIGHT\n    }\n  }\n\n  /**\n   * returns the bounding of the object, used for rendering purposes\n   * @param out {Float32Array[4]?} [optional] a place to store the output, to free garbage\n   * @param includeExternal {boolean?} [optional] set to true to\n   * include the shadow and connection points in the bounding calculation\n   * @returns the bounding box in format of [topleft_cornerx, topleft_cornery, width, height]\n   */\n  getBounding(out?: Rect, includeExternal?: boolean): Rect {\n    out ||= new Float32Array(4)\n\n    const rect = includeExternal ? this.renderArea : this.boundingRect\n    out[0] = rect[0]\n    out[1] = rect[1]\n    out[2] = rect[2]\n    out[3] = rect[3]\n\n    return out\n  }\n\n  /**\n   * Calculates the render area of this node, populating both {@link boundingRect} and {@link renderArea}.\n   * Called automatically at the start of every frame.\n   */\n  updateArea(ctx: CanvasRenderingContext2D): void {\n    const bounds = this.#boundingRect\n    this.measure(bounds, ctx)\n    this.onBounding?.(bounds)\n\n    const renderArea = this.#renderArea\n    renderArea.set(bounds)\n    // 4 offset for collapsed node connection points\n    renderArea[0] -= 4\n    renderArea[1] -= 4\n    // Add shadow & left offset\n    renderArea[2] += 6 + 4\n    // Add shadow & top offsets\n    renderArea[3] += 5 + 4\n  }\n\n  /**\n   * checks if a point is inside the shape of a node\n   */\n  isPointInside(x: number, y: number): boolean {\n    return isInRect(x, y, this.boundingRect)\n  }\n\n  /**\n   * Checks if the provided point is inside this node's collapse button area.\n   * @param x X co-ordinate to check\n   * @param y Y co-ordinate to check\n   * @returns true if the x,y point is in the collapse button area, otherwise false\n   */\n  isPointInCollapse(x: number, y: number): boolean {\n    const squareLength = LiteGraph.NODE_TITLE_HEIGHT\n    return isInRectangle(\n      x,\n      y,\n      this.pos[0],\n      this.pos[1] - squareLength,\n      squareLength,\n      squareLength,\n    )\n  }\n\n  /**\n   * Returns the input slot at the given position. Uses full 20 height, and approximates the label length.\n   * @param pos The graph co-ordinates to check\n   * @returns The input slot at the given position if found, otherwise `undefined`.\n   */\n  getInputOnPos(pos: Point): INodeInputSlot | undefined {\n    return getNodeInputOnPos(this, pos[0], pos[1])?.input\n  }\n\n  /**\n   * Returns the output slot at the given position. Uses full 20x20 box for the slot.\n   * @param pos The graph co-ordinates to check\n   * @returns The output slot at the given position if found, otherwise `undefined`.\n   */\n  getOutputOnPos(pos: Point): INodeOutputSlot | undefined {\n    return getNodeOutputOnPos(this, pos[0], pos[1])?.output\n  }\n\n  /**\n   * Returns the input or output slot at the given position.\n   *\n   * Tries {@link getNodeInputOnPos} first, then {@link getNodeOutputOnPos}.\n   * @param pos The graph co-ordinates to check\n   * @returns The input or output slot at the given position if found, otherwise `undefined`.\n   */\n  getSlotOnPos(pos: Point): INodeInputSlot | INodeOutputSlot | undefined {\n    if (!isPointInRect(pos, this.boundingRect)) return\n\n    return this.getInputOnPos(pos) ?? this.getOutputOnPos(pos)\n  }\n\n  /**\n   * @deprecated Use {@link getSlotOnPos} instead.\n   * checks if a point is inside a node slot, and returns info about which slot\n   * @param x\n   * @param y\n   * @returns if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }\n   */\n  getSlotInPosition(x: number, y: number): IFoundSlot | null {\n    // search for inputs\n    const { inputs, outputs } = this\n\n    if (inputs) {\n      for (const [i, input] of inputs.entries()) {\n        const pos = this.getInputPos(i)\n        if (isInRectangle(x, y, pos[0] - 10, pos[1] - 10, 20, 20)) {\n          return { input, slot: i, link_pos: pos }\n        }\n      }\n    }\n\n    if (outputs) {\n      for (const [i, output] of outputs.entries()) {\n        const pos = this.getOutputPos(i)\n        if (isInRectangle(x, y, pos[0] - 10, pos[1] - 10, 20, 20)) {\n          return { output, slot: i, link_pos: pos }\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Gets the widget on this node at the given co-ordinates.\n   * @param canvasX X co-ordinate in graph space\n   * @param canvasY Y co-ordinate in graph space\n   * @returns The widget found, otherwise `null`\n   */\n  getWidgetOnPos(\n    canvasX: number,\n    canvasY: number,\n    includeDisabled = false,\n  ): IBaseWidget | undefined {\n    const { widgets, pos, size } = this\n    if (!widgets?.length) return\n\n    const x = canvasX - pos[0]\n    const y = canvasY - pos[1]\n    const nodeWidth = size[0]\n\n    for (const widget of widgets) {\n      if (\n        (widget.computedDisabled && !includeDisabled) ||\n        !this.isWidgetVisible(widget)\n      ) {\n        continue\n      }\n\n      const h = widget.computedHeight ??\n        widget.computeSize?.(nodeWidth)[1] ??\n        LiteGraph.NODE_WIDGET_HEIGHT\n\n      const w = widget.width || nodeWidth\n      if (\n        widget.last_y !== undefined &&\n        isInRectangle(x, y, 6, widget.last_y, w - 12, h)\n      ) {\n        return widget\n      }\n    }\n  }\n\n  /**\n   * Returns the input slot with a given name (used for dynamic slots), -1 if not found\n   * @param name the name of the slot to find\n   * @param returnObj if the obj itself wanted\n   * @returns the slot (-1 if not found)\n   */\n  findInputSlot<TReturn extends false>(name: string, returnObj?: TReturn): number\n  findInputSlot<TReturn extends true>(name: string, returnObj?: TReturn): INodeInputSlot\n  findInputSlot(name: string, returnObj: boolean = false) {\n    const { inputs } = this\n    if (!inputs) return -1\n\n    for (const [i, input] of inputs.entries()) {\n      if (name == input.name) {\n        return !returnObj ? i : input\n      }\n    }\n    return -1\n  }\n\n  /**\n   * returns the output slot with a given name (used for dynamic slots), -1 if not found\n   * @param name the name of the slot to find\n   * @param returnObj if the obj itself wanted\n   * @returns the slot (-1 if not found)\n   */\n  findOutputSlot<TReturn extends false>(name: string, returnObj?: TReturn): number\n  findOutputSlot<TReturn extends true>(name: string, returnObj?: TReturn): INodeOutputSlot\n  findOutputSlot(name: string, returnObj: boolean = false) {\n    const { outputs } = this\n    if (!outputs) return -1\n\n    for (const [i, output] of outputs.entries()) {\n      if (name == output.name) {\n        return !returnObj ? i : output\n      }\n    }\n    return -1\n  }\n\n  /**\n   * Finds the first free input slot.\n   * @param optsIn\n   * @returns The index of the first matching slot, the slot itself if returnObj is true, or -1 if not found.\n   */\n  findInputSlotFree<TReturn extends false>(\n    optsIn?: FindFreeSlotOptions & { returnObj?: TReturn },\n  ): number\n  findInputSlotFree<TReturn extends true>(\n    optsIn?: FindFreeSlotOptions & { returnObj?: TReturn },\n  ): INodeInputSlot | -1\n  findInputSlotFree(optsIn?: FindFreeSlotOptions) {\n    return this.#findFreeSlot(this.inputs, optsIn)\n  }\n\n  /**\n   * Finds the first free output slot.\n   * @param optsIn\n   * @returns The index of the first matching slot, the slot itself if returnObj is true, or -1 if not found.\n   */\n  findOutputSlotFree<TReturn extends false>(\n    optsIn?: FindFreeSlotOptions & { returnObj?: TReturn },\n  ): number\n  findOutputSlotFree<TReturn extends true>(\n    optsIn?: FindFreeSlotOptions & { returnObj?: TReturn },\n  ): INodeOutputSlot | -1\n  findOutputSlotFree(optsIn?: FindFreeSlotOptions) {\n    return this.#findFreeSlot(this.outputs, optsIn)\n  }\n\n  /**\n   * Finds the next free slot\n   * @param slots The slots to search, i.e. this.inputs or this.outputs\n   */\n  #findFreeSlot<TSlot extends INodeInputSlot | INodeOutputSlot>(\n    slots: TSlot[],\n    options?: FindFreeSlotOptions,\n  ): TSlot | number {\n    const defaults = {\n      returnObj: false,\n      typesNotAccepted: [],\n    }\n    const opts = Object.assign(defaults, options || {})\n    const length = slots?.length\n    if (!(length > 0)) return -1\n\n    for (let i = 0; i < length; ++i) {\n      const slot: TSlot & IGenericLinkOrLinks = slots[i]\n      if (!slot || slot.link || slot.links?.length) continue\n      if (opts.typesNotAccepted?.includes?.(slot.type)) continue\n      return !opts.returnObj ? i : slot\n    }\n    return -1\n  }\n\n  /**\n   * findSlotByType for INPUTS\n   */\n  findInputSlotByType<TReturn extends false>(\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): number\n  findInputSlotByType<TReturn extends true>(\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): INodeInputSlot\n  findInputSlotByType(\n    type: ISlotType,\n    returnObj?: boolean,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ) {\n    return this.#findSlotByType(\n      this.inputs,\n      type,\n      returnObj,\n      preferFreeSlot,\n      doNotUseOccupied,\n    )\n  }\n\n  /**\n   * findSlotByType for OUTPUTS\n   */\n  findOutputSlotByType<TReturn extends false>(\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): number\n  findOutputSlotByType<TReturn extends true>(\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): INodeOutputSlot\n  findOutputSlotByType(\n    type: ISlotType,\n    returnObj?: boolean,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ) {\n    return this.#findSlotByType(\n      this.outputs,\n      type,\n      returnObj,\n      preferFreeSlot,\n      doNotUseOccupied,\n    )\n  }\n\n  /**\n   * returns the output (or input) slot with a given type, -1 if not found\n   * @param input uise inputs instead of outputs\n   * @param type the type of the slot to find\n   * @param returnObj if the obj itself wanted\n   * @param preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)\n   * @returns the slot (-1 if not found)\n   */\n  findSlotByType<TSlot extends true | false, TReturn extends false>(\n    input: TSlot,\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): number\n  findSlotByType<TSlot extends true, TReturn extends true>(\n    input: TSlot,\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): INodeInputSlot | -1\n  findSlotByType<TSlot extends false, TReturn extends true>(\n    input: TSlot,\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): INodeOutputSlot | -1\n  findSlotByType(\n    input: boolean,\n    type: ISlotType,\n    returnObj?: boolean,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): number | INodeOutputSlot | INodeInputSlot {\n    return input\n      ? this.#findSlotByType(\n        this.inputs,\n        type,\n        returnObj,\n        preferFreeSlot,\n        doNotUseOccupied,\n      )\n      : this.#findSlotByType(\n        this.outputs,\n        type,\n        returnObj,\n        preferFreeSlot,\n        doNotUseOccupied,\n      )\n  }\n\n  /**\n   * Finds a matching slot from those provided, returning the slot itself or its index in {@link slots}.\n   * @param slots Slots to search (this.inputs or this.outputs)\n   * @param type Type of slot to look for\n   * @param returnObj If true, returns the slot itself.  Otherwise, the index.\n   * @param preferFreeSlot Prefer a free slot, but if none are found, fall back to an occupied slot.\n   * @param doNotUseOccupied Do not fall back to occupied slots.\n   * @see {findSlotByType}\n   * @see {findOutputSlotByType}\n   * @see {findInputSlotByType}\n   * @returns If a match is found, the slot if returnObj is true, otherwise the index.  If no matches are found, -1\n   */\n  #findSlotByType<TSlot extends INodeInputSlot | INodeOutputSlot>(\n    slots: TSlot[],\n    type: ISlotType,\n    returnObj?: boolean,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): TSlot | number {\n    const length = slots?.length\n    if (!length) return -1\n\n    // Empty string and * match anything (type:  0)\n    if (type == \"\" || type == \"*\") type = 0\n    const sourceTypes = String(type).toLowerCase().split(\",\")\n\n    // Run the search\n    let occupiedSlot: number | TSlot | null = null\n    for (let i = 0; i < length; ++i) {\n      const slot: TSlot & IGenericLinkOrLinks = slots[i]\n      const destTypes = slot.type == \"0\" || slot.type == \"*\"\n        ? [\"0\"]\n        : String(slot.type).toLowerCase().split(\",\")\n\n      for (const sourceType of sourceTypes) {\n        // TODO: Remove _event_ entirely.\n        const source = sourceType == \"_event_\" ? LiteGraph.EVENT : sourceType\n\n        for (const destType of destTypes) {\n          const dest = destType == \"_event_\" ? LiteGraph.EVENT : destType\n\n          if (source == dest || source === \"*\" || dest === \"*\") {\n            if (preferFreeSlot && (slot.links?.length || slot.link != null)) {\n              // In case we can't find a free slot.\n              occupiedSlot ??= returnObj ? slot : i\n              continue\n            }\n            return returnObj ? slot : i\n          }\n        }\n      }\n    }\n\n    return doNotUseOccupied ? -1 : occupiedSlot ?? -1\n  }\n\n  /**\n   * Determines the slot index to connect to when attempting to connect by type.\n   * @param findInputs If true, searches for an input.  Otherwise, an output.\n   * @param node The node at the other end of the connection.\n   * @param slotType The type of slot at the other end of the connection.\n   * @param options Search restrictions to adhere to.\n   * @see {connectByType}\n   * @see {connectByTypeOutput}\n   */\n  findConnectByTypeSlot(\n    findInputs: boolean,\n    node: LGraphNode,\n    slotType: ISlotType,\n    options?: ConnectByTypeOptions,\n  ): number | undefined {\n    // LEGACY: Old options names\n    if (options && typeof options === \"object\") {\n      if (\"firstFreeIfInputGeneralInCase\" in options) options.wildcardToTyped = !!options.firstFreeIfInputGeneralInCase\n      if (\"firstFreeIfOutputGeneralInCase\" in options) options.wildcardToTyped = !!options.firstFreeIfOutputGeneralInCase\n      if (\"generalTypeInCase\" in options) options.typedToWildcard = !!options.generalTypeInCase\n    }\n    const optsDef: ConnectByTypeOptions = {\n      createEventInCase: true,\n      wildcardToTyped: true,\n      typedToWildcard: true,\n    }\n    const opts = Object.assign(optsDef, options)\n\n    if (!this.graph) throw new NullGraphError()\n\n    if (node && typeof node === \"number\") {\n      const nodeById = this.graph.getNodeById(node)\n      if (!nodeById) return\n\n      node = nodeById\n    }\n    const slot = node.findSlotByType(findInputs, slotType, false, true)\n    if (slot >= 0 && slot !== null) return slot\n\n    // TODO: Remove or reimpl. events.  WILL CREATE THE onTrigger IN SLOT\n    if (opts.createEventInCase && slotType == LiteGraph.EVENT) {\n      if (findInputs) return -1\n      if (LiteGraph.do_add_triggers_slots) return node.addOnExecutedOutput()\n    }\n\n    // connect to the first general output slot if not found a specific type and\n    if (opts.typedToWildcard) {\n      const generalSlot = node.findSlotByType(findInputs, 0, false, true, true)\n      if (generalSlot >= 0) return generalSlot\n    }\n    // connect to the first free input slot if not found a specific type and this output is general\n    if (\n      opts.wildcardToTyped &&\n      (slotType == 0 || slotType == \"*\" || slotType == \"\")\n    ) {\n      const opt = { typesNotAccepted: [LiteGraph.EVENT] }\n      const nonEventSlot = findInputs\n        ? node.findInputSlotFree(opt)\n        : node.findOutputSlotFree(opt)\n      if (nonEventSlot >= 0) return nonEventSlot\n    }\n  }\n\n  /**\n   * Finds the first free output slot with any of the comma-delimited types in {@link type}.\n   *\n   * If no slots are free, falls back in order to:\n   * - The first free wildcard slot\n   * - The first occupied slot\n   * - The first occupied wildcard slot\n   * @param type The {@link ISlotType type} of slot to find\n   * @returns The index and slot if found, otherwise `undefined`.\n   */\n  findOutputByType(type: ISlotType): { index: number, slot: INodeOutputSlot } | undefined {\n    return findFreeSlotOfType(this.outputs, type)\n  }\n\n  /**\n   * Finds the first free input slot with any of the comma-delimited types in {@link type}.\n   *\n   * If no slots are free, falls back in order to:\n   * - The first free wildcard slot\n   * - The first occupied slot\n   * - The first occupied wildcard slot\n   * @param type The {@link ISlotType type} of slot to find\n   * @returns The index and slot if found, otherwise `undefined`.\n   */\n  findInputByType(type: ISlotType): { index: number, slot: INodeInputSlot } | undefined {\n    return findFreeSlotOfType(this.inputs, type)\n  }\n\n  /**\n   * connect this node output to the input of another node BY TYPE\n   * @param slot (could be the number of the slot or the string with the name of the slot)\n   * @param target_node the target node\n   * @param target_slotType the input slot type of the target node\n   * @returns the link_info is created, otherwise null\n   */\n  connectByType(\n    slot: number | string,\n    target_node: LGraphNode,\n    target_slotType: ISlotType,\n    optsIn?: ConnectByTypeOptions,\n  ): LLink | null {\n    const slotIndex = this.findConnectByTypeSlot(\n      true,\n      target_node,\n      target_slotType,\n      optsIn,\n    )\n    if (slotIndex !== undefined)\n      return this.connect(slot, target_node, slotIndex, optsIn?.afterRerouteId)\n\n    console.debug(\"[connectByType]: no way to connect type:\", target_slotType, \"to node:\", target_node)\n    return null\n  }\n\n  /**\n   * connect this node input to the output of another node BY TYPE\n   * @param slot (could be the number of the slot or the string with the name of the slot)\n   * @param source_node the target node\n   * @param source_slotType the output slot type of the target node\n   * @returns the link_info is created, otherwise null\n   */\n  connectByTypeOutput(\n    slot: number | string,\n    source_node: LGraphNode,\n    source_slotType: ISlotType,\n    optsIn?: ConnectByTypeOptions,\n  ): LLink | null {\n    // LEGACY: Old options names\n    if (typeof optsIn === \"object\") {\n      if (\"firstFreeIfInputGeneralInCase\" in optsIn) optsIn.wildcardToTyped = !!optsIn.firstFreeIfInputGeneralInCase\n      if (\"generalTypeInCase\" in optsIn) optsIn.typedToWildcard = !!optsIn.generalTypeInCase\n    }\n    const slotIndex = this.findConnectByTypeSlot(\n      false,\n      source_node,\n      source_slotType,\n      optsIn,\n    )\n    if (slotIndex !== undefined)\n      return source_node.connect(slotIndex, this, slot, optsIn?.afterRerouteId)\n\n    console.debug(\"[connectByType]: no way to connect type:\", source_slotType, \"to node:\", source_node)\n    return null\n  }\n\n  canConnectTo(\n    node: LGraphNode,\n    toSlot: INodeInputSlot,\n    fromSlot: INodeOutputSlot,\n  ) {\n    return this.id !== node.id && LiteGraph.isValidConnection(fromSlot.type, toSlot.type)\n  }\n\n  /**\n   * Connect an output of this node to an input of another node\n   * @param slot (could be the number of the slot or the string with the name of the slot)\n   * @param target_node the target node\n   * @param target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)\n   * @returns the link_info is created, otherwise null\n   */\n  connect(\n    slot: number | string,\n    target_node: LGraphNode,\n    target_slot: ISlotType,\n    afterRerouteId?: RerouteId,\n  ): LLink | null {\n    // Allow legacy API support for searching target_slot by string, without mutating the input variables\n    let targetIndex: number | null\n\n    const { graph, outputs } = this\n    if (!graph) {\n      // could be connected before adding it to a graph\n      // due to link ids being associated with graphs\n      console.log(\"Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.\")\n      return null\n    }\n\n    // seek for the output slot\n    if (typeof slot === \"string\") {\n      slot = this.findOutputSlot(slot)\n      if (slot == -1) {\n        if (LiteGraph.debug) console.log(`Connect: Error, no slot of name ${slot}`)\n        return null\n      }\n    } else if (!outputs || slot >= outputs.length) {\n      if (LiteGraph.debug) console.log(\"Connect: Error, slot number not found\")\n      return null\n    }\n\n    if (target_node && typeof target_node === \"number\") {\n      const nodeById = graph.getNodeById(target_node)\n      if (!nodeById) throw \"target node is null\"\n\n      target_node = nodeById\n    }\n    if (!target_node) throw \"target node is null\"\n\n    // avoid loopback\n    if (target_node == this) return null\n\n    // you can specify the slot by name\n    if (typeof target_slot === \"string\") {\n      targetIndex = target_node.findInputSlot(target_slot)\n      if (targetIndex == -1) {\n        if (LiteGraph.debug) console.log(`Connect: Error, no slot of name ${targetIndex}`)\n        return null\n      }\n    } else if (target_slot === LiteGraph.EVENT) {\n      // TODO: Events\n      if (LiteGraph.do_add_triggers_slots) {\n        target_node.changeMode(LGraphEventMode.ON_TRIGGER)\n        targetIndex = target_node.findInputSlot(\"onTrigger\")\n      } else {\n        return null\n      }\n    } else if (typeof target_slot === \"number\") {\n      targetIndex = target_slot\n    } else {\n      targetIndex = 0\n    }\n\n    // Allow target node to change slot\n    if (target_node.onBeforeConnectInput) {\n      // This way node can choose another slot (or make a new one?)\n      const requestedIndex = target_node.onBeforeConnectInput(targetIndex, target_slot)\n      targetIndex = typeof requestedIndex === \"number\" ? requestedIndex : null\n    }\n\n    if (\n      targetIndex === null ||\n      !target_node.inputs ||\n      targetIndex >= target_node.inputs.length\n    ) {\n      if (LiteGraph.debug) console.log(\"Connect: Error, slot number not found\")\n      return null\n    }\n\n    const input = target_node.inputs[targetIndex]\n    const output = outputs[slot]\n\n    if (!output) return null\n\n    if (output.links?.length) {\n      if (output.type === LiteGraph.EVENT && !LiteGraph.allow_multi_output_for_events) {\n        graph.beforeChange()\n        // @ts-expect-error Unused param\n        this.disconnectOutput(slot, false, { doProcessChange: false })\n      }\n    }\n\n    const link = this.connectSlots(output, target_node, input, afterRerouteId)\n    return link ?? null\n  }\n\n  /**\n   * Connect two slots between two nodes\n   * @param output The output slot to connect\n   * @param inputNode The node that the input slot is on\n   * @param input The input slot to connect\n   * @param afterRerouteId The reroute ID to use for the link\n   * @returns The link that was created, or null if the connection was blocked\n   */\n  connectSlots(\n    output: INodeOutputSlot,\n    inputNode: LGraphNode,\n    input: INodeInputSlot,\n    afterRerouteId: RerouteId | undefined,\n  ): LLink | null | undefined {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const outputIndex = this.outputs.indexOf(output)\n    if (outputIndex === -1) {\n      console.warn(\"connectSlots: output not found\")\n      return\n    }\n    const inputIndex = inputNode.inputs.indexOf(input)\n    if (inputIndex === -1) {\n      console.warn(\"connectSlots: input not found\")\n      return\n    }\n\n    // check targetSlot and check connection types\n    if (!LiteGraph.isValidConnection(output.type, input.type)) {\n      this.setDirtyCanvas(false, true)\n      return null\n    }\n\n    // Allow nodes to block connection\n    if (inputNode.onConnectInput?.(inputIndex, output.type, output, this, outputIndex) === false)\n      return null\n    if (this.onConnectOutput?.(outputIndex, input.type, input, inputNode, inputIndex) === false)\n      return null\n\n    // if there is something already plugged there, disconnect\n    if (inputNode.inputs[inputIndex]?.link != null) {\n      graph.beforeChange()\n      inputNode.disconnectInput(inputIndex, true)\n    }\n\n    const link = new LLink(\n      ++graph.state.lastLinkId,\n      input.type || output.type,\n      this.id,\n      outputIndex,\n      inputNode.id,\n      inputIndex,\n      afterRerouteId,\n    )\n\n    // add to graph links list\n    graph._links.set(link.id, link)\n\n    // connect in output\n    output.links ??= []\n    output.links.push(link.id)\n    // connect in input\n    inputNode.inputs[inputIndex].link = link.id\n\n    // Reroutes\n    const reroutes = LLink.getReroutes(graph, link)\n    for (const reroute of reroutes) {\n      reroute.linkIds.add(link.id)\n      if (reroute.floating) delete reroute.floating\n      reroute._dragging = undefined\n    }\n\n    // If this is the terminus of a floating link, remove it\n    const lastReroute = reroutes.at(-1)\n    if (lastReroute) {\n      for (const linkId of lastReroute.floatingLinkIds) {\n        const link = graph.floatingLinks.get(linkId)\n        if (link?.parentId === lastReroute.id) {\n          graph.removeFloatingLink(link)\n        }\n      }\n    }\n    graph._version++\n\n    // link has been created now, so its updated\n    this.onConnectionsChange?.(\n      NodeSlotType.OUTPUT,\n      outputIndex,\n      true,\n      link,\n      output,\n    )\n\n    inputNode.onConnectionsChange?.(\n      NodeSlotType.INPUT,\n      inputIndex,\n      true,\n      link,\n      input,\n    )\n\n    this.setDirtyCanvas(false, true)\n    graph.afterChange()\n    graph.connectionChange(this)\n\n    return link\n  }\n\n  connectFloatingReroute(pos: Point, slot: INodeInputSlot | INodeOutputSlot, afterRerouteId?: RerouteId): Reroute {\n    const { graph, id } = this\n    if (!graph) throw new NullGraphError()\n\n    // Assertion: It's either there or it isn't.\n    const inputIndex = this.inputs.indexOf(slot as INodeInputSlot)\n    const outputIndex = this.outputs.indexOf(slot as INodeOutputSlot)\n    if (inputIndex === -1 && outputIndex === -1) throw new Error(\"Invalid slot\")\n\n    const slotType = outputIndex === -1 ? \"input\" : \"output\"\n\n    const reroute = graph.setReroute({\n      pos,\n      parentId: afterRerouteId,\n      linkIds: [],\n      floating: { slotType },\n    })\n\n    const parentReroute = graph.getReroute(afterRerouteId)\n    const fromLastFloatingReroute = parentReroute?.floating?.slotType === \"output\"\n\n    // Adding from an ouput, or a floating reroute that is NOT the tip of an existing floating chain\n    if (afterRerouteId == null || !fromLastFloatingReroute) {\n      const link = new LLink(\n        -1,\n        slot.type,\n        outputIndex === -1 ? -1 : id,\n        outputIndex,\n        inputIndex === -1 ? -1 : id,\n        inputIndex,\n      )\n      link.parentId = reroute.id\n      graph.addFloatingLink(link)\n      return reroute\n    }\n\n    // Adding a new floating reroute from the tip of a floating chain.\n    if (!parentReroute) throw new Error(\"[connectFloatingReroute] Parent reroute not found\")\n\n    const link = parentReroute.getFloatingLinks(\"output\")?.[0]\n    if (!link) throw new Error(\"[connectFloatingReroute] Floating link not found\")\n\n    reroute.floatingLinkIds.add(link.id)\n    link.parentId = reroute.id\n    delete parentReroute.floating\n    return reroute\n  }\n\n  /**\n   * disconnect one output to an specific node\n   * @param slot (could be the number of the slot or the string with the name of the slot)\n   * @param target_node the target node to which this slot is connected [Optional,\n   * if not target_node is specified all nodes will be disconnected]\n   * @returns if it was disconnected successfully\n   */\n  disconnectOutput(slot: string | number, target_node?: LGraphNode): boolean {\n    if (typeof slot === \"string\") {\n      slot = this.findOutputSlot(slot)\n      if (slot == -1) {\n        if (LiteGraph.debug) console.log(`Connect: Error, no slot of name ${slot}`)\n        return false\n      }\n    } else if (!this.outputs || slot >= this.outputs.length) {\n      if (LiteGraph.debug) console.log(\"Connect: Error, slot number not found\")\n      return false\n    }\n\n    // get output slot\n    const output = this.outputs[slot]\n    if (!output) return false\n\n    if (output._floatingLinks) {\n      for (const link of output._floatingLinks) {\n        if (link.hasOrigin(this.id, slot)) {\n          this.graph?.removeFloatingLink(link)\n        }\n      }\n    }\n\n    if (!output.links || output.links.length == 0) return false\n    const { links } = output\n\n    // one of the output links in this slot\n    const graph = this.graph\n    if (!graph) throw new NullGraphError()\n\n    if (target_node) {\n      const target = typeof target_node === \"number\"\n        ? graph.getNodeById(target_node)\n        : target_node\n      if (!target) throw \"Target Node not found\"\n\n      for (const [i, link_id] of links.entries()) {\n        const link_info = graph._links.get(link_id)\n        if (link_info?.target_id != target.id) continue\n\n        // is the link we are searching for...\n        // remove here\n        links.splice(i, 1)\n        const input = target.inputs[link_info.target_slot]\n        // remove there\n        input.link = null\n\n        // remove the link from the links pool\n        link_info.disconnect(graph, \"input\")\n        graph._version++\n\n        // link_info hasn't been modified so its ok\n        target.onConnectionsChange?.(\n          NodeSlotType.INPUT,\n          link_info.target_slot,\n          false,\n          link_info,\n          input,\n        )\n        this.onConnectionsChange?.(\n          NodeSlotType.OUTPUT,\n          slot,\n          false,\n          link_info,\n          output,\n        )\n\n        break\n      }\n    } else {\n      // all the links in this output slot\n      for (const link_id of links) {\n        const link_info = graph._links.get(link_id)\n        if (!link_info) continue\n\n        const target = graph.getNodeById(link_info.target_id)\n        graph._version++\n\n        if (target) {\n          const input = target.inputs[link_info.target_slot]\n          // remove other side link\n          input.link = null\n\n          // link_info hasn't been modified so its ok\n          target.onConnectionsChange?.(\n            NodeSlotType.INPUT,\n            link_info.target_slot,\n            false,\n            link_info,\n            input,\n          )\n        }\n        // remove the link from the links pool\n        link_info.disconnect(graph, \"input\")\n\n        this.onConnectionsChange?.(\n          NodeSlotType.OUTPUT,\n          slot,\n          false,\n          link_info,\n          output,\n        )\n      }\n      output.links = null\n    }\n\n    this.setDirtyCanvas(false, true)\n    graph.connectionChange(this)\n    return true\n  }\n\n  /**\n   * Disconnect one input\n   * @param slot Input slot index, or the name of the slot\n   * @param keepReroutes If `true`, reroutes will not be garbage collected.\n   * @returns true if disconnected successfully or already disconnected, otherwise false\n   */\n  disconnectInput(slot: number | string, keepReroutes?: boolean): boolean {\n    // Allow search by string\n    if (typeof slot === \"string\") {\n      slot = this.findInputSlot(slot)\n      if (slot == -1) {\n        if (LiteGraph.debug) console.log(`Connect: Error, no slot of name ${slot}`)\n        return false\n      }\n    } else if (!this.inputs || slot >= this.inputs.length) {\n      if (LiteGraph.debug) {\n        console.log(\"Connect: Error, slot number not found\")\n      }\n      return false\n    }\n\n    const input = this.inputs[slot]\n    if (!input) return false\n\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    // Break floating links\n    if (input._floatingLinks?.size) {\n      for (const link of input._floatingLinks) {\n        graph.removeFloatingLink(link)\n      }\n    }\n\n    const link_id = this.inputs[slot].link\n    if (link_id != null) {\n      this.inputs[slot].link = null\n\n      // remove other side\n      const link_info = graph._links.get(link_id)\n      if (link_info) {\n        const target_node = graph.getNodeById(link_info.origin_id)\n        if (!target_node) return false\n\n        const output = target_node.outputs[link_info.origin_slot]\n        if (!(output?.links?.length)) return false\n\n        // search in the inputs list for this link\n        let i = 0\n        for (const l = output.links.length; i < l; i++) {\n          if (output.links[i] == link_id) {\n            output.links.splice(i, 1)\n            break\n          }\n        }\n\n        link_info.disconnect(graph, keepReroutes ? \"output\" : undefined)\n        if (graph) graph._version++\n\n        this.onConnectionsChange?.(\n          NodeSlotType.INPUT,\n          slot,\n          false,\n          link_info,\n          input,\n        )\n        target_node.onConnectionsChange?.(\n          NodeSlotType.OUTPUT,\n          i,\n          false,\n          link_info,\n          output,\n        )\n      }\n    }\n\n    this.setDirtyCanvas(false, true)\n    graph?.connectionChange(this)\n    return true\n  }\n\n  /**\n   * @deprecated Use {@link getInputPos} or {@link getOutputPos} instead.\n   * returns the center of a connection point in canvas coords\n   * @param is_input true if if a input slot, false if it is an output\n   * @param slot_number (could be the number of the slot or the string with the name of the slot)\n   * @param out [optional] a place to store the output, to free garbage\n   * @returns the position\n   */\n  getConnectionPos(is_input: boolean, slot_number: number, out?: Point): Point {\n    out ||= new Float32Array(2)\n\n    const { pos: [nodeX, nodeY], inputs, outputs } = this\n\n    if (this.flags.collapsed) {\n      const w = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH\n      out[0] = is_input ? nodeX : nodeX + w\n      out[1] = nodeY - LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      return out\n    }\n\n    // weird feature that never got finished\n    if (is_input && slot_number == -1) {\n      out[0] = nodeX + LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      out[1] = nodeY + LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      return out\n    }\n\n    // hard-coded pos\n    const inputPos = inputs?.[slot_number]?.pos\n    const outputPos = outputs?.[slot_number]?.pos\n\n    if (is_input && inputPos) {\n      out[0] = nodeX + inputPos[0]\n      out[1] = nodeY + inputPos[1]\n      return out\n    } else if (!is_input && outputPos) {\n      out[0] = nodeX + outputPos[0]\n      out[1] = nodeY + outputPos[1]\n      return out\n    }\n\n    // default vertical slots\n    const offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    const slotIndex = is_input\n      ? this.#defaultVerticalInputs.indexOf(this.inputs[slot_number])\n      : this.#defaultVerticalOutputs.indexOf(this.outputs[slot_number])\n\n    out[0] = is_input\n      ? nodeX + offset\n      : nodeX + this.size[0] + 1 - offset\n    out[1] =\n      nodeY +\n      (slotIndex + 0.7) * LiteGraph.NODE_SLOT_HEIGHT +\n      (this.constructor.slot_start_y || 0)\n    return out\n  }\n\n  /**\n   * @internal The inputs that are not positioned with absolute coordinates.\n   */\n  get #defaultVerticalInputs() {\n    return this.inputs.filter(\n      slot => !slot.pos && !(this.widgets?.length && isWidgetInputSlot(slot)),\n    )\n  }\n\n  /**\n   * @internal The outputs that are not positioned with absolute coordinates.\n   */\n  get #defaultVerticalOutputs() {\n    return this.outputs.filter((slot: INodeOutputSlot) => !slot.pos)\n  }\n\n  /**\n   * Gets the position of an input slot, in graph co-ordinates.\n   *\n   * This method is preferred over the legacy {@link getConnectionPos} method.\n   * @param slot Input slot index\n   * @returns Position of the input slot\n   */\n  getInputPos(slot: number): Point {\n    return this.getInputSlotPos(this.inputs[slot])\n  }\n\n  /**\n   * Gets the position of an input slot, in graph co-ordinates.\n   * @param input The actual node input object\n   * @returns Position of the centre of the input slot in graph co-ordinates.\n   */\n  getInputSlotPos(input: INodeInputSlot): Point {\n    const { pos: [nodeX, nodeY] } = this\n\n    if (this.flags.collapsed) {\n      const halfTitle = LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      return [nodeX, nodeY - halfTitle]\n    }\n\n    const { pos } = input\n    if (pos) return [nodeX + pos[0], nodeY + pos[1]]\n\n    // default vertical slots\n    const offsetX = LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    const nodeOffsetY = this.constructor.slot_start_y || 0\n    const slotIndex = this.#defaultVerticalInputs.indexOf(input)\n    const slotY = (slotIndex + 0.7) * LiteGraph.NODE_SLOT_HEIGHT\n\n    return [nodeX + offsetX, nodeY + slotY + nodeOffsetY]\n  }\n\n  /**\n   * Gets the position of an output slot, in graph co-ordinates.\n   *\n   * This method is preferred over the legacy {@link getConnectionPos} method.\n   * @param slot Output slot index\n   * @returns Position of the output slot\n   */\n  getOutputPos(slot: number): Point {\n    const { pos: [nodeX, nodeY], outputs, size: [width] } = this\n\n    if (this.flags.collapsed) {\n      const width = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH\n      const halfTitle = LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      return [nodeX + width, nodeY - halfTitle]\n    }\n\n    const outputPos = outputs?.[slot]?.pos\n    if (outputPos) return [nodeX + outputPos[0], nodeY + outputPos[1]]\n\n    // default vertical slots\n    const offsetX = LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    const nodeOffsetY = this.constructor.slot_start_y || 0\n    const slotIndex = this.#defaultVerticalOutputs.indexOf(this.outputs[slot])\n    const slotY = (slotIndex + 0.7) * LiteGraph.NODE_SLOT_HEIGHT\n\n    // TODO: Why +1?\n    return [nodeX + width + 1 - offsetX, nodeY + slotY + nodeOffsetY]\n  }\n\n  /** @inheritdoc */\n  snapToGrid(snapTo: number): boolean {\n    return this.pinned ? false : snapPoint(this.pos, snapTo)\n  }\n\n  /** @see {@link snapToGrid} */\n  alignToGrid(): void {\n    this.snapToGrid(LiteGraph.CANVAS_GRID_SIZE)\n  }\n\n  /* Console output */\n  trace(msg: string): void {\n    this.console ||= []\n    this.console.push(msg)\n    // @ts-expect-error deprecated\n    if (this.console.length > LGraphNode.MAX_CONSOLE)\n      this.console.shift()\n  }\n\n  /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\n  setDirtyCanvas(dirty_foreground: boolean, dirty_background?: boolean): void {\n    this.graph?.canvasAction(c => c.setDirty(dirty_foreground, dirty_background))\n  }\n\n  loadImage(url: string): HTMLImageElement {\n    interface AsyncImageElement extends HTMLImageElement { ready?: boolean }\n\n    const img: AsyncImageElement = new Image()\n    img.src = LiteGraph.node_images_path + url\n    img.ready = false\n\n    const dirty = () => this.setDirtyCanvas(true)\n    img.addEventListener(\"load\", function (this: AsyncImageElement) {\n      this.ready = true\n      dirty()\n    })\n    return img\n  }\n\n  /**\n   * Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus\n   * @deprecated Use {@link LGraphCanvas.pointer} instead.\n   */\n  captureInput(v: boolean): void {\n    warnDeprecated(\"[DEPRECATED] captureInput will be removed in a future version. Please use LGraphCanvas.pointer (CanvasPointer) instead.\")\n    if (!this.graph || !this.graph.list_of_graphcanvas) return\n\n    const list = this.graph.list_of_graphcanvas\n\n    for (const c of list) {\n      // releasing somebody elses capture?!\n      if (!v && c.node_capturing_input != this) continue\n\n      // change\n      c.node_capturing_input = v ? this : null\n    }\n  }\n\n  get collapsed() {\n    return !!this.flags.collapsed\n  }\n\n  get collapsible() {\n    return !this.pinned && this.constructor.collapsable !== false\n  }\n\n  /**\n   * Toggle node collapse (makes it smaller on the canvas)\n   */\n  collapse(force?: boolean): void {\n    if (!this.collapsible && !force) return\n    if (!this.graph) throw new NullGraphError()\n    this.graph._version++\n    this.flags.collapsed = !this.flags.collapsed\n    this.setDirtyCanvas(true, true)\n  }\n\n  /**\n   * Toggles advanced mode of the node, showing advanced widgets\n   */\n  toggleAdvanced() {\n    if (!this.widgets?.some(w => w.advanced)) return\n    if (!this.graph) throw new NullGraphError()\n    this.graph._version++\n    this.showAdvanced = !this.showAdvanced\n    this.expandToFitContent()\n    this.setDirtyCanvas(true, true)\n  }\n\n  get pinned() {\n    return !!this.flags.pinned\n  }\n\n  /**\n   * Prevents the node being accidentally moved or resized by mouse interaction.\n   * Toggles pinned state if no value is provided.\n   */\n  pin(v?: boolean): void {\n    if (!this.graph) throw new NullGraphError()\n\n    this.graph._version++\n    this.flags.pinned = v ?? !this.flags.pinned\n    this.resizable = !this.pinned\n    // Delete the flag if unpinned, so that we don't get unnecessary\n    // flags.pinned = false in serialized object.\n    if (!this.pinned) delete this.flags.pinned\n  }\n\n  unpin(): void {\n    this.pin(false)\n  }\n\n  localToScreen(x: number, y: number, dragAndScale: DragAndScale): Point {\n    return [\n      (x + this.pos[0]) * dragAndScale.scale + dragAndScale.offset[0],\n      (y + this.pos[1]) * dragAndScale.scale + dragAndScale.offset[1],\n    ]\n  }\n\n  get width() {\n    return this.collapsed\n      ? this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH\n      : this.size[0]\n  }\n\n  /**\n   * Returns the height of the node, including the title bar.\n   */\n  get height() {\n    return LiteGraph.NODE_TITLE_HEIGHT + this.bodyHeight\n  }\n\n  /**\n   * Returns the height of the node, excluding the title bar.\n   */\n  get bodyHeight() {\n    return this.collapsed ? 0 : this.size[1]\n  }\n\n  drawBadges(ctx: CanvasRenderingContext2D, { gap = 2 } = {}): void {\n    const badgeInstances = this.badges.map(badge =>\n      badge instanceof LGraphBadge ? badge : badge())\n    const isLeftAligned = this.badgePosition === BadgePosition.TopLeft\n\n    let currentX = isLeftAligned\n      ? 0\n      : this.width - badgeInstances.reduce((acc, badge) => acc + badge.getWidth(ctx) + gap, 0)\n    const y = -(LiteGraph.NODE_TITLE_HEIGHT + gap)\n\n    for (const badge of badgeInstances) {\n      badge.draw(ctx, currentX, y - badge.height)\n      currentX += badge.getWidth(ctx) + gap\n    }\n  }\n\n  /**\n   * Renders the node's title bar background\n   */\n  drawTitleBarBackground(ctx: CanvasRenderingContext2D, {\n    scale,\n    title_height = LiteGraph.NODE_TITLE_HEIGHT,\n    low_quality = false,\n  }: DrawTitleOptions): void {\n    const fgcolor = this.renderingColor\n    const shape = this.renderingShape\n    const size = this.renderingSize\n\n    if (this.onDrawTitleBar) {\n      this.onDrawTitleBar(ctx, title_height, size, scale, fgcolor)\n      return\n    }\n\n    if (this.title_mode === TitleMode.TRANSPARENT_TITLE) {\n      return\n    }\n\n    if (this.collapsed) {\n      ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR\n    }\n\n    ctx.fillStyle = this.constructor.title_color || fgcolor\n    ctx.beginPath()\n\n    if (shape == RenderShape.BOX || low_quality) {\n      ctx.rect(0, -title_height, size[0], title_height)\n    } else if (shape == RenderShape.ROUND || shape == RenderShape.CARD) {\n      ctx.roundRect(\n        0,\n        -title_height,\n        size[0],\n        title_height,\n        this.collapsed\n          ? [LiteGraph.ROUND_RADIUS]\n          : [LiteGraph.ROUND_RADIUS, LiteGraph.ROUND_RADIUS, 0, 0],\n      )\n    }\n    ctx.fill()\n    ctx.shadowColor = \"transparent\"\n  }\n\n  /**\n   * Renders the node's title box, i.e. the dot in front of the title text that\n   * when clicked toggles the node's collapsed state. The term `title box` comes\n   * from the original LiteGraph implementation.\n   */\n  drawTitleBox(ctx: CanvasRenderingContext2D, {\n    scale,\n    low_quality = false,\n    title_height = LiteGraph.NODE_TITLE_HEIGHT,\n    box_size = 10,\n  }: DrawTitleBoxOptions): void {\n    const size = this.renderingSize\n    const shape = this.renderingShape\n\n    if (this.onDrawTitleBox) {\n      this.onDrawTitleBox(ctx, title_height, size, scale)\n      return\n    }\n\n    if (\n      [RenderShape.ROUND, RenderShape.CIRCLE, RenderShape.CARD].includes(shape)\n    ) {\n      if (low_quality) {\n        ctx.fillStyle = \"black\"\n        ctx.beginPath()\n        ctx.arc(\n          title_height * 0.5,\n          title_height * -0.5,\n          box_size * 0.5 + 1,\n          0,\n          Math.PI * 2,\n        )\n        ctx.fill()\n      }\n\n      ctx.fillStyle = this.renderingBoxColor\n      if (low_quality) {\n        ctx.fillRect(\n          title_height * 0.5 - box_size * 0.5,\n          title_height * -0.5 - box_size * 0.5,\n          box_size,\n          box_size,\n        )\n      } else {\n        ctx.beginPath()\n        ctx.arc(\n          title_height * 0.5,\n          title_height * -0.5,\n          box_size * 0.5,\n          0,\n          Math.PI * 2,\n        )\n        ctx.fill()\n      }\n    } else {\n      if (low_quality) {\n        ctx.fillStyle = \"black\"\n        ctx.fillRect(\n          (title_height - box_size) * 0.5 - 1,\n          (title_height + box_size) * -0.5 - 1,\n          box_size + 2,\n          box_size + 2,\n        )\n      }\n      ctx.fillStyle = this.renderingBoxColor\n      ctx.fillRect(\n        (title_height - box_size) * 0.5,\n        (title_height + box_size) * -0.5,\n        box_size,\n        box_size,\n      )\n    }\n  }\n\n  /**\n   * Renders the node's title text.\n   */\n  drawTitleText(ctx: CanvasRenderingContext2D, {\n    scale,\n    default_title_color,\n    low_quality = false,\n    title_height = LiteGraph.NODE_TITLE_HEIGHT,\n  }: DrawTitleTextOptions): void {\n    const size = this.renderingSize\n    const selected = this.selected\n\n    if (this.onDrawTitleText) {\n      this.onDrawTitleText(\n        ctx,\n        title_height,\n        size,\n        scale,\n        this.titleFontStyle,\n        selected,\n      )\n      return\n    }\n\n    // Don't render title text if low quality\n    if (low_quality) {\n      return\n    }\n\n    ctx.font = this.titleFontStyle\n    const rawTitle = this.getTitle() ?? `â ${this.type}`\n    const title = String(rawTitle) + (this.pinned ? \"ð\" : \"\")\n    if (title) {\n      if (selected) {\n        ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR\n      } else {\n        ctx.fillStyle = this.constructor.title_text_color || default_title_color\n      }\n      if (this.collapsed) {\n        ctx.textAlign = \"left\"\n        ctx.fillText(\n          // avoid urls too long\n          title.substr(0, 20),\n          title_height,\n          LiteGraph.NODE_TITLE_TEXT_Y - title_height,\n        )\n        ctx.textAlign = \"left\"\n      } else {\n        ctx.textAlign = \"left\"\n        ctx.fillText(\n          title,\n          title_height,\n          LiteGraph.NODE_TITLE_TEXT_Y - title_height,\n        )\n      }\n    }\n  }\n\n  /**\n   * Attempts to gracefully bypass this node in all of its connections by reconnecting all links.\n   *\n   * Each input is checked against each output.  This is done on a matching index basis, i.e. input 3 -> output 3.\n   * If there are any input links remaining,\n   * and {@link flags}.{@link INodeFlags.keepAllLinksOnBypass keepAllLinksOnBypass} is `true`,\n   * each input will check for outputs that match, and take the first one that matches\n   * `true`: Try the index matching first, then every input to every output.\n   * `false`: Only matches indexes, e.g. input 3 to output 3.\n   *\n   * If {@link flags}.{@link INodeFlags.keepAllLinksOnBypass keepAllLinksOnBypass} is `undefined`, it will fall back to\n   * the static {@link keepAllLinksOnBypass}.\n   * @returns `true` if any new links were established, otherwise `false`.\n   * @todo Decision: Change API to return array of new links instead?\n   */\n  connectInputToOutput(): boolean | undefined {\n    const { inputs, outputs, graph } = this\n    if (!inputs || !outputs) return\n    if (!graph) throw new NullGraphError()\n\n    const { _links } = graph\n    let madeAnyConnections = false\n\n    // First pass: only match exactly index-to-index\n    for (const [index, input] of inputs.entries()) {\n      if (input.link == null) continue\n\n      const output = outputs[index]\n      if (!output || !LiteGraph.isValidConnection(input.type, output.type)) continue\n\n      const inLink = _links.get(input.link)\n      if (!inLink) continue\n      const inNode = graph.getNodeById(inLink?.origin_id)\n      if (!inNode) continue\n\n      bypassAllLinks(output, inNode, inLink, graph)\n    }\n    // Configured to only use index-to-index matching\n    if (!(this.flags.keepAllLinksOnBypass ?? LGraphNode.keepAllLinksOnBypass))\n      return madeAnyConnections\n\n    // Second pass: match any remaining links\n    for (const input of inputs) {\n      if (input.link == null) continue\n\n      const inLink = _links.get(input.link)\n      if (!inLink) continue\n      const inNode = graph.getNodeById(inLink?.origin_id)\n      if (!inNode) continue\n\n      for (const output of outputs) {\n        if (!LiteGraph.isValidConnection(input.type, output.type)) continue\n\n        bypassAllLinks(output, inNode, inLink, graph)\n        break\n      }\n    }\n    return madeAnyConnections\n\n    function bypassAllLinks(output: INodeOutputSlot, inNode: LGraphNode, inLink: LLink, graph: LGraph) {\n      const outLinks = output.links\n        ?.map(x => _links.get(x))\n        .filter(x => !!x)\n      if (!outLinks?.length) return\n\n      for (const outLink of outLinks) {\n        const outNode = graph.getNodeById(outLink.target_id)\n        if (!outNode) continue\n\n        const result = inNode.connect(\n          inLink.origin_slot,\n          outNode,\n          outLink.target_slot,\n          inLink.parentId,\n        )\n        madeAnyConnections ||= !!result\n      }\n    }\n  }\n\n  /**\n   * Returns `true` if the widget is visible, otherwise `false`.\n   */\n  isWidgetVisible(widget: IBaseWidget): boolean {\n    const isHidden = (\n      this.collapsed ||\n      widget.hidden ||\n      (widget.advanced && !this.showAdvanced)\n    )\n    return !isHidden\n  }\n\n  drawWidgets(ctx: CanvasRenderingContext2D, {\n    lowQuality = false,\n    editorAlpha = 1,\n  }: DrawWidgetsOptions): void {\n    if (!this.widgets) return\n\n    const nodeWidth = this.size[0]\n    const { widgets } = this\n    const H = LiteGraph.NODE_WIDGET_HEIGHT\n    const showText = !lowQuality\n    ctx.save()\n    ctx.globalAlpha = editorAlpha\n\n    for (const widget of widgets) {\n      if (!this.isWidgetVisible(widget)) continue\n\n      const { y } = widget\n      const outlineColour = widget.advanced ? LiteGraph.WIDGET_ADVANCED_OUTLINE_COLOR : LiteGraph.WIDGET_OUTLINE_COLOR\n\n      widget.last_y = y\n      // Disable widget if it is disabled or if the value is passed from socket connection.\n      widget.computedDisabled = widget.disabled || this.getSlotFromWidget(widget)?.link != null\n\n      ctx.strokeStyle = outlineColour\n      ctx.fillStyle = \"#222\"\n      ctx.textAlign = \"left\"\n      if (widget.computedDisabled) ctx.globalAlpha *= 0.5\n      const width = widget.width || nodeWidth\n\n      const widgetInstance = toConcreteWidget(widget, this, false)\n      if (widgetInstance) {\n        widgetInstance.drawWidget(ctx, { width, showText })\n      } else {\n        widget.draw?.(ctx, this, width, y, H, lowQuality)\n      }\n      ctx.globalAlpha = editorAlpha\n    }\n    ctx.restore()\n  }\n\n  /**\n   * When {@link LGraphNode.collapsed} is `true`, this method draws the node's collapsed slots.\n   */\n  drawCollapsedSlots(ctx: CanvasRenderingContext2D): void {\n    // Render the first connected slot only.\n    for (const slot of this.#concreteInputs) {\n      if (slot.link != null) {\n        slot.drawCollapsed(ctx)\n        break\n      }\n    }\n    for (const slot of this.#concreteOutputs) {\n      if (slot.links?.length) {\n        slot.drawCollapsed(ctx)\n        break\n      }\n    }\n  }\n\n  get slots(): (INodeInputSlot | INodeOutputSlot)[] {\n    return [...this.inputs, ...this.outputs]\n  }\n\n  #measureSlot(slot: NodeInputSlot | NodeOutputSlot, slotIndex: number, isInput: boolean): void {\n    const pos = isInput ? this.getInputPos(slotIndex) : this.getOutputPos(slotIndex)\n\n    slot.boundingRect[0] = pos[0] - LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    slot.boundingRect[1] = pos[1] - LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    slot.boundingRect[2] = slot.isWidgetInputSlot ? BaseWidget.margin : LiteGraph.NODE_SLOT_HEIGHT\n    slot.boundingRect[3] = LiteGraph.NODE_SLOT_HEIGHT\n  }\n\n  #measureSlots(): ReadOnlyRect | null {\n    const slots: (NodeInputSlot | NodeOutputSlot)[] = []\n\n    for (const [slotIndex, slot] of this.#concreteInputs.entries()) {\n      // Unrecognized nodes (Nodes with error) has inputs but no widgets. Treat\n      // converted inputs as normal inputs.\n      /** Widget input slots are handled in {@link layoutWidgetInputSlots} */\n      if (this.widgets?.length && isWidgetInputSlot(slot)) continue\n\n      this.#measureSlot(slot, slotIndex, true)\n      slots.push(slot)\n    }\n    for (const [slotIndex, slot] of this.#concreteOutputs.entries()) {\n      this.#measureSlot(slot, slotIndex, false)\n      slots.push(slot)\n    }\n\n    return slots.length ? createBounds(slots, 0) : null\n  }\n\n  #getMouseOverSlot(slot: INodeSlot): INodeSlot | null {\n    const isInput = isINodeInputSlot(slot)\n    const mouseOverId = this.mouseOver?.[isInput ? \"inputId\" : \"outputId\"] ?? -1\n    if (mouseOverId === -1) {\n      return null\n    }\n    return isInput ? this.inputs[mouseOverId] : this.outputs[mouseOverId]\n  }\n\n  #isMouseOverSlot(slot: INodeSlot): boolean {\n    return this.#getMouseOverSlot(slot) === slot\n  }\n\n  #isMouseOverWidget(widget: IBaseWidget | undefined): boolean {\n    if (!widget) return false\n    return this.mouseOver?.overWidget === widget\n  }\n\n  /**\n   * Returns the input slot that is associated with the given widget.\n   */\n  getSlotFromWidget(widget: IBaseWidget | undefined): INodeInputSlot | undefined {\n    if (widget) return this.inputs.find(slot => isWidgetInputSlot(slot) && slot.widget.name === widget.name)\n  }\n\n  /**\n   * Returns the widget that is associated with the given input slot.\n   */\n  getWidgetFromSlot(slot: INodeInputSlot): IBaseWidget | undefined {\n    if (!isWidgetInputSlot(slot)) return\n    return this.widgets?.find(w => w.name === slot.widget.name)\n  }\n\n  /**\n   * Draws the node's input and output slots.\n   */\n  drawSlots(ctx: CanvasRenderingContext2D, {\n    fromSlot,\n    colorContext,\n    editorAlpha,\n    lowQuality,\n  }: DrawSlotsOptions) {\n    for (const slot of [...this.#concreteInputs, ...this.#concreteOutputs]) {\n      const isValidTarget = fromSlot && slot.isValidTarget(fromSlot)\n      const isMouseOverSlot = this.#isMouseOverSlot(slot)\n\n      // change opacity of incompatible slots when dragging a connection\n      const isValid = !fromSlot || isValidTarget\n      const highlight = isValid && isMouseOverSlot\n\n      // Show slot if it's not a widget input slot\n      // or if it's a widget input slot and satisfies one of the following:\n      // - the mouse is over the widget\n      // - the slot is valid during link drop\n      // - the slot is connected\n      if (\n        isMouseOverSlot ||\n        isValidTarget ||\n        !slot.isWidgetInputSlot ||\n        this.#isMouseOverWidget(this.getWidgetFromSlot(slot)) ||\n        slot.isConnected\n      ) {\n        ctx.globalAlpha = isValid ? editorAlpha : 0.4 * editorAlpha\n        slot.draw(ctx, {\n          colorContext,\n          lowQuality,\n          highlight,\n        })\n      }\n    }\n  }\n\n  /**\n   * Arranges the node's widgets vertically.\n   * Sets following properties on each widget:\n   * -  {@link IBaseWidget.computedHeight}\n   * -  {@link IBaseWidget.y}\n   * @param widgetStartY The y-coordinate of the first widget\n   */\n  #arrangeWidgets(widgetStartY: number): void {\n    if (!this.widgets || !this.widgets.length) return\n\n    const bodyHeight = this.bodyHeight\n    const startY = this.widgets_start_y ?? (\n      (this.widgets_up ? 0 : widgetStartY) + 2\n    )\n\n    let freeSpace = bodyHeight - startY\n\n    // Collect fixed height widgets first\n    let fixedWidgetHeight = 0\n    const growableWidgets: {\n      minHeight: number\n      prefHeight?: number\n      w: IBaseWidget\n    }[] = []\n\n    for (const w of this.widgets) {\n      if (w.computeSize) {\n        const height = w.computeSize()[1] + 4\n        w.computedHeight = height\n        fixedWidgetHeight += height\n      } else if (w.computeLayoutSize) {\n        const { minHeight, maxHeight } = w.computeLayoutSize(this)\n        growableWidgets.push({\n          minHeight,\n          prefHeight: maxHeight,\n          w,\n        })\n      } else {\n        const height = LiteGraph.NODE_WIDGET_HEIGHT + 4\n        w.computedHeight = height\n        fixedWidgetHeight += height\n      }\n    }\n\n    // Calculate remaining space for DOM widgets\n    freeSpace -= fixedWidgetHeight\n    this.freeWidgetSpace = freeSpace\n\n    // Prepare space requests for distribution\n    const spaceRequests = growableWidgets.map(d => ({\n      minSize: d.minHeight,\n      maxSize: d.prefHeight,\n    }))\n\n    // Distribute space among DOM widgets\n    const allocations = distributeSpace(Math.max(0, freeSpace), spaceRequests)\n\n    // Apply computed heights\n    for (const [i, d] of growableWidgets.entries()) {\n      d.w.computedHeight = allocations[i]\n    }\n\n    // Position widgets\n    let y = startY\n    for (const w of this.widgets) {\n      w.y = y\n      y += w.computedHeight ?? 0\n    }\n\n    if (!this.graph) throw new NullGraphError()\n\n    // Grow the node if necessary.\n    // Ref: https://github.com/Comfy-Org/ComfyUI_frontend/issues/2652\n    // TODO: Move the layout logic before drawing of the node shape, so we don't\n    // need to trigger extra round of rendering.\n    if (y > bodyHeight) {\n      this.setSize([this.size[0], y])\n      this.graph.setDirtyCanvas(false, true)\n    }\n  }\n\n  /**\n   * Arranges the layout of the node's widget input slots.\n   */\n  #arrangeWidgetInputSlots(): void {\n    if (!this.widgets) return\n\n    const slotByWidgetName = new Map<string, INodeInputSlot & { index: number }>()\n\n    for (const [i, slot] of this.inputs.entries()) {\n      if (!isWidgetInputSlot(slot)) continue\n\n      slotByWidgetName.set(slot.widget.name, { ...slot, index: i })\n    }\n    if (!slotByWidgetName.size) return\n\n    for (const widget of this.widgets) {\n      const slot = slotByWidgetName.get(widget.name)\n      if (!slot) continue\n\n      const actualSlot = this.#concreteInputs[slot.index]\n      const offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5\n      actualSlot.pos = [offset, widget.y + offset]\n      this.#measureSlot(actualSlot, slot.index, true)\n    }\n  }\n\n  /**\n   * @internal Sets the internal concrete slot arrays, ensuring they are instances of\n   * {@link NodeInputSlot} or {@link NodeOutputSlot}.\n   *\n   * A temporary workaround until duck-typed inputs and outputs\n   * have been removed from the ecosystem.\n   */\n  _setConcreteSlots(): void {\n    this.#concreteInputs = this.inputs.map(slot => toClass(NodeInputSlot, slot, this))\n    this.#concreteOutputs = this.outputs.map(slot => toClass(NodeOutputSlot, slot, this))\n  }\n\n  /**\n   * Arranges node elements in preparation for rendering (slots & widgets).\n   */\n  arrange(): void {\n    const slotsBounds = this.#measureSlots()\n    const widgetStartY = slotsBounds ? slotsBounds[1] + slotsBounds[3] - this.pos[1] : 0\n    this.#arrangeWidgets(widgetStartY)\n    this.#arrangeWidgetInputSlots()\n  }\n\n  /**\n   * Draws a progress bar on the node.\n   * @param ctx The canvas context to draw on\n   */\n  drawProgressBar(ctx: CanvasRenderingContext2D): void {\n    if (!this.progress) return\n\n    const originalFillStyle = ctx.fillStyle\n    ctx.fillStyle = \"green\"\n    ctx.fillRect(\n      0,\n      0,\n      this.width * this.progress,\n      6,\n    )\n    ctx.fillStyle = originalFillStyle\n  }\n}\n","import type {\n  ColorOption,\n  IColorable,\n  IContextMenuValue,\n  IPinnable,\n  Point,\n  Positionable,\n  Size,\n} from \"./interfaces\"\nimport type { LGraph } from \"./LGraph\"\nimport type { ISerialisedGroup } from \"./types/serialisation\"\n\nimport { NullGraphError } from \"@/infrastructure/NullGraphError\"\n\nimport { strokeShape } from \"./draw\"\nimport { LGraphCanvas } from \"./LGraphCanvas\"\nimport { LGraphNode } from \"./LGraphNode\"\nimport { LiteGraph } from \"./litegraph\"\nimport {\n  containsCentre,\n  containsRect,\n  createBounds,\n  isInRectangle,\n  isPointInRect,\n  snapPoint,\n} from \"./measure\"\n\nexport interface IGraphGroupFlags extends Record<string, unknown> {\n  pinned?: true\n}\n\nexport class LGraphGroup implements Positionable, IPinnable, IColorable {\n  static minWidth = 140\n  static minHeight = 80\n  static resizeLength = 10\n  static padding = 4\n  static defaultColour = \"#335\"\n\n  id: number\n  color?: string\n  title: string\n  font?: string\n  font_size: number = LiteGraph.DEFAULT_GROUP_FONT || 24\n  _bounding: Float32Array = new Float32Array([\n    10,\n    10,\n    LGraphGroup.minWidth,\n    LGraphGroup.minHeight,\n  ])\n\n  _pos: Point = this._bounding.subarray(0, 2)\n  _size: Size = this._bounding.subarray(2, 4)\n  /** @deprecated See {@link _children} */\n  _nodes: LGraphNode[] = []\n  _children: Set<Positionable> = new Set()\n  graph?: LGraph\n  flags: IGraphGroupFlags = {}\n  selected?: boolean\n\n  constructor(title?: string, id?: number) {\n    // TODO: Object instantiation pattern requires too much boilerplate and null checking.  ID should be passed in via constructor.\n    this.id = id ?? -1\n    this.title = title || \"Group\"\n\n    const { pale_blue } = LGraphCanvas.node_colors\n    this.color = pale_blue ? pale_blue.groupcolor : \"#AAA\"\n  }\n\n  /** @inheritdoc {@link IColorable.setColorOption} */\n  setColorOption(colorOption: ColorOption | null): void {\n    if (colorOption == null) {\n      delete this.color\n    } else {\n      this.color = colorOption.groupcolor\n    }\n  }\n\n  /** @inheritdoc {@link IColorable.getColorOption} */\n  getColorOption(): ColorOption | null {\n    return Object.values(LGraphCanvas.node_colors).find(\n      colorOption => colorOption.groupcolor === this.color,\n    ) ?? null\n  }\n\n  /** Position of the group, as x,y co-ordinates in graph space */\n  get pos() {\n    return this._pos\n  }\n\n  set pos(v) {\n    if (!v || v.length < 2) return\n\n    this._pos[0] = v[0]\n    this._pos[1] = v[1]\n  }\n\n  /** Size of the group, as width,height in graph units */\n  get size() {\n    return this._size\n  }\n\n  set size(v) {\n    if (!v || v.length < 2) return\n\n    this._size[0] = Math.max(LGraphGroup.minWidth, v[0])\n    this._size[1] = Math.max(LGraphGroup.minHeight, v[1])\n  }\n\n  get boundingRect() {\n    return this._bounding\n  }\n\n  get nodes() {\n    return this._nodes\n  }\n\n  get titleHeight() {\n    return this.font_size * 1.4\n  }\n\n  get children(): ReadonlySet<Positionable> {\n    return this._children\n  }\n\n  get pinned() {\n    return !!this.flags.pinned\n  }\n\n  /**\n   * Prevents the group being accidentally moved or resized by mouse interaction.\n   * Toggles pinned state if no value is provided.\n   */\n  pin(value?: boolean): void {\n    const newState = value === undefined ? !this.pinned : value\n\n    if (newState) this.flags.pinned = true\n    else delete this.flags.pinned\n  }\n\n  unpin(): void {\n    this.pin(false)\n  }\n\n  configure(o: ISerialisedGroup): void {\n    this.id = o.id\n    this.title = o.title\n    this._bounding.set(o.bounding)\n    this.color = o.color\n    this.flags = o.flags || this.flags\n    if (o.font_size) this.font_size = o.font_size\n  }\n\n  serialize(): ISerialisedGroup {\n    const b = this._bounding\n    return {\n      id: this.id,\n      title: this.title,\n      bounding: [...b],\n      color: this.color,\n      font_size: this.font_size,\n      flags: this.flags,\n    }\n  }\n\n  /**\n   * Draws the group on the canvas\n   * @param graphCanvas\n   * @param ctx\n   */\n  draw(graphCanvas: LGraphCanvas, ctx: CanvasRenderingContext2D): void {\n    const { padding, resizeLength, defaultColour } = LGraphGroup\n    const font_size = this.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE\n\n    const [x, y] = this._pos\n    const [width, height] = this._size\n    const color = this.color || defaultColour\n\n    // Titlebar\n    ctx.globalAlpha = 0.25 * graphCanvas.editor_alpha\n    ctx.fillStyle = color\n    ctx.strokeStyle = color\n    ctx.beginPath()\n    ctx.rect(x + 0.5, y + 0.5, width, font_size * 1.4)\n    ctx.fill()\n\n    // Group background, border\n    ctx.fillStyle = color\n    ctx.strokeStyle = color\n    ctx.beginPath()\n    ctx.rect(x + 0.5, y + 0.5, width, height)\n    ctx.fill()\n    ctx.globalAlpha = graphCanvas.editor_alpha\n    ctx.stroke()\n\n    // Resize marker\n    ctx.beginPath()\n    ctx.moveTo(x + width, y + height)\n    ctx.lineTo(x + width - resizeLength, y + height)\n    ctx.lineTo(x + width, y + height - resizeLength)\n    ctx.fill()\n\n    // Title\n    ctx.font = `${font_size}px ${LiteGraph.GROUP_FONT}`\n    ctx.textAlign = \"left\"\n    ctx.fillText(this.title + (this.pinned ? \"ð\" : \"\"), x + padding, y + font_size)\n\n    if (LiteGraph.highlight_selected_group && this.selected) {\n      strokeShape(ctx, this._bounding, {\n        title_height: this.titleHeight,\n        padding,\n      })\n    }\n  }\n\n  resize(width: number, height: number): boolean {\n    if (this.pinned) return false\n\n    this._size[0] = Math.max(LGraphGroup.minWidth, width)\n    this._size[1] = Math.max(LGraphGroup.minHeight, height)\n    return true\n  }\n\n  move(deltaX: number, deltaY: number, skipChildren: boolean = false): void {\n    if (this.pinned) return\n\n    this._pos[0] += deltaX\n    this._pos[1] += deltaY\n    if (skipChildren === true) return\n\n    for (const item of this._children) {\n      item.move(deltaX, deltaY)\n    }\n  }\n\n  /** @inheritdoc */\n  snapToGrid(snapTo: number): boolean {\n    return this.pinned ? false : snapPoint(this.pos, snapTo)\n  }\n\n  recomputeInsideNodes(): void {\n    if (!this.graph) throw new NullGraphError()\n    const { nodes, reroutes, groups } = this.graph\n    const children = this._children\n    this._nodes.length = 0\n    children.clear()\n\n    // Move nodes we overlap the centre point of\n    for (const node of nodes) {\n      if (containsCentre(this._bounding, node.boundingRect)) {\n        this._nodes.push(node)\n        children.add(node)\n      }\n    }\n\n    // Move reroutes we overlap the centre point of\n    for (const reroute of reroutes.values()) {\n      if (isPointInRect(reroute.pos, this._bounding))\n        children.add(reroute)\n    }\n\n    // Move groups we wholly contain\n    for (const group of groups) {\n      if (containsRect(this._bounding, group._bounding))\n        children.add(group)\n    }\n\n    groups.sort((a, b) => {\n      if (a === this) {\n        return children.has(b) ? -1 : 0\n      } else if (b === this) {\n        return children.has(a) ? 1 : 0\n      } else {\n        return 0\n      }\n    })\n  }\n\n  /**\n   * Resizes and moves the group to neatly fit all given {@link objects}.\n   * @param objects All objects that should be inside the group\n   * @param padding Value in graph units to add to all sides of the group.  Default: 10\n   */\n  resizeTo(objects: Iterable<Positionable>, padding: number = 10): void {\n    const boundingBox = createBounds(objects, padding)\n    if (boundingBox === null) return\n\n    this.pos[0] = boundingBox[0]\n    this.pos[1] = boundingBox[1] - this.titleHeight\n    this.size[0] = boundingBox[2]\n    this.size[1] = boundingBox[3] + this.titleHeight\n  }\n\n  /**\n   * Add nodes to the group and adjust the group's position and size accordingly\n   * @param nodes The nodes to add to the group\n   * @param padding The padding around the group\n   */\n  addNodes(nodes: LGraphNode[], padding: number = 10): void {\n    if (!this._nodes && nodes.length === 0) return\n    this.resizeTo([...this.children, ...this._nodes, ...nodes], padding)\n  }\n\n  getMenuOptions(): (IContextMenuValue<string> | IContextMenuValue<string | null> | null)[] {\n    return [\n      {\n        content: this.pinned ? \"Unpin\" : \"Pin\",\n        callback: () => {\n          if (this.pinned) this.unpin()\n          else this.pin()\n          this.setDirtyCanvas(false, true)\n        },\n      },\n      null,\n      { content: \"Title\", callback: LGraphCanvas.onShowPropertyEditor },\n      {\n        content: \"Color\",\n        has_submenu: true,\n        callback: LGraphCanvas.onMenuNodeColors,\n      },\n      {\n        content: \"Font size\",\n        property: \"font_size\",\n        type: \"Number\",\n        callback: LGraphCanvas.onShowPropertyEditor,\n      },\n      null,\n      { content: \"Remove\", callback: LGraphCanvas.onMenuNodeRemove },\n    ]\n  }\n\n  isPointInTitlebar(x: number, y: number): boolean {\n    const b = this.boundingRect\n    return isInRectangle(x, y, b[0], b[1], b[2], this.titleHeight)\n  }\n\n  isInResize(x: number, y: number): boolean {\n    const b = this.boundingRect\n    const right = b[0] + b[2]\n    const bottom = b[1] + b[3]\n\n    return (\n      x < right &&\n      y < bottom &&\n      x - right + (y - bottom) > -LGraphGroup.resizeLength\n    )\n  }\n\n  isPointInside = LGraphNode.prototype.isPointInside\n  setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas\n}\n","import type {\n  CanvasColour,\n  INodeInputSlot,\n  INodeOutputSlot,\n  LinkNetwork,\n  LinkSegment,\n  Point,\n  Positionable,\n  ReadonlyLinkNetwork,\n  ReadOnlyRect,\n} from \"./interfaces\"\nimport type { LGraphNode, NodeId } from \"./LGraphNode\"\nimport type { Serialisable, SerialisableReroute } from \"./types/serialisation\"\n\nimport { LGraphBadge } from \"./LGraphBadge\"\nimport { type LinkId, LLink } from \"./LLink\"\nimport { distance, isPointInRect } from \"./measure\"\n\nexport type RerouteId = number\n\n/** The input or output slot that an incomplete reroute link is connected to. */\nexport interface FloatingRerouteSlot {\n  /** Floating connection to an input or output */\n  slotType: \"input\" | \"output\"\n}\n\n/**\n * Represents an additional point on the graph that a link path will travel through.  Used for visual organisation only.\n *\n * Requires no disposal or clean up.\n * Stores only primitive values (IDs) to reference other items in its network,\n * and a `WeakRef` to a {@link LinkNetwork} to resolve them.\n */\nexport class Reroute implements Positionable, LinkSegment, Serialisable<SerialisableReroute> {\n  static radius: number = 10\n  /** Maximum distance from reroutes to their bezier curve control points. */\n  static maxSplineOffset: number = 80\n  static drawIdBadge: boolean = false\n  static slotRadius: number = 5\n  /** Distance from reroute centre to slot centre. */\n  static get slotOffset(): number {\n    const gap = Reroute.slotRadius * 0.33\n    return Reroute.radius + gap + Reroute.slotRadius\n  }\n\n  #malloc = new Float32Array(8)\n\n  /** The network this reroute belongs to.  Contains all valid links and reroutes. */\n  #network: WeakRef<LinkNetwork>\n\n  #parentId?: RerouteId\n  public get parentId(): RerouteId | undefined {\n    return this.#parentId\n  }\n\n  /** Ignores attempts to create an infinite loop. @inheritdoc */\n  public set parentId(value) {\n    if (value === this.id) return\n    if (this.getReroutes() === null) return\n    this.#parentId = value\n  }\n\n  public get parent(): Reroute | undefined {\n    return this.#network.deref()?.getReroute(this.#parentId)\n  }\n\n  /** This property is only defined on the last reroute of a floating reroute chain (closest to input end). */\n  floating?: FloatingRerouteSlot\n\n  #pos = this.#malloc.subarray(0, 2)\n  /** @inheritdoc */\n  get pos(): Point {\n    return this.#pos\n  }\n\n  set pos(value: Point) {\n    if (!(value?.length >= 2))\n      throw new TypeError(\"Reroute.pos is an x,y point, and expects an indexable with at least two values.\")\n    this.#pos[0] = value[0]\n    this.#pos[1] = value[1]\n  }\n\n  /** @inheritdoc */\n  get boundingRect(): ReadOnlyRect {\n    const { radius } = Reroute\n    const [x, y] = this.#pos\n    return [x - radius, y - radius, 2 * radius, 2 * radius]\n  }\n\n  /**\n   * Slightly over-sized rectangle, guaranteed to contain the entire surface area for hover detection.\n   * Eliminates most hover positions using an extremely cheap check.\n   */\n  get #hoverArea(): ReadOnlyRect {\n    const xOffset = 2 * Reroute.slotOffset\n    const yOffset = 2 * Math.max(Reroute.radius, Reroute.slotRadius)\n\n    const [x, y] = this.#pos\n    return [x - xOffset, y - yOffset, 2 * xOffset, 2 * yOffset]\n  }\n\n  /** The total number of links & floating links using this reroute */\n  get totalLinks(): number {\n    return this.linkIds.size + this.floatingLinkIds.size\n  }\n\n  /** @inheritdoc */\n  selected?: boolean\n\n  /** The ID ({@link LLink.id}) of every link using this reroute */\n  linkIds: Set<LinkId>\n\n  /** The ID ({@link LLink.id}) of every floating link using this reroute */\n  floatingLinkIds: Set<LinkId>\n\n  /** Cached cos */\n  cos: number = 0\n  sin: number = 0\n\n  /** Bezier curve control point for the \"target\" (input) side of the link */\n  controlPoint: Point = this.#malloc.subarray(4, 6)\n\n  /** @inheritdoc */\n  path?: Path2D\n  /** @inheritdoc */\n  _centreAngle?: number\n  /** @inheritdoc */\n  _pos: Float32Array = this.#malloc.subarray(6, 8)\n\n  /** @inheritdoc */\n  _dragging?: boolean\n\n  /** Colour of the first link that rendered this reroute */\n  _colour?: CanvasColour\n\n  /** Colour of the first link that rendered this reroute */\n  get colour(): CanvasColour {\n    return this._colour ?? \"#18184d\"\n  }\n\n  /**\n   * Used to ensure reroute angles are only executed once per frame.\n   * @todo Calculate on change instead.\n   */\n  #lastRenderTime: number = -Infinity\n\n  #inputSlot = new RerouteSlot(this, true)\n  #outputSlot = new RerouteSlot(this, false)\n\n  get isSlotHovered(): boolean {\n    return this.isInputHovered || this.isOutputHovered\n  }\n\n  get isInputHovered(): boolean {\n    return this.#inputSlot.hovering\n  }\n\n  get isOutputHovered(): boolean {\n    return this.#outputSlot.hovering\n  }\n\n  get firstLink(): LLink | undefined {\n    const linkId = this.linkIds.values().next().value\n    return linkId === undefined\n      ? undefined\n      : this.#network\n        .deref()\n        ?.links\n        .get(linkId)\n  }\n\n  get firstFloatingLink(): LLink | undefined {\n    const linkId = this.floatingLinkIds.values().next().value\n    return linkId === undefined\n      ? undefined\n      : this.#network\n        .deref()\n        ?.floatingLinks\n        .get(linkId)\n  }\n\n  /** @inheritdoc */\n  get origin_id(): NodeId | undefined {\n    return this.firstLink?.origin_id\n  }\n\n  /** @inheritdoc */\n  get origin_slot(): number | undefined {\n    return this.firstLink?.origin_slot\n  }\n\n  /**\n   * Initialises a new link reroute object.\n   * @param id Unique identifier for this reroute\n   * @param network The network of links this reroute belongs to.  Internally converted to a WeakRef.\n   * @param pos Position in graph coordinates\n   * @param linkIds Link IDs ({@link LLink.id}) of all links that use this reroute\n   */\n  constructor(\n    public readonly id: RerouteId,\n    network: LinkNetwork,\n    pos?: Point,\n    parentId?: RerouteId,\n    linkIds?: Iterable<LinkId>,\n    floatingLinkIds?: Iterable<LinkId>,\n  ) {\n    this.#network = new WeakRef(network)\n    this.parentId = parentId\n    if (pos) this.pos = pos\n    this.linkIds = new Set(linkIds)\n    this.floatingLinkIds = new Set(floatingLinkIds)\n  }\n\n  /**\n   * Applies a new parentId to the reroute, and optinoally a new position and linkId.\n   * Primarily used for deserialisation.\n   * @param parentId The ID of the reroute prior to this reroute, or\n   * `undefined` if it is the first reroute connected to a nodes output\n   * @param pos The position of this reroute\n   * @param linkIds All link IDs that pass through this reroute\n   */\n  update(\n    parentId: RerouteId | undefined,\n    pos?: Point,\n    linkIds?: Iterable<LinkId>,\n    floating?: FloatingRerouteSlot,\n  ): void {\n    this.parentId = parentId\n    if (pos) this.pos = pos\n    if (linkIds) this.linkIds = new Set(linkIds)\n    this.floating = floating\n  }\n\n  /**\n   * Validates the linkIds this reroute has.  Removes broken links.\n   * @param links Collection of valid links\n   * @returns true if any links remain after validation\n   */\n  validateLinks(links: ReadonlyMap<LinkId, LLink>, floatingLinks: ReadonlyMap<LinkId, LLink>): boolean {\n    const { linkIds, floatingLinkIds } = this\n    for (const linkId of linkIds) {\n      if (!links.has(linkId)) linkIds.delete(linkId)\n    }\n    for (const linkId of floatingLinkIds) {\n      if (!floatingLinks.has(linkId)) floatingLinkIds.delete(linkId)\n    }\n    return linkIds.size > 0 || floatingLinkIds.size > 0\n  }\n\n  /**\n   * Retrieves an ordered array of all reroutes from the node output.\n   * @param visited Internal.  A set of reroutes that this function\n   * has already visited whilst recursing up the chain.\n   * @returns An ordered array of all reroutes from the node output to this reroute, inclusive.\n   * `null` if an infinite loop is detected.\n   * `undefined` if the reroute chain or {@link LinkNetwork} are invalid.\n   */\n  getReroutes(visited = new Set<Reroute>()): Reroute[] | null {\n    // No parentId - last in the chain\n    if (this.#parentId === undefined) return [this]\n    // Invalid chain - looped\n    if (visited.has(this)) return null\n    visited.add(this)\n\n    const parent = this.#network.deref()?.reroutes.get(this.#parentId)\n    // Invalid parent (or network) - drop silently to recover\n    if (!parent) {\n      this.#parentId = undefined\n      return [this]\n    }\n\n    const reroutes = parent.getReroutes(visited)\n    reroutes?.push(this)\n    return reroutes\n  }\n\n  /**\n   * Internal.  Called by {@link LLink.findNextReroute}.  Not intended for use by itself.\n   * @param withParentId The rerouteId to look for\n   * @param visited A set of reroutes that have already been visited\n   * @returns The reroute that was found, `undefined` if no reroute was found, or `null` if an infinite loop was detected.\n   */\n  findNextReroute(\n    withParentId: RerouteId,\n    visited = new Set<Reroute>(),\n  ): Reroute | null | undefined {\n    if (this.#parentId === withParentId) return this\n    if (visited.has(this)) return null\n    visited.add(this)\n    if (this.#parentId === undefined) return\n\n    return this.#network\n      .deref()\n      ?.reroutes\n      .get(this.#parentId)\n      ?.findNextReroute(withParentId, visited)\n  }\n\n  /**\n   * Finds the output node and output slot of the first link passing through this reroute.\n   * @returns The output node and output slot of the first link passing through this reroute, or `undefined` if no link is found.\n   */\n  findSourceOutput(): { node: LGraphNode, output: INodeOutputSlot } | undefined {\n    const link = this.firstLink ?? this.firstFloatingLink\n    if (!link) return\n\n    const node = this.#network.deref()?.getNodeById(link.origin_id)\n    if (!node) return\n\n    return {\n      node,\n      output: node.outputs[link.origin_slot],\n    }\n  }\n\n  /**\n   * Finds the inputs and nodes of (floating) links passing through this reroute.\n   * @returns An array of objects containing the node and input slot of each link passing through this reroute.\n   */\n  findTargetInputs(): { node: LGraphNode, input: INodeInputSlot, link: LLink }[] | undefined {\n    const network = this.#network.deref()\n    if (!network) return\n\n    const results: {\n      node: LGraphNode\n      input: INodeInputSlot\n      link: LLink\n    }[] = []\n\n    addAllResults(network, this.linkIds, network.links)\n    addAllResults(network, this.floatingLinkIds, network.floatingLinks)\n\n    return results\n\n    function addAllResults(\n      network: ReadonlyLinkNetwork,\n      linkIds: Iterable<LinkId>,\n      links: ReadonlyMap<LinkId, LLink>,\n    ) {\n      for (const linkId of linkIds) {\n        const link = links.get(linkId)\n        if (!link) continue\n\n        const node = network.getNodeById(link.target_id)\n        const input = node?.inputs[link.target_slot]\n        if (!input) continue\n\n        results.push({ node, input, link })\n      }\n    }\n  }\n\n  /**\n   * Retrieves all floating links passing through this reroute.\n   * @param from Filters the links by the currently connected link side.\n   * @returns An array of floating links\n   */\n  getFloatingLinks(from: \"input\" | \"output\"): LLink[] | undefined {\n    const floatingLinks = this.#network.deref()?.floatingLinks\n    if (!floatingLinks) return\n\n    const idProp = from === \"input\" ? \"origin_id\" : \"target_id\"\n    const out: LLink[] = []\n\n    for (const linkId of this.floatingLinkIds) {\n      const link = floatingLinks.get(linkId)\n      if (link?.[idProp] === -1) out.push(link)\n    }\n    return out\n  }\n\n  /**\n   * Changes the origin node/output of all floating links that pass through this reroute.\n   * @param node The new origin node\n   * @param output The new origin output slot\n   * @param index The slot index of {@link output}\n   */\n  setFloatingLinkOrigin(node: LGraphNode, output: INodeOutputSlot, index: number) {\n    const network = this.#network.deref()\n    const floatingOutLinks = this.getFloatingLinks(\"output\")\n    if (!floatingOutLinks) throw new Error(\"[setFloatingLinkOrigin]: Invalid network.\")\n    if (!floatingOutLinks.length) return\n\n    output._floatingLinks ??= new Set()\n\n    for (const link of floatingOutLinks) {\n      // Update cached floating links\n      output._floatingLinks.add(link)\n\n      network?.getNodeById(link.origin_id)\n        ?.outputs[link.origin_slot]\n        ?._floatingLinks\n        ?.delete(link)\n\n      // Update the floating link\n      link.origin_id = node.id\n      link.origin_slot = index\n    }\n  }\n\n  /** @inheritdoc */\n  move(deltaX: number, deltaY: number) {\n    this.#pos[0] += deltaX\n    this.#pos[1] += deltaY\n  }\n\n  /** @inheritdoc */\n  snapToGrid(snapTo: number): boolean {\n    if (!snapTo) return false\n\n    const { pos } = this\n    pos[0] = snapTo * Math.round(pos[0] / snapTo)\n    pos[1] = snapTo * Math.round(pos[1] / snapTo)\n    return true\n  }\n\n  removeAllFloatingLinks() {\n    for (const linkId of this.floatingLinkIds) {\n      this.removeFloatingLink(linkId)\n    }\n  }\n\n  removeFloatingLink(linkId: LinkId) {\n    const network = this.#network.deref()\n    if (!network) return\n\n    const floatingLink = network.floatingLinks.get(linkId)\n    if (!floatingLink) {\n      console.warn(`[Reroute.removeFloatingLink] Floating link not found: ${linkId}, ignoring and discarding ID.`)\n      this.floatingLinkIds.delete(linkId)\n      return\n    }\n\n    network.removeFloatingLink(floatingLink)\n  }\n\n  /**\n   * Removes a link or floating link from this reroute, by matching link object instance equality.\n   * @param link The link to remove.\n   * @remarks Does not remove the link from the network.\n   */\n  removeLink(link: LLink) {\n    const network = this.#network.deref()\n    if (!network) return\n\n    const floatingLink = network.floatingLinks.get(link.id)\n    if (link === floatingLink) {\n      this.floatingLinkIds.delete(link.id)\n    } else {\n      this.linkIds.delete(link.id)\n    }\n  }\n\n  remove() {\n    const network = this.#network.deref()\n    if (!network) return\n\n    network.removeReroute(this.id)\n  }\n\n  calculateAngle(lastRenderTime: number, network: ReadonlyLinkNetwork, linkStart: Point): void {\n    // Ensure we run once per render\n    if (!(lastRenderTime > this.#lastRenderTime)) return\n    this.#lastRenderTime = lastRenderTime\n\n    const { id, pos: thisPos } = this\n\n    // Add all link angles\n    const angles: number[] = []\n    let sum = 0\n    calculateAngles(this.linkIds, network.links)\n    calculateAngles(this.floatingLinkIds, network.floatingLinks)\n\n    // Invalid - reset\n    if (!angles.length) {\n      this.cos = 0\n      this.sin = 0\n      this.controlPoint[0] = 0\n      this.controlPoint[1] = 0\n      return\n    }\n\n    sum /= angles.length\n\n    const originToReroute = Math.atan2(\n      this.#pos[1] - linkStart[1],\n      this.#pos[0] - linkStart[0],\n    )\n    let diff = (originToReroute - sum) * 0.5\n    if (Math.abs(diff) > Math.PI * 0.5) diff += Math.PI\n    const dist = Math.min(Reroute.maxSplineOffset, distance(linkStart, this.#pos) * 0.25)\n\n    // Store results\n    const originDiff = originToReroute - diff\n    const cos = Math.cos(originDiff)\n    const sin = Math.sin(originDiff)\n\n    this.cos = cos\n    this.sin = sin\n    this.controlPoint[0] = dist * -cos\n    this.controlPoint[1] = dist * -sin\n\n    /**\n     * Calculates the direction of each link and adds it to the array.\n     * @param linkIds The IDs of the links to calculate\n     * @param links The link container from the link network.\n     */\n    function calculateAngles(linkIds: Iterable<LinkId>, links: ReadonlyMap<LinkId, LLink>) {\n      for (const linkId of linkIds) {\n        const link = links.get(linkId)\n        const pos = getNextPos(network, link, id)\n        if (!pos) continue\n\n        const angle = getDirection(thisPos, pos)\n        angles.push(angle)\n        sum += angle\n      }\n    }\n  }\n\n  /**\n   * Renders the reroute on the canvas.\n   * @param ctx Canvas context to draw on\n   * @param backgroundPattern The canvas background pattern; used to make floating reroutes appear washed out.\n   * @remarks Leaves {@link ctx}.fillStyle, strokeStyle, and lineWidth dirty (perf.).\n   */\n  draw(ctx: CanvasRenderingContext2D, backgroundPattern?: CanvasPattern): void {\n    const { globalAlpha } = ctx\n    const { pos } = this\n\n    ctx.beginPath()\n    ctx.arc(pos[0], pos[1], Reroute.radius, 0, 2 * Math.PI)\n\n    if (this.linkIds.size === 0) {\n      ctx.fillStyle = backgroundPattern ?? \"#797979\"\n      ctx.fill()\n      ctx.globalAlpha = globalAlpha * 0.33\n    }\n\n    ctx.fillStyle = this.colour\n    ctx.lineWidth = Reroute.radius * 0.1\n    ctx.strokeStyle = \"rgb(0,0,0,0.5)\"\n    ctx.fill()\n    ctx.stroke()\n\n    ctx.fillStyle = \"#ffffff55\"\n    ctx.strokeStyle = \"rgb(0,0,0,0.3)\"\n    ctx.beginPath()\n    ctx.arc(pos[0], pos[1], Reroute.radius * 0.8, 0, 2 * Math.PI)\n    ctx.fill()\n    ctx.stroke()\n\n    if (this.selected) {\n      ctx.strokeStyle = \"#fff\"\n      ctx.beginPath()\n      ctx.arc(pos[0], pos[1], Reroute.radius * 1.2, 0, 2 * Math.PI)\n      ctx.stroke()\n    }\n\n    if (Reroute.drawIdBadge) {\n      const idBadge = new LGraphBadge({ text: this.id.toString() })\n      const x = pos[0] - idBadge.getWidth(ctx) * 0.5\n      const y = pos[1] - idBadge.height - Reroute.radius - 2\n      idBadge.draw(ctx, x, y)\n    }\n\n    ctx.globalAlpha = globalAlpha\n  }\n\n  /**\n   * Draws the input and output slots on the canvas, if the slots are visible.\n   * @param ctx The canvas context to draw on.\n   */\n  drawSlots(ctx: CanvasRenderingContext2D): void {\n    this.#inputSlot.draw(ctx)\n    this.#outputSlot.draw(ctx)\n  }\n\n  drawHighlight(ctx: CanvasRenderingContext2D, colour: CanvasColour): void {\n    const { pos } = this\n\n    const { strokeStyle, lineWidth } = ctx\n    ctx.strokeStyle = colour\n    ctx.lineWidth = 1\n\n    ctx.beginPath()\n    ctx.arc(pos[0], pos[1], Reroute.radius * 1.5, 0, 2 * Math.PI)\n    ctx.stroke()\n\n    ctx.strokeStyle = strokeStyle\n    ctx.lineWidth = lineWidth\n  }\n\n  /**\n   * Updates visibility of the input and output slots, based on the position of the pointer.\n   * @param pos The position of the pointer.\n   * @returns `true` if any changes require a redraw.\n   */\n  updateVisibility(pos: Point): boolean {\n    const input = this.#inputSlot\n    const output = this.#outputSlot\n    input.dirty = false\n    output.dirty = false\n\n    const { firstFloatingLink } = this\n    const hasLink = !!this.firstLink\n\n    const showInput = hasLink || firstFloatingLink?.isFloatingOutput\n    const showOutput = hasLink || firstFloatingLink?.isFloatingInput\n    const showEither = showInput || showOutput\n\n    // Check if even in the vicinity\n    if (showEither && isPointInRect(pos, this.#hoverArea)) {\n      const outlineOnly = this.#contains(pos)\n\n      if (showInput) input.update(pos, outlineOnly)\n      if (showOutput) output.update(pos, outlineOnly)\n    } else {\n      this.hideSlots()\n    }\n\n    return input.dirty || output.dirty\n  }\n\n  /** Prevents rendering of the input and output slots. */\n  hideSlots() {\n    this.#inputSlot.hide()\n    this.#outputSlot.hide()\n  }\n\n  /**\n   * Precisely determines if {@link pos} is inside this reroute.\n   * @param pos The position to check (canvas space)\n   * @returns `true` if {@link pos} is within the reroute's radius.\n   */\n  containsPoint(pos: Point): boolean {\n    return isPointInRect(pos, this.#hoverArea) && this.#contains(pos)\n  }\n\n  #contains(pos: Point): boolean {\n    return distance(this.pos, pos) <= Reroute.radius\n  }\n\n  /** @inheritdoc */\n  asSerialisable(): SerialisableReroute {\n    const { id, parentId, pos, linkIds } = this\n    return {\n      id,\n      parentId,\n      pos: [pos[0], pos[1]],\n      linkIds: [...linkIds],\n      floating: this.floating ? { slotType: this.floating.slotType } : undefined,\n    }\n  }\n}\n\n/**\n * Represents a slot on a reroute.\n * @private Designed for internal use within this module.\n */\nclass RerouteSlot {\n  /** The reroute that the slot belongs to. */\n  readonly #reroute: Reroute\n\n  readonly #offsetMultiplier: 1 | -1\n  /** Centre point of this slot. */\n  get pos(): Point {\n    const [x, y] = this.#reroute.pos\n    return [x + Reroute.slotOffset * this.#offsetMultiplier, y]\n  }\n\n  /** Whether any changes require a redraw. */\n  dirty: boolean = false\n\n  #hovering = false\n  /** Whether the pointer is hovering over the slot itself. */\n  get hovering() {\n    return this.#hovering\n  }\n\n  set hovering(value) {\n    if (!Object.is(this.#hovering, value)) {\n      this.#hovering = value\n      this.dirty = true\n    }\n  }\n\n  #showOutline = false\n  /** Whether the slot outline / faint background is visible. */\n  get showOutline() {\n    return this.#showOutline\n  }\n\n  set showOutline(value) {\n    if (!Object.is(this.#showOutline, value)) {\n      this.#showOutline = value\n      this.dirty = true\n    }\n  }\n\n  constructor(reroute: Reroute, isInput: boolean) {\n    this.#reroute = reroute\n    this.#offsetMultiplier = isInput ? -1 : 1\n  }\n\n  /**\n   * Updates the slot's visibility based on the position of the pointer.\n   * @param pos The position of the pointer.\n   * @param outlineOnly If `true`, slot will display with the faded outline only ({@link showOutline}).\n   */\n  update(pos: Point, outlineOnly?: boolean) {\n    if (outlineOnly) {\n      this.hovering = false\n      this.showOutline = true\n    } else {\n      const dist = distance(this.pos, pos)\n      this.hovering = dist <= 2 * Reroute.slotRadius\n      this.showOutline = dist <= 5 * Reroute.slotRadius\n    }\n  }\n\n  /** Hides the slot. */\n  hide() {\n    this.hovering = false\n    this.showOutline = false\n  }\n\n  /**\n   * Draws the slot on the canvas.\n   * @param ctx The canvas context to draw on.\n   */\n  draw(ctx: CanvasRenderingContext2D): void {\n    const { fillStyle, strokeStyle, lineWidth } = ctx\n    const { showOutline, hovering, pos: [x, y] } = this\n    if (!showOutline) return\n\n    try {\n      ctx.fillStyle = hovering\n        ? this.#reroute.colour\n        : \"rgba(127,127,127,0.3)\"\n      ctx.strokeStyle = \"rgb(0,0,0,0.5)\"\n      ctx.lineWidth = 1\n\n      ctx.beginPath()\n      ctx.arc(x, y, Reroute.slotRadius, 0, 2 * Math.PI)\n      ctx.fill()\n      ctx.stroke()\n    } finally {\n      ctx.fillStyle = fillStyle\n      ctx.strokeStyle = strokeStyle\n      ctx.lineWidth = lineWidth\n    }\n  }\n}\n\n/**\n * Retrieves the position of the next reroute in the chain, or the destination input slot on this link.\n * @param network The network of links\n * @param link The link representing the current reroute chain\n * @param id The ID of \"this\" reroute\n * @returns The position of the next reroute or the input slot target, otherwise `undefined`.\n */\nfunction getNextPos(network: ReadonlyLinkNetwork, link: LLink | undefined, id: RerouteId) {\n  if (!link) return\n\n  const linkPos = LLink.findNextReroute(network, link, id)?.pos\n  if (linkPos) return linkPos\n\n  // Floating link with no input to find\n  if (link.target_id === -1 || link.target_slot === -1) return\n\n  return network.getNodeById(link.target_id)?.getInputPos(link.target_slot)\n}\n\n/** Returns the direction from one point to another in radians. */\nfunction getDirection(fromPos: Point, toPos: Point) {\n  return Math.atan2(toPos[1] - fromPos[1], toPos[0] - fromPos[0])\n}\n","import type { Direction, IBoundaryNodes } from \"../interfaces\"\nimport type { LGraphNode } from \"../LGraphNode\"\n\n/**\n * Finds the nodes that are farthest in all four directions, representing the boundary of the nodes.\n * @param nodes The nodes to check the edges of\n * @returns An object listing the furthest node (edge) in all four directions.\n * `null` if no nodes were supplied or the first node was falsy.\n */\nexport function getBoundaryNodes(nodes: LGraphNode[]): IBoundaryNodes | null {\n  const valid = nodes?.find(x => x)\n  if (!valid) return null\n\n  let top = valid\n  let right = valid\n  let bottom = valid\n  let left = valid\n\n  for (const node of nodes) {\n    if (!node) continue\n    const [x, y] = node.pos\n    const [width, height] = node.size\n\n    if (y < top.pos[1]) top = node\n    if (x + width > right.pos[0] + right.size[0]) right = node\n    if (y + height > bottom.pos[1] + bottom.size[1]) bottom = node\n    if (x < left.pos[0]) left = node\n  }\n\n  return {\n    top,\n    right,\n    bottom,\n    left,\n  }\n}\n\n/**\n * Distributes nodes evenly along a horizontal or vertical plane.\n * @param nodes The nodes to distribute\n * @param horizontal If true, distributes along the horizontal plane.  Otherwise, the vertical plane.\n */\nexport function distributeNodes(nodes: LGraphNode[], horizontal?: boolean): void {\n  const nodeCount = nodes?.length\n  if (!(nodeCount > 1)) return\n\n  const index = horizontal ? 0 : 1\n\n  let total = 0\n  let highest = -Infinity\n\n  for (const node of nodes) {\n    total += node.size[index]\n\n    const high = node.pos[index] + node.size[index]\n    if (high > highest) highest = high\n  }\n  const sorted = [...nodes].sort((a, b) => a.pos[index] - b.pos[index])\n  const lowest = sorted[0].pos[index]\n\n  const gap = (highest - lowest - total) / (nodeCount - 1)\n  let startAt = lowest\n  for (let i = 0; i < nodeCount; i++) {\n    const node = sorted[i]\n    node.pos[index] = startAt + gap * i\n    startAt += node.size[index]\n  }\n}\n\n/**\n * Aligns all nodes along the edge of a node.\n * @param nodes The nodes to align\n * @param direction The edge to align nodes on\n * @param align_to The node to align all other nodes to.  If undefined, the farthest node will be used.\n */\nexport function alignNodes(\n  nodes: LGraphNode[],\n  direction: Direction,\n  align_to?: LGraphNode,\n): void {\n  if (!nodes) return\n\n  const boundary = align_to === undefined\n    ? getBoundaryNodes(nodes)\n    : { top: align_to, right: align_to, bottom: align_to, left: align_to }\n\n  if (boundary === null) return\n\n  for (const node of nodes) {\n    switch (direction) {\n    case \"right\":\n      node.pos[0] = boundary.right.pos[0] + boundary.right.size[0] - node.size[0]\n      break\n    case \"left\":\n      node.pos[0] = boundary.left.pos[0]\n      break\n    case \"top\":\n      node.pos[1] = boundary.top.pos[1]\n      break\n    case \"bottom\":\n      node.pos[1] = boundary.bottom.pos[1] + boundary.bottom.size[1] - node.size[1]\n      break\n    }\n  }\n}\n","import type { ContextMenu } from \"./ContextMenu\"\nimport type { LGraphCanvasEventMap } from \"./infrastructure/LGraphCanvasEventMap\"\nimport type {\n  CanvasColour,\n  ColorOption,\n  ConnectingLink,\n  ContextMenuDivElement,\n  DefaultConnectionColors,\n  Dictionary,\n  Direction,\n  IBoundaryNodes,\n  IColorable,\n  IContextMenuOptions,\n  IContextMenuValue,\n  INodeInputSlot,\n  INodeOutputSlot,\n  INodeSlot,\n  INodeSlotContextItem,\n  ISlotType,\n  LinkSegment,\n  NullableProperties,\n  Point,\n  Positionable,\n  ReadOnlyPoint,\n  ReadOnlyRect,\n  Rect,\n  Size,\n} from \"./interfaces\"\nimport type { LGraph } from \"./LGraph\"\nimport type {\n  CanvasMouseEvent,\n  CanvasPointerEvent,\n  CanvasPointerExtensions,\n} from \"./types/events\"\nimport type { ClipboardItems } from \"./types/serialisation\"\nimport type { IBaseWidget } from \"./types/widgets\"\n\nimport { LinkConnector } from \"@/canvas/LinkConnector\"\n\nimport { isOverNodeInput, isOverNodeOutput } from \"./canvas/measureSlots\"\nimport { CanvasPointer } from \"./CanvasPointer\"\nimport { type AnimationOptions, DragAndScale } from \"./DragAndScale\"\nimport { strokeShape } from \"./draw\"\nimport { NullGraphError } from \"./infrastructure/NullGraphError\"\nimport { LGraphGroup } from \"./LGraphGroup\"\nimport { LGraphNode, type NodeId, type NodeProperty } from \"./LGraphNode\"\nimport { LiteGraph, type Rectangle } from \"./litegraph\"\nimport { type LinkId, LLink } from \"./LLink\"\nimport {\n  containsRect,\n  createBounds,\n  distance,\n  findPointOnCurve,\n  isInRect,\n  isInRectangle,\n  isPointInRect,\n  overlapBounding,\n  snapPoint,\n} from \"./measure\"\nimport { NodeInputSlot } from \"./node/NodeInputSlot\"\nimport { Reroute, type RerouteId } from \"./Reroute\"\nimport { stringOrEmpty } from \"./strings\"\nimport { Subgraph } from \"./subgraph/Subgraph\"\nimport {\n  CanvasItem,\n  LGraphEventMode,\n  LinkDirection,\n  LinkMarkerShape,\n  LinkRenderType,\n  RenderShape,\n  TitleMode,\n} from \"./types/globalEnums\"\nimport { alignNodes, distributeNodes, getBoundaryNodes } from \"./utils/arrange\"\nimport { findFirstNode, getAllNestedItems } from \"./utils/collections\"\nimport { BaseWidget } from \"./widgets/BaseWidget\"\nimport { toConcreteWidget } from \"./widgets/widgetMap\"\n\ninterface IShowSearchOptions {\n  node_to?: LGraphNode | null\n  node_from?: LGraphNode | null\n  slot_from: number | INodeOutputSlot | INodeInputSlot | null | undefined\n  type_filter_in?: ISlotType\n  type_filter_out?: ISlotType | false\n\n  // TODO check for registered_slot_[in/out]_types not empty // this will be checked for functionality enabled : filter on slot type, in and out\n  do_type_filter?: boolean\n  show_general_if_none_on_typefilter?: boolean\n  show_general_after_typefiltered?: boolean\n  hide_on_mouse_leave?: boolean\n  show_all_if_empty?: boolean\n  show_all_on_open?: boolean\n}\n\ninterface ICreateNodeOptions {\n  /** input */\n  nodeFrom?: LGraphNode | null\n  /** input */\n  slotFrom?: number | INodeOutputSlot | INodeInputSlot | null\n  /** output */\n  nodeTo?: LGraphNode | null\n  /** output */\n  slotTo?: number | INodeOutputSlot | INodeInputSlot | null\n  /** pass the event coords */\n\n  /** Create the connection from a reroute */\n  afterRerouteId?: RerouteId\n\n  // FIXME: Should not be optional\n  /** choose a nodetype to add, AUTO to set at first good */\n  nodeType?: string\n  e?: CanvasMouseEvent\n  allow_searchbox?: boolean\n}\n\ninterface ICreateDefaultNodeOptions extends ICreateNodeOptions {\n  /** Position of new node */\n  position: Point\n  /** adjust x,y */\n  posAdd?: Point\n  /** alpha, adjust the position x,y based on the new node size w,h */\n  posSizeFix?: Point\n}\n\ninterface HasShowSearchCallback {\n  /** See {@link LGraphCanvas.showSearchBox} */\n  showSearchBox: (\n    event: MouseEvent,\n    options?: IShowSearchOptions,\n  ) => HTMLDivElement | void\n}\n\ninterface ICloseable {\n  close(): void\n}\n\ninterface IDialogExtensions extends ICloseable {\n  modified(): void\n  is_modified: boolean\n}\n\ninterface IDialog extends HTMLDivElement, IDialogExtensions {}\ntype PromptDialog = Omit<IDialog, \"modified\">\n\ninterface IDialogOptions {\n  position?: Point\n  event?: MouseEvent\n  checkForInput?: boolean\n  closeOnLeave?: boolean\n  onclose?(): void\n}\n\n/** @inheritdoc {@link LGraphCanvas.state} */\nexport interface LGraphCanvasState {\n  /** {@link Positionable} items are being dragged on the canvas. */\n  draggingItems: boolean\n  /** The canvas itself is being dragged. */\n  draggingCanvas: boolean\n  /** The canvas is read-only, preventing changes to nodes, disconnecting links, moving items, etc. */\n  readOnly: boolean\n\n  /** Bit flags indicating what is currently below the pointer. */\n  hoveringOver: CanvasItem\n  /** If `true`, pointer move events will set the canvas cursor style. */\n  shouldSetCursor: boolean\n\n  /**\n   * Dirty flag indicating that {@link selectedItems} has changed.\n   * Downstream consumers may reset to false once actioned.\n   */\n  selectionChanged: boolean\n}\n\n/**\n * The items created by a clipboard paste operation.\n * Includes maps of original copied IDs to newly created items.\n */\ninterface ClipboardPasteResult {\n  /** All successfully created items */\n  created: Positionable[]\n  /** Map: original node IDs to newly created nodes */\n  nodes: Map<NodeId, LGraphNode>\n  /** Map: original link IDs to new link IDs */\n  links: Map<LinkId, LLink>\n  /** Map: original reroute IDs to newly created reroutes */\n  reroutes: Map<RerouteId, Reroute>\n}\n\n/** Options for {@link LGraphCanvas.pasteFromClipboard}. */\ninterface IPasteFromClipboardOptions {\n  /** If `true`, always attempt to connect inputs of pasted nodes - including to nodes that were not pasted. */\n  connectInputs?: boolean\n  /** The position to paste the items at. */\n  position?: Point\n}\n\ninterface ICreatePanelOptions {\n  closable?: any\n  window?: any\n  onOpen?: () => void\n  onClose?: () => void\n  width?: any\n  height?: any\n}\n\n/**\n * This class is in charge of rendering one graph inside a canvas. And provides all the interaction required.\n * Valid callbacks are: onNodeSelected, onNodeDeselected, onShowNodePanel, onNodeDblClicked\n */\nexport class LGraphCanvas {\n  // Optimised buffers used during rendering\n  static #temp = new Float32Array(4)\n  static #temp_vec2 = new Float32Array(2)\n  static #tmp_area = new Float32Array(4)\n  static #margin_area = new Float32Array(4)\n  static #link_bounding = new Float32Array(4)\n  static #lTempA: Point = new Float32Array(2)\n  static #lTempB: Point = new Float32Array(2)\n  static #lTempC: Point = new Float32Array(2)\n\n  static DEFAULT_BACKGROUND_IMAGE = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=\"\n\n  static DEFAULT_EVENT_LINK_COLOR = \"#A86\"\n\n  /** Link type to colour dictionary. */\n  static link_type_colors: Dictionary<string> = {\n    \"-1\": LGraphCanvas.DEFAULT_EVENT_LINK_COLOR,\n    \"number\": \"#AAA\",\n    \"node\": \"#DCA\",\n  }\n\n  static gradients: Record<string, CanvasGradient> = {}\n\n  static search_limit = -1\n  static node_colors: Record<string, ColorOption> = {\n    red: { color: \"#322\", bgcolor: \"#533\", groupcolor: \"#A88\" },\n    brown: { color: \"#332922\", bgcolor: \"#593930\", groupcolor: \"#b06634\" },\n    green: { color: \"#232\", bgcolor: \"#353\", groupcolor: \"#8A8\" },\n    blue: { color: \"#223\", bgcolor: \"#335\", groupcolor: \"#88A\" },\n    pale_blue: {\n      color: \"#2a363b\",\n      bgcolor: \"#3f5159\",\n      groupcolor: \"#3f789e\",\n    },\n    cyan: { color: \"#233\", bgcolor: \"#355\", groupcolor: \"#8AA\" },\n    purple: { color: \"#323\", bgcolor: \"#535\", groupcolor: \"#a1309b\" },\n    yellow: { color: \"#432\", bgcolor: \"#653\", groupcolor: \"#b58b2a\" },\n    black: { color: \"#222\", bgcolor: \"#000\", groupcolor: \"#444\" },\n  }\n\n  /**\n   * @internal Exclusively a workaround for design limitation in {@link LGraphNode.computeSize}.\n   */\n  static _measureText?: (text: string, fontStyle?: string) => number\n\n  /**\n   * The state of this canvas, e.g. whether it is being dragged, or read-only.\n   *\n   * Implemented as a POCO that can be proxied without side-effects.\n   */\n  state: LGraphCanvasState = {\n    draggingItems: false,\n    draggingCanvas: false,\n    readOnly: false,\n    hoveringOver: CanvasItem.Nothing,\n    shouldSetCursor: true,\n    selectionChanged: false,\n  }\n\n  declare subgraph?: Subgraph\n\n  #updateCursorStyle() {\n    if (!this.state.shouldSetCursor) return\n\n    let cursor = \"default\"\n    if (this.state.draggingCanvas) {\n      cursor = \"grabbing\"\n    } else if (this.state.readOnly) {\n      cursor = \"grab\"\n    } else if (this.state.hoveringOver & CanvasItem.ResizeSe) {\n      cursor = \"se-resize\"\n    } else if (this.state.hoveringOver & CanvasItem.Node) {\n      cursor = \"crosshair\"\n    } else if (this.state.hoveringOver & CanvasItem.Reroute) {\n      cursor = \"grab\"\n    } else if (this.state.hoveringOver & CanvasItem.RerouteSlot) {\n      cursor = \"crosshair\"\n    }\n\n    this.canvas.style.cursor = cursor\n  }\n\n  // Whether the canvas was previously being dragged prior to pressing space key.\n  // null if space key is not pressed.\n  private _previously_dragging_canvas: boolean | null = null\n\n  // #region Legacy accessors\n  /** @deprecated @inheritdoc {@link LGraphCanvasState.readOnly} */\n  get read_only(): boolean {\n    return this.state.readOnly\n  }\n\n  set read_only(value: boolean) {\n    this.state.readOnly = value\n    this.#updateCursorStyle()\n  }\n\n  get isDragging(): boolean {\n    return this.state.draggingItems\n  }\n\n  set isDragging(value: boolean) {\n    this.state.draggingItems = value\n  }\n\n  get hoveringOver(): CanvasItem {\n    return this.state.hoveringOver\n  }\n\n  set hoveringOver(value: CanvasItem) {\n    this.state.hoveringOver = value\n    this.#updateCursorStyle()\n  }\n\n  /** @deprecated Replace all references with {@link pointer}.{@link CanvasPointer.isDown isDown}. */\n  get pointer_is_down() {\n    return this.pointer.isDown\n  }\n\n  /** @deprecated Replace all references with {@link pointer}.{@link CanvasPointer.isDouble isDouble}. */\n  get pointer_is_double() {\n    return this.pointer.isDouble\n  }\n\n  /** @deprecated @inheritdoc {@link LGraphCanvasState.draggingCanvas} */\n  get dragging_canvas(): boolean {\n    return this.state.draggingCanvas\n  }\n\n  set dragging_canvas(value: boolean) {\n    this.state.draggingCanvas = value\n    this.#updateCursorStyle()\n  }\n\n  /**\n   * @deprecated Use {@link LGraphNode.titleFontStyle} instead.\n   */\n  get title_text_font(): string {\n    return `${LiteGraph.NODE_TEXT_SIZE}px ${LiteGraph.NODE_FONT}`\n  }\n  // #endregion Legacy accessors\n\n  get inner_text_font(): string {\n    return `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px ${LiteGraph.NODE_FONT}`\n  }\n\n  #maximumFrameGap = 0\n  /** Maximum frames per second to render. 0: unlimited. Default: 0 */\n  public get maximumFps() {\n    return this.#maximumFrameGap > Number.EPSILON ? this.#maximumFrameGap / 1000 : 0\n  }\n\n  public set maximumFps(value) {\n    this.#maximumFrameGap = value > Number.EPSILON ? 1000 / value : 0\n  }\n\n  /**\n   * @deprecated Use {@link LiteGraphGlobal.ROUND_RADIUS} instead.\n   */\n  get round_radius() {\n    return LiteGraph.ROUND_RADIUS\n  }\n\n  /**\n   * @deprecated Use {@link LiteGraphGlobal.ROUND_RADIUS} instead.\n   */\n  set round_radius(value: number) {\n    LiteGraph.ROUND_RADIUS = value\n  }\n\n  /**\n   * Render low quality when zoomed out.\n   */\n  get low_quality(): boolean {\n    return this.ds.scale < this.low_quality_zoom_threshold\n  }\n\n  options: {\n    skip_events?: any\n    viewport?: any\n    skip_render?: any\n    autoresize?: any\n  }\n\n  background_image: string\n  readonly ds: DragAndScale\n  readonly pointer: CanvasPointer\n  zoom_modify_alpha: boolean\n  zoom_speed: number\n  node_title_color: string\n  default_link_color: string\n  default_connection_color: {\n    input_off: string\n    input_on: string\n    output_off: string\n    output_on: string\n  }\n\n  default_connection_color_byType: Dictionary<CanvasColour>\n  default_connection_color_byTypeOff: Dictionary<CanvasColour>\n\n  /** Gets link colours. Extremely basic impl. until the legacy object dictionaries are removed. */\n  colourGetter: DefaultConnectionColors = {\n    getConnectedColor: (type: string) =>\n      this.default_connection_color_byType[type] ||\n      this.default_connection_color.output_on,\n    getDisconnectedColor: (type: string) =>\n      this.default_connection_color_byTypeOff[type] ||\n      this.default_connection_color_byType[type] ||\n      this.default_connection_color.output_off,\n  }\n\n  highquality_render: boolean\n  use_gradients: boolean\n  editor_alpha: number\n  pause_rendering: boolean\n  clear_background: boolean\n  clear_background_color: string\n  render_only_selected: boolean\n  show_info: boolean\n  allow_dragcanvas: boolean\n  allow_dragnodes: boolean\n  allow_interaction: boolean\n  multi_select: boolean\n  allow_searchbox: boolean\n  allow_reconnect_links: boolean\n  align_to_grid: boolean\n  drag_mode: boolean\n  dragging_rectangle: Rect | null\n  filter?: string | null\n  set_canvas_dirty_on_mouse_event: boolean\n  always_render_background: boolean\n  render_shadows: boolean\n  render_canvas_border: boolean\n  render_connections_shadows: boolean\n  render_connections_border: boolean\n  render_curved_connections: boolean\n  render_connection_arrows: boolean\n  render_collapsed_slots: boolean\n  render_execution_order: boolean\n  render_link_tooltip: boolean\n\n  /** Shape of the markers shown at the midpoint of links.  Default: Circle */\n  linkMarkerShape: LinkMarkerShape = LinkMarkerShape.Circle\n  links_render_mode: number\n  /** Zoom threshold for low quality rendering. Zoom below this threshold will render low quality. */\n  low_quality_zoom_threshold: number = 0.6\n  /** mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle */\n  readonly mouse: Point\n  /** mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle */\n  readonly graph_mouse: Point\n  /** @deprecated LEGACY: REMOVE THIS, USE {@link graph_mouse} INSTEAD */\n  canvas_mouse: Point\n  /** to personalize the search box */\n  onSearchBox?: (helper: Element, str: string, canvas: LGraphCanvas) => any\n  onSearchBoxSelection?: (name: any, event: any, canvas: LGraphCanvas) => void\n  onMouse?: (e: CanvasMouseEvent) => boolean\n  /** to render background objects (behind nodes and connections) in the canvas affected by transform */\n  onDrawBackground?: (ctx: CanvasRenderingContext2D, visible_area: any) => void\n  /** to render foreground objects (above nodes and connections) in the canvas affected by transform */\n  onDrawForeground?: (arg0: CanvasRenderingContext2D, arg1: any) => void\n  connections_width: number\n  /** The current node being drawn by {@link drawNode}.  This should NOT be used to determine the currently selected node.  See {@link selectedItems} */\n  current_node: LGraphNode | null\n  /** used for widgets */\n  node_widget?: [LGraphNode, IBaseWidget] | null\n  /** The link to draw a tooltip for. */\n  over_link_center?: LinkSegment\n  last_mouse_position: Point\n  /** The visible area of this canvas.  Tightly coupled with {@link ds}. */\n  visible_area: Rectangle\n  /** Contains all links and reroutes that were rendered.  Repopulated every render cycle. */\n  renderedPaths: Set<LinkSegment> = new Set()\n  /** @deprecated Replaced by {@link renderedPaths}, but length is set to 0 by some extensions. */\n  visible_links: LLink[] = []\n  /** @deprecated This array is populated and cleared to support legacy extensions. The contents are ignored by Litegraph. */\n  connecting_links: ConnectingLink[] | null\n  linkConnector = new LinkConnector(links => this.connecting_links = links)\n  /** The viewport of this canvas.  Tightly coupled with {@link ds}. */\n  readonly viewport?: Rect\n  autoresize: boolean\n  static active_canvas: LGraphCanvas\n  frame = 0\n  last_draw_time = 0\n  render_time = 0\n  fps = 0\n  /** @deprecated See {@link LGraphCanvas.selectedItems} */\n  selected_nodes: Dictionary<LGraphNode> = {}\n  /** All selected nodes, groups, and reroutes */\n  selectedItems: Set<Positionable> = new Set()\n  /** The group currently being resized. */\n  resizingGroup: LGraphGroup | null = null\n  /** @deprecated See {@link LGraphCanvas.selectedItems} */\n  selected_group: LGraphGroup | null = null\n  /** The nodes that are currently visible on the canvas. */\n  visible_nodes: LGraphNode[] = []\n  /**\n   * The IDs of the nodes that are currently visible on the canvas. More\n   * performant than {@link visible_nodes} for visibility checks.\n   */\n  #visible_node_ids: Set<NodeId> = new Set()\n  node_over?: LGraphNode\n  node_capturing_input?: LGraphNode | null\n  highlighted_links: Dictionary<boolean> = {}\n\n  #visibleReroutes: Set<Reroute> = new Set()\n\n  dirty_canvas: boolean = true\n  dirty_bgcanvas: boolean = true\n  /** A map of nodes that require selective-redraw */\n  dirty_nodes = new Map<NodeId, LGraphNode>()\n  dirty_area?: Rect | null\n  /** @deprecated Unused */\n  node_in_panel?: LGraphNode | null\n  last_mouse: ReadOnlyPoint = [0, 0]\n  last_mouseclick: number = 0\n  graph: LGraph | null\n  canvas: HTMLCanvasElement\n  bgcanvas: HTMLCanvasElement\n  ctx: CanvasRenderingContext2D\n  _events_binded?: boolean\n  _mousedown_callback?(e: PointerEvent): void\n  _mousewheel_callback?(e: WheelEvent): void\n  _mousemove_callback?(e: PointerEvent): void\n  _mouseup_callback?(e: PointerEvent): void\n  _mouseout_callback?(e: PointerEvent): void\n  _mousecancel_callback?(e: PointerEvent): void\n  _key_callback?(e: KeyboardEvent): void\n  bgctx?: CanvasRenderingContext2D | null\n  is_rendering?: boolean\n  /** @deprecated Panels */\n  block_click?: boolean\n  /** @deprecated Panels */\n  last_click_position?: Point | null\n  resizing_node?: LGraphNode | null\n  /** @deprecated See {@link LGraphCanvas.resizingGroup} */\n  selected_group_resizing?: boolean\n  /** @deprecated See {@link pointer}.{@link CanvasPointer.dragStarted dragStarted} */\n  last_mouse_dragging?: boolean\n  onMouseDown?: (arg0: CanvasMouseEvent) => void\n  _highlight_pos?: Point\n  _highlight_input?: INodeInputSlot\n  // TODO: Check if panels are used\n  /** @deprecated Panels */\n  node_panel?: any\n  /** @deprecated Panels */\n  options_panel?: any\n  _bg_img?: HTMLImageElement\n  _pattern?: CanvasPattern\n  _pattern_img?: HTMLImageElement\n  // TODO: This looks like another panel thing\n  prompt_box?: PromptDialog | null\n  search_box?: HTMLDivElement\n  /** @deprecated Panels */\n  SELECTED_NODE?: LGraphNode\n  /** @deprecated Panels */\n  NODEPANEL_IS_OPEN?: boolean\n\n  /** Once per frame check of snap to grid value.  @todo Update on change. */\n  #snapToGrid?: number\n  /** Set on keydown, keyup. @todo */\n  #shiftDown: boolean = false\n\n  /** If true, enable drag zoom. Ctrl+Shift+Drag Up/Down: zoom canvas. */\n  dragZoomEnabled: boolean = false\n  /** The start position of the drag zoom. */\n  #dragZoomStart: { pos: Point, scale: number } | null = null\n\n  getMenuOptions?(): IContextMenuValue<string>[]\n  getExtraMenuOptions?(\n    canvas: LGraphCanvas,\n    options: IContextMenuValue<string>[],\n  ): IContextMenuValue<string>[]\n  static active_node: LGraphNode\n  /** called before modifying the graph */\n  onBeforeChange?(graph: LGraph): void\n  /** called after modifying the graph */\n  onAfterChange?(graph: LGraph): void\n  onClear?: () => void\n  /** called after moving a node @deprecated Does not handle multi-node move, and can return the wrong node. */\n  onNodeMoved?: (node_dragged: LGraphNode | undefined) => void\n  /** @deprecated Called with the deprecated {@link selected_nodes} when the selection changes. Replacement not yet impl. */\n  onSelectionChange?: (selected: Dictionary<Positionable>) => void\n  /** called when rendering a tooltip */\n  onDrawLinkTooltip?: (\n    ctx: CanvasRenderingContext2D,\n    link: LLink | null,\n    canvas?: LGraphCanvas,\n  ) => boolean\n\n  /** to render foreground objects not affected by transform (for GUIs) */\n  onDrawOverlay?: (ctx: CanvasRenderingContext2D) => void\n  onRenderBackground?: (\n    canvas: HTMLCanvasElement,\n    ctx: CanvasRenderingContext2D,\n  ) => boolean\n\n  onNodeDblClicked?: (n: LGraphNode) => void\n  onShowNodePanel?: (n: LGraphNode) => void\n  onNodeSelected?: (node: LGraphNode) => void\n  onNodeDeselected?: (node: LGraphNode) => void\n  onRender?: (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => void\n\n  /**\n   * Creates a new instance of LGraphCanvas.\n   * @param canvas The canvas HTML element (or its id) to use, or null / undefined to leave blank.\n   * @param graph The graph that owns this canvas.\n   * @param options\n   */\n  constructor(\n    canvas: HTMLCanvasElement,\n    graph: LGraph,\n    options?: LGraphCanvas[\"options\"],\n  ) {\n    options ||= {}\n    this.options = options\n\n    // if(graph === undefined)\n    // throw (\"No graph assigned\");\n    this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE\n\n    this.ds = new DragAndScale(canvas)\n    this.pointer = new CanvasPointer(canvas)\n\n    // @deprecated Workaround: Keep until connecting_links is removed.\n    this.linkConnector.events.addEventListener(\"reset\", () => {\n      this.connecting_links = null\n    })\n\n    // Dropped a link on the canvas\n    this.linkConnector.events.addEventListener(\"dropped-on-canvas\", (customEvent) => {\n      if (!this.connecting_links) return\n\n      const e = customEvent.detail\n      this.emitEvent({\n        subType: \"empty-release\",\n        originalEvent: e,\n        linkReleaseContext: { links: this.connecting_links },\n      })\n\n      const firstLink = this.linkConnector.renderLinks[0]\n\n      // No longer in use\n      // add menu when releasing link in empty space\n      if (LiteGraph.release_link_on_empty_shows_menu) {\n        const linkReleaseContext = this.linkConnector.state.connectingTo === \"input\"\n          ? {\n            node_from: firstLink.node,\n            slot_from: firstLink.fromSlot,\n            type_filter_in: firstLink.fromSlot.type,\n          }\n          : {\n            node_to: firstLink.node,\n            slot_from: firstLink.fromSlot,\n            type_filter_out: firstLink.fromSlot.type,\n          }\n\n        const afterRerouteId = firstLink.fromReroute?.id\n\n        if (\"shiftKey\" in e && e.shiftKey) {\n          if (this.allow_searchbox) {\n            this.showSearchBox(e as unknown as MouseEvent, linkReleaseContext)\n          }\n        } else if (this.linkConnector.state.connectingTo === \"input\") {\n          this.showConnectionMenu({ nodeFrom: firstLink.node, slotFrom: firstLink.fromSlot, e, afterRerouteId })\n        } else {\n          this.showConnectionMenu({ nodeTo: firstLink.node, slotTo: firstLink.fromSlot, e, afterRerouteId })\n        }\n      }\n    })\n\n    // otherwise it generates ugly patterns when scaling down too much\n    this.zoom_modify_alpha = true\n    // in range (1.01, 2.5). Less than 1 will invert the zoom direction\n    this.zoom_speed = 1.1\n\n    this.node_title_color = LiteGraph.NODE_TITLE_COLOR\n    this.default_link_color = LiteGraph.LINK_COLOR\n    this.default_connection_color = {\n      input_off: \"#778\",\n      input_on: \"#7F7\",\n      output_off: \"#778\",\n      output_on: \"#7F7\",\n    }\n    this.default_connection_color_byType = {\n      /* number: \"#7F7\",\n            string: \"#77F\",\n            boolean: \"#F77\", */\n    }\n    this.default_connection_color_byTypeOff = {\n      /* number: \"#474\",\n            string: \"#447\",\n            boolean: \"#744\", */\n    }\n\n    this.highquality_render = true\n    // set to true to render titlebar with gradients\n    this.use_gradients = false\n    // used for transition\n    this.editor_alpha = 1\n    this.pause_rendering = false\n    this.clear_background = true\n    this.clear_background_color = \"#222\"\n\n    this.render_only_selected = true\n    this.show_info = true\n    this.allow_dragcanvas = true\n    this.allow_dragnodes = true\n    // allow to control widgets, buttons, collapse, etc\n    this.allow_interaction = true\n    // allow selecting multi nodes without pressing extra keys\n    this.multi_select = false\n    this.allow_searchbox = true\n    // allows to change a connection with having to redo it again\n    this.allow_reconnect_links = true\n    // snap to grid\n    this.align_to_grid = false\n\n    this.drag_mode = false\n    this.dragging_rectangle = null\n\n    // allows to filter to only accept some type of nodes in a graph\n    this.filter = null\n\n    // forces to redraw the canvas on mouse events (except move)\n    this.set_canvas_dirty_on_mouse_event = true\n    this.always_render_background = false\n    this.render_shadows = true\n    this.render_canvas_border = true\n    // too much cpu\n    this.render_connections_shadows = false\n    this.render_connections_border = true\n    this.render_curved_connections = false\n    this.render_connection_arrows = false\n    this.render_collapsed_slots = true\n    this.render_execution_order = false\n    this.render_link_tooltip = true\n\n    this.links_render_mode = LinkRenderType.SPLINE_LINK\n\n    this.mouse = [0, 0]\n    this.graph_mouse = [0, 0]\n    this.canvas_mouse = this.graph_mouse\n\n    this.connections_width = 3\n\n    this.current_node = null\n    this.node_widget = null\n    this.last_mouse_position = [0, 0]\n    this.visible_area = this.ds.visible_area\n    // Explicitly null-checked\n    this.connecting_links = null\n\n    // to constraint render area to a portion of the canvas\n    this.viewport = options.viewport || null\n\n    // link canvas and graph\n    this.graph = graph\n    graph?.attachCanvas(this)\n\n    // TypeScript strict workaround: cannot use method to initialize properties.\n    this.canvas = undefined!\n    this.bgcanvas = undefined!\n    this.ctx = undefined!\n\n    this.setCanvas(canvas, options.skip_events)\n    this.clear()\n\n    LGraphCanvas._measureText = (text: string, fontStyle = this.inner_text_font) => {\n      const { ctx } = this\n      const { font } = ctx\n      try {\n        ctx.font = fontStyle\n        return ctx.measureText(text).width\n      } finally {\n        ctx.font = font\n      }\n    }\n\n    if (!options.skip_render) {\n      this.startRendering()\n    }\n\n    this.autoresize = options.autoresize\n  }\n\n  static onGroupAdd(info: unknown, entry: unknown, mouse_event: MouseEvent): void {\n    const canvas = LGraphCanvas.active_canvas\n\n    const group = new LiteGraph.LGraphGroup()\n    group.pos = canvas.convertEventToCanvasOffset(mouse_event)\n    if (!canvas.graph) throw new NullGraphError()\n    canvas.graph.add(group)\n  }\n\n  /**\n   * @deprecated Functionality moved to {@link getBoundaryNodes}.  The new function returns null on failure, instead of an object with all null properties.\n   * Determines the furthest nodes in each direction\n   * @param nodes the nodes to from which boundary nodes will be extracted\n   * @returns\n   */\n  static getBoundaryNodes(\n    nodes: LGraphNode[] | Dictionary<LGraphNode>,\n  ): NullableProperties<IBoundaryNodes> {\n    const _nodes = Array.isArray(nodes) ? nodes : Object.values(nodes)\n    return (\n      getBoundaryNodes(_nodes) ?? {\n        top: null,\n        right: null,\n        bottom: null,\n        left: null,\n      }\n    )\n  }\n\n  /**\n   * @deprecated Functionality moved to {@link alignNodes}.  The new function does not set dirty canvas.\n   * @param nodes a list of nodes\n   * @param direction Direction to align the nodes\n   * @param align_to Node to align to (if null, align to the furthest node in the given direction)\n   */\n  static alignNodes(\n    nodes: Dictionary<LGraphNode>,\n    direction: Direction,\n    align_to?: LGraphNode,\n  ): void {\n    alignNodes(Object.values(nodes), direction, align_to)\n    LGraphCanvas.active_canvas.setDirty(true, true)\n  }\n\n  static onNodeAlign(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    event: MouseEvent,\n    prev_menu: ContextMenu<string>,\n    node: LGraphNode,\n  ): void {\n    new LiteGraph.ContextMenu([\"Top\", \"Bottom\", \"Left\", \"Right\"], {\n      event,\n      callback: inner_clicked,\n      parentMenu: prev_menu,\n    })\n\n    function inner_clicked(value: string) {\n      alignNodes(\n        Object.values(LGraphCanvas.active_canvas.selected_nodes),\n        value.toLowerCase() as Direction,\n        node,\n      )\n      LGraphCanvas.active_canvas.setDirty(true, true)\n    }\n  }\n\n  static onGroupAlign(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    event: MouseEvent,\n    prev_menu: ContextMenu<string>,\n  ): void {\n    new LiteGraph.ContextMenu([\"Top\", \"Bottom\", \"Left\", \"Right\"], {\n      event,\n      callback: inner_clicked,\n      parentMenu: prev_menu,\n    })\n\n    function inner_clicked(value: string) {\n      alignNodes(\n        Object.values(LGraphCanvas.active_canvas.selected_nodes),\n        value.toLowerCase() as Direction,\n      )\n      LGraphCanvas.active_canvas.setDirty(true, true)\n    }\n  }\n\n  static createDistributeMenu(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    event: MouseEvent,\n    prev_menu: ContextMenu<string>,\n  ): void {\n    new LiteGraph.ContextMenu([\"Vertically\", \"Horizontally\"], {\n      event,\n      callback: inner_clicked,\n      parentMenu: prev_menu,\n    })\n\n    function inner_clicked(value: string) {\n      const canvas = LGraphCanvas.active_canvas\n      distributeNodes(Object.values(canvas.selected_nodes), value === \"Horizontally\")\n      canvas.setDirty(true, true)\n    }\n  }\n\n  static onMenuAdd(\n    value: unknown,\n    options: unknown,\n    e: MouseEvent,\n    prev_menu?: ContextMenu<string>,\n    callback?: (node: LGraphNode | null) => void,\n  ): boolean | undefined {\n    const canvas = LGraphCanvas.active_canvas\n    const ref_window = canvas.getCanvasWindow()\n    const { graph } = canvas\n    if (!graph) return\n\n    inner_onMenuAdded(\"\", prev_menu)\n    return false\n\n    type AddNodeMenu = Omit<IContextMenuValue<string>, \"callback\"> & {\n      callback: (\n        value: { value: string },\n        event: Event,\n        mouseEvent: MouseEvent,\n        contextMenu: ContextMenu<string>\n      ) => void\n    }\n\n    function inner_onMenuAdded(base_category: string, prev_menu?: ContextMenu<string>): void {\n      if (!graph) return\n\n      const categories = LiteGraph\n        .getNodeTypesCategories(canvas.filter || graph.filter)\n        .filter(category => category.startsWith(base_category))\n      const entries: AddNodeMenu[] = []\n\n      for (const category of categories) {\n        if (!category) continue\n\n        const base_category_regex = new RegExp(`^(${base_category})`)\n        const category_name = category\n          .replace(base_category_regex, \"\")\n          .split(\"/\", 1)[0]\n        const category_path =\n          base_category === \"\"\n            ? `${category_name}/`\n            : `${base_category}${category_name}/`\n\n        let name = category_name\n        // in case it has a namespace like \"shader::math/rand\" it hides the namespace\n        if (name.includes(\"::\")) name = name.split(\"::\", 2)[1]\n\n        const index = entries.findIndex(entry => entry.value === category_path)\n        if (index === -1) {\n          entries.push({\n            value: category_path,\n            content: name,\n            has_submenu: true,\n            callback: function (value, event, mouseEvent, contextMenu) {\n              inner_onMenuAdded(value.value, contextMenu)\n            },\n          })\n        }\n      }\n\n      const nodes = LiteGraph.getNodeTypesInCategory(\n        base_category.slice(0, -1),\n        canvas.filter || graph.filter,\n      )\n\n      for (const node of nodes) {\n        if (node.skip_list) continue\n\n        const entry: AddNodeMenu = {\n          value: node.type,\n          content: node.title,\n          has_submenu: false,\n          callback: function (value, event, mouseEvent, contextMenu) {\n            if (!canvas.graph) throw new NullGraphError()\n\n            const first_event = contextMenu.getFirstEvent()\n            canvas.graph.beforeChange()\n            const node = LiteGraph.createNode(value.value)\n            if (node) {\n              if (!first_event) throw new TypeError(\"Context menu event was null. This should not occur in normal usage.\")\n              node.pos = canvas.convertEventToCanvasOffset(first_event)\n              canvas.graph.add(node)\n            } else {\n              console.warn(\"Failed to create node of type:\", value.value)\n            }\n\n            callback?.(node)\n            canvas.graph.afterChange()\n          },\n        }\n\n        entries.push(entry)\n      }\n\n      // @ts-expect-error Remove param ref_window - unused\n      new LiteGraph.ContextMenu(entries, { event: e, parentMenu: prev_menu }, ref_window)\n    }\n  }\n\n  static onMenuCollapseAll() {}\n  static onMenuNodeEdit() {}\n\n  /** @param _options Parameter is never used */\n  static showMenuNodeOptionalOutputs(\n    v: unknown,\n    /** Unused - immediately overwritten */\n    _options: INodeOutputSlot[],\n    e: MouseEvent,\n    prev_menu: ContextMenu<INodeSlotContextItem>,\n    node: LGraphNode,\n  ): boolean | undefined {\n    if (!node) return\n\n    const canvas = LGraphCanvas.active_canvas\n\n    let entries: (IContextMenuValue<INodeSlotContextItem> | null)[] = []\n\n    if (LiteGraph.do_add_triggers_slots && node.findOutputSlot(\"onExecuted\") == -1) {\n      entries.push({ content: \"On Executed\", value: [\"onExecuted\", LiteGraph.EVENT, { nameLocked: true }], className: \"event\" })\n    }\n    // add callback for modifing the menu elements onMenuNodeOutputs\n    const retEntries = node.onMenuNodeOutputs?.(entries)\n    if (retEntries) entries = retEntries\n\n    if (!entries.length) return\n\n    new LiteGraph.ContextMenu<INodeSlotContextItem>(\n      entries,\n      {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: prev_menu,\n        node,\n      },\n    )\n\n    function inner_clicked(this: ContextMenuDivElement<INodeSlotContextItem>, v: IContextMenuValue<INodeSlotContextItem>, e: any, prev: any) {\n      if (!node) return\n\n      // TODO: This is a static method, so the below \"that\" appears broken.\n      if (v.callback) v.callback.call(this, node, v, e, prev)\n\n      if (!v.value) return\n\n      const value = v.value[1]\n\n      if (value &&\n        (typeof value === \"object\" || Array.isArray(value))) {\n        // submenu why?\n        const entries = []\n        for (const i in value) {\n          entries.push({ content: i, value: value[i] })\n        }\n        new LiteGraph.ContextMenu(entries, {\n          event: e,\n          callback: inner_clicked,\n          parentMenu: prev_menu,\n          node,\n        })\n        return false\n      }\n\n      const { graph } = node\n      if (!graph) throw new NullGraphError()\n\n      graph.beforeChange()\n      node.addOutput(v.value[0], v.value[1], v.value[2])\n\n      // a callback to the node when adding a slot\n      node.onNodeOutputAdd?.(v.value)\n      canvas.setDirty(true, true)\n      graph.afterChange()\n    }\n\n    return false\n  }\n\n  /** @param value Parameter is never used */\n  static onShowMenuNodeProperties(\n    value: NodeProperty | undefined,\n    options: unknown,\n    e: MouseEvent,\n    prev_menu: ContextMenu<string>,\n    node: LGraphNode,\n  ): boolean | undefined {\n    if (!node || !node.properties) return\n\n    const canvas = LGraphCanvas.active_canvas\n    const ref_window = canvas.getCanvasWindow()\n\n    const entries: IContextMenuValue<string>[] = []\n    for (const i in node.properties) {\n      value = node.properties[i] !== undefined ? node.properties[i] : \" \"\n      if (typeof value == \"object\")\n        value = JSON.stringify(value)\n      const info = node.getPropertyInfo(i)\n      if (info.type == \"enum\" || info.type == \"combo\")\n        value = LGraphCanvas.getPropertyPrintableValue(value, info.values)\n\n      // value could contain invalid html characters, clean that\n      value = LGraphCanvas.decodeHTML(stringOrEmpty(value))\n      entries.push({\n        content:\n         `<span class='property_name'>${info.label || i}</span>` +\n         `<span class='property_value'>${value}</span>`,\n        value: i,\n      })\n    }\n    if (!entries.length) {\n      return\n    }\n\n    new LiteGraph.ContextMenu<string>(\n      entries,\n      {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: prev_menu,\n        allow_html: true,\n        node,\n      },\n      // @ts-expect-error Unused\n      ref_window,\n    )\n\n    function inner_clicked(this: ContextMenuDivElement, v: { value: any }) {\n      if (!node) return\n\n      const rect = this.getBoundingClientRect()\n      canvas.showEditPropertyValue(node, v.value, {\n        position: [rect.left, rect.top],\n      })\n    }\n\n    return false\n  }\n\n  /** @deprecated */\n  static decodeHTML(str: string): string {\n    const e = document.createElement(\"div\")\n    e.textContent = str\n    return e.innerHTML\n  }\n\n  static onMenuResizeNode(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): void {\n    if (!node) return\n\n    const fApplyMultiNode = function (node: LGraphNode) {\n      node.setSize(node.computeSize())\n    }\n\n    const canvas = LGraphCanvas.active_canvas\n    if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node)\n    } else {\n      for (const i in canvas.selected_nodes) {\n        fApplyMultiNode(canvas.selected_nodes[i])\n      }\n    }\n\n    canvas.setDirty(true, true)\n  }\n\n  // TODO refactor :: this is used fot title but not for properties!\n  static onShowPropertyEditor(\n    item: { property: keyof LGraphNode, type: string },\n    options: IContextMenuOptions<string>,\n    e: MouseEvent,\n    menu: ContextMenu<string>,\n    node: LGraphNode,\n  ): void {\n    const property = item.property || \"title\"\n    const value = node[property]\n\n    const title = document.createElement(\"span\")\n    title.className = \"name\"\n    title.textContent = property\n\n    const input = document.createElement(\"input\")\n    Object.assign(input, { type: \"text\", className: \"value\", autofocus: true })\n\n    const button = document.createElement(\"button\")\n    button.textContent = \"OK\"\n\n    // TODO refactor :: use createDialog ?\n    const dialog = Object.assign(document.createElement(\"div\"), {\n      is_modified: false,\n      className: \"graphdialog\",\n      close: () => dialog.remove(),\n    })\n    dialog.append(title, input, button)\n\n    input.value = String(value)\n    input.addEventListener(\"blur\", function () {\n      this.focus()\n    })\n    input.addEventListener(\"keydown\", (e: KeyboardEvent) => {\n      dialog.is_modified = true\n      if (e.key == \"Escape\") {\n        // ESC\n        dialog.close()\n      } else if (e.key == \"Enter\") {\n        // save\n        inner()\n      } else if (!e.target || !(\"localName\" in e.target) || e.target.localName != \"textarea\") {\n        return\n      }\n      e.preventDefault()\n      e.stopPropagation()\n    })\n\n    const canvas = LGraphCanvas.active_canvas\n    const canvasEl = canvas.canvas\n\n    const rect = canvasEl.getBoundingClientRect()\n    const offsetx = rect ? -20 - rect.left : -20\n    const offsety = rect ? -20 - rect.top : -20\n\n    if (e) {\n      dialog.style.left = `${e.clientX + offsetx}px`\n      dialog.style.top = `${e.clientY + offsety}px`\n    } else {\n      dialog.style.left = `${canvasEl.width * 0.5 + offsetx}px`\n      dialog.style.top = `${canvasEl.height * 0.5 + offsety}px`\n    }\n\n    button.addEventListener(\"click\", inner)\n\n    if (canvasEl.parentNode == null) throw new TypeError(\"canvasEl.parentNode was null\")\n    canvasEl.parentNode.append(dialog)\n\n    input.focus()\n\n    let dialogCloseTimer: number\n    dialog.addEventListener(\"mouseleave\", function () {\n      if (LiteGraph.dialog_close_on_mouse_leave) {\n        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave) {\n          dialogCloseTimer = setTimeout(\n            dialog.close,\n            LiteGraph.dialog_close_on_mouse_leave_delay,\n          )\n        }\n      }\n    })\n    dialog.addEventListener(\"mouseenter\", function () {\n      if (LiteGraph.dialog_close_on_mouse_leave) {\n        if (dialogCloseTimer) clearTimeout(dialogCloseTimer)\n      }\n    })\n\n    function inner() {\n      if (input) setValue(input.value)\n    }\n\n    function setValue(value: NodeProperty) {\n      if (item.type == \"Number\") {\n        value = Number(value)\n      } else if (item.type == \"Boolean\") {\n        value = Boolean(value)\n      }\n      // @ts-expect-error Requires refactor.\n      node[property] = value\n      dialog.remove()\n      canvas.setDirty(true, true)\n    }\n  }\n\n  static getPropertyPrintableValue(value: unknown, values: unknown[] | object | undefined): string | undefined {\n    if (!values) return String(value)\n\n    if (Array.isArray(values)) {\n      return String(value)\n    }\n\n    if (typeof values === \"object\") {\n      let desc_value = \"\"\n      for (const k in values) {\n        // @ts-expect-error deprecated #578\n        if (values[k] != value) continue\n\n        desc_value = k\n        break\n      }\n      return `${String(value)} (${desc_value})`\n    }\n  }\n\n  static onMenuNodeCollapse(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): void {\n    if (!node.graph) throw new NullGraphError()\n\n    node.graph.beforeChange()\n\n    const fApplyMultiNode = function (node: LGraphNode) {\n      node.collapse()\n    }\n\n    const graphcanvas = LGraphCanvas.active_canvas\n    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node)\n    } else {\n      for (const i in graphcanvas.selected_nodes) {\n        fApplyMultiNode(graphcanvas.selected_nodes[i])\n      }\n    }\n\n    node.graph.afterChange()\n  }\n\n  static onMenuToggleAdvanced(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): void {\n    if (!node.graph) throw new NullGraphError()\n\n    node.graph.beforeChange()\n    const fApplyMultiNode = function (node: LGraphNode) {\n      node.toggleAdvanced()\n    }\n\n    const graphcanvas = LGraphCanvas.active_canvas\n    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node)\n    } else {\n      for (const i in graphcanvas.selected_nodes) {\n        fApplyMultiNode(graphcanvas.selected_nodes[i])\n      }\n    }\n    node.graph.afterChange()\n  }\n\n  static onMenuNodeMode(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): boolean {\n    new LiteGraph.ContextMenu(\n      LiteGraph.NODE_MODES,\n      { event: e, callback: inner_clicked, parentMenu: menu, node },\n    )\n\n    function inner_clicked(v: string) {\n      if (!node) return\n\n      const kV = Object.values(LiteGraph.NODE_MODES).indexOf(v)\n      const fApplyMultiNode = function (node: LGraphNode) {\n        if (kV !== -1 && LiteGraph.NODE_MODES[kV]) {\n          node.changeMode(kV)\n        } else {\n          console.warn(`unexpected mode: ${v}`)\n          node.changeMode(LGraphEventMode.ALWAYS)\n        }\n      }\n\n      const graphcanvas = LGraphCanvas.active_canvas\n      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n        fApplyMultiNode(node)\n      } else {\n        for (const i in graphcanvas.selected_nodes) {\n          fApplyMultiNode(graphcanvas.selected_nodes[i])\n        }\n      }\n    }\n\n    return false\n  }\n\n  /** @param value Parameter is never used */\n  static onMenuNodeColors(\n    value: IContextMenuValue<string | null>,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu<string | null>,\n    node: LGraphNode,\n  ): boolean {\n    if (!node) throw \"no node for color\"\n\n    const values: IContextMenuValue<string | null, unknown, { value: string | null }>[] = []\n    values.push({\n      value: null,\n      content: \"<span style='display: block; padding-left: 4px;'>No color</span>\",\n    })\n\n    for (const i in LGraphCanvas.node_colors) {\n      const color = LGraphCanvas.node_colors[i]\n      value = {\n        value: i,\n        content: `<span style='display: block; color: #999; padding-left: 4px;` +\n          ` border-left: 8px solid ${color.color}; background-color:${color.bgcolor}'>${i}</span>`,\n      }\n      values.push(value)\n    }\n    new LiteGraph.ContextMenu<string | null>(values, {\n      event: e,\n      callback: inner_clicked,\n      parentMenu: menu,\n      node,\n    })\n\n    function inner_clicked(v: IContextMenuValue<string>) {\n      if (!node) return\n\n      const fApplyColor = function (item: IColorable) {\n        const colorOption = v.value ? LGraphCanvas.node_colors[v.value] : null\n        item.setColorOption(colorOption)\n      }\n\n      const canvas = LGraphCanvas.active_canvas\n      if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {\n        fApplyColor(node)\n      } else {\n        for (const i in canvas.selected_nodes) {\n          fApplyColor(canvas.selected_nodes[i])\n        }\n      }\n      canvas.setDirty(true, true)\n    }\n\n    return false\n  }\n\n  static onMenuNodeShapes(\n    value: IContextMenuValue<typeof LiteGraph.VALID_SHAPES[number]>,\n    options: IContextMenuOptions<typeof LiteGraph.VALID_SHAPES[number]>,\n    e: MouseEvent,\n    menu?: ContextMenu<typeof LiteGraph.VALID_SHAPES[number]>,\n    node?: LGraphNode,\n  ): boolean {\n    if (!node) throw \"no node passed\"\n\n    new LiteGraph.ContextMenu<typeof LiteGraph.VALID_SHAPES[number]>(LiteGraph.VALID_SHAPES, {\n      event: e,\n      callback: inner_clicked,\n      parentMenu: menu,\n      node,\n    })\n\n    function inner_clicked(v: typeof LiteGraph.VALID_SHAPES[number]) {\n      if (!node) return\n      if (!node.graph) throw new NullGraphError()\n\n      node.graph.beforeChange()\n\n      const fApplyMultiNode = function (node: LGraphNode) {\n        node.shape = v\n      }\n\n      const canvas = LGraphCanvas.active_canvas\n      if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {\n        fApplyMultiNode(node)\n      } else {\n        for (const i in canvas.selected_nodes) {\n          fApplyMultiNode(canvas.selected_nodes[i])\n        }\n      }\n\n      node.graph.afterChange()\n      canvas.setDirty(true)\n    }\n\n    return false\n  }\n\n  static onMenuNodeRemove(): void {\n    LGraphCanvas.active_canvas.deleteSelected()\n  }\n\n  static onMenuNodeClone(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): void {\n    const { graph } = node\n    if (!graph) throw new NullGraphError()\n    graph.beforeChange()\n\n    const newSelected = new Set<LGraphNode>()\n\n    const fApplyMultiNode = function (node: LGraphNode, newNodes: Set<LGraphNode>): void {\n      if (node.clonable === false) return\n\n      const newnode = node.clone()\n      if (!newnode) return\n\n      newnode.pos = [node.pos[0] + 5, node.pos[1] + 5]\n      if (!node.graph) throw new NullGraphError()\n\n      node.graph.add(newnode)\n      newNodes.add(newnode)\n    }\n\n    const canvas = LGraphCanvas.active_canvas\n    if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node, newSelected)\n    } else {\n      for (const i in canvas.selected_nodes) {\n        fApplyMultiNode(canvas.selected_nodes[i], newSelected)\n      }\n    }\n\n    if (newSelected.size) {\n      canvas.selectNodes([...newSelected])\n    }\n\n    graph.afterChange()\n\n    canvas.setDirty(true, true)\n  }\n\n  /**\n   * clears all the data inside\n   *\n   */\n  clear(): void {\n    this.frame = 0\n    this.last_draw_time = 0\n    this.render_time = 0\n    this.fps = 0\n\n    // this.scale = 1;\n    // this.offset = [0,0];\n    this.dragging_rectangle = null\n\n    this.selected_nodes = {}\n    this.selected_group = null\n    this.selectedItems.clear()\n    this.state.selectionChanged = true\n    this.onSelectionChange?.(this.selected_nodes)\n\n    this.visible_nodes = []\n    this.node_over = undefined\n    this.node_capturing_input = null\n    this.connecting_links = null\n    this.highlighted_links = {}\n\n    this.dragging_canvas = false\n\n    this.#dirty()\n    this.dirty_area = null\n\n    this.node_in_panel = null\n    this.node_widget = null\n\n    this.last_mouse = [0, 0]\n    this.last_mouseclick = 0\n    this.pointer.reset()\n    this.visible_area.set([0, 0, 0, 0])\n\n    this.onClear?.()\n  }\n\n  /**\n   * Assigns a new graph to this canvas.\n   */\n  setGraph(newGraph: LGraph | Subgraph): void {\n    const { graph } = this\n    if (newGraph === graph) return\n\n    const options = {\n      bubbles: true,\n      detail: { newGraph, oldGraph: graph },\n    }\n\n    this.clear()\n    newGraph.attachCanvas(this)\n\n    this.canvas.dispatchEvent(new CustomEvent(\"litegraph:set-graph\", options))\n    this.#dirty()\n  }\n\n  /**\n   * @returns the visually active graph (in case there are more in the stack)\n   */\n  getCurrentGraph(): LGraph | null {\n    return this.graph\n  }\n\n  /**\n   * Finds the canvas if required, throwing on failure.\n   * @param canvas Canvas element, or its element ID\n   * @returns The canvas element\n   * @throws If {@link canvas} is an element ID that does not belong to a valid HTML canvas element\n   */\n  #validateCanvas(\n    canvas: string | HTMLCanvasElement,\n  ): HTMLCanvasElement & { data?: LGraphCanvas } {\n    if (typeof canvas === \"string\") {\n      const el = document.getElementById(canvas)\n      if (!(el instanceof HTMLCanvasElement)) throw \"Error validating LiteGraph canvas: Canvas element not found\"\n      return el\n    }\n    return canvas\n  }\n\n  /**\n   * Sets the current HTML canvas element.\n   * Calls bindEvents to add input event listeners, and (re)creates the background canvas.\n   * @param canvas The canvas element to assign, or its HTML element ID.  If null or undefined, the current reference is cleared.\n   * @param skip_events If true, events on the previous canvas will not be removed.  Has no effect on the first invocation.\n   */\n  setCanvas(canvas: string | HTMLCanvasElement, skip_events?: boolean) {\n    const element = this.#validateCanvas(canvas)\n    if (element === this.canvas) return\n    // maybe detach events from old_canvas\n    if (!element && this.canvas && !skip_events) this.unbindEvents()\n\n    this.canvas = element\n    this.ds.element = element\n    this.pointer.element = element\n\n    if (!element) return\n\n    // TODO: classList.add\n    element.className += \" lgraphcanvas\"\n    element.data = this\n\n    // Background canvas: To render objects behind nodes (background, links, groups)\n    this.bgcanvas = document.createElement(\"canvas\")\n    this.bgcanvas.width = this.canvas.width\n    this.bgcanvas.height = this.canvas.height\n\n    const ctx = element.getContext?.(\"2d\")\n    if (ctx == null) {\n      if (element.localName != \"canvas\") {\n        throw `Element supplied for LGraphCanvas must be a <canvas> element, you passed a ${element.localName}`\n      }\n      throw \"This browser doesn't support Canvas\"\n    }\n    this.ctx = ctx\n\n    if (!skip_events) this.bindEvents()\n  }\n\n  /** Captures an event and prevents default - returns false. */\n  _doNothing(e: Event): boolean {\n    // console.log(\"pointerevents: _doNothing \"+e.type);\n    e.preventDefault()\n    return false\n  }\n\n  /** Captures an event and prevents default - returns true. */\n  _doReturnTrue(e: Event): boolean {\n    e.preventDefault()\n    return true\n  }\n\n  /**\n   * binds mouse, keyboard, touch and drag events to the canvas\n   */\n  bindEvents(): void {\n    if (this._events_binded) {\n      console.warn(\"LGraphCanvas: events already binded\")\n      return\n    }\n\n    const { canvas } = this\n    // hack used when moving canvas between windows\n    const { document } = this.getCanvasWindow()\n\n    this._mousedown_callback = this.processMouseDown.bind(this)\n    this._mousewheel_callback = this.processMouseWheel.bind(this)\n    this._mousemove_callback = this.processMouseMove.bind(this)\n    this._mouseup_callback = this.processMouseUp.bind(this)\n    this._mouseout_callback = this.processMouseOut.bind(this)\n    this._mousecancel_callback = this.processMouseCancel.bind(this)\n\n    canvas.addEventListener(\"pointerdown\", this._mousedown_callback, true)\n    canvas.addEventListener(\"wheel\", this._mousewheel_callback, false)\n\n    canvas.addEventListener(\"pointerup\", this._mouseup_callback, true)\n    canvas.addEventListener(\"pointermove\", this._mousemove_callback)\n    canvas.addEventListener(\"pointerout\", this._mouseout_callback)\n    canvas.addEventListener(\"pointercancel\", this._mousecancel_callback, true)\n\n    canvas.addEventListener(\"contextmenu\", this._doNothing)\n\n    // Keyboard\n    this._key_callback = this.processKey.bind(this)\n\n    canvas.addEventListener(\"keydown\", this._key_callback, true)\n    // keyup event must be bound on the document\n    document.addEventListener(\"keyup\", this._key_callback, true)\n\n    canvas.addEventListener(\"dragover\", this._doNothing, false)\n    canvas.addEventListener(\"dragend\", this._doNothing, false)\n    canvas.addEventListener(\"dragenter\", this._doReturnTrue, false)\n\n    this._events_binded = true\n  }\n\n  /**\n   * unbinds mouse events from the canvas\n   */\n  unbindEvents(): void {\n    if (!this._events_binded) {\n      console.warn(\"LGraphCanvas: no events binded\")\n      return\n    }\n\n    // console.log(\"pointerevents: unbindEvents\");\n    const { document } = this.getCanvasWindow()\n    const { canvas } = this\n\n    // Assertions: removing nullish is fine.\n    canvas.removeEventListener(\"pointercancel\", this._mousecancel_callback!)\n    canvas.removeEventListener(\"pointerout\", this._mouseout_callback!)\n    canvas.removeEventListener(\"pointermove\", this._mousemove_callback!)\n    canvas.removeEventListener(\"pointerup\", this._mouseup_callback!)\n    canvas.removeEventListener(\"pointerdown\", this._mousedown_callback!)\n    canvas.removeEventListener(\"wheel\", this._mousewheel_callback!)\n    canvas.removeEventListener(\"keydown\", this._key_callback!)\n    document.removeEventListener(\"keyup\", this._key_callback!)\n    canvas.removeEventListener(\"contextmenu\", this._doNothing)\n    canvas.removeEventListener(\"dragenter\", this._doReturnTrue)\n\n    this._mousedown_callback = undefined\n    this._mousewheel_callback = undefined\n    this._key_callback = undefined\n\n    this._events_binded = false\n  }\n\n  /**\n   * Ensures the canvas will be redrawn on the next frame by setting the dirty flag(s).\n   * Without parameters, this function does nothing.\n   * @todo Impl. `setDirty()` or similar as shorthand to redraw everything.\n   * @param fgcanvas If true, marks the foreground canvas as dirty (nodes and anything drawn on top of them).  Default: false\n   * @param bgcanvas If true, mark the background canvas as dirty (background, groups, links).  Default: false\n   */\n  setDirty(fgcanvas: boolean, bgcanvas?: boolean): void {\n    if (fgcanvas) this.dirty_canvas = true\n    if (bgcanvas) this.dirty_bgcanvas = true\n  }\n\n  /** Marks the entire canvas as dirty. */\n  #dirty(): void {\n    this.dirty_canvas = true\n    this.dirty_bgcanvas = true\n  }\n\n  #linkConnectorDrop(): void {\n    const { graph, linkConnector, pointer } = this\n    if (!graph) throw new NullGraphError()\n\n    pointer.onDragEnd = upEvent => linkConnector.dropLinks(graph, upEvent)\n    pointer.finally = () => {\n      this.linkConnector.reset(true)\n      this.#dirty()\n    }\n  }\n\n  /**\n   * Used to attach the canvas in a popup\n   * @returns returns the window where the canvas is attached (the DOM root node)\n   */\n  getCanvasWindow(): Window {\n    if (!this.canvas) return window\n\n    const doc = this.canvas.ownerDocument\n    // @ts-expect-error Check if required\n    return doc.defaultView || doc.parentWindow\n  }\n\n  /**\n   * starts rendering the content of the canvas when needed\n   *\n   */\n  startRendering(): void {\n    // already rendering\n    if (this.is_rendering) return\n\n    this.is_rendering = true\n    renderFrame.call(this)\n\n    /** Render loop */\n    function renderFrame(this: LGraphCanvas) {\n      if (!this.pause_rendering) {\n        this.draw()\n      }\n\n      const window = this.getCanvasWindow()\n      if (this.is_rendering) {\n        if (this.#maximumFrameGap > 0) {\n          // Manual FPS limit\n          const gap = this.#maximumFrameGap - (LiteGraph.getTime() - this.last_draw_time)\n          setTimeout(renderFrame.bind(this), Math.max(1, gap))\n        } else {\n          // FPS limited by refresh rate\n          window.requestAnimationFrame(renderFrame.bind(this))\n        }\n      }\n    }\n  }\n\n  /**\n   * stops rendering the content of the canvas (to save resources)\n   *\n   */\n  stopRendering(): void {\n    this.is_rendering = false\n    /*\n    if(this.rendering_timer_id)\n    {\n        clearInterval(this.rendering_timer_id);\n        this.rendering_timer_id = null;\n    }\n    */\n  }\n\n  /* LiteGraphCanvas input */\n  // used to block future mouse events (because of im gui)\n  blockClick(): void {\n    this.block_click = true\n    this.last_mouseclick = 0\n  }\n\n  /**\n   * Gets the widget at the current cursor position.\n   * @param node Optional node to check for widgets under cursor\n   * @returns The widget located at the current cursor position, if any is found.\n   * @deprecated Use {@link LGraphNode.getWidgetOnPos} instead.\n   * ```ts\n   * const [x, y] = canvas.graph_mouse\n   * const widget = canvas.node_over?.getWidgetOnPos(x, y, true)\n   * ```\n   */\n  getWidgetAtCursor(node?: LGraphNode): IBaseWidget | undefined {\n    node ??= this.node_over\n    return node?.getWidgetOnPos(this.graph_mouse[0], this.graph_mouse[1], true)\n  }\n\n  /**\n   * Clears highlight and mouse-over information from nodes that should not have it.\n   *\n   * Intended to be called when the pointer moves away from a node.\n   * @param node The node that the mouse is now over\n   * @param e MouseEvent that is triggering this\n   */\n  updateMouseOverNodes(node: LGraphNode | null, e: CanvasMouseEvent): void {\n    if (!this.graph) throw new NullGraphError()\n\n    const nodes = this.graph._nodes\n    for (const otherNode of nodes) {\n      if (otherNode.mouseOver && node != otherNode) {\n        // mouse leave\n        otherNode.mouseOver = undefined\n        this._highlight_input = undefined\n        this._highlight_pos = undefined\n        this.linkConnector.overWidget = undefined\n\n        // Hover transitions\n        // TODO: Implement single lerp ease factor for current progress on hover in/out.\n        // In drawNode, multiply by ease factor and differential value (e.g. bg alpha +0.5).\n        otherNode.lostFocusAt = LiteGraph.getTime()\n\n        this.node_over?.onMouseLeave?.(e)\n        this.node_over = undefined\n        this.dirty_canvas = true\n      }\n    }\n  }\n\n  processMouseDown(e: PointerEvent): void {\n    if (this.dragZoomEnabled && e.ctrlKey && e.shiftKey && !e.altKey && e.buttons) {\n      this.#dragZoomStart = { pos: [e.x, e.y], scale: this.ds.scale }\n      return\n    }\n\n    const { graph, pointer } = this\n    this.adjustMouseEvent(e)\n    if (e.isPrimary) pointer.down(e)\n\n    if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true\n\n    if (!graph) return\n\n    const ref_window = this.getCanvasWindow()\n    LGraphCanvas.active_canvas = this\n\n    const x = e.clientX\n    const y = e.clientY\n    this.ds.viewport = this.viewport\n    const is_inside = !this.viewport || isInRect(x, y, this.viewport)\n\n    if (!is_inside) return\n\n    const node = graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes) ?? undefined\n\n    this.mouse[0] = x\n    this.mouse[1] = y\n    this.graph_mouse[0] = e.canvasX\n    this.graph_mouse[1] = e.canvasY\n    this.last_click_position = [this.mouse[0], this.mouse[1]]\n\n    pointer.isDouble = pointer.isDown && e.isPrimary\n    pointer.isDown = true\n\n    this.canvas.focus()\n\n    LiteGraph.closeAllContextMenus(ref_window)\n\n    if (this.onMouse?.(e) == true) return\n\n    // left button mouse / single finger\n    if (e.button === 0 && !pointer.isDouble) {\n      this.#processPrimaryButton(e, node)\n    } else if (e.button === 1) {\n      this.#processMiddleButton(e, node)\n    } else if (\n      (e.button === 2 || pointer.isDouble) &&\n      this.allow_interaction &&\n      !this.read_only\n    ) {\n      // Right / aux button\n\n      // Sticky select - won't remove single nodes\n      if (node) {\n        this.processSelect(node, e, true)\n      } else if (this.links_render_mode !== LinkRenderType.HIDDEN_LINK) {\n        // Reroutes\n        const reroute = graph.getRerouteOnPos(e.canvasX, e.canvasY, this.#visibleReroutes)\n        if (reroute) {\n          if (e.altKey) {\n            pointer.onClick = (upEvent) => {\n              if (upEvent.altKey) {\n                // Ensure deselected\n                if (reroute.selected) {\n                  this.deselect(reroute)\n                  this.onSelectionChange?.(this.selected_nodes)\n                }\n                reroute.remove()\n              }\n            }\n          } else {\n            this.processSelect(reroute, e, true)\n          }\n        }\n      }\n\n      // Show context menu for the node or group under the pointer\n      pointer.onClick ??= () => this.processContextMenu(node, e)\n    }\n\n    this.last_mouse = [x, y]\n    this.last_mouseclick = LiteGraph.getTime()\n    this.last_mouse_dragging = true\n\n    graph.change()\n\n    // this is to ensure to defocus(blur) if a text input element is on focus\n    if (\n      !ref_window.document.activeElement ||\n      (ref_window.document.activeElement.nodeName.toLowerCase() != \"input\" &&\n        ref_window.document.activeElement.nodeName.toLowerCase() != \"textarea\")\n    ) {\n      e.preventDefault()\n    }\n    e.stopPropagation()\n\n    this.onMouseDown?.(e)\n  }\n\n  #processPrimaryButton(e: CanvasPointerEvent, node: LGraphNode | undefined) {\n    const { pointer, graph, linkConnector } = this\n    if (!graph) throw new NullGraphError()\n\n    const x = e.canvasX\n    const y = e.canvasY\n\n    // Modifiers\n    const ctrlOrMeta = e.ctrlKey || e.metaKey\n\n    // Multi-select drag rectangle\n    if (ctrlOrMeta && !e.altKey) {\n      const dragRect = new Float32Array(4)\n      dragRect[0] = x\n      dragRect[1] = y\n      dragRect[2] = 1\n      dragRect[3] = 1\n\n      pointer.onClick = (eUp) => {\n        // Click, not drag\n        const clickedItem = node ??\n          graph.getRerouteOnPos(eUp.canvasX, eUp.canvasY, this.#visibleReroutes) ??\n          graph.getGroupTitlebarOnPos(eUp.canvasX, eUp.canvasY)\n        this.processSelect(clickedItem, eUp)\n      }\n      pointer.onDragStart = () => this.dragging_rectangle = dragRect\n      pointer.onDragEnd = upEvent => this.#handleMultiSelect(upEvent, dragRect)\n      pointer.finally = () => this.dragging_rectangle = null\n      return\n    }\n\n    if (this.read_only) {\n      pointer.finally = () => this.dragging_canvas = false\n      this.dragging_canvas = true\n      return\n    }\n\n    // clone node ALT dragging\n    if (LiteGraph.alt_drag_do_clone_nodes && e.altKey && !e.ctrlKey && node && this.allow_interaction) {\n      const node_data = node.clone()?.serialize()\n      if (node_data?.type != null) {\n        const cloned = LiteGraph.createNode(node_data.type)\n        if (cloned) {\n          cloned.configure(node_data)\n          cloned.pos[0] += 5\n          cloned.pos[1] += 5\n\n          if (this.allow_dragnodes) {\n            pointer.onDragStart = (pointer) => {\n              graph.add(cloned, false)\n              this.#startDraggingItems(cloned, pointer)\n            }\n            pointer.onDragEnd = e => this.#processDraggedItems(e)\n          } else {\n          // TODO: Check if before/after change are necessary here.\n            graph.beforeChange()\n            graph.add(cloned, false)\n            graph.afterChange()\n          }\n\n          return\n        }\n      }\n    }\n\n    // Node clicked\n    if (node && (this.allow_interaction || node.flags.allow_interaction)) {\n      this.#processNodeClick(e, ctrlOrMeta, node)\n    } else {\n      // Reroutes\n      if (this.links_render_mode !== LinkRenderType.HIDDEN_LINK) {\n        for (const reroute of this.#visibleReroutes) {\n          const overReroute = reroute.containsPoint([x, y])\n          if (!reroute.isSlotHovered && !overReroute) continue\n\n          if (overReroute) {\n            pointer.onClick = () => this.processSelect(reroute, e)\n            if (!e.shiftKey) {\n              pointer.onDragStart = pointer => this.#startDraggingItems(reroute, pointer, true)\n              pointer.onDragEnd = e => this.#processDraggedItems(e)\n            }\n          }\n\n          if (reroute.isOutputHovered || (overReroute && e.shiftKey)) {\n            linkConnector.dragFromReroute(graph, reroute)\n            this.#linkConnectorDrop()\n          }\n\n          if (reroute.isInputHovered) {\n            linkConnector.dragFromRerouteToOutput(graph, reroute)\n            this.#linkConnectorDrop()\n          }\n\n          reroute.hideSlots()\n          this.dirty_bgcanvas = true\n          return\n        }\n      }\n\n      // Links - paths of links & reroutes\n      // Set the width of the line for isPointInStroke checks\n      const { lineWidth } = this.ctx\n      this.ctx.lineWidth = this.connections_width + 7\n      const dpi = window?.devicePixelRatio || 1\n\n      for (const linkSegment of this.renderedPaths) {\n        const centre = linkSegment._pos\n        if (!centre) continue\n\n        // If we shift click on a link then start a link from that input\n        if (\n          (e.shiftKey || e.altKey) &&\n          linkSegment.path &&\n          this.ctx.isPointInStroke(linkSegment.path, x * dpi, y * dpi)\n        ) {\n          this.ctx.lineWidth = lineWidth\n\n          if (e.shiftKey && !e.altKey) {\n            linkConnector.dragFromLinkSegment(graph, linkSegment)\n            this.#linkConnectorDrop()\n\n            return\n          } else if (e.altKey && !e.shiftKey) {\n            const newReroute = graph.createReroute([x, y], linkSegment)\n            pointer.onDragStart = pointer => this.#startDraggingItems(newReroute, pointer)\n            pointer.onDragEnd = e => this.#processDraggedItems(e)\n            return\n          }\n        } else if (isInRectangle(x, y, centre[0] - 4, centre[1] - 4, 8, 8)) {\n          this.ctx.lineWidth = lineWidth\n\n          pointer.onClick = () => this.showLinkMenu(linkSegment, e)\n          pointer.onDragStart = () => this.dragging_canvas = true\n          pointer.finally = () => this.dragging_canvas = false\n\n          // clear tooltip\n          this.over_link_center = undefined\n          return\n        }\n      }\n\n      // Restore line width\n      this.ctx.lineWidth = lineWidth\n\n      // Groups\n      const group = graph.getGroupOnPos(x, y)\n      this.selected_group = group ?? null\n      if (group) {\n        if (group.isInResize(x, y)) {\n          // Resize group\n          const b = group.boundingRect\n          const offsetX = x - (b[0] + b[2])\n          const offsetY = y - (b[1] + b[3])\n\n          pointer.onDragStart = () => this.resizingGroup = group\n          pointer.onDrag = (eMove) => {\n            if (this.read_only) return\n\n            // Resize only by the exact pointer movement\n            const pos: Point = [\n              eMove.canvasX - group.pos[0] - offsetX,\n              eMove.canvasY - group.pos[1] - offsetY,\n            ]\n            // Unless snapping.\n            if (this.#snapToGrid) snapPoint(pos, this.#snapToGrid)\n\n            const resized = group.resize(pos[0], pos[1])\n            if (resized) this.dirty_bgcanvas = true\n          }\n          pointer.finally = () => this.resizingGroup = null\n        } else {\n          const f = group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE\n          const headerHeight = f * 1.4\n          if (\n            isInRectangle(\n              x,\n              y,\n              group.pos[0],\n              group.pos[1],\n              group.size[0],\n              headerHeight,\n            )\n          ) {\n            // In title bar\n            pointer.onClick = () => this.processSelect(group, e)\n            pointer.onDragStart = (pointer) => {\n              group.recomputeInsideNodes()\n              this.#startDraggingItems(group, pointer, true)\n            }\n            pointer.onDragEnd = e => this.#processDraggedItems(e)\n          }\n        }\n\n        pointer.onDoubleClick = () => {\n          this.emitEvent({\n            subType: \"group-double-click\",\n            originalEvent: e,\n            group,\n          })\n        }\n      } else {\n        pointer.onDoubleClick = () => {\n          // Double click within group should not trigger the searchbox.\n          if (this.allow_searchbox) {\n            this.showSearchBox(e)\n            e.preventDefault()\n          }\n          this.emitEvent({\n            subType: \"empty-double-click\",\n            originalEvent: e,\n          })\n        }\n      }\n    }\n\n    if (\n      !pointer.onDragStart &&\n      !pointer.onClick &&\n      !pointer.onDrag &&\n      this.allow_dragcanvas\n    ) {\n      pointer.onClick = () => this.processSelect(null, e)\n      pointer.finally = () => this.dragging_canvas = false\n      this.dragging_canvas = true\n    }\n  }\n\n  /**\n   * Processes a pointerdown event inside the bounds of a node.  Part of {@link processMouseDown}.\n   * @param e The pointerdown event\n   * @param ctrlOrMeta Ctrl or meta key is pressed\n   * @param node The node to process a click event for\n   */\n  #processNodeClick(\n    e: CanvasPointerEvent,\n    ctrlOrMeta: boolean,\n    node: LGraphNode,\n  ): void {\n    const { pointer, graph, linkConnector } = this\n    if (!graph) throw new NullGraphError()\n\n    const x = e.canvasX\n    const y = e.canvasY\n\n    pointer.onClick = () => this.processSelect(node, e)\n\n    // Immediately bring to front\n    if (!node.flags.pinned) {\n      this.bringToFront(node)\n    }\n\n    // Collapse toggle\n    const inCollapse = node.isPointInCollapse(x, y)\n    if (inCollapse) {\n      pointer.onClick = () => {\n        node.collapse()\n        this.setDirty(true, true)\n      }\n    } else if (!node.flags.collapsed) {\n      // Resize node\n      if (node.resizable !== false && node.inResizeCorner(x, y)) {\n        const b = node.boundingRect\n        const offsetX = x - (b[0] + b[2])\n        const offsetY = y - (b[1] + b[3])\n\n        pointer.onDragStart = () => {\n          graph.beforeChange()\n          this.resizing_node = node\n        }\n\n        pointer.onDrag = (eMove) => {\n          if (this.read_only) return\n\n          // Resize only by the exact pointer movement\n          const pos: Point = [\n            eMove.canvasX - node.pos[0] - offsetX,\n            eMove.canvasY - node.pos[1] - offsetY,\n          ]\n          // Unless snapping.\n          if (this.#snapToGrid) snapPoint(pos, this.#snapToGrid)\n\n          const min = node.computeSize()\n          pos[0] = Math.max(min[0], pos[0])\n          pos[1] = Math.max(min[1], pos[1])\n          node.setSize(pos)\n\n          this.#dirty()\n        }\n\n        pointer.onDragEnd = () => {\n          this.#dirty()\n          graph.afterChange(this.resizing_node)\n        }\n        pointer.finally = () => this.resizing_node = null\n        this.canvas.style.cursor = \"se-resize\"\n        return\n      }\n\n      const { inputs, outputs } = node\n\n      // Outputs\n      if (outputs) {\n        for (const [i, output] of outputs.entries()) {\n          const link_pos = node.getOutputPos(i)\n          if (isInRectangle(x, y, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n            // Drag multiple output links\n            if (e.shiftKey && (output.links?.length || output._floatingLinks?.size)) {\n              linkConnector.moveOutputLink(graph, output)\n              this.#linkConnectorDrop()\n              return\n            }\n\n            // New output link\n            linkConnector.dragNewFromOutput(graph, node, output)\n            this.#linkConnectorDrop()\n\n            if (LiteGraph.shift_click_do_break_link_from) {\n              if (e.shiftKey) {\n                node.disconnectOutput(i)\n              }\n            } else if (LiteGraph.ctrl_alt_click_do_break_link) {\n              if (ctrlOrMeta && e.altKey && !e.shiftKey) {\n                node.disconnectOutput(i)\n              }\n            }\n\n            // TODO: Move callbacks to the start of this closure (onInputClick is already correct).\n            pointer.onDoubleClick = () => node.onOutputDblClick?.(i, e)\n            pointer.onClick = () => node.onOutputClick?.(i, e)\n\n            return\n          }\n        }\n      }\n\n      // Inputs\n      if (inputs) {\n        for (const [i, input] of inputs.entries()) {\n          const link_pos = node.getInputPos(i)\n          const isInSlot = input instanceof NodeInputSlot\n            ? isInRect(x, y, input.boundingRect)\n            : isInRectangle(x, y, link_pos[0] - 15, link_pos[1] - 10, 30, 20)\n\n          if (isInSlot) {\n            pointer.onDoubleClick = () => node.onInputDblClick?.(i, e)\n            pointer.onClick = () => node.onInputClick?.(i, e)\n\n            const shouldBreakLink = LiteGraph.ctrl_alt_click_do_break_link &&\n              ctrlOrMeta &&\n              e.altKey &&\n              !e.shiftKey\n            if (input.link !== null || input._floatingLinks?.size) {\n              // Existing link\n              if (shouldBreakLink || LiteGraph.click_do_break_link_to) {\n                node.disconnectInput(i, true)\n              } else if (e.shiftKey || this.allow_reconnect_links) {\n                linkConnector.moveInputLink(graph, input)\n              }\n            }\n\n            // Dragging a new link from input to output\n            if (!linkConnector.isConnecting) {\n              linkConnector.dragNewFromInput(graph, node, input)\n            }\n\n            this.#linkConnectorDrop()\n            this.dirty_bgcanvas = true\n\n            return\n          }\n        }\n      }\n    }\n\n    // Click was inside the node, but not on input/output, or the resize corner\n    const pos: Point = [x - node.pos[0], y - node.pos[1]]\n\n    // Widget\n    const widget = node.getWidgetOnPos(x, y)\n    if (widget) {\n      this.#processWidgetClick(e, node, widget)\n      this.node_widget = [node, widget]\n    } else {\n      pointer.onDoubleClick = () => {\n        // Double-click\n        // Check if it's a double click on the title bar\n        // Note: pos[1] is the y-coordinate of the node's body\n        // If clicking on node header (title), pos[1] is negative\n        if (pos[1] < 0 && !inCollapse) {\n          node.onNodeTitleDblClick?.(e, pos, this)\n        }\n        node.onDblClick?.(e, pos, this)\n        this.emitEvent({\n          subType: \"node-double-click\",\n          originalEvent: e,\n          node,\n        })\n        this.processNodeDblClicked(node)\n      }\n\n      // Mousedown callback - can block drag\n      if (node.onMouseDown?.(e, pos, this) || !this.allow_dragnodes)\n        return\n\n      // Drag node\n      pointer.onDragStart = pointer => this.#startDraggingItems(node, pointer, true)\n      pointer.onDragEnd = e => this.#processDraggedItems(e)\n    }\n\n    this.dirty_canvas = true\n  }\n\n  #processWidgetClick(e: CanvasPointerEvent, node: LGraphNode, widget: IBaseWidget) {\n    const { pointer } = this\n\n    // Custom widget - CanvasPointer\n    if (typeof widget.onPointerDown === \"function\") {\n      const handled = widget.onPointerDown(pointer, node, this)\n      if (handled) return\n    }\n\n    const oldValue = widget.value\n\n    const pos = this.graph_mouse\n    const x = pos[0] - node.pos[0]\n    const y = pos[1] - node.pos[1]\n\n    const widgetInstance = toConcreteWidget(widget, node, false)\n    if (widgetInstance) {\n      pointer.onClick = () => widgetInstance.onClick({\n        e,\n        node,\n        canvas: this,\n      })\n      pointer.onDrag = eMove => widgetInstance.onDrag?.({\n        e: eMove,\n        node,\n        canvas: this,\n      })\n    } else if (widget.mouse) {\n      const result = widget.mouse(e, [x, y], node)\n      if (result != null) this.dirty_canvas = result\n    }\n\n    // value changed\n    if (oldValue != widget.value) {\n      node.onWidgetChanged?.(widget.name, widget.value, oldValue, widget)\n      if (!node.graph) throw new NullGraphError()\n      node.graph._version++\n    }\n\n    // Clean up state var\n    pointer.finally = () => {\n      // Legacy custom widget callback\n      if (widget.mouse) {\n        const { eUp } = pointer\n        if (!eUp) return\n        const { canvasX, canvasY } = eUp\n        widget.mouse(eUp, [canvasX - node.pos[0], canvasY - node.pos[1]], node)\n      }\n\n      this.node_widget = null\n    }\n  }\n\n  /**\n   * Pointer middle button click processing.  Part of {@link processMouseDown}.\n   * @param e The pointerdown event\n   * @param node The node to process a click event for\n   */\n  #processMiddleButton(e: CanvasPointerEvent, node: LGraphNode | undefined) {\n    const { pointer } = this\n\n    if (\n      LiteGraph.middle_click_slot_add_default_node &&\n      node &&\n      this.allow_interaction &&\n      !this.read_only &&\n      !this.connecting_links &&\n      !node.flags.collapsed\n    ) {\n      // not dragging mouse to connect two slots\n      let mClikSlot: INodeSlot | false = false\n      let mClikSlot_index: number | false = false\n      let mClikSlot_isOut: boolean = false\n      const { inputs, outputs } = node\n\n      // search for outputs\n      if (outputs) {\n        for (const [i, output] of outputs.entries()) {\n          const link_pos = node.getOutputPos(i)\n          if (isInRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n            mClikSlot = output\n            mClikSlot_index = i\n            mClikSlot_isOut = true\n            break\n          }\n        }\n      }\n\n      // search for inputs\n      if (inputs) {\n        for (const [i, input] of inputs.entries()) {\n          const link_pos = node.getInputPos(i)\n          if (isInRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n            mClikSlot = input\n            mClikSlot_index = i\n            mClikSlot_isOut = false\n            break\n          }\n        }\n      }\n      // Middle clicked a slot\n      if (mClikSlot && mClikSlot_index !== false) {\n        const alphaPosY =\n          0.5 -\n          (mClikSlot_index + 1) /\n          (mClikSlot_isOut ? outputs.length : inputs.length)\n        const node_bounding = node.getBounding()\n        // estimate a position: this is a bad semi-bad-working mess .. REFACTOR with\n        // a correct autoplacement that knows about the others slots and nodes\n        const posRef: Point = [\n          !mClikSlot_isOut\n            ? node_bounding[0]\n            : node_bounding[0] + node_bounding[2],\n          e.canvasY - 80,\n        ]\n\n        pointer.onClick = () => this.createDefaultNodeForSlot({\n          nodeFrom: !mClikSlot_isOut ? null : node,\n          slotFrom: !mClikSlot_isOut ? null : mClikSlot_index,\n          nodeTo: !mClikSlot_isOut ? node : null,\n          slotTo: !mClikSlot_isOut ? mClikSlot_index : null,\n          position: posRef,\n          nodeType: \"AUTO\",\n          posAdd: [!mClikSlot_isOut ? -30 : 30, -alphaPosY * 130],\n          posSizeFix: [!mClikSlot_isOut ? -1 : 0, 0],\n        })\n      }\n    }\n\n    // Drag canvas using middle mouse button\n    if (this.allow_dragcanvas) {\n      pointer.onDragStart = () => this.dragging_canvas = true\n      pointer.finally = () => this.dragging_canvas = false\n    }\n  }\n\n  #processDragZoom(e: PointerEvent): void {\n    // stop canvas zoom action\n    if (!e.buttons) {\n      this.#dragZoomStart = null\n      return\n    }\n\n    const start = this.#dragZoomStart\n    if (!start) throw new TypeError(\"Drag-zoom state object was null\")\n    if (!this.graph) throw new NullGraphError()\n\n    // calculate delta\n    const deltaY = e.y - start.pos[1]\n    const startScale = start.scale\n\n    const scale = startScale - deltaY / 100\n\n    this.ds.changeScale(scale, start.pos)\n    this.graph.change()\n  }\n\n  /**\n   * Called when a mouse move event has to be processed\n   */\n  processMouseMove(e: PointerEvent): void {\n    if (this.dragZoomEnabled && e.ctrlKey && e.shiftKey && this.#dragZoomStart) {\n      this.#processDragZoom(e)\n      return\n    }\n\n    if (this.autoresize) this.resize()\n\n    if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true\n\n    const { graph, resizingGroup, linkConnector } = this\n    if (!graph) return\n\n    LGraphCanvas.active_canvas = this\n    this.adjustMouseEvent(e)\n    const mouse: ReadOnlyPoint = [e.clientX, e.clientY]\n    this.mouse[0] = mouse[0]\n    this.mouse[1] = mouse[1]\n    const delta = [\n      mouse[0] - this.last_mouse[0],\n      mouse[1] - this.last_mouse[1],\n    ]\n    this.last_mouse = mouse\n    this.graph_mouse[0] = e.canvasX\n    this.graph_mouse[1] = e.canvasY\n\n    if (e.isPrimary) this.pointer.move(e)\n\n    if (this.block_click) {\n      e.preventDefault()\n      return\n    }\n\n    e.dragging = this.last_mouse_dragging\n\n    if (this.node_widget) {\n      // Legacy widget mouse callbacks for pointermove events\n      const [node, widget] = this.node_widget\n\n      if (widget?.mouse) {\n        const x = e.canvasX - node.pos[0]\n        const y = e.canvasY - node.pos[1]\n        const result = widget.mouse(e, [x, y], node)\n        if (result != null) this.dirty_canvas = result\n      }\n    }\n\n    /** See {@link state}.{@link LGraphCanvasState.hoveringOver hoveringOver} */\n    let underPointer = CanvasItem.Nothing\n    // get node over\n    const node = graph.getNodeOnPos(\n      e.canvasX,\n      e.canvasY,\n      this.visible_nodes,\n    )\n\n    const dragRect = this.dragging_rectangle\n    if (dragRect) {\n      dragRect[2] = e.canvasX - dragRect[0]\n      dragRect[3] = e.canvasY - dragRect[1]\n      this.dirty_canvas = true\n    } else if (resizingGroup) {\n      // Resizing a group\n      underPointer |= CanvasItem.ResizeSe | CanvasItem.Group\n    } else if (this.dragging_canvas) {\n      this.ds.offset[0] += delta[0] / this.ds.scale\n      this.ds.offset[1] += delta[1] / this.ds.scale\n      this.#dirty()\n    } else if (\n      (this.allow_interaction || node?.flags.allow_interaction) &&\n      !this.read_only\n    ) {\n      if (linkConnector.isConnecting) this.dirty_canvas = true\n\n      // remove mouseover flag\n      this.updateMouseOverNodes(node, e)\n\n      // mouse over a node\n      if (node) {\n        underPointer |= CanvasItem.Node\n\n        if (node.redraw_on_mouse) this.dirty_canvas = true\n\n        // For input/output hovering\n        // to store the output of isOverNodeInput\n        const pos: Point = [0, 0]\n        const inputId = isOverNodeInput(node, e.canvasX, e.canvasY, pos)\n        const outputId = isOverNodeOutput(node, e.canvasX, e.canvasY, pos)\n        const overWidget = node.getWidgetOnPos(e.canvasX, e.canvasY, true) ?? undefined\n\n        if (!node.mouseOver) {\n          // mouse enter\n          node.mouseOver = {}\n          this.node_over = node\n          this.dirty_canvas = true\n\n          for (const reroute of this.#visibleReroutes) {\n            reroute.hideSlots()\n            this.dirty_bgcanvas = true\n          }\n          node.onMouseEnter?.(e)\n        }\n\n        // in case the node wants to do something\n        node.onMouseMove?.(e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this)\n\n        // The input the mouse is over has changed\n        const { mouseOver } = node\n        if (\n          mouseOver.inputId !== inputId ||\n          mouseOver.outputId !== outputId ||\n          mouseOver.overWidget !== overWidget\n        ) {\n          mouseOver.inputId = inputId\n          mouseOver.outputId = outputId\n          mouseOver.overWidget = overWidget\n\n          // State reset\n          linkConnector.overWidget = undefined\n\n          // Check if link is over anything it could connect to - record position of valid target for snap / highlight\n          if (linkConnector.isConnecting) {\n            const firstLink = linkConnector.renderLinks.at(0)\n\n            // Default: nothing highlighted\n            let highlightPos: Point | undefined\n            let highlightInput: INodeInputSlot | undefined\n\n            if (!firstLink || !linkConnector.isNodeValidDrop(node)) {\n              // No link, or none of the dragged links may be dropped here\n            } else if (linkConnector.state.connectingTo === \"input\") {\n              if (overWidget) {\n                // Check widgets first - inputId is only valid if over the input socket\n                const slot = node.getSlotFromWidget(overWidget)\n\n                if (slot && linkConnector.isInputValidDrop(node, slot)) {\n                  highlightInput = slot\n                  highlightPos = node.getInputSlotPos(slot)\n                  linkConnector.overWidget = overWidget\n                }\n              }\n\n              // Not over a valid widget - treat drop on invalid widget same as node background\n              if (!linkConnector.overWidget) {\n                if (inputId === -1 && outputId === -1) {\n                // Node background / title under the pointer\n                  const result = node.findInputByType(firstLink.fromSlot.type)\n                  if (result) {\n                    highlightInput = result.slot\n                    highlightPos = node.getInputSlotPos(result.slot)\n                  }\n                } else if (\n                  inputId != -1 &&\n                  node.inputs[inputId] &&\n                  LiteGraph.isValidConnection(firstLink.fromSlot.type, node.inputs[inputId].type)\n                ) {\n                  highlightPos = pos\n                  // XXX CHECK THIS\n                  highlightInput = node.inputs[inputId]\n                }\n\n                if (highlightInput) {\n                  const widget = node.getWidgetFromSlot(highlightInput)\n                  if (widget) linkConnector.overWidget = widget\n                }\n              }\n            } else if (linkConnector.state.connectingTo === \"output\") {\n              // Connecting from an input to an output\n              if (inputId === -1 && outputId === -1) {\n                const result = node.findOutputByType(firstLink.fromSlot.type)\n                if (result) {\n                  highlightPos = node.getOutputPos(result.index)\n                }\n              } else {\n                // check if I have a slot below de mouse\n                if (\n                  outputId != -1 &&\n                  node.outputs[outputId] &&\n                  LiteGraph.isValidConnection(firstLink.fromSlot.type, node.outputs[outputId].type)\n                ) {\n                  highlightPos = pos\n                }\n              }\n            }\n            this._highlight_pos = highlightPos\n            this._highlight_input = highlightInput\n          }\n\n          this.dirty_canvas = true\n        }\n\n        // Resize corner\n        if (node.inResizeCorner(e.canvasX, e.canvasY)) {\n          underPointer |= CanvasItem.ResizeSe\n        }\n      } else {\n        // Reroutes\n        underPointer = this.#updateReroutes(underPointer)\n\n        // Not over a node\n        const segment = this.#getLinkCentreOnPos(e)\n        if (this.over_link_center !== segment) {\n          underPointer |= CanvasItem.Link\n          this.over_link_center = segment\n          this.dirty_bgcanvas = true\n        }\n\n        if (this.canvas) {\n          const group = graph.getGroupOnPos(e.canvasX, e.canvasY)\n          if (\n            group &&\n            !e.ctrlKey &&\n            !this.read_only &&\n            group.isInResize(e.canvasX, e.canvasY)\n          ) {\n            underPointer |= CanvasItem.ResizeSe\n          }\n        }\n      }\n\n      // send event to node if capturing input (used with widgets that allow drag outside of the area of the node)\n      if (this.node_capturing_input && this.node_capturing_input != node) {\n        this.node_capturing_input.onMouseMove?.(\n          e,\n          [\n            e.canvasX - this.node_capturing_input.pos[0],\n            e.canvasY - this.node_capturing_input.pos[1],\n          ],\n          this,\n        )\n      }\n\n      // Items being dragged\n      if (this.isDragging) {\n        const selected = this.selectedItems\n        const allItems = e.ctrlKey ? selected : getAllNestedItems(selected)\n\n        const deltaX = delta[0] / this.ds.scale\n        const deltaY = delta[1] / this.ds.scale\n        for (const item of allItems) {\n          item.move(deltaX, deltaY, true)\n        }\n\n        this.#dirty()\n      }\n\n      if (this.resizing_node) underPointer |= CanvasItem.ResizeSe\n    }\n\n    this.hoveringOver = underPointer\n\n    e.preventDefault()\n    return\n  }\n\n  /**\n   * Updates the hover / snap state of all visible reroutes.\n   * @returns The original value of {@link underPointer}, with any found reroute items added.\n   */\n  #updateReroutes(underPointer: CanvasItem): CanvasItem {\n    const { graph, pointer, linkConnector } = this\n    if (!graph) throw new NullGraphError()\n\n    // Update reroute hover state\n    if (!pointer.isDown) {\n      let anyChanges = false\n      for (const reroute of this.#visibleReroutes) {\n        anyChanges ||= reroute.updateVisibility(this.graph_mouse)\n\n        if (reroute.isSlotHovered) underPointer |= CanvasItem.RerouteSlot\n      }\n      if (anyChanges) this.dirty_bgcanvas = true\n    } else if (linkConnector.isConnecting) {\n      // Highlight the reroute that the mouse is over\n      for (const reroute of this.#visibleReroutes) {\n        if (reroute.containsPoint(this.graph_mouse)) {\n          if (linkConnector.isRerouteValidDrop(reroute)) {\n            linkConnector.overReroute = reroute\n            this._highlight_pos = reroute.pos\n          }\n\n          return underPointer |= CanvasItem.RerouteSlot\n        }\n      }\n    }\n\n    this._highlight_pos &&= undefined\n    linkConnector.overReroute &&= undefined\n    return underPointer\n  }\n\n  /**\n   * Start dragging an item, optionally including all other selected items.\n   *\n   * ** This function sets the {@link CanvasPointer.finally}() callback. **\n   * @param item The item that the drag event started on\n   * @param pointer The pointer event that initiated the drag, e.g. pointerdown\n   * @param sticky If `true`, the item is added to the selection - see {@link processSelect}\n   */\n  #startDraggingItems(item: Positionable, pointer: CanvasPointer, sticky = false): void {\n    this.emitBeforeChange()\n    this.graph?.beforeChange()\n    // Ensure that dragging is properly cleaned up, on success or failure.\n    pointer.finally = () => {\n      this.isDragging = false\n      this.graph?.afterChange()\n      this.emitAfterChange()\n    }\n\n    this.processSelect(item, pointer.eDown, sticky)\n    this.isDragging = true\n  }\n\n  /**\n   * Handles shared clean up and placement after items have been dragged.\n   * @param e The event that completed the drag, e.g. pointerup, pointermove\n   */\n  #processDraggedItems(e: CanvasPointerEvent): void {\n    const { graph } = this\n    if (e.shiftKey || LiteGraph.alwaysSnapToGrid)\n      graph?.snapToGrid(this.selectedItems)\n\n    this.dirty_canvas = true\n    this.dirty_bgcanvas = true\n\n    // TODO: Replace legacy behaviour: callbacks were never extended for multiple items\n    this.onNodeMoved?.(findFirstNode(this.selectedItems))\n  }\n\n  /**\n   * Called when a mouse up event has to be processed\n   */\n  processMouseUp(e: PointerEvent): void {\n    // early exit for extra pointer\n    if (e.isPrimary === false) return\n\n    const { graph, pointer } = this\n    if (!graph) return\n\n    LGraphCanvas.active_canvas = this\n\n    this.adjustMouseEvent(e)\n\n    const now = LiteGraph.getTime()\n    e.click_time = now - this.last_mouseclick\n\n    /** The mouseup event occurred near the mousedown event. */\n    /** Normal-looking click event - mouseUp occurred near mouseDown, without dragging. */\n    const isClick = pointer.up(e)\n    if (isClick === true) {\n      pointer.isDown = false\n      pointer.isDouble = false\n      // Required until all link behaviour is added to Pointer API\n      this.connecting_links = null\n      this.dragging_canvas = false\n\n      graph.change()\n\n      e.stopPropagation()\n      e.preventDefault()\n      return\n    }\n\n    this.last_mouse_dragging = false\n    this.last_click_position = null\n\n    // used to avoid sending twice a click in an immediate button\n    this.block_click &&= false\n\n    if (e.button === 0) {\n      // left button\n      this.selected_group = null\n\n      this.isDragging = false\n\n      const x = e.canvasX\n      const y = e.canvasY\n\n      if (!this.linkConnector.isConnecting) {\n        this.dirty_canvas = true\n\n        // @ts-expect-error Unused param\n        this.node_over?.onMouseUp?.(e, [x - this.node_over.pos[0], y - this.node_over.pos[1]], this)\n        this.node_capturing_input?.onMouseUp?.(e, [\n          x - this.node_capturing_input.pos[0],\n          y - this.node_capturing_input.pos[1],\n        ])\n      }\n    } else if (e.button === 1) {\n      // middle button\n      this.dirty_canvas = true\n      this.dragging_canvas = false\n    } else if (e.button === 2) {\n      // right button\n      this.dirty_canvas = true\n    }\n\n    pointer.isDown = false\n    pointer.isDouble = false\n\n    graph.change()\n\n    e.stopPropagation()\n    e.preventDefault()\n    return\n  }\n\n  /**\n   * Called when the mouse moves off the canvas.  Clears all node hover states.\n   * @param e\n   */\n  processMouseOut(e: MouseEvent): void {\n    // TODO: Check if document.contains(e.relatedTarget) - handle mouseover node textarea etc.\n    this.adjustMouseEvent(e)\n    this.updateMouseOverNodes(null, e)\n  }\n\n  processMouseCancel(): void {\n    console.warn(\"Pointer cancel!\")\n    this.pointer.reset()\n  }\n\n  /**\n   * Called when a mouse wheel event has to be processed\n   */\n  processMouseWheel(e: WheelEvent): void {\n    if (!this.graph || !this.allow_dragcanvas) return\n\n    // TODO: Mouse wheel zoom rewrite\n    // @ts-expect-error\n    const delta = e.wheelDeltaY ?? e.detail * -60\n\n    this.adjustMouseEvent(e)\n\n    const pos: Point = [e.clientX, e.clientY]\n    if (this.viewport && !isPointInRect(pos, this.viewport)) return\n\n    let { scale } = this.ds\n\n    if (\n      LiteGraph.macTrackpadGestures &&\n      (!LiteGraph.macGesturesRequireMac || navigator.userAgent.includes(\"Mac\"))\n    ) {\n      if (e.ctrlKey && !Number.isInteger(e.deltaY)) {\n        scale *= 1 + e.deltaY * (1 - this.zoom_speed) * 0.18\n        this.ds.changeScale(scale, [e.clientX, e.clientY], false)\n      } else {\n        this.ds.offset[0] -= e.deltaX * 1.18 * (1 / scale)\n        this.ds.offset[1] -= e.deltaY * 1.18 * (1 / scale)\n      }\n    } else {\n      if (delta > 0) {\n        scale *= this.zoom_speed\n      } else if (delta < 0) {\n        scale *= 1 / (this.zoom_speed)\n      }\n      this.ds.changeScale(scale, [e.clientX, e.clientY])\n    }\n\n    this.graph.change()\n\n    e.preventDefault()\n    return\n  }\n\n  #noItemsSelected(): void {\n    const event = new CustomEvent(\"litegraph:no-items-selected\", { bubbles: true })\n    this.canvas.dispatchEvent(event)\n  }\n\n  /**\n   * process a key event\n   */\n  processKey(e: KeyboardEvent): void {\n    this.#shiftDown = e.shiftKey\n\n    const { graph } = this\n    if (!graph) return\n\n    let block_default = false\n    // @ts-expect-error\n    if (e.target.localName == \"input\") return\n\n    if (e.type == \"keydown\") {\n      // TODO: Switch\n      if (e.key === \" \") {\n        // space\n        this.read_only = true\n        if (this._previously_dragging_canvas === null) {\n          this._previously_dragging_canvas = this.dragging_canvas\n        }\n        this.dragging_canvas = this.pointer.isDown\n        block_default = true\n      } else if (e.key === \"Escape\") {\n        // esc\n        if (this.linkConnector.isConnecting) {\n          this.linkConnector.reset()\n          this.#dirty()\n          e.preventDefault()\n          return\n        }\n        this.node_panel?.close()\n        this.options_panel?.close()\n        block_default = true\n      } else if (e.keyCode === 65 && e.ctrlKey) {\n        // select all Control A\n        this.selectItems()\n        block_default = true\n      } else if (e.keyCode === 67 && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n        // copy\n        if (this.selected_nodes) {\n          this.copyToClipboard()\n          block_default = true\n        }\n      } else if (e.keyCode === 86 && (e.metaKey || e.ctrlKey)) {\n        // paste\n        this.pasteFromClipboard({ connectInputs: e.shiftKey })\n      } else if (e.key === \"Delete\" || e.key === \"Backspace\") {\n        // delete or backspace\n        // @ts-expect-error\n        if (e.target.localName != \"input\" && e.target.localName != \"textarea\") {\n          if (this.selectedItems.size === 0) {\n            this.#noItemsSelected()\n            return\n          }\n\n          this.deleteSelected()\n          block_default = true\n        }\n      }\n\n      // TODO\n      for (const node of Object.values(this.selected_nodes)) {\n        node.onKeyDown?.(e)\n      }\n    } else if (e.type == \"keyup\") {\n      if (e.key === \" \") {\n        // space\n        this.read_only = false\n        this.dragging_canvas = (this._previously_dragging_canvas ?? false) && this.pointer.isDown\n        this._previously_dragging_canvas = null\n      }\n\n      for (const node of Object.values(this.selected_nodes)) {\n        node.onKeyUp?.(e)\n      }\n    }\n\n    // TODO: Do we need to remeasure and recalculate everything on every key down/up?\n    graph.change()\n\n    if (block_default) {\n      e.preventDefault()\n      e.stopImmediatePropagation()\n    }\n  }\n\n  /**\n   * Copies canvas items to an internal, app-specific clipboard backed by local storage.\n   * When called without parameters, it copies {@link selectedItems}.\n   * @param items The items to copy.  If nullish, all selected items are copied.\n   */\n  copyToClipboard(items?: Iterable<Positionable>): void {\n    const serialisable: Required<ClipboardItems> = {\n      nodes: [],\n      groups: [],\n      reroutes: [],\n      links: [],\n    }\n\n    // Create serialisable objects\n    for (const item of items ?? this.selectedItems) {\n      if (item instanceof LGraphNode) {\n        // Nodes\n        if (item.clonable === false) continue\n\n        const cloned = item.clone()?.serialize()\n        if (!cloned) continue\n\n        cloned.id = item.id\n        serialisable.nodes.push(cloned)\n\n        // Links\n        if (item.inputs) {\n          for (const { link: linkId } of item.inputs) {\n            if (linkId == null) continue\n\n            const link = this.graph?._links.get(linkId)?.asSerialisable()\n            if (link) serialisable.links.push(link)\n          }\n        }\n      } else if (item instanceof LGraphGroup) {\n        // Groups\n        serialisable.groups.push(item.serialize())\n      } else if (item instanceof Reroute) {\n        // Reroutes\n        serialisable.reroutes.push(item.asSerialisable())\n      }\n    }\n\n    localStorage.setItem(\n      \"litegrapheditor_clipboard\",\n      JSON.stringify(serialisable),\n    )\n  }\n\n  emitEvent(detail: LGraphCanvasEventMap[\"litegraph:canvas\"]): void {\n    this.canvas.dispatchEvent(\n      new CustomEvent(\"litegraph:canvas\", {\n        bubbles: true,\n        detail,\n      }),\n    )\n  }\n\n  /** @todo Refactor to where it belongs - e.g. Deleting / creating nodes is not actually canvas event. */\n  emitBeforeChange(): void {\n    this.emitEvent({\n      subType: \"before-change\",\n    })\n  }\n\n  /** @todo See {@link emitBeforeChange} */\n  emitAfterChange(): void {\n    this.emitEvent({\n      subType: \"after-change\",\n    })\n  }\n\n  /**\n   * Pastes the items from the canvas \"clipbaord\" - a local storage variable.\n   */\n  _pasteFromClipboard(options: IPasteFromClipboardOptions = {}): ClipboardPasteResult | undefined {\n    const {\n      connectInputs = false,\n      position = this.graph_mouse,\n    } = options\n\n    // if ctrl + shift + v is off, return when isConnectUnselected is true (shift is pressed) to maintain old behavior\n    if (!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && connectInputs) return\n\n    const data = localStorage.getItem(\"litegrapheditor_clipboard\")\n    if (!data) return\n\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n    graph.beforeChange()\n\n    // Parse & initialise\n    const parsed: ClipboardItems = JSON.parse(data)\n    parsed.nodes ??= []\n    parsed.groups ??= []\n    parsed.reroutes ??= []\n    parsed.links ??= []\n\n    // Find top-left-most boundary\n    let offsetX = Infinity\n    let offsetY = Infinity\n    for (const item of [...parsed.nodes, ...parsed.reroutes]) {\n      if (item.pos == null) throw new TypeError(\"Invalid node encounterd on paste.  `pos` was null.\")\n\n      if (item.pos[0] < offsetX) offsetX = item.pos[0]\n      if (item.pos[1] < offsetY) offsetY = item.pos[1]\n    }\n\n    // TODO: Remove when implementing `asSerialisable`\n    if (parsed.groups) {\n      for (const group of parsed.groups) {\n        if (group.bounding[0] < offsetX) offsetX = group.bounding[0]\n        if (group.bounding[1] < offsetY) offsetY = group.bounding[1]\n      }\n    }\n\n    const results: ClipboardPasteResult = {\n      created: [],\n      nodes: new Map<NodeId, LGraphNode>(),\n      links: new Map<LinkId, LLink>(),\n      reroutes: new Map<RerouteId, Reroute>(),\n    }\n    const { created, nodes, links, reroutes } = results\n\n    // const failedNodes: ISerialisedNode[] = []\n\n    // Groups\n    for (const info of parsed.groups) {\n      info.id = -1\n\n      const group = new LGraphGroup()\n      group.configure(info)\n      graph.add(group)\n      created.push(group)\n    }\n\n    // Nodes\n    for (const info of parsed.nodes) {\n      const node = info.type == null ? null : LiteGraph.createNode(info.type)\n      if (!node) {\n        // failedNodes.push(info)\n        continue\n      }\n\n      nodes.set(info.id, node)\n      info.id = -1\n\n      node.configure(info)\n      graph.add(node)\n\n      created.push(node)\n    }\n\n    // Reroutes\n    for (const info of parsed.reroutes) {\n      const { id, ...rerouteInfo } = info\n\n      const reroute = graph.setReroute(rerouteInfo)\n      created.push(reroute)\n      reroutes.set(id, reroute)\n    }\n\n    // Remap reroute parentIds for pasted reroutes\n    for (const reroute of reroutes.values()) {\n      if (reroute.parentId == null) continue\n\n      const mapped = reroutes.get(reroute.parentId)\n      if (mapped) reroute.parentId = mapped.id\n    }\n\n    // Links\n    for (const info of parsed.links) {\n      // Find the copied node / reroute ID\n      let outNode: LGraphNode | null | undefined = nodes.get(info.origin_id)\n      let afterRerouteId: number | undefined\n      if (info.parentId != null) afterRerouteId = reroutes.get(info.parentId)?.id\n\n      // If it wasn't copied, use the original graph value\n      if (connectInputs && LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs) {\n        outNode ??= graph.getNodeById(info.origin_id)\n        afterRerouteId ??= info.parentId\n      }\n\n      const inNode = nodes.get(info.target_id)\n      if (inNode) {\n        const link = outNode?.connect(\n          info.origin_slot,\n          inNode,\n          info.target_slot,\n          afterRerouteId,\n        )\n        if (link) links.set(info.id, link)\n      }\n    }\n\n    // Remap linkIds\n    for (const reroute of reroutes.values()) {\n      const ids = [...reroute.linkIds].map(x => links.get(x)?.id ?? x)\n      reroute.update(reroute.parentId, undefined, ids, reroute.floating)\n\n      // Remove any invalid items\n      if (!reroute.validateLinks(graph.links, graph.floatingLinks)) {\n        graph.removeReroute(reroute.id)\n      }\n    }\n\n    // Adjust positions\n    for (const item of created) {\n      item.pos[0] += position[0] - offsetX\n      item.pos[1] += position[1] - offsetY\n    }\n\n    // TODO: Report failures, i.e. `failedNodes`\n\n    this.selectItems(created)\n\n    graph.afterChange()\n\n    return results\n  }\n\n  pasteFromClipboard(options: IPasteFromClipboardOptions = {}): void {\n    this.emitBeforeChange()\n    try {\n      this._pasteFromClipboard(options)\n    } finally {\n      this.emitAfterChange()\n    }\n  }\n\n  processNodeDblClicked(n: LGraphNode): void {\n    this.onShowNodePanel?.(n)\n    this.onNodeDblClicked?.(n)\n\n    this.setDirty(true)\n  }\n\n  #handleMultiSelect(e: CanvasPointerEvent, dragRect: Float32Array) {\n    // Process drag\n    // Convert Point pair (pos, offset) to Rect\n    const { graph, selectedItems } = this\n    if (!graph) throw new NullGraphError()\n\n    const w = Math.abs(dragRect[2])\n    const h = Math.abs(dragRect[3])\n    if (dragRect[2] < 0) dragRect[0] -= w\n    if (dragRect[3] < 0) dragRect[1] -= h\n    dragRect[2] = w\n    dragRect[3] = h\n\n    // Select nodes - any part of the node is in the select area\n    const isSelected = new Set<Positionable>()\n    const notSelected: Positionable[] = []\n\n    for (const nodeX of graph._nodes) {\n      if (overlapBounding(dragRect, nodeX.boundingRect)) {\n        addPositionable(nodeX)\n      }\n    }\n\n    // Select groups - the group is wholly inside the select area\n    for (const group of graph.groups) {\n      if (!containsRect(dragRect, group._bounding)) continue\n\n      group.recomputeInsideNodes()\n      addPositionable(group)\n    }\n\n    // Select reroutes - the centre point is inside the select area\n    for (const reroute of graph.reroutes.values()) {\n      if (!isPointInRect(reroute.pos, dragRect)) continue\n\n      selectedItems.add(reroute)\n      reroute.selected = true\n      addPositionable(reroute)\n    }\n\n    if (e.shiftKey) {\n      // Add to selection\n      for (const item of notSelected) this.select(item)\n    } else if (e.altKey) {\n      // Remove from selection\n      for (const item of isSelected) this.deselect(item)\n    } else {\n      // Replace selection\n      for (const item of selectedItems.values()) {\n        if (!isSelected.has(item)) this.deselect(item)\n      }\n      for (const item of notSelected) this.select(item)\n    }\n    this.onSelectionChange?.(this.selected_nodes)\n\n    function addPositionable(item: Positionable): void {\n      if (!item.selected || !selectedItems.has(item)) notSelected.push(item)\n      else isSelected.add(item)\n    }\n  }\n\n  /**\n   * Determines whether to select or deselect an item that has received a pointer event.  Will deselect other nodes if\n   * @param item Canvas item to select/deselect\n   * @param e The MouseEvent to handle\n   * @param sticky Prevents deselecting individual nodes (as used by aux/right-click)\n   * @remarks\n   * Accessibility: anyone using {@link mutli_select} always deselects when clicking empty space.\n   */\n  processSelect<TPositionable extends Positionable = LGraphNode>(\n    item: TPositionable | null | undefined,\n    e: CanvasMouseEvent | undefined,\n    sticky: boolean = false,\n  ): void {\n    const addModifier = e?.shiftKey\n    const subtractModifier = e != null && (e.metaKey || e.ctrlKey)\n    const eitherModifier = addModifier || subtractModifier\n    const modifySelection = eitherModifier || this.multi_select\n\n    if (!item) {\n      if (!eitherModifier || this.multi_select) this.deselectAll()\n    } else if (!item.selected || !this.selectedItems.has(item)) {\n      if (!modifySelection) this.deselectAll(item)\n      this.select(item)\n    } else if (modifySelection && !sticky) {\n      this.deselect(item)\n    } else if (!sticky) {\n      this.deselectAll(item)\n    } else {\n      return\n    }\n    this.onSelectionChange?.(this.selected_nodes)\n    this.setDirty(true)\n  }\n\n  /**\n   * Selects a {@link Positionable} item.\n   * @param item The canvas item to add to the selection.\n   */\n  select<TPositionable extends Positionable = LGraphNode>(item: TPositionable): void {\n    if (item.selected && this.selectedItems.has(item)) return\n\n    item.selected = true\n    this.selectedItems.add(item)\n    this.state.selectionChanged = true\n    if (!(item instanceof LGraphNode)) return\n\n    // Node-specific handling\n    item.onSelected?.()\n    this.selected_nodes[item.id] = item\n\n    this.onNodeSelected?.(item)\n\n    // Highlight links\n    if (item.inputs) {\n      for (const input of item.inputs) {\n        if (input.link == null) continue\n        this.highlighted_links[input.link] = true\n      }\n    }\n    if (item.outputs) {\n      for (const id of item.outputs.flatMap(x => x.links)) {\n        if (id == null) continue\n        this.highlighted_links[id] = true\n      }\n    }\n  }\n\n  /**\n   * Deselects a {@link Positionable} item.\n   * @param item The canvas item to remove from the selection.\n   */\n  deselect<TPositionable extends Positionable = LGraphNode>(item: TPositionable): void {\n    if (!item.selected && !this.selectedItems.has(item)) return\n\n    item.selected = false\n    this.selectedItems.delete(item)\n    this.state.selectionChanged = true\n    if (!(item instanceof LGraphNode)) return\n\n    // Node-specific handling\n    item.onDeselected?.()\n    delete this.selected_nodes[item.id]\n\n    this.onNodeDeselected?.(item)\n\n    // Should be moved to top of function, and throw if null\n    const { graph } = this\n    if (!graph) return\n\n    // Clear link highlight\n    if (item.inputs) {\n      for (const input of item.inputs) {\n        if (input.link == null) continue\n\n        const node = LLink.getOriginNode(graph, input.link)\n        if (node && this.selectedItems.has(node)) continue\n\n        delete this.highlighted_links[input.link]\n      }\n    }\n    if (item.outputs) {\n      for (const id of item.outputs.flatMap(x => x.links)) {\n        if (id == null) continue\n\n        const node = LLink.getTargetNode(graph, id)\n        if (node && this.selectedItems.has(node)) continue\n\n        delete this.highlighted_links[id]\n      }\n    }\n  }\n\n  /** @deprecated See {@link LGraphCanvas.processSelect} */\n  processNodeSelected(item: LGraphNode, e: CanvasMouseEvent): void {\n    this.processSelect(\n      item,\n      e,\n      e && (e.shiftKey || e.metaKey || e.ctrlKey || this.multi_select),\n    )\n  }\n\n  /** @deprecated See {@link LGraphCanvas.select} */\n  selectNode(node: LGraphNode, add_to_current_selection?: boolean): void {\n    if (node == null) {\n      this.deselectAll()\n    } else {\n      this.selectNodes([node], add_to_current_selection)\n    }\n  }\n\n  get empty(): boolean {\n    if (!this.graph) throw new NullGraphError()\n    return this.graph.empty\n  }\n\n  get positionableItems() {\n    if (!this.graph) throw new NullGraphError()\n    return this.graph.positionableItems()\n  }\n\n  /**\n   * Selects several items.\n   * @param items Items to select - if falsy, all items on the canvas will be selected\n   * @param add_to_current_selection If set, the items will be added to the current selection instead of replacing it\n   */\n  selectItems(items?: Positionable[], add_to_current_selection?: boolean): void {\n    const itemsToSelect = items ?? this.positionableItems\n    if (!add_to_current_selection) this.deselectAll()\n    for (const item of itemsToSelect) this.select(item)\n    this.onSelectionChange?.(this.selected_nodes)\n    this.setDirty(true)\n  }\n\n  /**\n   * selects several nodes (or adds them to the current selection)\n   * @deprecated See {@link LGraphCanvas.selectItems}\n   */\n  selectNodes(nodes?: LGraphNode[], add_to_current_selection?: boolean): void {\n    this.selectItems(nodes, add_to_current_selection)\n  }\n\n  /** @deprecated See {@link LGraphCanvas.deselect} */\n  deselectNode(node: LGraphNode): void {\n    this.deselect(node)\n  }\n\n  /**\n   * Deselects all items on the canvas.\n   * @param keepSelected If set, this item will not be removed from the selection.\n   */\n  deselectAll(keepSelected?: Positionable): void {\n    if (!this.graph) return\n\n    const selected = this.selectedItems\n    if (!selected.size) return\n\n    let wasSelected: Positionable | undefined\n    for (const sel of selected) {\n      if (sel === keepSelected) {\n        wasSelected = sel\n        continue\n      }\n      sel.onDeselected?.()\n      sel.selected = false\n    }\n    selected.clear()\n    if (wasSelected) selected.add(wasSelected)\n\n    this.setDirty(true)\n\n    // Legacy code\n    const oldNode = keepSelected?.id == null ? null : this.selected_nodes[keepSelected.id]\n    this.selected_nodes = {}\n    this.current_node = null\n    this.highlighted_links = {}\n\n    if (keepSelected instanceof LGraphNode) {\n      // Handle old object lookup\n      if (oldNode) this.selected_nodes[oldNode.id] = oldNode\n\n      // Highlight links\n      if (keepSelected.inputs) {\n        for (const input of keepSelected.inputs) {\n          if (input.link == null) continue\n          this.highlighted_links[input.link] = true\n        }\n      }\n      if (keepSelected.outputs) {\n        for (const id of keepSelected.outputs.flatMap(x => x.links)) {\n          if (id == null) continue\n          this.highlighted_links[id] = true\n        }\n      }\n    }\n\n    this.state.selectionChanged = true\n    this.onSelectionChange?.(this.selected_nodes)\n  }\n\n  /** @deprecated See {@link LGraphCanvas.deselectAll} */\n  deselectAllNodes(): void {\n    this.deselectAll()\n  }\n\n  /**\n   * Deletes all selected items from the graph.\n   * @todo Refactor deletion task to LGraph.  Selection is a canvas property, delete is a graph action.\n   */\n  deleteSelected(): void {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    this.emitBeforeChange()\n    graph.beforeChange()\n\n    for (const item of this.selectedItems) {\n      if (item instanceof LGraphNode) {\n        const node = item\n        if (node.block_delete) continue\n        node.connectInputToOutput()\n        graph.remove(node)\n        this.onNodeDeselected?.(node)\n      } else if (item instanceof LGraphGroup) {\n        graph.remove(item)\n      } else if (item instanceof Reroute) {\n        graph.removeReroute(item.id)\n      }\n    }\n\n    this.selected_nodes = {}\n    this.selectedItems.clear()\n    this.current_node = null\n    this.highlighted_links = {}\n\n    this.state.selectionChanged = true\n    this.onSelectionChange?.(this.selected_nodes)\n    this.setDirty(true)\n    graph.afterChange()\n    this.emitAfterChange()\n  }\n\n  /**\n   * deletes all nodes in the current selection from the graph\n   * @deprecated See {@link LGraphCanvas.deleteSelected}\n   */\n  deleteSelectedNodes(): void {\n    this.deleteSelected()\n  }\n\n  /**\n   * centers the camera on a given node\n   */\n  centerOnNode(node: LGraphNode): void {\n    const dpi = window?.devicePixelRatio || 1\n    this.ds.offset[0] =\n      -node.pos[0] -\n      node.size[0] * 0.5 +\n      (this.canvas.width * 0.5) / (this.ds.scale * dpi)\n    this.ds.offset[1] =\n      -node.pos[1] -\n      node.size[1] * 0.5 +\n      (this.canvas.height * 0.5) / (this.ds.scale * dpi)\n    this.setDirty(true, true)\n  }\n\n  /**\n   * adds some useful properties to a mouse event, like the position in graph coordinates\n   */\n  adjustMouseEvent<T extends MouseEvent>(\n    e: T & Partial<CanvasPointerExtensions>,\n  ): asserts e is T & CanvasMouseEvent {\n    let clientX_rel = e.clientX\n    let clientY_rel = e.clientY\n\n    if (this.canvas) {\n      const b = this.canvas.getBoundingClientRect()\n      clientX_rel -= b.left\n      clientY_rel -= b.top\n    }\n\n    e.safeOffsetX = clientX_rel\n    e.safeOffsetY = clientY_rel\n\n    // TODO: Find a less brittle way to do this\n\n    // Only set deltaX and deltaY if not already set.\n    // If deltaX and deltaY are already present, they are read-only.\n    // Setting them would result browser error => zoom in/out feature broken.\n    if (e.deltaX === undefined)\n      e.deltaX = clientX_rel - this.last_mouse_position[0]\n    if (e.deltaY === undefined)\n      e.deltaY = clientY_rel - this.last_mouse_position[1]\n\n    this.last_mouse_position[0] = clientX_rel\n    this.last_mouse_position[1] = clientY_rel\n\n    e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0]\n    e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1]\n  }\n\n  /**\n   * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom\n   */\n  setZoom(value: number, zooming_center: Point) {\n    this.ds.changeScale(value, zooming_center)\n    this.#dirty()\n  }\n\n  /**\n   * converts a coordinate from graph coordinates to canvas2D coordinates\n   */\n  convertOffsetToCanvas(pos: Point, out: Point): Point {\n    // @ts-expect-error Unused param\n    return this.ds.convertOffsetToCanvas(pos, out)\n  }\n\n  /**\n   * converts a coordinate from Canvas2D coordinates to graph space\n   */\n  convertCanvasToOffset(pos: Point, out?: Point): Point {\n    return this.ds.convertCanvasToOffset(pos, out)\n  }\n\n  // converts event coordinates from canvas2D to graph coordinates\n  convertEventToCanvasOffset(e: MouseEvent): Point {\n    const rect = this.canvas.getBoundingClientRect()\n    // TODO: -> this.ds.convertCanvasToOffset\n    return this.convertCanvasToOffset([\n      e.clientX - rect.left,\n      e.clientY - rect.top,\n    ])\n  }\n\n  /**\n   * brings a node to front (above all other nodes)\n   */\n  bringToFront(node: LGraphNode): void {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const i = graph._nodes.indexOf(node)\n    if (i == -1) return\n\n    graph._nodes.splice(i, 1)\n    graph._nodes.push(node)\n  }\n\n  /**\n   * sends a node to the back (below all other nodes)\n   */\n  sendToBack(node: LGraphNode): void {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const i = graph._nodes.indexOf(node)\n    if (i == -1) return\n\n    graph._nodes.splice(i, 1)\n    graph._nodes.unshift(node)\n  }\n\n  /**\n   * Determines which nodes are visible and populates {@link out} with the results.\n   * @param nodes The list of nodes to check - if falsy, all nodes in the graph will be checked\n   * @param out Array to write visible nodes into - if falsy, a new array is created instead\n   * @returns Array passed ({@link out}), or a new array containing all visible nodes\n   */\n  computeVisibleNodes(nodes?: LGraphNode[], out?: LGraphNode[]): LGraphNode[] {\n    const visible_nodes = out || []\n    visible_nodes.length = 0\n    if (!this.graph) throw new NullGraphError()\n\n    const _nodes = nodes || this.graph._nodes\n    for (const node of _nodes) {\n      node.updateArea(this.ctx)\n      // Not in visible area\n      if (!overlapBounding(this.visible_area, node.renderArea)) continue\n\n      visible_nodes.push(node)\n    }\n    return visible_nodes\n  }\n\n  /**\n   * Checks if a node is visible on the canvas.\n   * @param node The node to check\n   * @returns `true` if the node is visible, otherwise `false`\n   */\n  isNodeVisible(node: LGraphNode): boolean {\n    return this.#visible_node_ids.has(node.id)\n  }\n\n  /**\n   * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)\n   */\n  draw(force_canvas?: boolean, force_bgcanvas?: boolean): void {\n    if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) return\n\n    // fps counting\n    const now = LiteGraph.getTime()\n    this.render_time = (now - this.last_draw_time) * 0.001\n    this.last_draw_time = now\n\n    if (this.graph) this.ds.computeVisibleArea(this.viewport)\n\n    // Compute node size before drawing links.\n    if (this.dirty_canvas || force_canvas) {\n      this.computeVisibleNodes(undefined, this.visible_nodes)\n      // Update visible node IDs\n      this.#visible_node_ids = new Set(this.visible_nodes.map(node => node.id))\n    }\n\n    if (\n      this.dirty_bgcanvas ||\n      force_bgcanvas ||\n      this.always_render_background ||\n      (this.graph?._last_trigger_time &&\n        now - this.graph._last_trigger_time < 1000)\n    ) {\n      this.drawBackCanvas()\n    }\n\n    if (this.dirty_canvas || force_canvas) this.drawFrontCanvas()\n\n    this.fps = this.render_time ? 1.0 / this.render_time : 0\n    this.frame++\n  }\n\n  /**\n   * draws the front canvas (the one containing all the nodes)\n   */\n  drawFrontCanvas(): void {\n    this.dirty_canvas = false\n\n    const { ctx, canvas, linkConnector } = this\n\n    // @ts-expect-error\n    if (ctx.start2D && !this.viewport) {\n      // @ts-expect-error\n      ctx.start2D()\n      ctx.restore()\n      ctx.setTransform(1, 0, 0, 1, 0, 0)\n    }\n\n    // clip dirty area if there is one, otherwise work in full canvas\n    const area = this.viewport || this.dirty_area\n    if (area) {\n      ctx.save()\n      ctx.beginPath()\n      ctx.rect(area[0], area[1], area[2], area[3])\n      ctx.clip()\n    }\n\n    // TODO: Set snapping value when changed instead of once per frame\n    this.#snapToGrid = this.#shiftDown || LiteGraph.alwaysSnapToGrid\n      ? this.graph?.getSnapToGridSize()\n      : undefined\n\n    // clear\n    // canvas.width = canvas.width;\n    if (this.clear_background) {\n      if (area) ctx.clearRect(area[0], area[1], area[2], area[3])\n      else ctx.clearRect(0, 0, canvas.width, canvas.height)\n    }\n\n    // draw bg canvas\n    if (this.bgcanvas == this.canvas) {\n      this.drawBackCanvas()\n    } else {\n      const scale = window.devicePixelRatio\n      ctx.drawImage(\n        this.bgcanvas,\n        0,\n        0,\n        this.bgcanvas.width / scale,\n        this.bgcanvas.height / scale,\n      )\n    }\n\n    // rendering\n    this.onRender?.(canvas, ctx)\n\n    // info widget\n    if (this.show_info) {\n      this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0)\n    }\n\n    if (this.graph) {\n      // apply transformations\n      ctx.save()\n      this.ds.toCanvasContext(ctx)\n\n      // draw nodes\n      const { visible_nodes } = this\n      const drawSnapGuides = this.#snapToGrid && this.isDragging\n\n      for (const node of visible_nodes) {\n        ctx.save()\n\n        // Draw snap shadow\n        if (drawSnapGuides && this.selectedItems.has(node))\n          this.drawSnapGuide(ctx, node)\n\n        // Localise co-ordinates to node position\n        ctx.translate(node.pos[0], node.pos[1])\n\n        // Draw\n        this.drawNode(node, ctx)\n\n        ctx.restore()\n      }\n\n      // on top (debug)\n      if (this.render_execution_order) {\n        this.drawExecutionOrder(ctx)\n      }\n\n      // connections ontop?\n      if (this.graph.config.links_ontop) {\n        this.drawConnections(ctx)\n      }\n\n      if (linkConnector.isConnecting) {\n        // current connection (the one being dragged by the mouse)\n        const { renderLinks } = linkConnector\n        const highlightPos = this.#getHighlightPosition()\n        ctx.lineWidth = this.connections_width\n\n        for (const renderLink of renderLinks) {\n          const { fromSlot, fromPos: pos, fromDirection, dragDirection } = renderLink\n          const connShape = fromSlot.shape\n          const connType = fromSlot.type\n\n          const colour = connType === LiteGraph.EVENT\n            ? LiteGraph.EVENT_LINK_COLOR\n            : LiteGraph.CONNECTING_LINK_COLOR\n\n          // the connection being dragged by the mouse\n          this.renderLink(\n            ctx,\n            pos,\n            highlightPos,\n            null,\n            false,\n            null,\n            colour,\n            fromDirection,\n            dragDirection,\n          )\n\n          ctx.beginPath()\n          if (connType === LiteGraph.EVENT || connShape === RenderShape.BOX) {\n            ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10)\n            ctx.rect(\n              highlightPos[0] - 6 + 0.5,\n              highlightPos[1] - 5 + 0.5,\n              14,\n              10,\n            )\n          } else if (connShape === RenderShape.ARROW) {\n            ctx.moveTo(pos[0] + 8, pos[1] + 0.5)\n            ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5)\n            ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5)\n            ctx.closePath()\n          } else {\n            ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2)\n            ctx.arc(highlightPos[0], highlightPos[1], 4, 0, Math.PI * 2)\n          }\n          ctx.fill()\n        }\n\n        // Gradient half-border over target node\n        this.#renderSnapHighlight(ctx, highlightPos)\n      }\n\n      // Area-selection rectangle\n      if (this.dragging_rectangle) {\n        const { eDown, eMove } = this.pointer\n        ctx.strokeStyle = \"#FFF\"\n\n        if (eDown && eMove) {\n          // Do not scale the selection box\n          const transform = ctx.getTransform()\n          const ratio = Math.max(1, window.devicePixelRatio)\n          ctx.setTransform(ratio, 0, 0, ratio, 0, 0)\n\n          const x = eDown.safeOffsetX\n          const y = eDown.safeOffsetY\n          ctx.strokeRect(x, y, eMove.safeOffsetX - x, eMove.safeOffsetY - y)\n\n          ctx.setTransform(transform)\n        } else {\n          // Fallback to legacy behaviour\n          const [x, y, w, h] = this.dragging_rectangle\n          ctx.strokeRect(x, y, w, h)\n        }\n      }\n\n      // on top of link center\n      if (!this.isDragging && this.over_link_center && this.render_link_tooltip) {\n        this.drawLinkTooltip(ctx, this.over_link_center)\n      } else {\n        this.onDrawLinkTooltip?.(ctx, null)\n      }\n\n      // custom info\n      this.onDrawForeground?.(ctx, this.visible_area)\n\n      ctx.restore()\n    }\n\n    this.onDrawOverlay?.(ctx)\n\n    if (area) ctx.restore()\n  }\n\n  /** @returns If the pointer is over a link centre marker, the link segment it belongs to.  Otherwise, `undefined`.  */\n  #getLinkCentreOnPos(e: CanvasMouseEvent): LinkSegment | undefined {\n    for (const linkSegment of this.renderedPaths) {\n      const centre = linkSegment._pos\n      if (!centre) continue\n\n      if (isInRectangle(e.canvasX, e.canvasY, centre[0] - 4, centre[1] - 4, 8, 8)) {\n        return linkSegment\n      }\n    }\n  }\n\n  /** Get the target snap / highlight point in graph space */\n  #getHighlightPosition(): ReadOnlyPoint {\n    return LiteGraph.snaps_for_comfy\n      ? this.linkConnector.state.snapLinksPos ?? this._highlight_pos ?? this.graph_mouse\n      : this.graph_mouse\n  }\n\n  /**\n   * Renders indicators showing where a link will connect if released.\n   * Partial border over target node and a highlight over the slot itself.\n   * @param ctx Canvas 2D context\n   */\n  #renderSnapHighlight(\n    ctx: CanvasRenderingContext2D,\n    highlightPos: ReadOnlyPoint,\n  ): void {\n    const linkConnectorSnap = !!this.linkConnector.state.snapLinksPos\n    if (!this._highlight_pos && !linkConnectorSnap) return\n\n    ctx.fillStyle = \"#ffcc00\"\n    ctx.beginPath()\n    const shape = this._highlight_input?.shape\n\n    if (shape === RenderShape.ARROW) {\n      ctx.moveTo(highlightPos[0] + 8, highlightPos[1] + 0.5)\n      ctx.lineTo(highlightPos[0] - 4, highlightPos[1] + 6 + 0.5)\n      ctx.lineTo(highlightPos[0] - 4, highlightPos[1] - 6 + 0.5)\n      ctx.closePath()\n    } else {\n      ctx.arc(highlightPos[0], highlightPos[1], 6, 0, Math.PI * 2)\n    }\n    ctx.fill()\n\n    const { linkConnector } = this\n    const { overReroute, overWidget } = linkConnector\n    if (!LiteGraph.snap_highlights_node || !linkConnector.isConnecting || linkConnectorSnap) return\n\n    // Reroute highlight\n    overReroute?.drawHighlight(ctx, \"#ffcc00aa\")\n\n    // Ensure we're mousing over a node and connecting a link\n    const node = this.node_over\n    if (!node) return\n\n    const { strokeStyle, lineWidth } = ctx\n\n    const area = node.boundingRect\n    const gap = 3\n    const radius = LiteGraph.ROUND_RADIUS + gap\n\n    const x = area[0] - gap\n    const y = area[1] - gap\n    const width = area[2] + gap * 2\n    const height = area[3] + gap * 2\n\n    ctx.beginPath()\n    ctx.roundRect(x, y, width, height, radius)\n\n    // TODO: Currently works on LTR slots only.  Add support for other directions.\n    const start = linkConnector.state.connectingTo === \"output\" ? 0 : 1\n    const inverter = start ? -1 : 1\n\n    // Radial highlight centred on highlight pos\n    const hx = highlightPos[0]\n    const hy = highlightPos[1]\n    const gRadius = width < height\n      ? width\n      : width * Math.max(height / width, 0.5)\n\n    const gradient = ctx.createRadialGradient(hx, hy, 0, hx, hy, gRadius)\n    gradient.addColorStop(1, \"#00000000\")\n    gradient.addColorStop(0, \"#ffcc00aa\")\n\n    // Linear gradient over half the node.\n    const linearGradient = ctx.createLinearGradient(x, y, x + width, y)\n    linearGradient.addColorStop(0.5, \"#00000000\")\n    linearGradient.addColorStop(start + 0.67 * inverter, \"#ddeeff33\")\n    linearGradient.addColorStop(start + inverter, \"#ffcc0055\")\n\n    /**\n     * Workaround for a canvas render issue.\n     * In Chromium 129 (2024-10-15), rounded corners can be rendered with the wrong part of a gradient colour.\n     * Occurs only at certain thicknesses / arc sizes.\n     */\n    ctx.setLineDash([radius, radius * 0.001])\n\n    ctx.lineWidth = 1\n    ctx.strokeStyle = linearGradient\n    ctx.stroke()\n\n    if (overWidget) {\n      const { computedHeight } = overWidget\n\n      ctx.beginPath()\n      const { pos: [nodeX, nodeY] } = node\n      const height = LiteGraph.NODE_WIDGET_HEIGHT\n      if (\n        overWidget.type.startsWith(\"custom\") &&\n        computedHeight != null &&\n        computedHeight > height * 2\n      ) {\n        // Most likely DOM widget text box\n        ctx.rect(\n          nodeX + 9,\n          nodeY + overWidget.y + 9,\n          (overWidget.width ?? area[2]) - 18,\n          computedHeight - 18,\n        )\n      } else {\n        // Regular widget, probably\n        ctx.roundRect(\n          nodeX + BaseWidget.margin,\n          nodeY + overWidget.y,\n          overWidget.width ?? area[2],\n          height,\n          height * 0.5,\n        )\n      }\n      ctx.stroke()\n    }\n\n    ctx.strokeStyle = gradient\n    ctx.stroke()\n\n    ctx.setLineDash([])\n    ctx.lineWidth = lineWidth\n    ctx.strokeStyle = strokeStyle\n  }\n\n  /**\n   * draws some useful stats in the corner of the canvas\n   */\n  renderInfo(ctx: CanvasRenderingContext2D, x: number, y: number): void {\n    x = x || 10\n    y = y || this.canvas.offsetHeight - 80\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.font = `10px ${LiteGraph.DEFAULT_FONT}`\n    ctx.fillStyle = \"#888\"\n    ctx.textAlign = \"left\"\n    if (this.graph) {\n      ctx.fillText(`T: ${this.graph.globaltime.toFixed(2)}s`, 5, 13 * 1)\n      ctx.fillText(`I: ${this.graph.iteration}`, 5, 13 * 2)\n      ctx.fillText(`N: ${this.graph._nodes.length} [${this.visible_nodes.length}]`, 5, 13 * 3)\n      ctx.fillText(`V: ${this.graph._version}`, 5, 13 * 4)\n      ctx.fillText(`FPS:${this.fps.toFixed(2)}`, 5, 13 * 5)\n    } else {\n      ctx.fillText(\"No graph selected\", 5, 13 * 1)\n    }\n    ctx.restore()\n  }\n\n  /**\n   * draws the back canvas (the one containing the background and the connections)\n   */\n  drawBackCanvas(): void {\n    const canvas = this.bgcanvas\n    if (\n      canvas.width != this.canvas.width ||\n      canvas.height != this.canvas.height\n    ) {\n      canvas.width = this.canvas.width\n      canvas.height = this.canvas.height\n    }\n\n    if (!this.bgctx) {\n      this.bgctx = this.bgcanvas.getContext(\"2d\")\n    }\n    const ctx = this.bgctx\n    if (!ctx) throw new TypeError(\"Background canvas context was null.\")\n\n    const viewport = this.viewport || [0, 0, ctx.canvas.width, ctx.canvas.height]\n\n    // clear\n    if (this.clear_background) {\n      ctx.clearRect(viewport[0], viewport[1], viewport[2], viewport[3])\n    }\n\n    const bg_already_painted = this.onRenderBackground\n      ? this.onRenderBackground(canvas, ctx)\n      : false\n\n    // reset in case of error\n    if (!this.viewport) {\n      const scale = window.devicePixelRatio\n      ctx.restore()\n      ctx.setTransform(scale, 0, 0, scale, 0, 0)\n    }\n\n    if (this.graph) {\n      // apply transformations\n      ctx.save()\n      this.ds.toCanvasContext(ctx)\n\n      // render BG\n      if (\n        this.ds.scale < 1.5 &&\n        !bg_already_painted &&\n        this.clear_background_color\n      ) {\n        ctx.fillStyle = this.clear_background_color\n        ctx.fillRect(\n          this.visible_area[0],\n          this.visible_area[1],\n          this.visible_area[2],\n          this.visible_area[3],\n        )\n      }\n\n      if (this.background_image && this.ds.scale > 0.5 && !bg_already_painted) {\n        if (this.zoom_modify_alpha) {\n          ctx.globalAlpha = (1.0 - 0.5 / this.ds.scale) * this.editor_alpha\n        } else {\n          ctx.globalAlpha = this.editor_alpha\n        }\n        ctx.imageSmoothingEnabled = false\n        if (!this._bg_img || this._bg_img.name != this.background_image) {\n          this._bg_img = new Image()\n          this._bg_img.name = this.background_image\n          this._bg_img.src = this.background_image\n          const that = this\n          this._bg_img.addEventListener(\"load\", function () {\n            that.draw(true, true)\n          })\n        }\n\n        let pattern = this._pattern\n        if (pattern == null && this._bg_img.width > 0) {\n          pattern = ctx.createPattern(this._bg_img, \"repeat\") ?? undefined\n          this._pattern_img = this._bg_img\n          this._pattern = pattern\n        }\n\n        // NOTE: This ridiculous kludge provides a significant performance increase when rendering many large (> canvas width) paths in HTML canvas.\n        // I could find no documentation or explanation.  Requires that the BG image is set.\n        if (pattern) {\n          ctx.fillStyle = pattern\n          ctx.fillRect(\n            this.visible_area[0],\n            this.visible_area[1],\n            this.visible_area[2],\n            this.visible_area[3],\n          )\n          ctx.fillStyle = \"transparent\"\n        }\n\n        ctx.globalAlpha = 1.0\n        ctx.imageSmoothingEnabled = true\n      }\n\n      // groups\n      if (this.graph._groups.length) {\n        this.drawGroups(canvas, ctx)\n      }\n\n      this.onDrawBackground?.(ctx, this.visible_area)\n\n      // DEBUG: show clipping area\n      // ctx.fillStyle = \"red\";\n      // ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10, this.visible_area[2] - 20, this.visible_area[3] - 20);\n      // bg\n      if (this.render_canvas_border) {\n        ctx.strokeStyle = \"#235\"\n        ctx.strokeRect(0, 0, canvas.width, canvas.height)\n      }\n\n      if (this.render_connections_shadows) {\n        ctx.shadowColor = \"#000\"\n        ctx.shadowOffsetX = 0\n        ctx.shadowOffsetY = 0\n        ctx.shadowBlur = 6\n      } else {\n        ctx.shadowColor = \"rgba(0,0,0,0)\"\n      }\n\n      // draw connections\n      this.drawConnections(ctx)\n\n      ctx.shadowColor = \"rgba(0,0,0,0)\"\n\n      // restore state\n      ctx.restore()\n    }\n\n    this.dirty_bgcanvas = false\n    // Forces repaint of the front canvas.\n    this.dirty_canvas = true\n  }\n\n  /**\n   * draws the given node inside the canvas\n   */\n  drawNode(node: LGraphNode, ctx: CanvasRenderingContext2D): void {\n    this.current_node = node\n\n    const color = node.renderingColor\n    const bgcolor = node.renderingBgColor\n\n    const { low_quality, editor_alpha } = this\n    ctx.globalAlpha = editor_alpha\n\n    if (this.render_shadows && !low_quality) {\n      ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR\n      ctx.shadowOffsetX = 2 * this.ds.scale\n      ctx.shadowOffsetY = 2 * this.ds.scale\n      ctx.shadowBlur = 3 * this.ds.scale\n    } else {\n      ctx.shadowColor = \"transparent\"\n    }\n\n    // custom draw collapsed method (draw after shadows because they are affected)\n    if (node.flags.collapsed && node.onDrawCollapsed?.(ctx, this) == true)\n      return\n\n    // clip if required (mask)\n    const shape = node._shape || RenderShape.BOX\n    const size = LGraphCanvas.#temp_vec2\n    size.set(node.renderingSize)\n\n    if (node.collapsed) {\n      ctx.font = this.inner_text_font\n    }\n\n    if (node.clip_area) {\n      // Start clipping\n      ctx.save()\n      ctx.beginPath()\n      if (shape == RenderShape.BOX) {\n        ctx.rect(0, 0, size[0], size[1])\n      } else if (shape == RenderShape.ROUND) {\n        ctx.roundRect(0, 0, size[0], size[1], [10])\n      } else if (shape == RenderShape.CIRCLE) {\n        ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5, 0, Math.PI * 2)\n      }\n      ctx.clip()\n    }\n\n    // draw shape\n    this.drawNodeShape(\n      node,\n      ctx,\n      size,\n      color,\n      bgcolor,\n      !!node.selected,\n    )\n\n    if (!low_quality) {\n      node.drawBadges(ctx)\n    }\n\n    ctx.shadowColor = \"transparent\"\n\n    // TODO: Legacy behaviour: onDrawForeground received ctx in this state\n    ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR\n\n    // Draw Foreground\n    node.onDrawForeground?.(ctx, this, this.canvas)\n\n    // connection slots\n    ctx.font = this.inner_text_font\n\n    // render inputs and outputs\n    node._setConcreteSlots()\n    if (!node.collapsed) {\n      node.arrange()\n      node.drawSlots(ctx, {\n        fromSlot: this.linkConnector.renderLinks[0]?.fromSlot,\n        colorContext: this.colourGetter,\n        editorAlpha: this.editor_alpha,\n        lowQuality: this.low_quality,\n      })\n\n      ctx.textAlign = \"left\"\n      ctx.globalAlpha = 1\n\n      this.drawNodeWidgets(node, null, ctx)\n    } else if (this.render_collapsed_slots) {\n      node.drawCollapsedSlots(ctx)\n    }\n\n    if (node.clip_area) {\n      ctx.restore()\n    }\n\n    ctx.globalAlpha = 1.0\n  }\n\n  /**\n   * Draws the link mouseover effect and tooltip.\n   * @param ctx Canvas 2D context to draw on\n   * @param link The link to render the mouseover effect for\n   * @remarks\n   * Called against {@link LGraphCanvas.over_link_center}.\n   * @todo Split tooltip from hover, so it can be drawn / eased separately\n   */\n  drawLinkTooltip(ctx: CanvasRenderingContext2D, link: LinkSegment): void {\n    const pos = link._pos\n    ctx.fillStyle = \"black\"\n    ctx.beginPath()\n    if (this.linkMarkerShape === LinkMarkerShape.Arrow) {\n      const transform = ctx.getTransform()\n      ctx.translate(pos[0], pos[1])\n      // Assertion: Number.isFinite guarantees this is a number.\n      if (Number.isFinite(link._centreAngle)) ctx.rotate(link._centreAngle as number)\n      ctx.moveTo(-2, -3)\n      ctx.lineTo(+4, 0)\n      ctx.lineTo(-2, +3)\n      ctx.setTransform(transform)\n    } else if (\n      this.linkMarkerShape == null ||\n      this.linkMarkerShape === LinkMarkerShape.Circle\n    ) {\n      ctx.arc(pos[0], pos[1], 3, 0, Math.PI * 2)\n    }\n    ctx.fill()\n\n    // @ts-expect-error TODO: Better value typing\n    const { data } = link\n    if (data == null) return\n\n    // @ts-expect-error TODO: Better value typing\n    if (this.onDrawLinkTooltip?.(ctx, link, this) == true) return\n\n    let text: string | null = null\n\n    if (typeof data === \"number\")\n      text = data.toFixed(2)\n    else if (typeof data === \"string\")\n      text = `\"${data}\"`\n    else if (typeof data === \"boolean\")\n      text = String(data)\n    else if (data.toToolTip)\n      text = data.toToolTip()\n    else\n      text = `[${data.constructor.name}]`\n\n    if (text == null) return\n\n    // Hard-coded tooltip limit\n    text = text.substring(0, 30)\n\n    ctx.font = \"14px Courier New\"\n    const info = ctx.measureText(text)\n    const w = info.width + 20\n    const h = 24\n    ctx.shadowColor = \"black\"\n    ctx.shadowOffsetX = 2\n    ctx.shadowOffsetY = 2\n    ctx.shadowBlur = 3\n    ctx.fillStyle = \"#454\"\n    ctx.beginPath()\n    ctx.roundRect(pos[0] - w * 0.5, pos[1] - 15 - h, w, h, [3])\n    ctx.moveTo(pos[0] - 10, pos[1] - 15)\n    ctx.lineTo(pos[0] + 10, pos[1] - 15)\n    ctx.lineTo(pos[0], pos[1] - 5)\n    ctx.fill()\n    ctx.shadowColor = \"transparent\"\n    ctx.textAlign = \"center\"\n    ctx.fillStyle = \"#CEC\"\n    ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3)\n  }\n\n  /**\n   * Draws the shape of the given node on the canvas\n   * @param node The node to draw\n   * @param ctx 2D canvas rendering context used to draw\n   * @param size Size of the background to draw, in graph units.  Differs from node size if collapsed, etc.\n   * @param fgcolor Foreground colour - used for text\n   * @param bgcolor Background colour of the node\n   * @param _selected Whether to render the node as selected.  Likely to be removed in future, as current usage is simply the selected property of the node.\n   */\n  drawNodeShape(\n    node: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    size: Size,\n    fgcolor: CanvasColour,\n    bgcolor: CanvasColour,\n    _selected: boolean,\n  ): void {\n    // Rendering options\n    ctx.strokeStyle = fgcolor\n    ctx.fillStyle = bgcolor\n\n    const title_height = LiteGraph.NODE_TITLE_HEIGHT\n    const { low_quality } = this\n\n    const { collapsed } = node.flags\n    const shape = node.renderingShape\n    const { title_mode } = node\n\n    const render_title = title_mode == TitleMode.TRANSPARENT_TITLE || title_mode == TitleMode.NO_TITLE\n      ? false\n      : true\n\n    // Normalised node dimensions\n    const area = LGraphCanvas.#tmp_area\n    area.set(node.boundingRect)\n    area[0] -= node.pos[0]\n    area[1] -= node.pos[1]\n\n    const old_alpha = ctx.globalAlpha\n\n    // Draw node background (shape)\n    ctx.beginPath()\n    if (shape == RenderShape.BOX || low_quality) {\n      ctx.rect(area[0], area[1], area[2], area[3])\n    } else if (shape == RenderShape.ROUND || shape == RenderShape.CARD) {\n      ctx.roundRect(\n        area[0],\n        area[1],\n        area[2],\n        area[3],\n        shape == RenderShape.CARD\n          ? [LiteGraph.ROUND_RADIUS, LiteGraph.ROUND_RADIUS, 0, 0]\n          : [LiteGraph.ROUND_RADIUS],\n      )\n    } else if (shape == RenderShape.CIRCLE) {\n      ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5, 0, Math.PI * 2)\n    }\n    ctx.fill()\n\n    // Separator - title bar <-> body\n    if (!collapsed && render_title) {\n      ctx.shadowColor = \"transparent\"\n      ctx.fillStyle = \"rgba(0,0,0,0.2)\"\n      ctx.fillRect(0, -1, area[2], 2)\n    }\n    ctx.shadowColor = \"transparent\"\n\n    node.onDrawBackground?.(ctx)\n\n    // Title bar background (remember, it is rendered ABOVE the node)\n    if (render_title || title_mode == TitleMode.TRANSPARENT_TITLE) {\n      node.drawTitleBarBackground(ctx, {\n        scale: this.ds.scale,\n        low_quality,\n      })\n\n      // title box\n      node.drawTitleBox(ctx, {\n        scale: this.ds.scale,\n        low_quality,\n        box_size: 10,\n      })\n\n      ctx.globalAlpha = old_alpha\n\n      // title text\n      node.drawTitleText(ctx, {\n        scale: this.ds.scale,\n        default_title_color: this.node_title_color,\n        low_quality,\n      })\n\n      // custom title render\n      node.onDrawTitle?.(ctx)\n    }\n\n    // Draw stroke styles\n    for (const getStyle of Object.values(node.strokeStyles)) {\n      const strokeStyle = getStyle.call(node)\n      if (strokeStyle) {\n        strokeShape(ctx, area, {\n          shape,\n          title_height,\n          title_mode,\n          collapsed,\n          ...strokeStyle,\n        })\n      }\n    }\n\n    node.drawProgressBar(ctx)\n\n    // these counter helps in conditioning drawing based on if the node has been executed or an action occurred\n    if (node.execute_triggered != null && node.execute_triggered > 0) node.execute_triggered--\n    if (node.action_triggered != null && node.action_triggered > 0) node.action_triggered--\n  }\n\n  /**\n   * Draws a snap guide for a {@link Positionable} item.\n   *\n   * Initial design was a simple white rectangle representing the location the\n   * item would land if dropped.\n   * @param ctx The 2D canvas context to draw on\n   * @param item The item to draw a snap guide for\n   * @param shape The shape of the snap guide to draw\n   * @todo Update to align snapping with boundingRect\n   * @todo Shapes\n   */\n  drawSnapGuide(\n    ctx: CanvasRenderingContext2D,\n    item: Positionable,\n    shape = RenderShape.ROUND,\n  ) {\n    const snapGuide = LGraphCanvas.#temp\n    snapGuide.set(item.boundingRect)\n\n    // Not all items have pos equal to top-left of bounds\n    const { pos } = item\n    const offsetX = pos[0] - snapGuide[0]\n    const offsetY = pos[1] - snapGuide[1]\n\n    // Normalise boundingRect to pos to snap\n    snapGuide[0] += offsetX\n    snapGuide[1] += offsetY\n    if (this.#snapToGrid) snapPoint(snapGuide, this.#snapToGrid)\n    snapGuide[0] -= offsetX\n    snapGuide[1] -= offsetY\n\n    const { globalAlpha } = ctx\n    ctx.globalAlpha = 1\n    ctx.beginPath()\n    const [x, y, w, h] = snapGuide\n    if (shape === RenderShape.CIRCLE) {\n      const midX = x + (w * 0.5)\n      const midY = y + (h * 0.5)\n      const radius = Math.min(w * 0.5, h * 0.5)\n      ctx.arc(midX, midY, radius, 0, Math.PI * 2)\n    } else {\n      ctx.rect(x, y, w, h)\n    }\n\n    ctx.lineWidth = 0.5\n    ctx.strokeStyle = \"#FFFFFF66\"\n    ctx.fillStyle = \"#FFFFFF22\"\n    ctx.fill()\n    ctx.stroke()\n    ctx.globalAlpha = globalAlpha\n  }\n\n  drawConnections(ctx: CanvasRenderingContext2D): void {\n    this.renderedPaths.clear()\n    if (this.links_render_mode === LinkRenderType.HIDDEN_LINK) return\n\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const visibleReroutes: Reroute[] = []\n\n    const now = LiteGraph.getTime()\n    const { visible_area } = this\n    LGraphCanvas.#margin_area[0] = visible_area[0] - 20\n    LGraphCanvas.#margin_area[1] = visible_area[1] - 20\n    LGraphCanvas.#margin_area[2] = visible_area[2] + 40\n    LGraphCanvas.#margin_area[3] = visible_area[3] + 40\n\n    // draw connections\n    ctx.lineWidth = this.connections_width\n\n    ctx.fillStyle = \"#AAA\"\n    ctx.strokeStyle = \"#AAA\"\n    ctx.globalAlpha = this.editor_alpha\n    // for every node\n    const nodes = graph._nodes\n    for (const node of nodes) {\n      // for every input (we render just inputs because it is easier as every slot can only have one input)\n      const { inputs } = node\n      if (!inputs?.length) continue\n\n      for (const [i, input] of inputs.entries()) {\n        if (!input || input.link == null) continue\n\n        const link_id = input.link\n        const link = graph._links.get(link_id)\n        if (!link) continue\n\n        const endPos = node.getInputPos(i)\n\n        // find link info\n        const start_node = graph.getNodeById(link.origin_id)\n        if (start_node == null) continue\n\n        const outputId = link.origin_slot\n        const startPos: Point = outputId === -1\n          ? [start_node.pos[0] + 10, start_node.pos[1] + 10]\n          : start_node.getOutputPos(outputId)\n\n        const output = start_node.outputs[outputId]\n        if (!output) continue\n\n        this.#renderAllLinkSegments(ctx, link, startPos, endPos, visibleReroutes, now, output.dir, input.dir)\n      }\n    }\n\n    if (graph.floatingLinks.size > 0) {\n      this.#renderFloatingLinks(ctx, graph, visibleReroutes, now)\n    }\n\n    const rerouteSet = this.#visibleReroutes\n    rerouteSet.clear()\n\n    // Render reroutes, ordered by number of non-floating links\n    visibleReroutes.sort((a, b) => a.linkIds.size - b.linkIds.size)\n    for (const reroute of visibleReroutes) {\n      rerouteSet.add(reroute)\n\n      if (\n        this.#snapToGrid &&\n        this.isDragging &&\n        this.selectedItems.has(reroute)\n      ) {\n        this.drawSnapGuide(ctx, reroute, RenderShape.CIRCLE)\n      }\n      reroute.draw(ctx, this._pattern)\n\n      // Never draw slots when the pointer is down\n      if (!this.pointer.isDown) reroute.drawSlots(ctx)\n    }\n    ctx.globalAlpha = 1\n  }\n\n  #renderFloatingLinks(ctx: CanvasRenderingContext2D, graph: LGraph, visibleReroutes: Reroute[], now: number) {\n    // Render floating links with 3/4 current alpha\n    const { globalAlpha } = ctx\n    ctx.globalAlpha = globalAlpha * 0.33\n\n    // Floating reroutes\n    for (const link of graph.floatingLinks.values()) {\n      const reroutes = LLink.getReroutes(graph, link)\n      const firstReroute = reroutes[0]\n      const reroute = reroutes.at(-1)\n      if (!firstReroute || !reroute?.floating) continue\n\n      // Input not connected\n      if (reroute.floating.slotType === \"input\") {\n        const node = graph.getNodeById(link.target_id)\n        if (!node) continue\n\n        const startPos = firstReroute.pos\n        const endPos = node.getInputPos(link.target_slot)\n        const endDirection = node.inputs[link.target_slot]?.dir\n\n        firstReroute._dragging = true\n        this.#renderAllLinkSegments(ctx, link, startPos, endPos, visibleReroutes, now, LinkDirection.CENTER, endDirection, true)\n      } else {\n        const node = graph.getNodeById(link.origin_id)\n        if (!node) continue\n\n        const startPos = node.getOutputPos(link.origin_slot)\n        const endPos = reroute.pos\n        const startDirection = node.outputs[link.origin_slot]?.dir\n\n        link._dragging = true\n        this.#renderAllLinkSegments(ctx, link, startPos, endPos, visibleReroutes, now, startDirection, LinkDirection.CENTER, true)\n      }\n    }\n    ctx.globalAlpha = globalAlpha\n  }\n\n  #renderAllLinkSegments(\n    ctx: CanvasRenderingContext2D,\n    link: LLink,\n    startPos: Point,\n    endPos: Point,\n    visibleReroutes: Reroute[],\n    now: number,\n    startDirection?: LinkDirection,\n    endDirection?: LinkDirection,\n    disabled: boolean = false,\n  ) {\n    const { graph, renderedPaths } = this\n    if (!graph) return\n\n    // Get all points this link passes through\n    const reroutes = LLink.getReroutes(graph, link)\n    const points: [Point, ...Point[], Point] = [\n      startPos,\n      ...reroutes.map(x => x.pos),\n      endPos,\n    ]\n\n    // Bounding box of all points (bezier overshoot on long links will be cut)\n    const pointsX = points.map(x => x[0])\n    const pointsY = points.map(x => x[1])\n    LGraphCanvas.#link_bounding[0] = Math.min(...pointsX)\n    LGraphCanvas.#link_bounding[1] = Math.min(...pointsY)\n    LGraphCanvas.#link_bounding[2] = Math.max(...pointsX) - LGraphCanvas.#link_bounding[0]\n    LGraphCanvas.#link_bounding[3] = Math.max(...pointsY) - LGraphCanvas.#link_bounding[1]\n\n    // skip links outside of the visible area of the canvas\n    if (!overlapBounding(LGraphCanvas.#link_bounding, LGraphCanvas.#margin_area))\n      return\n\n    const start_dir = startDirection || LinkDirection.RIGHT\n    const end_dir = endDirection || LinkDirection.LEFT\n\n    // Has reroutes\n    if (reroutes.length) {\n      let startControl: Point | undefined\n\n      const l = reroutes.length\n      for (let j = 0; j < l; j++) {\n        const reroute = reroutes[j]\n\n        // Only render once\n        if (!renderedPaths.has(reroute)) {\n          renderedPaths.add(reroute)\n          visibleReroutes.push(reroute)\n          reroute._colour = link.color ||\n            LGraphCanvas.link_type_colors[link.type] ||\n            this.default_link_color\n\n          const prevReroute = graph.getReroute(reroute.parentId)\n          const rerouteStartPos = prevReroute?.pos ?? startPos\n          reroute.calculateAngle(this.last_draw_time, graph, rerouteStartPos)\n\n          // Skip the first segment if it is being dragged\n          if (!reroute._dragging) {\n            this.renderLink(\n              ctx,\n              rerouteStartPos,\n              reroute.pos,\n              link,\n              false,\n              0,\n              null,\n              startControl === undefined ? start_dir : LinkDirection.CENTER,\n              LinkDirection.CENTER,\n              {\n                startControl,\n                endControl: reroute.controlPoint,\n                reroute,\n                disabled,\n              },\n            )\n          }\n        }\n\n        if (!startControl && reroutes.at(-1)?.floating?.slotType === \"input\") {\n          // Floating link connected to an input\n          startControl = [0, 0]\n        } else {\n          // Calculate start control for the next iter control point\n          const nextPos = reroutes[j + 1]?.pos ?? endPos\n          const dist = Math.min(Reroute.maxSplineOffset, distance(reroute.pos, nextPos) * 0.25)\n          startControl = [dist * reroute.cos, dist * reroute.sin]\n        }\n      }\n\n      // Skip the last segment if it is being dragged\n      if (link._dragging) return\n\n      // Use runtime fallback; TypeScript cannot evaluate this correctly.\n      const segmentStartPos = points.at(-2) ?? startPos\n\n      // Render final link segment\n      this.renderLink(\n        ctx,\n        segmentStartPos,\n        endPos,\n        link,\n        false,\n        0,\n        null,\n        LinkDirection.CENTER,\n        end_dir,\n        { startControl, disabled },\n      )\n      // Skip normal render when link is being dragged\n    } else if (!link._dragging) {\n      this.renderLink(\n        ctx,\n        startPos,\n        endPos,\n        link,\n        false,\n        0,\n        null,\n        start_dir,\n        end_dir,\n      )\n    }\n    renderedPaths.add(link)\n\n    // event triggered rendered on top\n    if (link?._last_time && now - link._last_time < 1000) {\n      const f = 2.0 - (now - link._last_time) * 0.002\n      const tmp = ctx.globalAlpha\n      ctx.globalAlpha = tmp * f\n      this.renderLink(\n        ctx,\n        startPos,\n        endPos,\n        link,\n        true,\n        f,\n        \"white\",\n        start_dir,\n        end_dir,\n      )\n      ctx.globalAlpha = tmp\n    }\n  }\n\n  /**\n   * draws a link between two points\n   * @param ctx Canvas 2D rendering context\n   * @param a start pos\n   * @param b end pos\n   * @param link the link object with all the link info\n   * @param skip_border ignore the shadow of the link\n   * @param flow show flow animation (for events)\n   * @param color the color for the link\n   * @param start_dir the direction enum\n   * @param end_dir the direction enum\n   */\n  renderLink(\n    ctx: CanvasRenderingContext2D,\n    a: ReadOnlyPoint,\n    b: ReadOnlyPoint,\n    link: LLink | null,\n    skip_border: boolean,\n    flow: number | null,\n    color: CanvasColour | null,\n    start_dir: LinkDirection,\n    end_dir: LinkDirection,\n    {\n      startControl,\n      endControl,\n      reroute,\n      num_sublines = 1,\n      disabled = false,\n    }: {\n      /** When defined, render data will be saved to this reroute instead of the {@link link}. */\n      reroute?: Reroute\n      /** Offset of the bezier curve control point from {@link a point a} (output side) */\n      startControl?: ReadOnlyPoint\n      /** Offset of the bezier curve control point from {@link b point b} (input side) */\n      endControl?: ReadOnlyPoint\n      /** Number of sublines (useful to represent vec3 or rgb) @todo If implemented, refactor calculations out of the loop */\n      num_sublines?: number\n      /** Whether this is a floating link segment */\n      disabled?: boolean\n    } = {},\n  ): void {\n    const linkColour =\n      link != null && this.highlighted_links[link.id]\n        ? \"#FFF\"\n        : color ||\n          link?.color ||\n          (link?.type != null && LGraphCanvas.link_type_colors[link.type]) ||\n          this.default_link_color\n    const startDir = start_dir || LinkDirection.RIGHT\n    const endDir = end_dir || LinkDirection.LEFT\n\n    const dist = this.links_render_mode == LinkRenderType.SPLINE_LINK && (!endControl || !startControl)\n      ? distance(a, b)\n      : 0\n\n    // TODO: Subline code below was inserted in the wrong place - should be before this statement\n    if (this.render_connections_border && !this.low_quality) {\n      ctx.lineWidth = this.connections_width + 4\n    }\n    ctx.lineJoin = \"round\"\n    num_sublines ||= 1\n    if (num_sublines > 1) ctx.lineWidth = 0.5\n\n    // begin line shape\n    const path = new Path2D()\n\n    /** The link or reroute we're currently rendering */\n    const linkSegment = reroute ?? link\n    if (linkSegment) linkSegment.path = path\n\n    const innerA = LGraphCanvas.#lTempA\n    const innerB = LGraphCanvas.#lTempB\n\n    /** Reference to {@link reroute._pos} if present, or {@link link._pos} if present.  Caches the centre point of the link. */\n    const pos: Point = linkSegment?._pos ?? [0, 0]\n\n    for (let i = 0; i < num_sublines; i++) {\n      const offsety = (i - (num_sublines - 1) * 0.5) * 5\n      innerA[0] = a[0]\n      innerA[1] = a[1]\n      innerB[0] = b[0]\n      innerB[1] = b[1]\n\n      if (this.links_render_mode == LinkRenderType.SPLINE_LINK) {\n        if (endControl) {\n          innerB[0] = b[0] + endControl[0]\n          innerB[1] = b[1] + endControl[1]\n        } else {\n          this.#addSplineOffset(innerB, endDir, dist)\n        }\n        if (startControl) {\n          innerA[0] = a[0] + startControl[0]\n          innerA[1] = a[1] + startControl[1]\n        } else {\n          this.#addSplineOffset(innerA, startDir, dist)\n        }\n        path.moveTo(a[0], a[1] + offsety)\n        path.bezierCurveTo(\n          innerA[0],\n          innerA[1] + offsety,\n          innerB[0],\n          innerB[1] + offsety,\n          b[0],\n          b[1] + offsety,\n        )\n\n        // Calculate centre point\n        findPointOnCurve(pos, a, b, innerA, innerB, 0.5)\n\n        if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {\n          const justPastCentre = LGraphCanvas.#lTempC\n          findPointOnCurve(justPastCentre, a, b, innerA, innerB, 0.51)\n\n          linkSegment._centreAngle = Math.atan2(\n            justPastCentre[1] - pos[1],\n            justPastCentre[0] - pos[0],\n          )\n        }\n      } else {\n        const l = this.links_render_mode == LinkRenderType.LINEAR_LINK ? 15 : 10\n        switch (startDir) {\n        case LinkDirection.LEFT:\n          innerA[0] += -l\n          break\n        case LinkDirection.RIGHT:\n          innerA[0] += l\n          break\n        case LinkDirection.UP:\n          innerA[1] += -l\n          break\n        case LinkDirection.DOWN:\n          innerA[1] += l\n          break\n        }\n        switch (endDir) {\n        case LinkDirection.LEFT:\n          innerB[0] += -l\n          break\n        case LinkDirection.RIGHT:\n          innerB[0] += l\n          break\n        case LinkDirection.UP:\n          innerB[1] += -l\n          break\n        case LinkDirection.DOWN:\n          innerB[1] += l\n          break\n        }\n        if (this.links_render_mode == LinkRenderType.LINEAR_LINK) {\n          path.moveTo(a[0], a[1] + offsety)\n          path.lineTo(innerA[0], innerA[1] + offsety)\n          path.lineTo(innerB[0], innerB[1] + offsety)\n          path.lineTo(b[0], b[1] + offsety)\n\n          // Calculate centre point\n          pos[0] = (innerA[0] + innerB[0]) * 0.5\n          pos[1] = (innerA[1] + innerB[1]) * 0.5\n\n          if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {\n            linkSegment._centreAngle = Math.atan2(\n              innerB[1] - innerA[1],\n              innerB[0] - innerA[0],\n            )\n          }\n        } else if (this.links_render_mode == LinkRenderType.STRAIGHT_LINK) {\n          const midX = (innerA[0] + innerB[0]) * 0.5\n\n          path.moveTo(a[0], a[1])\n          path.lineTo(innerA[0], innerA[1])\n          path.lineTo(midX, innerA[1])\n          path.lineTo(midX, innerB[1])\n          path.lineTo(innerB[0], innerB[1])\n          path.lineTo(b[0], b[1])\n\n          // Calculate centre point\n          pos[0] = midX\n          pos[1] = (innerA[1] + innerB[1]) * 0.5\n\n          if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {\n            const diff = innerB[1] - innerA[1]\n            if (Math.abs(diff) < 4) linkSegment._centreAngle = 0\n            else if (diff > 0) linkSegment._centreAngle = Math.PI * 0.5\n            else linkSegment._centreAngle = -(Math.PI * 0.5)\n          }\n        } else {\n          return\n        }\n      }\n    }\n\n    // rendering the outline of the connection can be a little bit slow\n    if (this.render_connections_border && !this.low_quality && !skip_border) {\n      ctx.strokeStyle = \"rgba(0,0,0,0.5)\"\n      ctx.stroke(path)\n    }\n\n    ctx.lineWidth = this.connections_width\n    ctx.fillStyle = ctx.strokeStyle = linkColour\n    ctx.stroke(path)\n\n    // render arrow in the middle\n    if (\n      this.ds.scale >= 0.6 &&\n      this.highquality_render &&\n      linkSegment\n    ) {\n      // render arrow\n      if (this.render_connection_arrows) {\n        // compute two points in the connection\n        const posA = this.computeConnectionPoint(a, b, 0.25, startDir, endDir)\n        const posB = this.computeConnectionPoint(a, b, 0.26, startDir, endDir)\n        const posC = this.computeConnectionPoint(a, b, 0.75, startDir, endDir)\n        const posD = this.computeConnectionPoint(a, b, 0.76, startDir, endDir)\n\n        // compute the angle between them so the arrow points in the right direction\n        let angleA = 0\n        let angleB = 0\n        if (this.render_curved_connections) {\n          angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1])\n          angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1])\n        } else {\n          angleB = angleA = b[1] > a[1] ? 0 : Math.PI\n        }\n\n        // render arrow\n        const transform = ctx.getTransform()\n        ctx.translate(posA[0], posA[1])\n        ctx.rotate(angleA)\n        ctx.beginPath()\n        ctx.moveTo(-5, -3)\n        ctx.lineTo(0, +7)\n        ctx.lineTo(+5, -3)\n        ctx.fill()\n        ctx.setTransform(transform)\n\n        ctx.translate(posC[0], posC[1])\n        ctx.rotate(angleB)\n        ctx.beginPath()\n        ctx.moveTo(-5, -3)\n        ctx.lineTo(0, +7)\n        ctx.lineTo(+5, -3)\n        ctx.fill()\n        ctx.setTransform(transform)\n      }\n\n      // Draw link centre marker\n      ctx.beginPath()\n      if (this.linkMarkerShape === LinkMarkerShape.Arrow) {\n        const transform = ctx.getTransform()\n        ctx.translate(pos[0], pos[1])\n        if (linkSegment._centreAngle) ctx.rotate(linkSegment._centreAngle)\n        // The math is off, but it currently looks better in chromium\n        ctx.moveTo(-3.2, -5)\n        ctx.lineTo(+7, 0)\n        ctx.lineTo(-3.2, +5)\n        ctx.setTransform(transform)\n      } else if (\n        this.linkMarkerShape == null ||\n        this.linkMarkerShape === LinkMarkerShape.Circle\n      ) {\n        ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2)\n      }\n      if (disabled) {\n        const { fillStyle, globalAlpha } = ctx\n        ctx.fillStyle = this._pattern ?? \"#797979\"\n        ctx.globalAlpha = 0.75\n        ctx.fill()\n        ctx.globalAlpha = globalAlpha\n        ctx.fillStyle = fillStyle\n      }\n      ctx.fill()\n    }\n\n    // render flowing points\n    if (flow) {\n      ctx.fillStyle = linkColour\n      for (let i = 0; i < 5; ++i) {\n        const f = (LiteGraph.getTime() * 0.001 + i * 0.2) % 1\n        const flowPos = this.computeConnectionPoint(a, b, f, startDir, endDir)\n        ctx.beginPath()\n        ctx.arc(flowPos[0], flowPos[1], 5, 0, 2 * Math.PI)\n        ctx.fill()\n      }\n    }\n  }\n\n  /**\n   * Finds a point along a spline represented by a to b, with spline endpoint directions dictacted by start_dir and end_dir.\n   * @param a Start point\n   * @param b End point\n   * @param t Time: distance between points (e.g 0.25 is 25% along the line)\n   * @param start_dir Spline start direction\n   * @param end_dir Spline end direction\n   * @returns The point at {@link t} distance along the spline a-b.\n   */\n  computeConnectionPoint(\n    a: ReadOnlyPoint,\n    b: ReadOnlyPoint,\n    t: number,\n    start_dir: LinkDirection,\n    end_dir: LinkDirection,\n  ): Point {\n    start_dir ||= LinkDirection.RIGHT\n    end_dir ||= LinkDirection.LEFT\n\n    const dist = distance(a, b)\n    const pa: Point = [a[0], a[1]]\n    const pb: Point = [b[0], b[1]]\n\n    this.#addSplineOffset(pa, start_dir, dist)\n    this.#addSplineOffset(pb, end_dir, dist)\n\n    const c1 = (1 - t) * (1 - t) * (1 - t)\n    const c2 = 3 * ((1 - t) * (1 - t)) * t\n    const c3 = 3 * (1 - t) * (t * t)\n    const c4 = t * t * t\n\n    const x = c1 * a[0] + c2 * pa[0] + c3 * pb[0] + c4 * b[0]\n    const y = c1 * a[1] + c2 * pa[1] + c3 * pb[1] + c4 * b[1]\n    return [x, y]\n  }\n\n  /**\n   * Modifies an existing point, adding a single-axis offset.\n   * @param point The point to add the offset to\n   * @param direction The direction to add the offset in\n   * @param dist Distance to offset\n   * @param factor Distance is mulitplied by this value.  Default: 0.25\n   */\n  #addSplineOffset(\n    point: Point,\n    direction: LinkDirection,\n    dist: number,\n    factor = 0.25,\n  ): void {\n    switch (direction) {\n    case LinkDirection.LEFT:\n      point[0] += dist * -factor\n      break\n    case LinkDirection.RIGHT:\n      point[0] += dist * factor\n      break\n    case LinkDirection.UP:\n      point[1] += dist * -factor\n      break\n    case LinkDirection.DOWN:\n      point[1] += dist * factor\n      break\n    }\n  }\n\n  drawExecutionOrder(ctx: CanvasRenderingContext2D): void {\n    ctx.shadowColor = \"transparent\"\n    ctx.globalAlpha = 0.25\n\n    ctx.textAlign = \"center\"\n    ctx.strokeStyle = \"white\"\n    ctx.globalAlpha = 0.75\n\n    const { visible_nodes } = this\n    for (const node of visible_nodes) {\n      ctx.fillStyle = \"black\"\n      ctx.fillRect(\n        node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,\n        node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,\n        LiteGraph.NODE_TITLE_HEIGHT,\n        LiteGraph.NODE_TITLE_HEIGHT,\n      )\n      if (node.order == 0) {\n        ctx.strokeRect(\n          node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,\n          node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,\n          LiteGraph.NODE_TITLE_HEIGHT,\n          LiteGraph.NODE_TITLE_HEIGHT,\n        )\n      }\n      ctx.fillStyle = \"#FFF\"\n      ctx.fillText(\n        stringOrEmpty(node.order),\n        node.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,\n        node.pos[1] - 6,\n      )\n    }\n    ctx.globalAlpha = 1\n  }\n\n  /**\n   * draws the widgets stored inside a node\n   * @deprecated Use {@link LGraphNode.drawWidgets} instead.\n   * @remarks Currently there are extensions hijacking this function, so we cannot remove it.\n   */\n  drawNodeWidgets(\n    node: LGraphNode,\n    _posY: null,\n    ctx: CanvasRenderingContext2D,\n  ): void {\n    node.drawWidgets(ctx, {\n      lowQuality: this.low_quality,\n      editorAlpha: this.editor_alpha,\n    })\n  }\n\n  /**\n   * draws every group area in the background\n   */\n  drawGroups(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D): void {\n    if (!this.graph) return\n\n    const groups = this.graph._groups\n\n    ctx.save()\n    ctx.globalAlpha = 0.5 * this.editor_alpha\n    const drawSnapGuides = this.#snapToGrid && this.isDragging\n\n    for (const group of groups) {\n      // out of the visible area\n      if (!overlapBounding(this.visible_area, group._bounding)) {\n        continue\n      }\n\n      // Draw snap shadow\n      if (drawSnapGuides && this.selectedItems.has(group))\n        this.drawSnapGuide(ctx, group)\n\n      group.draw(this, ctx)\n    }\n\n    ctx.restore()\n  }\n\n  /**\n   * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode\n   * @todo Remove or rewrite\n   */\n  resize(width?: number, height?: number): void {\n    if (!width && !height) {\n      const parent = this.canvas.parentElement\n      if (!parent) throw new TypeError(\"Attempted to resize canvas, but parent element was null.\")\n      width = parent.offsetWidth\n      height = parent.offsetHeight\n    }\n\n    if (this.canvas.width == width && this.canvas.height == height) return\n\n    this.canvas.width = width ?? 0\n    this.canvas.height = height ?? 0\n    this.bgcanvas.width = this.canvas.width\n    this.bgcanvas.height = this.canvas.height\n    this.setDirty(true, true)\n  }\n\n  onNodeSelectionChange(): void {}\n\n  /**\n   * Determines the furthest nodes in each direction for the currently selected nodes\n   */\n  boundaryNodesForSelection(): NullableProperties<IBoundaryNodes> {\n    return LGraphCanvas.getBoundaryNodes(this.selected_nodes)\n  }\n\n  showLinkMenu(segment: LinkSegment, e: CanvasMouseEvent): boolean {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const title = \"data\" in segment && segment.data != null\n      ? segment.data.constructor.name\n      : undefined\n\n    const { origin_id, origin_slot } = segment\n    if (origin_id == null || origin_slot == null) {\n      new LiteGraph.ContextMenu<string>([\"Link has no origin\"], {\n        event: e,\n        title,\n      })\n      return false\n    }\n\n    const node_left = graph.getNodeById(origin_id)\n    const fromType = node_left?.outputs?.[origin_slot]?.type\n\n    const options = [\"Add Node\", \"Add Reroute\", null, \"Delete\", null]\n\n    const menu = new LiteGraph.ContextMenu<string>(options, {\n      event: e,\n      title,\n      callback: inner_clicked.bind(this),\n    })\n\n    return false\n\n    function inner_clicked(this: LGraphCanvas, v: string, options: unknown, e: MouseEvent) {\n      if (!graph) throw new NullGraphError()\n\n      switch (v) {\n      case \"Add Node\":\n        LGraphCanvas.onMenuAdd(null, null, e, menu, (node) => {\n          if (!node?.inputs?.length || !node?.outputs?.length || origin_slot == null) return\n\n          // leave the connection type checking inside connectByType\n          const options = { afterRerouteId: segment.parentId }\n          if (node_left?.connectByType(origin_slot, node, fromType ?? \"*\", options)) {\n            node.pos[0] -= node.size[0] * 0.5\n          }\n        })\n        break\n\n      case \"Add Reroute\": {\n        try {\n          this.emitBeforeChange()\n          this.adjustMouseEvent(e)\n          graph.createReroute(segment._pos, segment)\n          this.setDirty(false, true)\n        } catch (error) {\n          console.error(error)\n        } finally {\n          this.emitAfterChange()\n        }\n        break\n      }\n\n      case \"Delete\":\n        graph.removeLink(segment.id)\n        break\n      default:\n      }\n    }\n  }\n\n  createDefaultNodeForSlot(optPass: ICreateDefaultNodeOptions): boolean {\n    type DefaultOptions = ICreateDefaultNodeOptions & {\n      posAdd: Point\n      posSizeFix: Point\n    }\n\n    const opts = Object.assign<DefaultOptions, ICreateDefaultNodeOptions>({\n      nodeFrom: null,\n      slotFrom: null,\n      nodeTo: null,\n      slotTo: null,\n      position: [0, 0],\n      nodeType: undefined,\n      posAdd: [0, 0],\n      posSizeFix: [0, 0],\n    }, optPass)\n    const { afterRerouteId } = opts\n\n    const isFrom = opts.nodeFrom && opts.slotFrom !== null\n    const isTo = !isFrom && opts.nodeTo && opts.slotTo !== null\n\n    if (!isFrom && !isTo) {\n      console.warn(`No data passed to createDefaultNodeForSlot`, opts.nodeFrom, opts.slotFrom, opts.nodeTo, opts.slotTo)\n      return false\n    }\n    if (!opts.nodeType) {\n      console.warn(\"No type to createDefaultNodeForSlot\")\n      return false\n    }\n\n    const nodeX = isFrom ? opts.nodeFrom : opts.nodeTo\n    if (!nodeX) throw new TypeError(\"nodeX was null when creating default node for slot.\")\n\n    let slotX = isFrom ? opts.slotFrom : opts.slotTo\n\n    let iSlotConn: number | false = false\n    switch (typeof slotX) {\n    case \"string\":\n      iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false)\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX]\n      break\n    case \"object\":\n      if (slotX === null) {\n        console.warn(\"Cant get slot information\", slotX)\n        return false\n      }\n\n      // ok slotX\n      iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name)\n      break\n    case \"number\":\n      iSlotConn = slotX\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX]\n      break\n    case \"undefined\":\n    default:\n      console.warn(\"Cant get slot information\", slotX)\n      return false\n    }\n\n    // check for defaults nodes for this slottype\n    const fromSlotType = slotX.type == LiteGraph.EVENT ? \"_event_\" : slotX.type\n    const slotTypesDefault = isFrom\n      ? LiteGraph.slot_types_default_out\n      : LiteGraph.slot_types_default_in\n    if (slotTypesDefault?.[fromSlotType]) {\n      // TODO: Remove \"any\" kludge\n      let nodeNewType: any = false\n      if (typeof slotTypesDefault[fromSlotType] == \"object\") {\n        for (const typeX in slotTypesDefault[fromSlotType]) {\n          if (\n            opts.nodeType == slotTypesDefault[fromSlotType][typeX] ||\n            opts.nodeType == \"AUTO\"\n          ) {\n            nodeNewType = slotTypesDefault[fromSlotType][typeX]\n            break\n          }\n        }\n      } else if (\n        opts.nodeType == slotTypesDefault[fromSlotType] ||\n        opts.nodeType == \"AUTO\"\n      ) {\n        nodeNewType = slotTypesDefault[fromSlotType]\n      }\n      if (nodeNewType) {\n        // TODO: Remove \"any\" kludge\n        let nodeNewOpts: any = false\n        if (typeof nodeNewType == \"object\" && nodeNewType.node) {\n          nodeNewOpts = nodeNewType\n          nodeNewType = nodeNewType.node\n        }\n\n        // that.graph.beforeChange();\n        const newNode = LiteGraph.createNode(nodeNewType)\n        if (newNode) {\n          // if is object pass options\n          if (nodeNewOpts) {\n            if (nodeNewOpts.properties) {\n              for (const i in nodeNewOpts.properties) {\n                newNode.addProperty(i, nodeNewOpts.properties[i])\n              }\n            }\n            if (nodeNewOpts.inputs) {\n              newNode.inputs = []\n              for (const i in nodeNewOpts.inputs) {\n                newNode.addOutput(\n                  nodeNewOpts.inputs[i][0],\n                  nodeNewOpts.inputs[i][1],\n                )\n              }\n            }\n            if (nodeNewOpts.outputs) {\n              newNode.outputs = []\n              for (const i in nodeNewOpts.outputs) {\n                newNode.addOutput(\n                  nodeNewOpts.outputs[i][0],\n                  nodeNewOpts.outputs[i][1],\n                )\n              }\n            }\n            if (nodeNewOpts.title) {\n              newNode.title = nodeNewOpts.title\n            }\n            if (nodeNewOpts.json) {\n              newNode.configure(nodeNewOpts.json)\n            }\n          }\n\n          // add the node\n          if (!this.graph) throw new NullGraphError()\n\n          this.graph.add(newNode)\n          newNode.pos = [\n            opts.position[0] + opts.posAdd[0] + (opts.posSizeFix[0] ? opts.posSizeFix[0] * newNode.size[0] : 0),\n            opts.position[1] + opts.posAdd[1] + (opts.posSizeFix[1] ? opts.posSizeFix[1] * newNode.size[1] : 0),\n          ]\n\n          // Interim API - allow the link connection to be canceled.\n          // TODO: https://github.com/Comfy-Org/litegraph.js/issues/946\n          const detail = { node: newNode, opts }\n          const mayConnectLinks = this.canvas.dispatchEvent(new CustomEvent(\"connect-new-default-node\", { detail, cancelable: true }))\n          if (!mayConnectLinks) return true\n\n          // connect the two!\n          if (isFrom) {\n            if (!opts.nodeFrom) throw new TypeError(\"createDefaultNodeForSlot - nodeFrom was null\")\n            opts.nodeFrom.connectByType(iSlotConn, newNode, fromSlotType, { afterRerouteId })\n          } else {\n            if (!opts.nodeTo) throw new TypeError(\"createDefaultNodeForSlot - nodeTo was null\")\n            opts.nodeTo.connectByTypeOutput(iSlotConn, newNode, fromSlotType, { afterRerouteId })\n          }\n\n          // if connecting in between\n          if (isFrom && isTo) {\n            // TODO\n          }\n\n          return true\n        }\n        console.log(`failed creating ${nodeNewType}`)\n      }\n    }\n    return false\n  }\n\n  showConnectionMenu(optPass: Partial<ICreateNodeOptions & { e: MouseEvent }>): ContextMenu<string> | undefined {\n    const opts = Object.assign<ICreateNodeOptions & HasShowSearchCallback, ICreateNodeOptions>({\n      nodeFrom: null,\n      slotFrom: null,\n      nodeTo: null,\n      slotTo: null,\n      e: undefined,\n      allow_searchbox: this.allow_searchbox,\n      showSearchBox: this.showSearchBox,\n    }, optPass || {})\n    const dirty = () => this.#dirty()\n    const that = this\n    const { graph } = this\n    const { afterRerouteId } = opts\n\n    const isFrom = opts.nodeFrom && opts.slotFrom\n    const isTo = !isFrom && opts.nodeTo && opts.slotTo\n\n    if (!isFrom && !isTo) {\n      console.warn(\"No data passed to showConnectionMenu\")\n      return\n    }\n\n    const nodeX = isFrom ? opts.nodeFrom : opts.nodeTo\n    if (!nodeX) throw new TypeError(\"nodeX was null when creating default node for slot.\")\n    let slotX = isFrom ? opts.slotFrom : opts.slotTo\n\n    let iSlotConn: number\n    switch (typeof slotX) {\n    case \"string\":\n      iSlotConn = isFrom\n        ? nodeX.findOutputSlot(slotX, false)\n        : nodeX.findInputSlot(slotX, false)\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX]\n      break\n    case \"object\":\n      if (slotX === null) {\n        console.warn(\"Cant get slot information\", slotX)\n        return\n      }\n\n      // ok slotX\n      iSlotConn = isFrom\n        ? nodeX.findOutputSlot(slotX.name)\n        : nodeX.findInputSlot(slotX.name)\n      break\n    case \"number\":\n      iSlotConn = slotX\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX]\n      break\n    default:\n      console.warn(\"Cant get slot information\", slotX)\n      return\n    }\n\n    const options = [\"Add Node\", \"Add Reroute\", null]\n\n    if (opts.allow_searchbox) {\n      options.push(\"Search\", null)\n    }\n\n    // get defaults nodes for this slottype\n    const fromSlotType = slotX.type == LiteGraph.EVENT ? \"_event_\" : slotX.type\n    const slotTypesDefault = isFrom\n      ? LiteGraph.slot_types_default_out\n      : LiteGraph.slot_types_default_in\n    if (slotTypesDefault?.[fromSlotType]) {\n      if (typeof slotTypesDefault[fromSlotType] == \"object\") {\n        for (const typeX in slotTypesDefault[fromSlotType]) {\n          options.push(slotTypesDefault[fromSlotType][typeX])\n        }\n      } else {\n        options.push(slotTypesDefault[fromSlotType])\n      }\n    }\n\n    // build menu\n    const menu = new LiteGraph.ContextMenu<string>(options, {\n      event: opts.e,\n      extra: slotX,\n      title:\n        (slotX && slotX.name != \"\"\n          ? slotX.name + (fromSlotType ? \" | \" : \"\")\n          : \"\") + (slotX && fromSlotType ? fromSlotType : \"\"),\n      callback: inner_clicked,\n    })\n\n    return menu\n\n    // callback\n    function inner_clicked(v: string | undefined, options: IContextMenuOptions<string, INodeInputSlot | INodeOutputSlot>, e: MouseEvent) {\n      switch (v) {\n      case \"Add Node\":\n        LGraphCanvas.onMenuAdd(null, null, e, menu, function (node) {\n          if (!node) return\n\n          if (isFrom) {\n            opts.nodeFrom?.connectByType(iSlotConn, node, fromSlotType, { afterRerouteId })\n          } else {\n            opts.nodeTo?.connectByTypeOutput(iSlotConn, node, fromSlotType, { afterRerouteId })\n          }\n        })\n        break\n      case \"Add Reroute\":{\n        const node = isFrom ? opts.nodeFrom : opts.nodeTo\n        const slot = options.extra\n\n        if (!graph) throw new NullGraphError()\n        if (!node) throw new TypeError(\"Cannot add reroute: node was null\")\n        if (!slot) throw new TypeError(\"Cannot add reroute: slot was null\")\n        if (!opts.e) throw new TypeError(\"Cannot add reroute: CanvasPointerEvent was null\")\n\n        const reroute = node.connectFloatingReroute([opts.e.canvasX, opts.e.canvasY], slot, afterRerouteId)\n        if (!reroute) throw new Error(\"Failed to create reroute\")\n\n        dirty()\n        break\n      }\n      case \"Search\":\n        if (isFrom) {\n          opts.showSearchBox(e, { node_from: opts.nodeFrom, slot_from: slotX, type_filter_in: fromSlotType })\n        } else {\n          opts.showSearchBox(e, { node_to: opts.nodeTo, slot_from: slotX, type_filter_out: fromSlotType })\n        }\n        break\n      default: {\n        const customProps = {\n          position: [opts.e?.canvasX ?? 0, opts.e?.canvasY ?? 0],\n          nodeType: v,\n          afterRerouteId,\n        } satisfies Partial<ICreateDefaultNodeOptions>\n\n        const options = Object.assign(opts, customProps)\n        that.createDefaultNodeForSlot(options)\n        break\n      }\n      }\n    }\n  }\n\n  // refactor: there are different dialogs, some uses createDialog some dont\n  prompt(\n    title: string,\n    value: any,\n    callback: (arg0: any) => void,\n    event: CanvasMouseEvent,\n    multiline?: boolean,\n  ): HTMLDivElement {\n    const that = this\n    title = title || \"\"\n\n    const customProperties = {\n      is_modified: false,\n      className: \"graphdialog rounded\",\n      innerHTML: multiline\n        ? \"<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>\"\n        : \"<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>\",\n      close() {\n        that.prompt_box = null\n        if (dialog.parentNode) {\n          dialog.remove()\n        }\n      },\n    } satisfies Partial<IDialog>\n\n    const div = document.createElement(\"div\")\n    const dialog: PromptDialog = Object.assign(div, customProperties)\n\n    const graphcanvas = LGraphCanvas.active_canvas\n    const { canvas } = graphcanvas\n    if (!canvas.parentNode) throw new TypeError(\"canvas element parentNode was null when opening a prompt.\")\n    canvas.parentNode.append(dialog)\n\n    if (this.ds.scale > 1) dialog.style.transform = `scale(${this.ds.scale})`\n\n    let dialogCloseTimer: number\n    let prevent_timeout = 0\n    LiteGraph.pointerListenerAdd(dialog, \"leave\", function () {\n      if (prevent_timeout) return\n      if (LiteGraph.dialog_close_on_mouse_leave) {\n        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave) {\n          dialogCloseTimer = setTimeout(\n            dialog.close,\n            LiteGraph.dialog_close_on_mouse_leave_delay,\n          )\n        }\n      }\n    })\n    LiteGraph.pointerListenerAdd(dialog, \"enter\", function () {\n      if (LiteGraph.dialog_close_on_mouse_leave && dialogCloseTimer)\n        clearTimeout(dialogCloseTimer)\n    })\n    const selInDia = dialog.querySelectorAll(\"select\")\n    if (selInDia) {\n      // if filtering, check focus changed to comboboxes and prevent closing\n      for (const selIn of selInDia) {\n        selIn.addEventListener(\"click\", function () {\n          prevent_timeout++\n        })\n        selIn.addEventListener(\"blur\", function () {\n          prevent_timeout = 0\n        })\n        selIn.addEventListener(\"change\", function () {\n          prevent_timeout = -1\n        })\n      }\n    }\n    this.prompt_box?.close()\n    this.prompt_box = dialog\n\n    const name_element: HTMLSpanElement | null = dialog.querySelector(\".name\")\n    if (!name_element) throw new TypeError(\"name_element was null\")\n\n    name_element.textContent = title\n    const value_element: HTMLInputElement | null = dialog.querySelector(\".value\")\n    if (!value_element) throw new TypeError(\"value_element was null\")\n\n    value_element.value = value\n    value_element.select()\n\n    const input = value_element\n    input.addEventListener(\"keydown\", function (e: KeyboardEvent) {\n      dialog.is_modified = true\n      if (e.key == \"Escape\") {\n        // ESC\n        dialog.close()\n      } else if (\n        e.key == \"Enter\" &&\n        (e.target as Element).localName != \"textarea\"\n      ) {\n        if (callback) {\n          callback(this.value)\n        }\n        dialog.close()\n      } else {\n        return\n      }\n      e.preventDefault()\n      e.stopPropagation()\n    })\n\n    const button = dialog.querySelector(\"button\")\n    if (!button) throw new TypeError(\"button was null when opening prompt\")\n\n    button.addEventListener(\"click\", function () {\n      callback?.(input.value)\n      that.setDirty(true)\n      dialog.close()\n    })\n\n    const rect = canvas.getBoundingClientRect()\n    let offsetx = -20\n    let offsety = -20\n    if (rect) {\n      offsetx -= rect.left\n      offsety -= rect.top\n    }\n\n    if (event) {\n      dialog.style.left = `${event.clientX + offsetx}px`\n      dialog.style.top = `${event.clientY + offsety}px`\n    } else {\n      dialog.style.left = `${canvas.width * 0.5 + offsetx}px`\n      dialog.style.top = `${canvas.height * 0.5 + offsety}px`\n    }\n\n    setTimeout(function () {\n      input.focus()\n      const clickTime = Date.now()\n      function handleOutsideClick(e: Event) {\n        if (e.target === canvas && Date.now() - clickTime > 256) {\n          dialog.close()\n          canvas.parentElement?.removeEventListener(\"click\", handleOutsideClick)\n          canvas.parentElement?.removeEventListener(\"touchend\", handleOutsideClick)\n        }\n      }\n      canvas.parentElement?.addEventListener(\"click\", handleOutsideClick)\n      canvas.parentElement?.addEventListener(\"touchend\", handleOutsideClick)\n    }, 10)\n\n    return dialog\n  }\n\n  showSearchBox(\n    event: MouseEvent,\n    searchOptions?: IShowSearchOptions,\n  ): HTMLDivElement {\n    // proposed defaults\n    const options: IShowSearchOptions = {\n      slot_from: null,\n      node_from: null,\n      node_to: null,\n      // TODO check for registered_slot_[in/out]_types not empty\n      // this will be checked for functionality enabled : filter on slot type, in and out\n      do_type_filter: LiteGraph.search_filter_enabled,\n\n      // these are default: pass to set initially set values\n      // @ts-expect-error\n      type_filter_in: false,\n\n      type_filter_out: false,\n      show_general_if_none_on_typefilter: true,\n      show_general_after_typefiltered: true,\n      hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave,\n      show_all_if_empty: true,\n      show_all_on_open: LiteGraph.search_show_all_on_open,\n    }\n    Object.assign(options, searchOptions)\n\n    // console.log(options);\n    const that = this\n    const graphcanvas = LGraphCanvas.active_canvas\n    const { canvas } = graphcanvas\n    const root_document = canvas.ownerDocument || document\n\n    const div = document.createElement(\"div\")\n    const dialog = Object.assign(div, {\n      close(this: typeof div) {\n        that.search_box = undefined\n        this.blur()\n        canvas.focus()\n        root_document.body.style.overflow = \"\"\n\n        // important, if canvas loses focus keys wont be captured\n        setTimeout(() => canvas.focus(), 20)\n        dialog.remove()\n      },\n    } satisfies Partial<HTMLDivElement> & ICloseable)\n    dialog.className = \"litegraph litesearchbox graphdialog rounded\"\n    dialog.innerHTML = \"<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>\"\n    if (options.do_type_filter) {\n      dialog.innerHTML += \"<select class='slot_in_type_filter'><option value=''></option></select>\"\n      dialog.innerHTML += \"<select class='slot_out_type_filter'><option value=''></option></select>\"\n    }\n    const helper = document.createElement(\"div\")\n    helper.className = \"helper\"\n    dialog.append(helper)\n\n    if (root_document.fullscreenElement) {\n      root_document.fullscreenElement.append(dialog)\n    } else {\n      root_document.body.append(dialog)\n      root_document.body.style.overflow = \"hidden\"\n    }\n\n    // dialog element has been appended\n    let selIn\n    let selOut\n    if (options.do_type_filter) {\n      selIn = dialog.querySelector(\".slot_in_type_filter\")\n      selOut = dialog.querySelector(\".slot_out_type_filter\")\n    }\n\n    if (this.ds.scale > 1) {\n      dialog.style.transform = `scale(${this.ds.scale})`\n    }\n\n    // hide on mouse leave\n    if (options.hide_on_mouse_leave) {\n      // FIXME: Remove \"any\" kludge\n      let prevent_timeout: any = false\n      let timeout_close: number | null = null\n      LiteGraph.pointerListenerAdd(dialog, \"enter\", function () {\n        if (timeout_close) {\n          clearTimeout(timeout_close)\n          timeout_close = null\n        }\n      })\n      dialog.addEventListener(\"pointerleave\", function () {\n        if (prevent_timeout) return\n\n        const hideDelay = options.hide_on_mouse_leave\n        const delay = typeof hideDelay === \"number\" ? hideDelay : 500\n        timeout_close = setTimeout(dialog.close, delay)\n      })\n      // if filtering, check focus changed to comboboxes and prevent closing\n      if (options.do_type_filter) {\n        if (!selIn) throw new TypeError(\"selIn was null when showing search box\")\n        if (!selOut) throw new TypeError(\"selOut was null when showing search box\")\n\n        selIn.addEventListener(\"click\", function () {\n          prevent_timeout++\n        })\n        selIn.addEventListener(\"blur\", function () {\n          prevent_timeout = 0\n        })\n        selIn.addEventListener(\"change\", function () {\n          prevent_timeout = -1\n        })\n        selOut.addEventListener(\"click\", function () {\n          prevent_timeout++\n        })\n        selOut.addEventListener(\"blur\", function () {\n          prevent_timeout = 0\n        })\n        selOut.addEventListener(\"change\", function () {\n          prevent_timeout = -1\n        })\n      }\n    }\n\n    // @ts-expect-error Panel?\n    that.search_box?.close()\n    that.search_box = dialog\n\n    let first: string | null = null\n    let timeout: number | null = null\n    let selected: ChildNode | null = null\n\n    const maybeInput = dialog.querySelector(\"input\")\n    if (!maybeInput) throw new TypeError(\"Could not create search input box.\")\n\n    const input = maybeInput\n\n    if (input) {\n      input.addEventListener(\"blur\", function () {\n        this.focus()\n      })\n      input.addEventListener(\"keydown\", function (e) {\n        if (e.key == \"ArrowUp\") {\n          // UP\n          changeSelection(false)\n        } else if (e.key == \"ArrowDown\") {\n          // DOWN\n          changeSelection(true)\n        } else if (e.key == \"Escape\") {\n          // ESC\n          dialog.close()\n        } else if (e.key == \"Enter\") {\n          if (selected instanceof HTMLElement) {\n            select(unescape(String(selected.dataset[\"type\"])))\n          } else if (first) {\n            select(first)\n          } else {\n            dialog.close()\n          }\n        } else {\n          if (timeout) {\n            clearInterval(timeout)\n          }\n          timeout = setTimeout(refreshHelper, 10)\n          return\n        }\n        e.preventDefault()\n        e.stopPropagation()\n        e.stopImmediatePropagation()\n        return true\n      })\n    }\n\n    // if should filter on type, load and fill selected and choose elements if passed\n    if (options.do_type_filter) {\n      if (selIn) {\n        const aSlots = LiteGraph.slot_types_in\n        const nSlots = aSlots.length\n\n        if (\n          options.type_filter_in == LiteGraph.EVENT ||\n          options.type_filter_in == LiteGraph.ACTION\n        ) {\n          options.type_filter_in = \"_event_\"\n        }\n        for (let iK = 0; iK < nSlots; iK++) {\n          const opt = document.createElement(\"option\")\n          opt.value = aSlots[iK]\n          opt.innerHTML = aSlots[iK]\n          selIn.append(opt)\n          if (\n            // @ts-expect-error\n            options.type_filter_in !== false &&\n            String(options.type_filter_in).toLowerCase() ==\n            String(aSlots[iK]).toLowerCase()\n          ) {\n            opt.selected = true\n          }\n        }\n        selIn.addEventListener(\"change\", function () {\n          refreshHelper()\n        })\n      }\n      if (selOut) {\n        const aSlots = LiteGraph.slot_types_out\n\n        if (\n          options.type_filter_out == LiteGraph.EVENT ||\n          options.type_filter_out == LiteGraph.ACTION\n        ) {\n          options.type_filter_out = \"_event_\"\n        }\n        for (const aSlot of aSlots) {\n          const opt = document.createElement(\"option\")\n          opt.value = aSlot\n          opt.innerHTML = aSlot\n          selOut.append(opt)\n          if (\n            options.type_filter_out !== false &&\n            String(options.type_filter_out).toLowerCase() ==\n            String(aSlot).toLowerCase()\n          ) {\n            opt.selected = true\n          }\n        }\n        selOut.addEventListener(\"change\", function () {\n          refreshHelper()\n        })\n      }\n    }\n\n    // compute best position\n    const rect = canvas.getBoundingClientRect()\n\n    const left = (event ? event.clientX : rect.left + rect.width * 0.5) - 80\n    const top = (event ? event.clientY : rect.top + rect.height * 0.5) - 20\n    dialog.style.left = `${left}px`\n    dialog.style.top = `${top}px`\n\n    // To avoid out of screen problems\n    if (event.layerY > rect.height - 200) {\n      helper.style.maxHeight = `${rect.height - event.layerY - 20}px`\n    }\n    requestAnimationFrame(function () {\n      input.focus()\n    })\n    if (options.show_all_on_open) refreshHelper()\n\n    function select(name: string) {\n      if (name) {\n        if (that.onSearchBoxSelection) {\n          that.onSearchBoxSelection(name, event, graphcanvas)\n        } else {\n          if (!graphcanvas.graph) throw new NullGraphError()\n\n          graphcanvas.graph.beforeChange()\n          const node = LiteGraph.createNode(name)\n          if (node) {\n            node.pos = graphcanvas.convertEventToCanvasOffset(event)\n            graphcanvas.graph.add(node, false)\n          }\n\n          // join node after inserting\n          if (options.node_from) {\n            // FIXME: any\n            let iS: any = false\n            switch (typeof options.slot_from) {\n            case \"string\":\n              iS = options.node_from.findOutputSlot(options.slot_from)\n              break\n            case \"object\":\n              if (options.slot_from == null) throw new TypeError(\"options.slot_from was null when showing search box\")\n\n              iS = options.slot_from.name\n                ? options.node_from.findOutputSlot(options.slot_from.name)\n                : -1\n              // @ts-expect-error change interface check\n              if (iS == -1 && options.slot_from.slot_index !== undefined) iS = options.slot_from.slot_index\n              break\n            case \"number\":\n              iS = options.slot_from\n              break\n            default:\n              // try with first if no name set\n              iS = 0\n            }\n            if (options.node_from.outputs[iS] !== undefined) {\n              if (iS !== false && iS > -1) {\n                if (node == null) throw new TypeError(\"options.slot_from was null when showing search box\")\n\n                options.node_from.connectByType(iS, node, options.node_from.outputs[iS].type)\n              }\n            } else {\n              // console.warn(\"cant find slot \" + options.slot_from);\n            }\n          }\n          if (options.node_to) {\n            // FIXME: any\n            let iS: any = false\n            switch (typeof options.slot_from) {\n            case \"string\":\n              iS = options.node_to.findInputSlot(options.slot_from)\n              break\n            case \"object\":\n              if (options.slot_from == null) throw new TypeError(\"options.slot_from was null when showing search box\")\n\n              iS = options.slot_from.name\n                ? options.node_to.findInputSlot(options.slot_from.name)\n                : -1\n              // @ts-expect-error change interface check\n              if (iS == -1 && options.slot_from.slot_index !== undefined) iS = options.slot_from.slot_index\n              break\n            case \"number\":\n              iS = options.slot_from\n              break\n            default:\n              // try with first if no name set\n              iS = 0\n            }\n            if (options.node_to.inputs[iS] !== undefined) {\n              if (iS !== false && iS > -1) {\n                if (node == null) throw new TypeError(\"options.slot_from was null when showing search box\")\n                // try connection\n                options.node_to.connectByTypeOutput(iS, node, options.node_to.inputs[iS].type)\n              }\n            } else {\n              // console.warn(\"cant find slot_nodeTO \" + options.slot_from);\n            }\n          }\n\n          graphcanvas.graph.afterChange()\n        }\n      }\n\n      dialog.close()\n    }\n\n    function changeSelection(forward: boolean) {\n      const prev = selected\n      if (!selected) {\n        selected = forward\n          ? helper.childNodes[0]\n          : helper.childNodes[helper.childNodes.length]\n      } else if (selected instanceof Element) {\n        selected.classList.remove(\"selected\")\n        selected = forward\n          ? selected.nextSibling\n          : selected.previousSibling\n        selected ||= prev\n      }\n\n      if (selected instanceof Element) {\n        selected.classList.add(\"selected\")\n        selected.scrollIntoView({ block: \"end\", behavior: \"smooth\" })\n      }\n    }\n\n    function refreshHelper() {\n      timeout = null\n      let str = input.value\n      first = null\n      helper.innerHTML = \"\"\n      if (!str && !options.show_all_if_empty) return\n\n      if (that.onSearchBox) {\n        const list = that.onSearchBox(helper, str, graphcanvas)\n        if (list) {\n          for (const item of list) {\n            addResult(item)\n          }\n        }\n      } else {\n        let c = 0\n        str = str.toLowerCase()\n        if (!graphcanvas.graph) throw new NullGraphError()\n\n        const filter = graphcanvas.filter || graphcanvas.graph.filter\n\n        // FIXME: any\n        // filter by type preprocess\n        let sIn: any = false\n        let sOut: any = false\n        if (options.do_type_filter && that.search_box) {\n          sIn = that.search_box.querySelector(\".slot_in_type_filter\")\n          sOut = that.search_box.querySelector(\".slot_out_type_filter\")\n        }\n\n        const keys = Object.keys(LiteGraph.registered_node_types)\n        const filtered = keys.filter(x => inner_test_filter(x))\n\n        for (const item of filtered) {\n          addResult(item)\n          if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)\n            break\n        }\n\n        // add general type if filtering\n        if (\n          options.show_general_after_typefiltered &&\n          (sIn.value || sOut.value)\n        ) {\n          // FIXME: Undeclared variable again\n          // @ts-expect-error\n          filtered_extra = []\n          for (const i in LiteGraph.registered_node_types) {\n            if (\n              inner_test_filter(i, {\n                inTypeOverride: sIn && sIn.value ? \"*\" : false,\n                outTypeOverride: sOut && sOut.value ? \"*\" : false,\n              })\n            ) {\n              // @ts-expect-error\n              filtered_extra.push(i)\n            }\n          }\n          // @ts-expect-error\n          for (const extraItem of filtered_extra) {\n            addResult(extraItem, \"generic_type\")\n            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)\n              break\n          }\n        }\n\n        // check il filtering gave no results\n        if (\n          (sIn.value || sOut.value) &&\n          helper.childNodes.length == 0 &&\n          options.show_general_if_none_on_typefilter\n        ) {\n          // @ts-expect-error\n          filtered_extra = []\n          for (const i in LiteGraph.registered_node_types) {\n            if (inner_test_filter(i, { skipFilter: true }))\n              // @ts-expect-error\n              filtered_extra.push(i)\n          }\n          // @ts-expect-error\n          for (const extraItem of filtered_extra) {\n            addResult(extraItem, \"not_in_filter\")\n            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)\n              break\n          }\n        }\n\n        function inner_test_filter(\n          type: string,\n          optsIn?: {\n            inTypeOverride?: string | boolean\n            outTypeOverride?: string | boolean\n            skipFilter?: boolean\n          },\n        ): boolean {\n          optsIn = optsIn || {}\n          const optsDef = {\n            skipFilter: false,\n            inTypeOverride: false,\n            outTypeOverride: false,\n          }\n          const opts = Object.assign(optsDef, optsIn)\n          const ctor = LiteGraph.registered_node_types[type]\n          if (filter && ctor.filter != filter) return false\n          if (\n            (!options.show_all_if_empty || str) &&\n            !type.toLowerCase().includes(str) &&\n            (!ctor.title || !ctor.title.toLowerCase().includes(str))\n          ) {\n            return false\n          }\n\n          // filter by slot IN, OUT types\n          if (options.do_type_filter && !opts.skipFilter) {\n            const sType = type\n\n            let sV = opts.inTypeOverride !== false\n              ? opts.inTypeOverride\n              : sIn.value\n            // type is stored\n            if (sIn && sV && LiteGraph.registered_slot_in_types[sV]?.nodes) {\n              const doesInc = LiteGraph.registered_slot_in_types[sV].nodes.includes(sType)\n              if (doesInc === false) return false\n            }\n\n            sV = sOut.value\n            if (opts.outTypeOverride !== false) sV = opts.outTypeOverride\n            // type is stored\n            if (sOut && sV && LiteGraph.registered_slot_out_types[sV]?.nodes) {\n              const doesInc = LiteGraph.registered_slot_out_types[sV].nodes.includes(sType)\n              if (doesInc === false) return false\n            }\n          }\n          return true\n        }\n      }\n\n      function addResult(type: string, className?: string): void {\n        const help = document.createElement(\"div\")\n        first ||= type\n\n        const nodeType = LiteGraph.registered_node_types[type]\n        if (nodeType?.title) {\n          help.textContent = nodeType?.title\n          const typeEl = document.createElement(\"span\")\n          typeEl.className = \"litegraph lite-search-item-type\"\n          typeEl.textContent = type\n          help.append(typeEl)\n        } else {\n          help.textContent = type\n        }\n\n        help.dataset[\"type\"] = escape(type)\n        help.className = \"litegraph lite-search-item\"\n        if (className) {\n          help.className += ` ${className}`\n        }\n        help.addEventListener(\"click\", function () {\n          select(unescape(String(this.dataset[\"type\"])))\n        })\n        helper.append(help)\n      }\n    }\n\n    return dialog\n  }\n\n  showEditPropertyValue(\n    node: LGraphNode,\n    property: string,\n    options: IDialogOptions,\n  ): IDialog | undefined {\n    if (!node || node.properties[property] === undefined) return\n\n    options = options || {}\n\n    const info = node.getPropertyInfo(property)\n    const { type } = info\n\n    let input_html = \"\"\n\n    if (\n      type == \"string\" ||\n      type == \"number\" ||\n      type == \"array\" ||\n      type == \"object\"\n    ) {\n      input_html = \"<input autofocus type='text' class='value'/>\"\n    } else if ((type == \"enum\" || type == \"combo\") && info.values) {\n      input_html = \"<select autofocus type='text' class='value'>\"\n      for (const i in info.values) {\n        const v = Array.isArray(info.values) ? info.values[i] : i\n\n        const selected = v == node.properties[property] ? \"selected\" : \"\"\n        input_html += `<option value='${v}' ${selected}>${info.values[i]}</option>`\n      }\n      input_html += \"</select>\"\n    } else if (type == \"boolean\" || type == \"toggle\") {\n      const checked = node.properties[property] ? \"checked\" : \"\"\n      input_html = `<input autofocus type='checkbox' class='value' ${checked}/>`\n    } else {\n      console.warn(`unknown type: ${type}`)\n      return\n    }\n\n    const dialog = this.createDialog(\n      `<span class='name'>${info.label || property}</span>${input_html}<button>OK</button>`,\n      options,\n    )\n\n    let input: HTMLInputElement | HTMLSelectElement | null\n    if ((type == \"enum\" || type == \"combo\") && info.values) {\n      input = dialog.querySelector(\"select\")\n      input?.addEventListener(\"change\", function (e) {\n        dialog.modified()\n        setValue((e.target as HTMLSelectElement)?.value)\n      })\n    } else if (type == \"boolean\" || type == \"toggle\") {\n      input = dialog.querySelector(\"input\")\n      input?.addEventListener(\"click\", function () {\n        dialog.modified()\n        // @ts-expect-error\n        setValue(!!input.checked)\n      })\n    } else {\n      input = dialog.querySelector(\"input\")\n      if (input) {\n        input.addEventListener(\"blur\", function () {\n          this.focus()\n        })\n\n        let v = node.properties[property] !== undefined\n          ? node.properties[property]\n          : \"\"\n        if (type !== \"string\") {\n          v = JSON.stringify(v)\n        }\n\n        // @ts-expect-error\n        input.value = v\n        input.addEventListener(\"keydown\", function (e) {\n          if (e.key == \"Escape\") {\n            // ESC\n            dialog.close()\n          } else if (e.key == \"Enter\") {\n            // ENTER\n            // save\n            inner()\n          } else {\n            dialog.modified()\n            return\n          }\n          e.preventDefault()\n          e.stopPropagation()\n        })\n      }\n    }\n    input?.focus()\n\n    const button = dialog.querySelector(\"button\")\n    if (!button) throw new TypeError(\"Show edit property value button was null.\")\n    button.addEventListener(\"click\", inner)\n\n    function inner() {\n      setValue(input?.value)\n    }\n    const dirty = () => this.#dirty()\n\n    function setValue(value: string | number | undefined) {\n      if (\n        info?.values &&\n        typeof info.values === \"object\" &&\n        info.values[value] != undefined\n      ) {\n        value = info.values[value]\n      }\n\n      if (typeof node.properties[property] == \"number\") {\n        value = Number(value)\n      }\n      if (type == \"array\" || type == \"object\") {\n        // @ts-expect-error JSON.parse doesn't care.\n        value = JSON.parse(value)\n      }\n      node.properties[property] = value\n      if (node.graph) {\n        node.graph._version++\n      }\n      node.onPropertyChanged?.(property, value)\n      options.onclose?.()\n      dialog.close()\n      dirty()\n    }\n\n    return dialog\n  }\n\n  // TODO refactor, theer are different dialog, some uses createDialog, some dont\n  createDialog(html: string, options: IDialogOptions): IDialog {\n    const def_options = {\n      checkForInput: false,\n      closeOnLeave: true,\n      closeOnLeave_checkModified: true,\n    }\n    options = Object.assign(def_options, options || {})\n\n    const customProperties = {\n      className: \"graphdialog\",\n      innerHTML: html,\n      is_modified: false,\n      modified() {\n        this.is_modified = true\n      },\n      close(this: IDialog) {\n        this.remove()\n      },\n    } satisfies Partial<IDialog>\n\n    const div = document.createElement(\"div\")\n    const dialog: IDialog = Object.assign(div, customProperties)\n\n    const rect = this.canvas.getBoundingClientRect()\n    let offsetx = -20\n    let offsety = -20\n    if (rect) {\n      offsetx -= rect.left\n      offsety -= rect.top\n    }\n\n    if (options.position) {\n      offsetx += options.position[0]\n      offsety += options.position[1]\n    } else if (options.event) {\n      offsetx += options.event.clientX\n      offsety += options.event.clientY\n    } else {\n      // centered\n      offsetx += this.canvas.width * 0.5\n      offsety += this.canvas.height * 0.5\n    }\n\n    dialog.style.left = `${offsetx}px`\n    dialog.style.top = `${offsety}px`\n\n    if (!this.canvas.parentNode) throw new TypeError(\"Canvas parent element was null.\")\n    this.canvas.parentNode.append(dialog)\n\n    // acheck for input and use default behaviour: save on enter, close on esc\n    if (options.checkForInput) {\n      const aI = dialog.querySelectorAll(\"input\")\n      if (aI) {\n        for (const iX of aI) {\n          iX.addEventListener(\"keydown\", function (e) {\n            dialog.modified()\n            if (e.key == \"Escape\") {\n              dialog.close()\n            } else if (e.key != \"Enter\") {\n              return\n            }\n            e.preventDefault()\n            e.stopPropagation()\n          })\n          iX.focus()\n        }\n      }\n    }\n\n    let dialogCloseTimer: number\n    let prevent_timeout = 0\n    dialog.addEventListener(\"mouseleave\", function () {\n      if (prevent_timeout) return\n\n      if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave) {\n        dialogCloseTimer = setTimeout(\n          dialog.close,\n          LiteGraph.dialog_close_on_mouse_leave_delay,\n        )\n      }\n    })\n    dialog.addEventListener(\"mouseenter\", function () {\n      if (options.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) {\n        if (dialogCloseTimer) clearTimeout(dialogCloseTimer)\n      }\n    })\n    const selInDia = dialog.querySelectorAll(\"select\")\n    // if filtering, check focus changed to comboboxes and prevent closing\n    if (selInDia) {\n      for (const selIn of selInDia) {\n        selIn.addEventListener(\"click\", function () {\n          prevent_timeout++\n        })\n        selIn.addEventListener(\"blur\", function () {\n          prevent_timeout = 0\n        })\n        selIn.addEventListener(\"change\", function () {\n          prevent_timeout = -1\n        })\n      }\n    }\n\n    return dialog\n  }\n\n  createPanel(title: string, options: ICreatePanelOptions) {\n    options = options || {}\n\n    const ref_window = options.window || window\n    // TODO: any kludge\n    const root: any = document.createElement(\"div\")\n    root.className = \"litegraph dialog\"\n    root.innerHTML = \"<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>\"\n    root.header = root.querySelector(\".dialog-header\")\n\n    if (options.width)\n      root.style.width = options.width + (typeof options.width === \"number\" ? \"px\" : \"\")\n    if (options.height)\n      root.style.height = options.height + (typeof options.height === \"number\" ? \"px\" : \"\")\n    if (options.closable) {\n      const close = document.createElement(\"span\")\n      close.innerHTML = \"&#10005;\"\n      close.classList.add(\"close\")\n      close.addEventListener(\"click\", function () {\n        root.close()\n      })\n      root.header.append(close)\n    }\n    root.title_element = root.querySelector(\".dialog-title\")\n    root.title_element.textContent = title\n    root.content = root.querySelector(\".dialog-content\")\n    root.alt_content = root.querySelector(\".dialog-alt-content\")\n    root.footer = root.querySelector(\".dialog-footer\")\n\n    root.close = function () {\n      if (typeof root.onClose == \"function\") root.onClose()\n      root.remove()\n      this.remove()\n    }\n\n    // function to swap panel content\n    root.toggleAltContent = function (force: unknown) {\n      let vTo: string\n      let vAlt: string\n      if (force !== undefined) {\n        vTo = force ? \"block\" : \"none\"\n        vAlt = force ? \"none\" : \"block\"\n      } else {\n        vTo = root.alt_content.style.display != \"block\" ? \"block\" : \"none\"\n        vAlt = root.alt_content.style.display != \"block\" ? \"none\" : \"block\"\n      }\n      root.alt_content.style.display = vTo\n      root.content.style.display = vAlt\n    }\n\n    root.toggleFooterVisibility = function (force: unknown) {\n      let vTo: string\n      if (force !== undefined) {\n        vTo = force ? \"block\" : \"none\"\n      } else {\n        vTo = root.footer.style.display != \"block\" ? \"block\" : \"none\"\n      }\n      root.footer.style.display = vTo\n    }\n\n    root.clear = function () {\n      this.content.innerHTML = \"\"\n    }\n\n    root.addHTML = function (code: string, classname: string, on_footer: any) {\n      const elem = document.createElement(\"div\")\n      if (classname) elem.className = classname\n      elem.innerHTML = code\n      if (on_footer) root.footer.append(elem)\n      else root.content.append(elem)\n      return elem\n    }\n\n    root.addButton = function (name: any, callback: any, options: any) {\n      // TODO: any kludge\n      const elem: any = document.createElement(\"button\")\n      elem.textContent = name\n      elem.options = options\n      elem.classList.add(\"btn\")\n      elem.addEventListener(\"click\", callback)\n      root.footer.append(elem)\n      return elem\n    }\n\n    root.addSeparator = function () {\n      const elem = document.createElement(\"div\")\n      elem.className = \"separator\"\n      root.content.append(elem)\n    }\n\n    root.addWidget = function (type: string, name: any, value: unknown, options: { label?: any, type?: any, values?: any, callback?: any }, callback: (arg0: any, arg1: any, arg2: any) => void) {\n      options = options || {}\n      let str_value = String(value)\n      type = type.toLowerCase()\n      if (type == \"number\" && typeof value === \"number\") str_value = value.toFixed(3)\n\n      // FIXME: any kludge\n      const elem: HTMLDivElement & { options?: unknown, value?: unknown } = document.createElement(\"div\")\n      elem.className = \"property\"\n      elem.innerHTML = \"<span class='property_name'></span><span class='property_value'></span>\"\n      const nameSpan = elem.querySelector(\".property_name\")\n      if (!nameSpan) throw new TypeError(\"Property name element was null.\")\n\n      nameSpan.textContent = options.label || name\n      // TODO: any kludge\n      const value_element: HTMLSpanElement | null = elem.querySelector(\".property_value\")\n      if (!value_element) throw new TypeError(\"Property name element was null.\")\n      value_element.textContent = str_value\n      elem.dataset[\"property\"] = name\n      elem.dataset[\"type\"] = options.type || type\n      elem.options = options\n      elem.value = value\n\n      if (type == \"code\") {\n        elem.addEventListener(\"click\", function () {\n          root.inner_showCodePad(this.dataset[\"property\"])\n        })\n      } else if (type == \"boolean\") {\n        elem.classList.add(\"boolean\")\n        if (value) elem.classList.add(\"bool-on\")\n        elem.addEventListener(\"click\", () => {\n          const propname = elem.dataset[\"property\"]\n          elem.value = !elem.value\n          elem.classList.toggle(\"bool-on\")\n          if (!value_element) throw new TypeError(\"Property name element was null.\")\n\n          value_element.textContent = elem.value\n            ? \"true\"\n            : \"false\"\n          innerChange(propname, elem.value)\n        })\n      } else if (type == \"string\" || type == \"number\") {\n        if (!value_element) throw new TypeError(\"Property name element was null.\")\n        value_element.setAttribute(\"contenteditable\", \"true\")\n        value_element.addEventListener(\"keydown\", function (e) {\n          // allow for multiline\n          if (e.code == \"Enter\" && (type != \"string\" || !e.shiftKey)) {\n            e.preventDefault()\n            this.blur()\n          }\n        })\n        value_element.addEventListener(\"blur\", function () {\n          let v: string | number | null = this.textContent\n          const propname = this.parentElement?.dataset[\"property\"]\n          const proptype = this.parentElement?.dataset[\"type\"]\n          if (proptype == \"number\") v = Number(v)\n          innerChange(propname, v)\n        })\n      } else if (type == \"enum\" || type == \"combo\") {\n        const str_value = LGraphCanvas.getPropertyPrintableValue(value, options.values)\n        if (!value_element) throw new TypeError(\"Property name element was null.\")\n        value_element.textContent = str_value ?? \"\"\n\n        value_element.addEventListener(\"click\", function (event) {\n          const values = options.values || []\n          const propname = this.parentElement?.dataset[\"property\"]\n          const inner_clicked = (v: string | null) => {\n            // node.setProperty(propname,v);\n            // graphcanvas.dirty_canvas = true;\n            this.textContent = v\n            innerChange(propname, v)\n            return false\n          }\n          new LiteGraph.ContextMenu(\n            values,\n            {\n              event,\n              className: \"dark\",\n              callback: inner_clicked,\n            },\n            // @ts-expect-error\n            ref_window,\n          )\n        })\n      }\n\n      root.content.append(elem)\n\n      function innerChange(name: string | undefined, value: unknown) {\n        options.callback?.(name, value, options)\n        callback?.(name, value, options)\n      }\n\n      return elem\n    }\n\n    if (typeof root.onOpen == \"function\") root.onOpen()\n\n    return root\n  }\n\n  closePanels(): void {\n    type MightHaveClose = HTMLDivElement & Partial<ICloseable>\n    document.querySelector<MightHaveClose>(\"#node-panel\")?.close?.()\n    document.querySelector<MightHaveClose>(\"#option-panel\")?.close?.()\n  }\n\n  showShowNodePanel(node: LGraphNode): void {\n    this.SELECTED_NODE = node\n    this.closePanels()\n    const ref_window = this.getCanvasWindow()\n    const panel = this.createPanel(node.title || \"\", {\n      closable: true,\n      window: ref_window,\n      onOpen: () => {\n        this.NODEPANEL_IS_OPEN = true\n      },\n      onClose: () => {\n        this.NODEPANEL_IS_OPEN = false\n        this.node_panel = null\n      },\n    })\n    this.node_panel = panel\n    panel.id = \"node-panel\"\n    panel.node = node\n    panel.classList.add(\"settings\")\n\n    const inner_refresh = () => {\n      // clear\n      panel.content.innerHTML = \"\"\n      // @ts-expect-error ctor props\n      panel.addHTML(`<span class='node_type'>${node.type}</span><span class='node_desc'>${node.constructor.desc || \"\"}</span><span class='separator'></span>`)\n\n      panel.addHTML(\"<h3>Properties</h3>\")\n\n      const fUpdate = (name: string, value: string | number | boolean | object | undefined) => {\n        if (!this.graph) throw new NullGraphError()\n        this.graph.beforeChange(node)\n        switch (name) {\n        case \"Title\":\n          if (typeof value !== \"string\") throw new TypeError(\"Attempting to set title to non-string value.\")\n\n          node.title = value\n          break\n        case \"Mode\": {\n          if (typeof value !== \"string\") throw new TypeError(\"Attempting to set mode to non-string value.\")\n\n          const kV = Object.values(LiteGraph.NODE_MODES).indexOf(value)\n          if (kV !== -1 && LiteGraph.NODE_MODES[kV]) {\n            node.changeMode(kV)\n          } else {\n            console.warn(`unexpected mode: ${value}`)\n          }\n          break\n        }\n        case \"Color\":\n          if (typeof value !== \"string\") throw new TypeError(\"Attempting to set colour to non-string value.\")\n\n          if (LGraphCanvas.node_colors[value]) {\n            node.color = LGraphCanvas.node_colors[value].color\n            node.bgcolor = LGraphCanvas.node_colors[value].bgcolor\n          } else {\n            console.warn(`unexpected color: ${value}`)\n          }\n          break\n        default:\n          node.setProperty(name, value)\n          break\n        }\n        this.graph.afterChange()\n        this.dirty_canvas = true\n      }\n\n      panel.addWidget(\"string\", \"Title\", node.title, {}, fUpdate)\n\n      const mode = node.mode == null ? undefined : LiteGraph.NODE_MODES[node.mode]\n      panel.addWidget(\"combo\", \"Mode\", mode, { values: LiteGraph.NODE_MODES }, fUpdate)\n\n      const nodeCol = node.color !== undefined\n        ? Object.keys(LGraphCanvas.node_colors).filter(function (nK) { return LGraphCanvas.node_colors[nK].color == node.color })\n        : \"\"\n\n      panel.addWidget(\"combo\", \"Color\", nodeCol, { values: Object.keys(LGraphCanvas.node_colors) }, fUpdate)\n\n      for (const pName in node.properties) {\n        const value = node.properties[pName]\n        const info = node.getPropertyInfo(pName)\n\n        // in case the user wants control over the side panel widget\n        if (node.onAddPropertyToPanel?.(pName, panel)) continue\n\n        panel.addWidget(info.widget || info.type, pName, value, info, fUpdate)\n      }\n\n      panel.addSeparator()\n\n      node.onShowCustomPanelInfo?.(panel)\n\n      // clear\n      panel.footer.innerHTML = \"\"\n      panel.addButton(\"Delete\", function () {\n        if (node.block_delete) return\n        if (!node.graph) throw new NullGraphError()\n\n        node.graph.remove(node)\n        panel.close()\n      }).classList.add(\"delete\")\n    }\n\n    panel.inner_showCodePad = function (propname: string) {\n      panel.classList.remove(\"settings\")\n      panel.classList.add(\"centered\")\n\n      panel.alt_content.innerHTML = \"<textarea class='code'></textarea>\"\n      const textarea: HTMLTextAreaElement = panel.alt_content.querySelector(\"textarea\")\n      const fDoneWith = function () {\n        panel.toggleAltContent(false)\n        panel.toggleFooterVisibility(true)\n        textarea.remove()\n        panel.classList.add(\"settings\")\n        panel.classList.remove(\"centered\")\n        inner_refresh()\n      }\n      textarea.value = String(node.properties[propname])\n      textarea.addEventListener(\"keydown\", function (e: KeyboardEvent) {\n        if (e.code == \"Enter\" && e.ctrlKey) {\n          node.setProperty(propname, textarea.value)\n          fDoneWith()\n        }\n      })\n      panel.toggleAltContent(true)\n      panel.toggleFooterVisibility(false)\n      textarea.style.height = \"calc(100% - 40px)\"\n\n      const assign = panel.addButton(\"Assign\", function () {\n        node.setProperty(propname, textarea.value)\n        fDoneWith()\n      })\n      panel.alt_content.append(assign)\n      const button = panel.addButton(\"Close\", fDoneWith)\n      button.style.float = \"right\"\n      panel.alt_content.append(button)\n    }\n\n    inner_refresh()\n\n    if (!this.canvas.parentNode) throw new TypeError(\"showNodePanel - this.canvas.parentNode was null\")\n    this.canvas.parentNode.append(panel)\n  }\n\n  checkPanels(): void {\n    if (!this.canvas) return\n\n    if (!this.canvas.parentNode) throw new TypeError(\"checkPanels - this.canvas.parentNode was null\")\n    const panels = this.canvas.parentNode.querySelectorAll(\".litegraph.dialog\")\n    for (const panel of panels) {\n      // @ts-expect-error Panel\n      if (!panel.node) continue\n      // @ts-expect-error Panel\n      if (!panel.node.graph || panel.graph != this.graph) panel.close()\n    }\n  }\n\n  getCanvasMenuOptions(): IContextMenuValue<string>[] {\n    let options: IContextMenuValue<string>[]\n    if (this.getMenuOptions) {\n      options = this.getMenuOptions()\n    } else {\n      options = [\n        {\n          content: \"Add Node\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuAdd,\n        },\n        { content: \"Add Group\", callback: LGraphCanvas.onGroupAdd },\n        // { content: \"Arrange\", callback: that.graph.arrange },\n        // {content:\"Collapse All\", callback: LGraphCanvas.onMenuCollapseAll }\n      ]\n      if (Object.keys(this.selected_nodes).length > 1) {\n        options.push({\n          content: \"Align\",\n          has_submenu: true,\n          callback: LGraphCanvas.onGroupAlign,\n        })\n      }\n    }\n\n    const extra = this.getExtraMenuOptions?.(this, options)\n    return Array.isArray(extra)\n      ? options.concat(extra)\n      : options\n  }\n\n  // called by processContextMenu to extract the menu list\n  getNodeMenuOptions(node: LGraphNode) {\n    let options: (IContextMenuValue<string> | IContextMenuValue<string | null> | IContextMenuValue<INodeSlotContextItem> | IContextMenuValue<unknown, LGraphNode> | IContextMenuValue<typeof LiteGraph.VALID_SHAPES[number]> | null)[]\n\n    if (node.getMenuOptions) {\n      options = node.getMenuOptions(this)\n    } else {\n      options = [\n        {\n          content: \"Inputs\",\n          has_submenu: true,\n          disabled: true,\n        },\n        {\n          content: \"Outputs\",\n          has_submenu: true,\n          disabled: true,\n          callback: LGraphCanvas.showMenuNodeOptionalOutputs,\n        },\n        null,\n        {\n          content: \"Properties\",\n          has_submenu: true,\n          callback: LGraphCanvas.onShowMenuNodeProperties,\n        },\n        {\n          content: \"Properties Panel\",\n          callback: function (item: any, options: any, e: any, menu: any, node: LGraphNode) { LGraphCanvas.active_canvas.showShowNodePanel(node) },\n        },\n        null,\n        {\n          content: \"Title\",\n          callback: LGraphCanvas.onShowPropertyEditor,\n        },\n        {\n          content: \"Mode\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeMode,\n        },\n      ]\n      if (node.resizable !== false) {\n        options.push({\n          content: \"Resize\",\n          callback: LGraphCanvas.onMenuResizeNode,\n        })\n      }\n      if (node.collapsible) {\n        options.push({\n          content: node.collapsed ? \"Expand\" : \"Collapse\",\n          callback: LGraphCanvas.onMenuNodeCollapse,\n        })\n      }\n      if (node.widgets?.some(w => w.advanced)) {\n        options.push({\n          content: node.showAdvanced ? \"Hide Advanced\" : \"Show Advanced\",\n          callback: LGraphCanvas.onMenuToggleAdvanced,\n        })\n      }\n      options.push(\n        {\n          content: node.pinned ? \"Unpin\" : \"Pin\",\n          callback: () => {\n            for (const i in this.selected_nodes) {\n              const node = this.selected_nodes[i]\n              node.pin()\n            }\n            this.setDirty(true, true)\n          },\n        },\n        {\n          content: \"Colors\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeColors,\n        },\n        {\n          content: \"Shapes\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeShapes,\n        },\n        null,\n      )\n    }\n\n    const extra = node.getExtraMenuOptions?.(this, options)\n    if (Array.isArray(extra) && extra.length > 0) {\n      extra.push(null)\n      options = extra.concat(options)\n    }\n\n    if (node.clonable !== false) {\n      options.push({\n        content: \"Clone\",\n        callback: LGraphCanvas.onMenuNodeClone,\n      })\n    }\n\n    if (Object.keys(this.selected_nodes).length > 1) {\n      options.push({\n        content: \"Align Selected To\",\n        has_submenu: true,\n        callback: LGraphCanvas.onNodeAlign,\n      }, {\n        content: \"Distribute Nodes\",\n        has_submenu: true,\n        callback: LGraphCanvas.createDistributeMenu,\n      })\n    }\n\n    options.push(null, {\n      content: \"Remove\",\n      disabled: !(node.removable !== false && !node.block_delete),\n      callback: LGraphCanvas.onMenuNodeRemove,\n    })\n\n    node.graph?.onGetNodeMenuOptions?.(options, node)\n\n    return options\n  }\n\n  /** @deprecated */\n  getGroupMenuOptions(group: LGraphGroup) {\n    console.warn(\"LGraphCanvas.getGroupMenuOptions is deprecated, use LGraphGroup.getMenuOptions instead\")\n    return group.getMenuOptions()\n  }\n\n  processContextMenu(node: LGraphNode | undefined, event: CanvasMouseEvent): void {\n    const canvas = LGraphCanvas.active_canvas\n    const ref_window = canvas.getCanvasWindow()\n\n    // TODO: Remove type kludge\n    let menu_info: (IContextMenuValue | string | null)[]\n    const options: IContextMenuOptions = {\n      event,\n      callback: inner_option_clicked,\n      extra: node,\n    }\n\n    if (node) {\n      options.title = node.type ?? undefined\n      LGraphCanvas.active_node = node\n\n      // check if mouse is in input\n      const slot = node.getSlotInPosition(event.canvasX, event.canvasY)\n      if (slot) {\n        // on slot\n        menu_info = []\n        if (node.getSlotMenuOptions) {\n          menu_info = node.getSlotMenuOptions(slot)\n        } else {\n          if (slot.output?.links?.length || slot.input?.link != null) {\n            menu_info.push({ content: \"Disconnect Links\", slot })\n          }\n\n          const _slot = slot.input || slot.output\n          if (!_slot) throw new TypeError(\"Both in put and output slots were null when processing context menu.\")\n\n          if (_slot.removable) {\n            menu_info.push(\n              _slot.locked\n                ? \"Cannot remove\"\n                : { content: \"Remove Slot\", slot },\n            )\n          }\n          if (!_slot.nameLocked && !((\"link\" in _slot) && _slot.widget)) {\n            menu_info.push({ content: \"Rename Slot\", slot })\n          }\n\n          if (node.getExtraSlotMenuOptions) {\n            menu_info.push(...node.getExtraSlotMenuOptions(slot))\n          }\n        }\n        // @ts-expect-error Slot type can be number and has number checks\n        options.title = (slot.input ? slot.input.type : slot.output.type) || \"*\"\n        if (slot.input && slot.input.type == LiteGraph.ACTION)\n          options.title = \"Action\"\n\n        if (slot.output && slot.output.type == LiteGraph.EVENT)\n          options.title = \"Event\"\n      } else {\n        // on node\n        menu_info = this.getNodeMenuOptions(node)\n      }\n    } else {\n      menu_info = this.getCanvasMenuOptions()\n      if (!this.graph) throw new NullGraphError()\n\n      // Check for reroutes\n      if (this.links_render_mode !== LinkRenderType.HIDDEN_LINK) {\n        const reroute = this.graph.getRerouteOnPos(event.canvasX, event.canvasY, this.#visibleReroutes)\n        if (reroute) {\n          menu_info.unshift({\n            content: \"Delete Reroute\",\n            callback: () => {\n              if (!this.graph) throw new NullGraphError()\n\n              this.graph.removeReroute(reroute.id)\n            },\n          }, null)\n        }\n      }\n\n      const group = this.graph.getGroupOnPos(\n        event.canvasX,\n        event.canvasY,\n      )\n      if (group) {\n        // on group\n        menu_info.push(null, {\n          content: \"Edit Group\",\n          has_submenu: true,\n          submenu: {\n            title: \"Group\",\n            extra: group,\n            options: group.getMenuOptions(),\n          },\n        })\n      }\n    }\n\n    // show menu\n    if (!menu_info) return\n\n    // @ts-expect-error Remove param ref_window - unused\n    new LiteGraph.ContextMenu(menu_info, options, ref_window)\n\n    const createDialog = (options: IDialogOptions) => this.createDialog(\n      \"<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>\",\n      options,\n    )\n    const setDirty = () => this.setDirty(true)\n\n    function inner_option_clicked(v: IContextMenuValue<unknown>, options: IDialogOptions) {\n      if (!v) return\n\n      if (v.content == \"Remove Slot\") {\n        if (!node?.graph) throw new NullGraphError()\n\n        const info = v.slot\n        if (!info) throw new TypeError(\"Found-slot info was null when processing context menu.\")\n\n        node.graph.beforeChange()\n        if (info.input) {\n          node.removeInput(info.slot)\n        } else if (info.output) {\n          node.removeOutput(info.slot)\n        }\n        node.graph.afterChange()\n        return\n      } else if (v.content == \"Disconnect Links\") {\n        if (!node?.graph) throw new NullGraphError()\n\n        const info = v.slot\n        if (!info) throw new TypeError(\"Found-slot info was null when processing context menu.\")\n\n        node.graph.beforeChange()\n        if (info.output) {\n          node.disconnectOutput(info.slot)\n        } else if (info.input) {\n          node.disconnectInput(info.slot, true)\n        }\n        node.graph.afterChange()\n        return\n      } else if (v.content == \"Rename Slot\") {\n        if (!node) throw new TypeError(\"`node` was null when processing the context menu.\")\n\n        const info = v.slot\n        if (!info) throw new TypeError(\"Found-slot info was null when processing context menu.\")\n\n        const slot_info = info.input\n          ? node.getInputInfo(info.slot)\n          : node.getOutputInfo(info.slot)\n        const dialog = createDialog(options)\n\n        const input = dialog.querySelector(\"input\")\n        if (input && slot_info) {\n          input.value = slot_info.label || \"\"\n        }\n        const inner = function () {\n          if (!node.graph) throw new NullGraphError()\n\n          node.graph.beforeChange()\n          if (input?.value) {\n            if (slot_info) {\n              slot_info.label = input.value\n            }\n            setDirty()\n          }\n          dialog.close()\n          node.graph.afterChange()\n        }\n        dialog.querySelector(\"button\")?.addEventListener(\"click\", inner)\n        if (!input) throw new TypeError(\"Input element was null when processing context menu.\")\n\n        input.addEventListener(\"keydown\", function (e) {\n          dialog.is_modified = true\n          if (e.key == \"Escape\") {\n            // ESC\n            dialog.close()\n          } else if (e.key == \"Enter\") {\n            // save\n            inner()\n          } else if ((e.target as Element).localName != \"textarea\") {\n            return\n          }\n          e.preventDefault()\n          e.stopPropagation()\n        })\n        input.focus()\n      }\n    }\n  }\n\n  /**\n   * Starts an animation to fit the view around the specified selection of nodes.\n   * @param bounds The bounds to animate the view to, defined by a rectangle.\n   */\n  animateToBounds(bounds: ReadOnlyRect, options: AnimationOptions = {}) {\n    const setDirty = () => this.setDirty(true, true)\n    this.ds.animateToBounds(bounds, setDirty, options)\n  }\n\n  /**\n   * Fits the view to the selected nodes with animation.\n   * If nothing is selected, the view is fitted around all items in the graph.\n   */\n  fitViewToSelectionAnimated(options: AnimationOptions = {}) {\n    const items = this.selectedItems.size\n      ? Array.from(this.selectedItems)\n      : this.positionableItems\n    const bounds = createBounds(items)\n    if (!bounds) throw new TypeError(\"Attempted to fit to view but could not calculate bounds.\")\n\n    const setDirty = () => this.setDirty(true, true)\n    this.ds.animateToBounds(bounds, setDirty, options)\n  }\n}\n","/**\n * Temporary workaround until downstream consumers migrate to Map.\n * A brittle wrapper with many flaws, but should be fine for simple maps using int indexes.\n */\nexport class MapProxyHandler<V> implements ProxyHandler<Map<number | string, V>> {\n  getOwnPropertyDescriptor(\n    target: Map<number | string, V>,\n    p: string | symbol,\n  ): PropertyDescriptor | undefined {\n    const value = this.get(target, p)\n    if (value) {\n      return {\n        configurable: true,\n        enumerable: true,\n        value,\n      }\n    }\n  }\n\n  has(target: Map<number | string, V>, p: string | symbol): boolean {\n    if (typeof p === \"symbol\") return false\n\n    const int = parseInt(p, 10)\n    return target.has(!isNaN(int) ? int : p)\n  }\n\n  ownKeys(target: Map<number | string, V>): ArrayLike<string | symbol> {\n    return [...target.keys()].map(String)\n  }\n\n  get(target: Map<number | string, V>, p: string | symbol): any {\n    // Workaround does not support link IDs of \"values\", \"entries\", \"constructor\", etc.\n    if (p in target) return Reflect.get(target, p, target)\n    if (typeof p === \"symbol\") return\n\n    const int = parseInt(p, 10)\n    return target.get(!isNaN(int) ? int : p)\n  }\n\n  set(target: Map<number | string, V>, p: string | symbol, newValue: any): boolean {\n    if (typeof p === \"symbol\") return false\n\n    const int = parseInt(p, 10)\n    target.set(!isNaN(int) ? int : p, newValue)\n    return true\n  }\n\n  deleteProperty(target: Map<number | string, V>, p: string | symbol): boolean {\n    return target.delete(p as number | string)\n  }\n\n  static bindAllMethods(map: Map<any, any>): void {\n    map.clear = map.clear.bind(map)\n    map.delete = map.delete.bind(map)\n    map.forEach = map.forEach.bind(map)\n    map.get = map.get.bind(map)\n    map.has = map.has.bind(map)\n    map.set = map.set.bind(map)\n    map.entries = map.entries.bind(map)\n    map.keys = map.keys.bind(map)\n    map.values = map.values.bind(map)\n\n    map[Symbol.iterator] = map[Symbol.iterator].bind(map)\n  }\n}\n","import type { DragAndScaleState } from \"./DragAndScale\"\nimport type {\n  Dictionary,\n  IContextMenuValue,\n  LinkNetwork,\n  LinkSegment,\n  MethodNames,\n  OptionalProps,\n  Point,\n  Positionable,\n} from \"./interfaces\"\nimport type {\n  ISerialisedGraph,\n  Serialisable,\n  SerialisableGraph,\n  SerialisableReroute,\n} from \"./types/serialisation\"\nimport type { UUID } from \"@/utils/uuid\"\n\nimport { createUuidv4, zeroUuid } from \"@/utils/uuid\"\n\nimport { LGraphCanvas } from \"./LGraphCanvas\"\nimport { LGraphGroup } from \"./LGraphGroup\"\nimport { LGraphNode, type NodeId } from \"./LGraphNode\"\nimport { LiteGraph } from \"./litegraph\"\nimport { type LinkId, LLink } from \"./LLink\"\nimport { MapProxyHandler } from \"./MapProxyHandler\"\nimport { Reroute, type RerouteId } from \"./Reroute\"\nimport { stringOrEmpty } from \"./strings\"\nimport { LGraphEventMode } from \"./types/globalEnums\"\nimport { getAllNestedItems } from \"./utils/collections\"\n\nexport interface LGraphState {\n  lastGroupId: number\n  lastNodeId: number\n  lastLinkId: number\n  lastRerouteId: number\n}\n\ntype ParamsArray<T extends Record<any, any>, K extends MethodNames<T>> =\n Parameters<T[K]>[1] extends undefined\n   ? Parameters<T[K]> | Parameters<T[K]>[0]\n   : Parameters<T[K]>\n\n/** Configuration used by {@link LGraph} `config`. */\nexport interface LGraphConfig {\n  /** @deprecated Legacy config - unused */\n  align_to_grid?: any\n  links_ontop?: any\n}\n\nexport interface LGraphExtra extends Dictionary<unknown> {\n  reroutes?: SerialisableReroute[]\n  linkExtensions?: { id: number, parentId: number | undefined }[]\n  ds?: DragAndScaleState\n}\n\nexport interface BaseLGraph {\n  readonly rootGraph: LGraph\n}\n\n/**\n * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.\n * supported callbacks:\n * + onNodeAdded: when a new node is added to the graph\n * + onNodeRemoved: when a node inside this graph is removed\n */\nexport class LGraph implements LinkNetwork, BaseLGraph, Serialisable<SerialisableGraph> {\n  static serialisedSchemaVersion = 1 as const\n\n  static STATUS_STOPPED = 1\n  static STATUS_RUNNING = 2\n\n  id: UUID = zeroUuid\n  revision: number = 0\n\n  _version: number = -1\n  /** The backing store for links.  Keys are wrapped in String() */\n  _links: Map<LinkId, LLink> = new Map()\n  /**\n   * Indexed property access is deprecated.\n   * Backwards compatibility with a Proxy has been added, but will eventually be removed.\n   *\n   * Use {@link Map} methods:\n   * ```\n   * const linkId = 123\n   * const link = graph.links.get(linkId)\n   * // Deprecated: const link = graph.links[linkId]\n   * ```\n   */\n  links: Map<LinkId, LLink> & Record<LinkId, LLink>\n  list_of_graphcanvas: LGraphCanvas[] | null\n  status: number = LGraph.STATUS_STOPPED\n\n  state: LGraphState = {\n    lastGroupId: 0,\n    lastNodeId: 0,\n    lastLinkId: 0,\n    lastRerouteId: 0,\n  }\n\n  _nodes: LGraphNode[] = []\n  _nodes_by_id: Record<NodeId, LGraphNode> = {}\n  _nodes_in_order: LGraphNode[] = []\n  _nodes_executable: LGraphNode[] | null = null\n  _groups: LGraphGroup[] = []\n  iteration: number = 0\n  globaltime: number = 0\n  /** @deprecated Unused */\n  runningtime: number = 0\n  fixedtime: number = 0\n  fixedtime_lapse: number = 0.01\n  elapsed_time: number = 0.01\n  last_update_time: number = 0\n  starttime: number = 0\n  catch_errors: boolean = true\n  execution_timer_id?: number | null\n  errors_in_execution?: boolean\n  /** @deprecated Unused */\n  execution_time!: number\n  _last_trigger_time?: number\n  filter?: string\n  /** Must contain serialisable values, e.g. primitive types */\n  config: LGraphConfig = {}\n  vars: Dictionary<unknown> = {}\n  nodes_executing: boolean[] = []\n  nodes_actioning: (string | boolean)[] = []\n  nodes_executedAction: string[] = []\n  extra: LGraphExtra = {}\n\n  /** @deprecated Deserialising a workflow sets this unused property. */\n  version?: number\n\n  /** @returns Whether the graph has no items */\n  get empty(): boolean {\n    return this._nodes.length + this._groups.length + this.reroutes.size === 0\n  }\n\n  /** @returns All items on the canvas that can be selected */\n  *positionableItems(): Generator<LGraphNode | LGraphGroup | Reroute> {\n    for (const node of this._nodes) yield node\n    for (const group of this._groups) yield group\n    for (const reroute of this.reroutes.values()) yield reroute\n    return\n  }\n\n  /** Internal only.  Not required for serialisation; calculated on deserialise. */\n  #lastFloatingLinkId: number = 0\n\n  #floatingLinks: Map<LinkId, LLink> = new Map()\n  get floatingLinks(): ReadonlyMap<LinkId, LLink> {\n    return this.#floatingLinks\n  }\n\n  #reroutes = new Map<RerouteId, Reroute>()\n  /** All reroutes in this graph. */\n  public get reroutes(): Map<RerouteId, Reroute> {\n    return this.#reroutes\n  }\n\n  get rootGraph(): LGraph {\n    return this\n  }\n\n  get isRootGraph(): boolean {\n    return this.rootGraph === this\n  }\n\n  /** @deprecated See {@link state}.{@link LGraphState.lastNodeId lastNodeId} */\n  get last_node_id() {\n    return this.state.lastNodeId\n  }\n\n  set last_node_id(value) {\n    this.state.lastNodeId = value\n  }\n\n  /** @deprecated See {@link state}.{@link LGraphState.lastLinkId lastLinkId} */\n  get last_link_id() {\n    return this.state.lastLinkId\n  }\n\n  set last_link_id(value) {\n    this.state.lastLinkId = value\n  }\n\n  onAfterStep?(): void\n  onBeforeStep?(): void\n  onPlayEvent?(): void\n  onStopEvent?(): void\n  onAfterExecute?(): void\n  onExecuteStep?(): void\n  onNodeAdded?(node: LGraphNode): void\n  onNodeRemoved?(node: LGraphNode): void\n  onTrigger?(action: string, param: unknown): void\n  onBeforeChange?(graph: LGraph, info?: LGraphNode): void\n  onAfterChange?(graph: LGraph, info?: LGraphNode | null): void\n  onConnectionChange?(node: LGraphNode): void\n  on_change?(graph: LGraph): void\n  onSerialize?(data: ISerialisedGraph | SerialisableGraph): void\n  onConfigure?(data: ISerialisedGraph | SerialisableGraph): void\n  onGetNodeMenuOptions?(options: (IContextMenuValue<unknown> | null)[], node: LGraphNode): void\n\n  private _input_nodes?: LGraphNode[]\n\n  /**\n   * See {@link LGraph}\n   * @param o data from previous serialization [optional]\n   */\n  constructor(o?: ISerialisedGraph | SerialisableGraph) {\n    if (LiteGraph.debug) console.log(\"Graph created\")\n\n    /** @see MapProxyHandler */\n    const links = this._links\n    MapProxyHandler.bindAllMethods(links)\n    const handler = new MapProxyHandler<LLink>()\n    this.links = new Proxy(links, handler) as Map<LinkId, LLink> & Record<LinkId, LLink>\n\n    this.list_of_graphcanvas = null\n    this.clear()\n\n    if (o) this.configure(o)\n  }\n\n  /**\n   * Removes all nodes from this graph\n   */\n  clear(): void {\n    this.stop()\n    this.status = LGraph.STATUS_STOPPED\n\n    this.id = zeroUuid\n    this.revision = 0\n\n    this.state = {\n      lastGroupId: 0,\n      lastNodeId: 0,\n      lastLinkId: 0,\n      lastRerouteId: 0,\n    }\n\n    // used to detect changes\n    this._version = -1\n\n    // safe clear\n    if (this._nodes) {\n      for (const _node of this._nodes) {\n        _node.onRemoved?.()\n      }\n    }\n\n    // nodes\n    this._nodes = []\n    this._nodes_by_id = {}\n    // nodes sorted in execution order\n    this._nodes_in_order = []\n    // nodes that contain onExecute sorted in execution order\n    this._nodes_executable = null\n\n    this._links.clear()\n    this.reroutes.clear()\n    this.#floatingLinks.clear()\n\n    this.#lastFloatingLinkId = 0\n\n    // other scene stuff\n    this._groups = []\n\n    // iterations\n    this.iteration = 0\n\n    // custom data\n    this.config = {}\n    this.vars = {}\n    // to store custom data\n    this.extra = {}\n\n    // timing\n    this.globaltime = 0\n    this.runningtime = 0\n    this.fixedtime = 0\n    this.fixedtime_lapse = 0.01\n    this.elapsed_time = 0.01\n    this.last_update_time = 0\n    this.starttime = 0\n\n    this.catch_errors = true\n\n    this.nodes_executing = []\n    this.nodes_actioning = []\n    this.nodes_executedAction = []\n\n    // notify canvas to redraw\n    this.change()\n\n    this.canvasAction(c => c.clear())\n  }\n\n  get nodes() {\n    return this._nodes\n  }\n\n  get groups() {\n    return this._groups\n  }\n\n  /**\n   * Attach Canvas to this graph\n   */\n  attachCanvas(canvas: LGraphCanvas): void {\n    if (!(canvas instanceof LGraphCanvas)) {\n      throw new TypeError(\"attachCanvas expects an LGraphCanvas instance\")\n    }\n\n    this.list_of_graphcanvas ??= []\n    if (!this.list_of_graphcanvas.includes(canvas)) {\n      this.list_of_graphcanvas.push(canvas)\n    }\n\n    if (canvas.graph === this) return\n\n    canvas.graph?.detachCanvas(canvas)\n    canvas.graph = this\n  }\n\n  /**\n   * Detach Canvas from this graph\n   */\n  detachCanvas(canvas: LGraphCanvas): void {\n    canvas.graph = null\n    const canvases = this.list_of_graphcanvas\n    if (canvases) {\n      const pos = canvases.indexOf(canvas)\n      if (pos !== -1) canvases.splice(pos, 1)\n    }\n  }\n\n  /**\n   * @deprecated Will be removed in 0.9\n   * Starts running this graph every interval milliseconds.\n   * @param interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate\n   */\n  start(interval?: number): void {\n    if (this.status == LGraph.STATUS_RUNNING) return\n    this.status = LGraph.STATUS_RUNNING\n\n    this.onPlayEvent?.()\n    this.sendEventToAllNodes(\"onStart\")\n\n    // launch\n    this.starttime = LiteGraph.getTime()\n    this.last_update_time = this.starttime\n    interval ||= 0\n\n    // execute once per frame\n    if (\n      interval == 0 &&\n      typeof window != \"undefined\" &&\n      window.requestAnimationFrame\n    ) {\n      const on_frame = () => {\n        if (this.execution_timer_id != -1) return\n\n        window.requestAnimationFrame(on_frame)\n        this.onBeforeStep?.()\n        this.runStep(1, !this.catch_errors)\n        this.onAfterStep?.()\n      }\n      this.execution_timer_id = -1\n      on_frame()\n    } else {\n      // execute every 'interval' ms\n      this.execution_timer_id = setInterval(() => {\n        // execute\n        this.onBeforeStep?.()\n        this.runStep(1, !this.catch_errors)\n        this.onAfterStep?.()\n      }, interval)\n    }\n  }\n\n  /**\n   * @deprecated Will be removed in 0.9\n   * Stops the execution loop of the graph\n   */\n  stop(): void {\n    if (this.status == LGraph.STATUS_STOPPED) return\n\n    this.status = LGraph.STATUS_STOPPED\n\n    this.onStopEvent?.()\n\n    if (this.execution_timer_id != null) {\n      if (this.execution_timer_id != -1) {\n        clearInterval(this.execution_timer_id)\n      }\n      this.execution_timer_id = null\n    }\n\n    this.sendEventToAllNodes(\"onStop\")\n  }\n\n  /**\n   * Run N steps (cycles) of the graph\n   * @param num number of steps to run, default is 1\n   * @param do_not_catch_errors [optional] if you want to try/catch errors\n   * @param limit max number of nodes to execute (used to execute from start to a node)\n   */\n  runStep(num: number, do_not_catch_errors: boolean, limit?: number): void {\n    num = num || 1\n\n    const start = LiteGraph.getTime()\n    this.globaltime = 0.001 * (start - this.starttime)\n\n    const nodes = this._nodes_executable || this._nodes\n    if (!nodes) return\n\n    limit = limit || nodes.length\n\n    if (do_not_catch_errors) {\n      // iterations\n      for (let i = 0; i < num; i++) {\n        for (let j = 0; j < limit; ++j) {\n          const node = nodes[j]\n          // FIXME: Looks like copy/paste broken logic - checks for \"on\", executes \"do\"\n          if (node.mode == LGraphEventMode.ALWAYS && node.onExecute) {\n            // wrap node.onExecute();\n            node.doExecute?.()\n          }\n        }\n\n        this.fixedtime += this.fixedtime_lapse\n        this.onExecuteStep?.()\n      }\n\n      this.onAfterExecute?.()\n    } else {\n      try {\n        // iterations\n        for (let i = 0; i < num; i++) {\n          for (let j = 0; j < limit; ++j) {\n            const node = nodes[j]\n            if (node.mode == LGraphEventMode.ALWAYS) {\n              node.onExecute?.()\n            }\n          }\n\n          this.fixedtime += this.fixedtime_lapse\n          this.onExecuteStep?.()\n        }\n\n        this.onAfterExecute?.()\n        this.errors_in_execution = false\n      } catch (error) {\n        this.errors_in_execution = true\n        if (LiteGraph.throw_errors) throw error\n\n        if (LiteGraph.debug) console.log(\"Error during execution:\", error)\n        this.stop()\n      }\n    }\n\n    const now = LiteGraph.getTime()\n    let elapsed = now - start\n    if (elapsed == 0) elapsed = 1\n\n    this.execution_time = 0.001 * elapsed\n    this.globaltime += 0.001 * elapsed\n    this.iteration += 1\n    this.elapsed_time = (now - this.last_update_time) * 0.001\n    this.last_update_time = now\n    this.nodes_executing = []\n    this.nodes_actioning = []\n    this.nodes_executedAction = []\n  }\n\n  /**\n   * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than\n   * nodes with only inputs.\n   */\n  updateExecutionOrder(): void {\n    this._nodes_in_order = this.computeExecutionOrder(false)\n    this._nodes_executable = []\n    for (const node of this._nodes_in_order) {\n      if (node.onExecute) {\n        this._nodes_executable.push(node)\n      }\n    }\n  }\n\n  // This is more internal, it computes the executable nodes in order and returns it\n  computeExecutionOrder(\n    only_onExecute: boolean,\n    set_level?: boolean,\n  ): LGraphNode[] {\n    const L: LGraphNode[] = []\n    const S: LGraphNode[] = []\n    const M: Dictionary<LGraphNode> = {}\n    // to avoid repeating links\n    const visited_links: Record<NodeId, boolean> = {}\n    const remaining_links: Record<NodeId, number> = {}\n\n    // search for the nodes without inputs (starting nodes)\n    for (const node of this._nodes) {\n      if (only_onExecute && !node.onExecute) {\n        continue\n      }\n\n      // add to pending nodes\n      M[node.id] = node\n\n      // num of input connections\n      let num = 0\n      if (node.inputs) {\n        for (const input of node.inputs) {\n          if (input?.link != null) {\n            num += 1\n          }\n        }\n      }\n\n      if (num == 0) {\n        // is a starting node\n        S.push(node)\n        if (set_level) node._level = 1\n      } else {\n        // num of input links\n        if (set_level) node._level = 0\n        remaining_links[node.id] = num\n      }\n    }\n\n    while (true) {\n      // get an starting node\n      const node = S.shift()\n      if (node === undefined) break\n\n      // add to ordered list\n      L.push(node)\n      // remove from the pending nodes\n      delete M[node.id]\n\n      if (!node.outputs) continue\n\n      // for every output\n      for (const output of node.outputs) {\n        // not connected\n        // TODO: Confirm functionality, clean condition\n        if (output?.links == null || output.links.length == 0)\n          continue\n\n        // for every connection\n        for (const link_id of output.links) {\n          const link = this._links.get(link_id)\n          if (!link) continue\n\n          // already visited link (ignore it)\n          if (visited_links[link.id]) continue\n\n          const target_node = this.getNodeById(link.target_id)\n          if (target_node == null) {\n            visited_links[link.id] = true\n            continue\n          }\n\n          if (set_level) {\n            node._level ??= 0\n            if (!target_node._level || target_node._level <= node._level) {\n              target_node._level = node._level + 1\n            }\n          }\n\n          // mark as visited\n          visited_links[link.id] = true\n          // reduce the number of links remaining\n          remaining_links[target_node.id] -= 1\n\n          // if no more links, then add to starters array\n          if (remaining_links[target_node.id] == 0) S.push(target_node)\n        }\n      }\n    }\n\n    // the remaining ones (loops)\n    for (const i in M) {\n      L.push(M[i])\n    }\n\n    if (L.length != this._nodes.length && LiteGraph.debug)\n      console.warn(\"something went wrong, nodes missing\")\n\n    /** Ensure type is set */\n    type OrderedLGraphNode = LGraphNode & { order: number }\n\n    /** Sets the order property of each provided node to its index in {@link nodes}. */\n    function setOrder(nodes: LGraphNode[]): asserts nodes is OrderedLGraphNode[] {\n      const l = nodes.length\n      for (let i = 0; i < l; ++i) {\n        nodes[i].order = i\n      }\n    }\n\n    // save order number in the node\n    setOrder(L)\n\n    // sort now by priority\n    L.sort(function (A, B) {\n      // @ts-expect-error ctor props\n      const Ap = A.constructor.priority || A.priority || 0\n      // @ts-expect-error ctor props\n      const Bp = B.constructor.priority || B.priority || 0\n      // if same priority, sort by order\n\n      return Ap == Bp\n        ? A.order - B.order\n        : Ap - Bp\n    })\n\n    // save order number in the node, again...\n    setOrder(L)\n\n    return L\n  }\n\n  /**\n   * Positions every node in a more readable manner\n   */\n  arrange(margin?: number, layout?: string): void {\n    margin = margin || 100\n\n    const nodes = this.computeExecutionOrder(false, true)\n    const columns: LGraphNode[][] = []\n    for (const node of nodes) {\n      const col = node._level || 1\n      columns[col] ||= []\n      columns[col].push(node)\n    }\n\n    let x = margin\n\n    for (const column of columns) {\n      if (!column) continue\n\n      let max_size = 100\n      let y = margin + LiteGraph.NODE_TITLE_HEIGHT\n      for (const node of column) {\n        node.pos[0] = layout == LiteGraph.VERTICAL_LAYOUT ? y : x\n        node.pos[1] = layout == LiteGraph.VERTICAL_LAYOUT ? x : y\n        const max_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 1 : 0\n        if (node.size[max_size_index] > max_size) {\n          max_size = node.size[max_size_index]\n        }\n        const node_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 0 : 1\n        y += node.size[node_size_index] + margin + LiteGraph.NODE_TITLE_HEIGHT\n      }\n      x += max_size + margin\n    }\n\n    this.setDirtyCanvas(true, true)\n  }\n\n  /**\n   * Returns the amount of time the graph has been running in milliseconds\n   * @returns number of milliseconds the graph has been running\n   */\n  getTime(): number {\n    return this.globaltime\n  }\n\n  /**\n   * Returns the amount of time accumulated using the fixedtime_lapse var.\n   * This is used in context where the time increments should be constant\n   * @returns number of milliseconds the graph has been running\n   */\n  getFixedTime(): number {\n    return this.fixedtime\n  }\n\n  /**\n   * Returns the amount of time it took to compute the latest iteration.\n   * Take into account that this number could be not correct\n   * if the nodes are using graphical actions\n   * @returns number of milliseconds it took the last cycle\n   */\n  getElapsedTime(): number {\n    return this.elapsed_time\n  }\n\n  /**\n   * @deprecated Will be removed in 0.9\n   * Sends an event to all the nodes, useful to trigger stuff\n   * @param eventname the name of the event (function to be called)\n   * @param params parameters in array format\n   */\n  sendEventToAllNodes(\n    eventname: string,\n    params?: object | object[],\n    mode?: LGraphEventMode,\n  ): void {\n    mode = mode || LGraphEventMode.ALWAYS\n\n    const nodes = this._nodes_in_order || this._nodes\n    if (!nodes) return\n\n    for (const node of nodes) {\n      // @ts-expect-error deprecated\n      if (!node[eventname] || node.mode != mode) continue\n      if (params === undefined) {\n        // @ts-expect-error deprecated\n        node[eventname]()\n      } else if (params && params.constructor === Array) {\n        // @ts-expect-error deprecated\n        node[eventname].apply(node, params)\n      } else {\n        // @ts-expect-error deprecated\n        node[eventname](params)\n      }\n    }\n  }\n\n  /**\n   * Runs an action on every canvas registered to this graph.\n   * @param action Action to run for every canvas\n   */\n  canvasAction(action: (canvas: LGraphCanvas) => void): void {\n    const canvases = this.list_of_graphcanvas\n    if (!canvases) return\n    for (const canvas of canvases) action(canvas)\n  }\n\n  /** @deprecated See {@link LGraph.canvasAction} */\n  sendActionToCanvas<T extends MethodNames<LGraphCanvas>>(\n    action: T,\n    params?: ParamsArray<LGraphCanvas, T>,\n  ): void {\n    const { list_of_graphcanvas } = this\n    if (!list_of_graphcanvas) return\n\n    for (const c of list_of_graphcanvas) {\n      c[action]?.apply(c, params)\n    }\n  }\n\n  /**\n   * Adds a new node instance to this graph\n   * @param node the instance of the node\n   */\n  add(\n    node: LGraphNode | LGraphGroup,\n    skip_compute_order?: boolean,\n  ): LGraphNode | null | undefined {\n    if (!node) return\n    const { state } = this\n\n    // Ensure created items are snapped\n    if (LiteGraph.alwaysSnapToGrid) {\n      const snapTo = this.getSnapToGridSize()\n      if (snapTo) node.snapToGrid(snapTo)\n    }\n\n    // LEGACY: This was changed from constructor === LGraphGroup\n    // groups\n    if (node instanceof LGraphGroup) {\n      // Assign group ID\n      if (node.id == null || node.id === -1) node.id = ++state.lastGroupId\n      if (node.id > state.lastGroupId) state.lastGroupId = node.id\n\n      this._groups.push(node)\n      this.setDirtyCanvas(true)\n      this.change()\n      node.graph = this\n      this._version++\n      return\n    }\n\n    // nodes\n    if (node.id != -1 && this._nodes_by_id[node.id] != null) {\n      console.warn(\n        \"LiteGraph: there is already a node with this ID, changing it\",\n      )\n      node.id = LiteGraph.use_uuids\n        ? LiteGraph.uuidv4()\n        : ++state.lastNodeId\n    }\n\n    if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {\n      throw \"LiteGraph: max number of nodes in a graph reached\"\n    }\n\n    // give him an id\n    if (LiteGraph.use_uuids) {\n      if (node.id == null || node.id == -1)\n        node.id = LiteGraph.uuidv4()\n    } else {\n      if (node.id == null || node.id == -1) {\n        node.id = ++state.lastNodeId\n      } else if (typeof node.id === \"number\" && state.lastNodeId < node.id) {\n        state.lastNodeId = node.id\n      }\n    }\n\n    node.graph = this\n    this._version++\n\n    this._nodes.push(node)\n    this._nodes_by_id[node.id] = node\n\n    node.onAdded?.(this)\n\n    if (this.config.align_to_grid) node.alignToGrid()\n\n    if (!skip_compute_order) this.updateExecutionOrder()\n\n    this.onNodeAdded?.(node)\n\n    this.setDirtyCanvas(true)\n    this.change()\n\n    // to chain actions\n    return node\n  }\n\n  /**\n   * Removes a node from the graph\n   * @param node the instance of the node\n   */\n  remove(node: LGraphNode | LGraphGroup): void {\n    // LEGACY: This was changed from constructor === LiteGraph.LGraphGroup\n    if (node instanceof LGraphGroup) {\n      this.canvasAction(c => c.deselect(node))\n\n      const index = this._groups.indexOf(node)\n      if (index != -1) {\n        this._groups.splice(index, 1)\n      }\n      node.graph = undefined\n      this._version++\n      this.setDirtyCanvas(true, true)\n      this.change()\n      return\n    }\n\n    // not found\n    if (this._nodes_by_id[node.id] == null) {\n      console.warn(\"LiteGraph: node not found\", node)\n      return\n    }\n    // cannot be removed\n    if (node.ignore_remove) {\n      console.warn(\"LiteGraph: node cannot be removed\", node)\n      return\n    }\n\n    // sure? - almost sure is wrong\n    this.beforeChange()\n\n    const { inputs, outputs } = node\n\n    // disconnect inputs\n    if (inputs) {\n      for (const [i, slot] of inputs.entries()) {\n        if (slot.link != null) node.disconnectInput(i, true)\n      }\n    }\n\n    // disconnect outputs\n    if (outputs) {\n      for (const [i, slot] of outputs.entries()) {\n        if (slot.links?.length) node.disconnectOutput(i)\n      }\n    }\n\n    // Floating links\n    for (const link of this.floatingLinks.values()) {\n      if (link.origin_id === node.id || link.target_id === node.id) {\n        this.removeFloatingLink(link)\n      }\n    }\n\n    // callback\n    node.onRemoved?.()\n\n    node.graph = null\n    this._version++\n\n    // remove from canvas render\n    const { list_of_graphcanvas } = this\n    if (list_of_graphcanvas) {\n      for (const canvas of list_of_graphcanvas) {\n        if (canvas.selected_nodes[node.id])\n          delete canvas.selected_nodes[node.id]\n\n        canvas.deselect(node)\n      }\n    }\n\n    // remove from containers\n    const pos = this._nodes.indexOf(node)\n    if (pos != -1) this._nodes.splice(pos, 1)\n\n    delete this._nodes_by_id[node.id]\n\n    this.onNodeRemoved?.(node)\n\n    // close panels\n    this.canvasAction(c => c.checkPanels())\n\n    this.setDirtyCanvas(true, true)\n    // sure? - almost sure is wrong\n    this.afterChange()\n    this.change()\n\n    this.updateExecutionOrder()\n  }\n\n  /**\n   * Returns a node by its id.\n   */\n  getNodeById(id: NodeId | null | undefined): LGraphNode | null {\n    return id != null\n      ? this._nodes_by_id[id]\n      : null\n  }\n\n  /**\n   * Returns a list of nodes that matches a class\n   * @param classObject the class itself (not an string)\n   * @returns a list with all the nodes of this type\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  findNodesByClass(classObject: Function, result?: LGraphNode[]): LGraphNode[] {\n    result = result || []\n    result.length = 0\n    const { _nodes } = this\n    for (const node of _nodes) {\n      if (node.constructor === classObject)\n        result.push(node)\n    }\n    return result\n  }\n\n  /**\n   * Returns a list of nodes that matches a type\n   * @param type the name of the node type\n   * @returns a list with all the nodes of this type\n   */\n  findNodesByType(type: string, result: LGraphNode[]): LGraphNode[] {\n    const matchType = type.toLowerCase()\n    result = result || []\n    result.length = 0\n    const { _nodes } = this\n    for (const node of _nodes) {\n      if (node.type?.toLowerCase() == matchType)\n        result.push(node)\n    }\n    return result\n  }\n\n  /**\n   * Returns the first node that matches a name in its title\n   * @param title the name of the node to search\n   * @returns the node or null\n   */\n  findNodeByTitle(title: string): LGraphNode | null {\n    const { _nodes } = this\n    for (const node of _nodes) {\n      if (node.title == title)\n        return node\n    }\n    return null\n  }\n\n  /**\n   * Returns a list of nodes that matches a name\n   * @param title the name of the node to search\n   * @returns a list with all the nodes with this name\n   */\n  findNodesByTitle(title: string): LGraphNode[] {\n    const result: LGraphNode[] = []\n    const { _nodes } = this\n    for (const node of _nodes) {\n      if (node.title == title)\n        result.push(node)\n    }\n    return result\n  }\n\n  /**\n   * Returns the top-most node in this position of the canvas\n   * @param x the x coordinate in canvas space\n   * @param y the y coordinate in canvas space\n   * @param nodeList a list with all the nodes to search from, by default is all the nodes in the graph\n   * @returns the node at this position or null\n   */\n  getNodeOnPos(\n    x: number,\n    y: number,\n    nodeList?: LGraphNode[],\n  ): LGraphNode | null {\n    const nodes = nodeList || this._nodes\n    let i = nodes.length\n    while (--i >= 0) {\n      const node = nodes[i]\n      if (node.isPointInside(x, y)) return node\n    }\n    return null\n  }\n\n  /**\n   * Returns the top-most group in that position\n   * @param x The x coordinate in canvas space\n   * @param y The y coordinate in canvas space\n   * @returns The group or null\n   */\n  getGroupOnPos(x: number, y: number): LGraphGroup | undefined {\n    return this._groups.toReversed().find(g => g.isPointInside(x, y))\n  }\n\n  /**\n   * Returns the top-most group with a titlebar in the provided position.\n   * @param x The x coordinate in canvas space\n   * @param y The y coordinate in canvas space\n   * @returns The group or null\n   */\n  getGroupTitlebarOnPos(x: number, y: number): LGraphGroup | undefined {\n    return this._groups.toReversed().find(g => g.isPointInTitlebar(x, y))\n  }\n\n  /**\n   * Finds a reroute a the given graph point\n   * @param x X co-ordinate in graph space\n   * @param y Y co-ordinate in graph space\n   * @returns The first reroute under the given co-ordinates, or undefined\n   */\n  getRerouteOnPos(x: number, y: number, reroutes?: Iterable<Reroute>): Reroute | undefined {\n    for (const reroute of reroutes ?? this.reroutes.values()) {\n      if (reroute.containsPoint([x, y])) return reroute\n    }\n  }\n\n  /**\n   * Snaps the provided items to a grid.\n   *\n   * Item positions are reounded to the nearest multiple of {@link LiteGraph.CANVAS_GRID_SIZE}.\n   *\n   * When {@link LiteGraph.alwaysSnapToGrid} is enabled\n   * and the grid size is falsy, a default of 1 is used.\n   * @param items The items to be snapped to the grid\n   * @todo Currently only snaps nodes.\n   */\n  snapToGrid(items: Set<Positionable>): void {\n    const snapTo = this.getSnapToGridSize()\n    if (!snapTo) return\n\n    for (const item of getAllNestedItems(items)) {\n      if (!item.pinned) item.snapToGrid(snapTo)\n    }\n  }\n\n  /**\n   * Finds the size of the grid that items should be snapped to when moved.\n   * @returns The size of the grid that items should be snapped to\n   */\n  getSnapToGridSize(): number {\n    // Default to 1 when always snapping\n    return LiteGraph.alwaysSnapToGrid\n      ? LiteGraph.CANVAS_GRID_SIZE || 1\n      : LiteGraph.CANVAS_GRID_SIZE\n  }\n\n  /**\n   * @deprecated Will be removed in 0.9\n   * Checks that the node type matches the node type registered,\n   * used when replacing a nodetype by a newer version during execution\n   * this replaces the ones using the old version with the new version\n   */\n  checkNodeTypes() {\n    const { _nodes } = this\n    for (const [i, node] of _nodes.entries()) {\n      const ctor = LiteGraph.registered_node_types[node.type]\n      if (node.constructor == ctor) continue\n\n      console.log(\"node being replaced by newer version:\", node.type)\n      const newnode = LiteGraph.createNode(node.type)\n      if (!newnode) continue\n      _nodes[i] = newnode\n      newnode.configure(node.serialize())\n      newnode.graph = this\n      this._nodes_by_id[newnode.id] = newnode\n\n      if (node.inputs) newnode.inputs = [...node.inputs]\n      if (node.outputs) newnode.outputs = [...node.outputs]\n    }\n    this.updateExecutionOrder()\n  }\n\n  // ********** GLOBALS *****************\n  trigger(action: string, param: unknown) {\n    this.onTrigger?.(action, param)\n  }\n\n  /** @todo Clean up - never implemented. */\n  triggerInput(name: string, value: any): void {\n    const nodes = this.findNodesByTitle(name)\n    for (const node of nodes) {\n      // @ts-expect-error\n      node.onTrigger(value)\n    }\n  }\n\n  /** @todo Clean up - never implemented. */\n  setCallback(name: string, func: any): void {\n    const nodes = this.findNodesByTitle(name)\n    for (const node of nodes) {\n      // @ts-expect-error\n      node.setTrigger(func)\n    }\n  }\n\n  // used for undo, called before any change is made to the graph\n  beforeChange(info?: LGraphNode): void {\n    this.onBeforeChange?.(this, info)\n    this.canvasAction(c => c.onBeforeChange?.(this))\n  }\n\n  // used to resend actions, called after any change is made to the graph\n  afterChange(info?: LGraphNode | null): void {\n    this.onAfterChange?.(this, info)\n    this.canvasAction(c => c.onAfterChange?.(this))\n  }\n\n  connectionChange(node: LGraphNode): void {\n    this.updateExecutionOrder()\n    this.onConnectionChange?.(node)\n    this._version++\n    // TODO: Interface never implemented - any consumers?\n    // @ts-expect-error\n    this.canvasAction(c => c.onConnectionChange?.())\n  }\n\n  /**\n   * clears the triggered slot animation in all links (stop visual animation)\n   */\n  clearTriggeredSlots(): void {\n    for (const link_info of this._links.values()) {\n      if (!link_info) continue\n\n      if (link_info._last_time) link_info._last_time = 0\n    }\n  }\n\n  /* Called when something visually changed (not the graph!) */\n  change(): void {\n    if (LiteGraph.debug) {\n      console.log(\"Graph changed\")\n    }\n    this.canvasAction(c => c.setDirty(true, true))\n    this.on_change?.(this)\n  }\n\n  setDirtyCanvas(fg: boolean, bg?: boolean): void {\n    this.canvasAction(c => c.setDirty(fg, bg))\n  }\n\n  addFloatingLink(link: LLink): LLink {\n    if (link.id === -1) {\n      link.id = ++this.#lastFloatingLinkId\n    }\n    this.#floatingLinks.set(link.id, link)\n\n    const slot = link.target_id !== -1\n      ? this.getNodeById(link.target_id)?.inputs?.[link.target_slot]\n      : this.getNodeById(link.origin_id)?.outputs?.[link.origin_slot]\n    if (slot) {\n      slot._floatingLinks ??= new Set()\n      slot._floatingLinks.add(link)\n    } else {\n      console.warn(`Adding invalid floating link: target/slot: [${link.target_id}/${link.target_slot}] origin/slot: [${link.origin_id}/${link.origin_slot}]`)\n    }\n\n    const reroutes = LLink.getReroutes(this, link)\n    for (const reroute of reroutes) {\n      reroute.floatingLinkIds.add(link.id)\n    }\n    return link\n  }\n\n  removeFloatingLink(link: LLink): void {\n    this.#floatingLinks.delete(link.id)\n\n    const slot = link.target_id !== -1\n      ? this.getNodeById(link.target_id)?.inputs?.[link.target_slot]\n      : this.getNodeById(link.origin_id)?.outputs?.[link.origin_slot]\n    if (slot) {\n      slot._floatingLinks?.delete(link)\n    }\n\n    const reroutes = LLink.getReroutes(this, link)\n    for (const reroute of reroutes) {\n      reroute.floatingLinkIds.delete(link.id)\n      if (reroute.floatingLinkIds.size === 0) {\n        delete reroute.floating\n      }\n\n      if (reroute.totalLinks === 0) this.removeReroute(reroute.id)\n    }\n  }\n\n  /**\n   * Finds the link with the provided ID.\n   * @param id ID of link to find\n   * @returns The link with the provided {@link id}, otherwise `undefined`. Always returns `undefined` if `id` is nullish.\n   */\n  getLink(id: null | undefined): undefined\n  getLink(id: LinkId | null | undefined): LLink | undefined\n  getLink(id: LinkId | null | undefined): LLink | undefined {\n    return id == null ? undefined : this._links.get(id)\n  }\n\n  /**\n   * Finds the reroute with the provided ID.\n   * @param id ID of reroute to find\n   * @returns The reroute with the provided {@link id}, otherwise `undefined`. Always returns `undefined` if `id` is nullish.\n   */\n  getReroute(id: null | undefined): undefined\n  getReroute(id: RerouteId | null | undefined): Reroute | undefined\n  getReroute(id: RerouteId | null | undefined): Reroute | undefined {\n    return id == null ? undefined : this.reroutes.get(id)\n  }\n\n  /**\n   * Configures a reroute on the graph where ID is already known (probably deserialisation).\n   * Creates the object if it does not exist.\n   * @param serialisedReroute See {@link SerialisableReroute}\n   */\n  setReroute({ id, parentId, pos, linkIds, floating }: OptionalProps<SerialisableReroute, \"id\">): Reroute {\n    id ??= ++this.state.lastRerouteId\n    if (id > this.state.lastRerouteId) this.state.lastRerouteId = id\n\n    const reroute = this.reroutes.get(id) ?? new Reroute(id, this)\n    reroute.update(parentId, pos, linkIds, floating)\n    this.reroutes.set(id, reroute)\n    return reroute\n  }\n\n  /**\n   * Creates a new reroute and adds it to the graph.\n   * @param pos Position in graph space\n   * @param before The existing link segment (reroute, link) that will be after this reroute,\n   * going from the node output to input.\n   * @returns The newly created reroute - typically ignored.\n   */\n  createReroute(pos: Point, before: LinkSegment): Reroute {\n    const rerouteId = ++this.state.lastRerouteId\n    const linkIds = before instanceof Reroute\n      ? before.linkIds\n      : [before.id]\n    const floatingLinkIds = before instanceof Reroute\n      ? before.floatingLinkIds\n      : [before.id]\n    const reroute = new Reroute(rerouteId, this, pos, before.parentId, linkIds, floatingLinkIds)\n    this.reroutes.set(rerouteId, reroute)\n    for (const linkId of linkIds) {\n      const link = this._links.get(linkId)\n      if (!link) continue\n      if (link.parentId === before.parentId) link.parentId = rerouteId\n\n      const reroutes = LLink.getReroutes(this, link)\n      for (const x of reroutes.filter(x => x.parentId === before.parentId)) {\n        x.parentId = rerouteId\n      }\n    }\n\n    for (const linkId of floatingLinkIds) {\n      const link = this.floatingLinks.get(linkId)\n      if (!link) continue\n      if (link.parentId === before.parentId) link.parentId = rerouteId\n\n      const reroutes = LLink.getReroutes(this, link)\n      for (const x of reroutes.filter(x => x.parentId === before.parentId)) {\n        x.parentId = rerouteId\n      }\n    }\n\n    return reroute\n  }\n\n  /**\n   * Removes a reroute from the graph\n   * @param id ID of reroute to remove\n   */\n  removeReroute(id: RerouteId): void {\n    const { reroutes } = this\n    const reroute = reroutes.get(id)\n    if (!reroute) return\n\n    this.canvasAction(c => c.deselect(reroute))\n\n    // Extract reroute from the reroute chain\n    const { parentId, linkIds, floatingLinkIds } = reroute\n    for (const reroute of reroutes.values()) {\n      if (reroute.parentId === id) reroute.parentId = parentId\n    }\n\n    for (const linkId of linkIds) {\n      const link = this._links.get(linkId)\n      if (link && link.parentId === id) link.parentId = parentId\n    }\n\n    for (const linkId of floatingLinkIds) {\n      const link = this.floatingLinks.get(linkId)\n      if (!link) {\n        console.warn(`Removed reroute had floating link ID that did not exist [${linkId}]`)\n        continue\n      }\n\n      // A floating link is a unique branch; if there is no parent reroute, or\n      // the parent reroute has any other links, remove this floating link.\n      const floatingReroutes = LLink.getReroutes(this, link)\n      const lastReroute = floatingReroutes.at(-1)\n      const secondLastReroute = floatingReroutes.at(-2)\n\n      if (reroute !== lastReroute) {\n        continue\n      } else if (secondLastReroute?.totalLinks !== 1) {\n        this.removeFloatingLink(link)\n      } else if (link.parentId === id) {\n        link.parentId = parentId\n        secondLastReroute.floating = reroute.floating\n      }\n    }\n\n    reroutes.delete(id)\n    // This does not belong here; it should be handled by the caller, or run by a remove-many API.\n    // https://github.com/Comfy-Org/litegraph.js/issues/898\n    this.setDirtyCanvas(false, true)\n  }\n\n  /**\n   * Destroys a link\n   */\n  removeLink(link_id: LinkId): void {\n    const link = this._links.get(link_id)\n    if (!link) return\n\n    const node = this.getNodeById(link.target_id)\n    node?.disconnectInput(link.target_slot, false)\n\n    link.disconnect(this)\n  }\n\n  /**\n   * Creates a Object containing all the info about this graph, it can be serialized\n   * @deprecated Use {@link asSerialisable}, which returns the newer schema version.\n   * @returns value of the node\n   */\n  serialize(option?: { sortNodes: boolean }): ISerialisedGraph {\n    const { config, state, groups, nodes, reroutes, extra, floatingLinks } = this.asSerialisable(option)\n    const linkArray = [...this._links.values()]\n    const links = linkArray.map(x => x.serialize())\n\n    if (reroutes?.length) {\n      // Link parent IDs cannot go in 0.4 schema arrays\n      extra.linkExtensions = linkArray\n        .filter(x => x.parentId !== undefined)\n        .map(x => ({ id: x.id, parentId: x.parentId }))\n    }\n\n    extra.reroutes = reroutes?.length ? reroutes : undefined\n    return {\n      id: this.id,\n      revision: this.revision,\n      last_node_id: state.lastNodeId,\n      last_link_id: state.lastLinkId,\n      nodes,\n      links,\n      floatingLinks,\n      groups,\n      config,\n      extra,\n      version: LiteGraph.VERSION,\n    }\n  }\n\n  /** @returns The drag and scale state of the first attached canvas, otherwise `undefined`. */\n  #getDragAndScale(): DragAndScaleState | undefined {\n    const ds = this.list_of_graphcanvas?.at(0)?.ds\n    if (ds) return { scale: ds.scale, offset: ds.offset }\n  }\n\n  /**\n   * Prepares a shallow copy of this object for immediate serialisation or structuredCloning.\n   * The return value should be discarded immediately.\n   * @param options Serialise options = currently `sortNodes: boolean`, whether to sort nodes by ID.\n   * @returns A shallow copy of parts of this graph, with shallow copies of its serialisable objects.\n   * Mutating the properties of the return object may result in changes to your graph.\n   * It is intended for use with {@link structuredClone} or {@link JSON.stringify}.\n   */\n  asSerialisable(options?: { sortNodes: boolean }): SerialisableGraph & Required<Pick<SerialisableGraph, \"nodes\" | \"groups\" | \"extra\">> {\n    const { id, revision, config, state } = this\n\n    const nodeList = !LiteGraph.use_uuids && options?.sortNodes\n      // @ts-expect-error If LiteGraph.use_uuids is false, ids are numbers.\n      ? [...this._nodes].sort((a, b) => a.id - b.id)\n      : this._nodes\n\n    const nodes = nodeList.map(node => node.serialize())\n    const groups = this._groups.map(x => x.serialize())\n\n    const links = this._links.size ? [...this._links.values()].map(x => x.asSerialisable()) : undefined\n    const floatingLinks = this.floatingLinks.size ? [...this.floatingLinks.values()].map(x => x.asSerialisable()) : undefined\n    const reroutes = this.reroutes.size ? [...this.reroutes.values()].map(x => x.asSerialisable()) : undefined\n\n    // Save scale and offset\n    const extra = { ...this.extra }\n    if (LiteGraph.saveViewportWithGraph) extra.ds = this.#getDragAndScale()\n    if (!extra.ds) delete extra.ds\n\n    const data: ReturnType<typeof this.asSerialisable> = {\n      id,\n      revision,\n      version: LGraph.serialisedSchemaVersion,\n      config,\n      state,\n      groups,\n      nodes,\n      links,\n      floatingLinks,\n      reroutes,\n      extra,\n    }\n\n    this.onSerialize?.(data)\n    return data\n  }\n\n  /**\n   * Configure a graph from a JSON string\n   * @param data The deserialised object to configure this graph from\n   * @param keep_old If `true`, the graph will not be cleared prior to\n   * adding the configuration.\n   */\n  configure(\n    data: ISerialisedGraph | SerialisableGraph,\n    keep_old?: boolean,\n  ): boolean | undefined {\n    // TODO: Finish typing configure()\n    if (!data) return\n    if (!keep_old) this.clear()\n\n    // Create a new graph ID if none is provided\n    if (data.id) this.id = data.id\n    else if (this.id === zeroUuid) this.id = createUuidv4()\n\n    let reroutes: SerialisableReroute[] | undefined\n\n    // TODO: Determine whether this should this fall back to 0.4.\n    if (data.version === 0.4) {\n      const { extra } = data\n      // Deprecated - old schema version, links are arrays\n      if (Array.isArray(data.links)) {\n        for (const linkData of data.links) {\n          const link = LLink.createFromArray(linkData)\n          this._links.set(link.id, link)\n        }\n      }\n      // #region `extra` embeds for v0.4\n\n      // LLink parentIds\n      if (Array.isArray(extra?.linkExtensions)) {\n        for (const linkEx of extra.linkExtensions) {\n          const link = this._links.get(linkEx.id)\n          if (link) link.parentId = linkEx.parentId\n        }\n      }\n\n      // Reroutes\n      reroutes = extra?.reroutes\n\n      // #endregion `extra` embeds for v0.4\n    } else {\n      // New schema - one version so far, no check required.\n\n      // State\n      if (data.state) {\n        const { lastGroupId, lastLinkId, lastNodeId, lastRerouteId } = data.state\n        const { state } = this\n        if (lastGroupId != null) state.lastGroupId = lastGroupId\n        if (lastLinkId != null) state.lastLinkId = lastLinkId\n        if (lastNodeId != null) state.lastNodeId = lastNodeId\n        if (lastRerouteId != null) state.lastRerouteId = lastRerouteId\n      }\n\n      // Links\n      if (Array.isArray(data.links)) {\n        for (const linkData of data.links) {\n          const link = LLink.create(linkData)\n          this._links.set(link.id, link)\n        }\n      }\n\n      reroutes = data.reroutes\n    }\n\n    // Reroutes\n    if (Array.isArray(reroutes)) {\n      for (const rerouteData of reroutes) {\n        this.setReroute(rerouteData)\n      }\n    }\n\n    const nodesData = data.nodes\n\n    // copy all stored fields\n    for (const i in data) {\n      // links must be accepted\n      if ([\"nodes\", \"groups\", \"links\", \"state\", \"reroutes\", \"floatingLinks\", \"id\"].includes(i)) {\n        continue\n      }\n      // @ts-expect-error #574 Legacy property assignment\n      this[i] = data[i]\n    }\n\n    let error = false\n\n    // create nodes\n    this._nodes = []\n    if (nodesData) {\n      for (const n_info of nodesData) {\n        // stored info\n        let node = LiteGraph.createNode(String(n_info.type), n_info.title)\n        if (!node) {\n          if (LiteGraph.debug) console.log(\"Node not found or has errors:\", n_info.type)\n\n          // in case of error we create a replacement node to avoid losing info\n          node = new LGraphNode(\"\")\n          node.last_serialization = n_info\n          node.has_errors = true\n          error = true\n          // continue;\n        }\n\n        // id it or it will create a new id\n        node.id = n_info.id\n        // add before configure, otherwise configure cannot create links\n        this.add(node, true)\n      }\n\n      // configure nodes afterwards so they can reach each other\n      for (const n_info of nodesData) {\n        const node = this.getNodeById(n_info.id)\n        node?.configure(n_info)\n      }\n    }\n\n    // Floating links\n    if (Array.isArray(data.floatingLinks)) {\n      for (const linkData of data.floatingLinks) {\n        const floatingLink = LLink.create(linkData)\n        this.addFloatingLink(floatingLink)\n\n        if (floatingLink.id > this.#lastFloatingLinkId) this.#lastFloatingLinkId = floatingLink.id\n      }\n    }\n\n    // Drop broken reroutes\n    for (const reroute of this.reroutes.values()) {\n      // Drop broken links, and ignore reroutes with no valid links\n      if (!reroute.validateLinks(this._links, this.floatingLinks)) {\n        this.reroutes.delete(reroute.id)\n      }\n    }\n\n    // groups\n    this._groups.length = 0\n    const groupData = data.groups\n    if (groupData) {\n      for (const data of groupData) {\n        // TODO: Search/remove these global object refs\n        const group = new LiteGraph.LGraphGroup()\n        group.configure(data)\n        this.add(group)\n      }\n    }\n\n    this.updateExecutionOrder()\n\n    this.extra = data.extra || {}\n    // Ensure auto-generated serialisation data is removed from extra\n    delete this.extra.linkExtensions\n\n    this.onConfigure?.(data)\n    this._version++\n    this.setDirtyCanvas(true, true)\n    return error\n  }\n\n  load(url: string | Blob | URL | File, callback: () => void) {\n    const that = this\n\n    // from file\n    if (url instanceof Blob || url instanceof File) {\n      const reader = new FileReader()\n      reader.addEventListener(\"load\", function (event) {\n        const result = stringOrEmpty(event.target?.result)\n        const data = JSON.parse(result)\n        that.configure(data)\n        callback?.()\n      })\n\n      reader.readAsText(url)\n      return\n    }\n\n    // is a string, then an URL\n    const req = new XMLHttpRequest()\n    req.open(\"GET\", url, true)\n    req.send(null)\n    req.addEventListener(\"load\", function () {\n      if (req.status !== 200) {\n        console.error(\"Error loading graph:\", req.status, req.response)\n        return\n      }\n      const data = JSON.parse(req.response)\n      that.configure(data)\n      callback?.()\n    })\n    req.addEventListener(\"error\", (err) => {\n      console.error(\"Error loading graph:\", err)\n    })\n  }\n}\n","import type { SubgraphIONodeBase } from \"./SubgraphIONodeBase\"\nimport type { Point, ReadOnlyRect, Rect } from \"@/interfaces\"\nimport type { LinkId } from \"@/LLink\"\nimport type { Serialisable, SubgraphIO } from \"@/types/serialisation\"\n\nimport { LiteGraph } from \"@/litegraph\"\nimport { SlotBase } from \"@/node/SlotBase\"\nimport { createUuidv4, type UUID } from \"@/utils/uuid\"\n\n/** Shared base class for the slots used on Subgraph . */\nexport abstract class SubgraphSlot extends SlotBase implements SubgraphIO, Serialisable<SubgraphIO> {\n  static get defaultHeight() {\n    return LiteGraph.NODE_SLOT_HEIGHT\n  }\n\n  readonly #pos: Point = new Float32Array(2)\n\n  readonly id: UUID\n  readonly parent: SubgraphIONodeBase\n  override type: string\n\n  readonly linkIds: LinkId[] = []\n\n  override readonly boundingRect: Rect = [0, 0, 0, SubgraphSlot.defaultHeight]\n\n  override get pos() {\n    return this.#pos\n  }\n\n  override set pos(value) {\n    if (!value || value.length < 2) return\n\n    this.#pos[0] = value[0]\n    this.#pos[1] = value[1]\n  }\n\n  /** Whether this slot is connected to another slot. */\n  override get isConnected() {\n    return this.linkIds.length > 0\n  }\n\n  /** The display name of this slot. */\n  get displayName() {\n    return this.label ?? this.localized_name ?? this.name\n  }\n\n  abstract get labelPos(): Point\n\n  constructor(slot: SubgraphIO, parent: SubgraphIONodeBase) {\n    super(slot.name, slot.type, slot.boundingRect)\n\n    Object.assign(this, slot)\n    this.id = slot.id ?? createUuidv4()\n    this.type = slot.type\n    this.parent = parent\n  }\n\n  abstract arrange(rect: ReadOnlyRect): void\n\n  asSerialisable(): SubgraphIO {\n    const { id, name, type, linkIds, localized_name, label, dir, shape, color_off, color_on, pos, boundingRect } = this\n    return { id, name, type, linkIds, localized_name, label, dir, shape, color_off, color_on, pos, boundingRect }\n  }\n}\n","import type { Point, ReadOnlyRect } from \"@/interfaces\"\n\nimport { SubgraphSlot } from \"./SubgraphSlotBase\"\n\nexport class SubgraphInput extends SubgraphSlot {\n  get labelPos(): Point {\n    const [x, y, , height] = this.boundingRect\n    return [x, y + height * 0.5]\n  }\n\n  /** For inputs, x is the right edge of the input node. */\n  override arrange(rect: ReadOnlyRect): void {\n    const [right, top, width, height] = rect\n    const { boundingRect: b, pos } = this\n\n    b[0] = right - width\n    b[1] = top\n    b[2] = width\n    b[3] = height\n\n    pos[0] = right - height * 0.5\n    pos[1] = top + height * 0.5\n  }\n}\n","import type { Subgraph } from \"./Subgraph\"\nimport type { SubgraphInput } from \"./SubgraphInput\"\nimport type { SubgraphOutput } from \"./SubgraphOutput\"\nimport type { Point, Positionable, ReadOnlyRect, Rect } from \"@/interfaces\"\nimport type { NodeId } from \"@/LGraphNode\"\nimport type { ExportedSubgraphIONode, Serialisable } from \"@/types/serialisation\"\n\nimport { isPointInRect, snapPoint } from \"@/measure\"\n\nexport abstract class SubgraphIONodeBase implements Positionable, Serialisable<ExportedSubgraphIONode> {\n  static margin = 10\n  static defaultWidth = 100\n  static roundedRadius = 10\n\n  readonly #boundingRect: Float32Array = new Float32Array(4)\n  readonly #pos: Point = this.#boundingRect.subarray(0, 2)\n  readonly #size: Point = this.#boundingRect.subarray(2, 4)\n\n  abstract readonly id: NodeId\n\n  get boundingRect(): Rect {\n    return this.#boundingRect\n  }\n\n  selected: boolean = false\n  pinned: boolean = false\n\n  get pos() {\n    return this.#pos\n  }\n\n  set pos(value) {\n    if (!value || value.length < 2) return\n\n    this.#pos[0] = value[0]\n    this.#pos[1] = value[1]\n  }\n\n  get size() {\n    return this.#size\n  }\n\n  set size(value) {\n    if (!value || value.length < 2) return\n\n    this.#size[0] = value[0]\n    this.#size[1] = value[1]\n  }\n\n  abstract readonly slots: SubgraphInput[] | SubgraphOutput[]\n\n  constructor(\n    /** The subgraph that this node belongs to. */\n    readonly subgraph: Subgraph,\n  ) {}\n\n  move(deltaX: number, deltaY: number): void {\n    this.pos[0] += deltaX\n    this.pos[1] += deltaY\n  }\n\n  /** @inheritdoc */\n  snapToGrid(snapTo: number): boolean {\n    return this.pinned ? false : snapPoint(this.pos, snapTo)\n  }\n\n  containsPoint(point: Point): boolean {\n    return isPointInRect(point, this.boundingRect)\n  }\n\n  asSerialisable(): ExportedSubgraphIONode {\n    return {\n      id: this.id,\n      bounding: serialiseRect(this.boundingRect),\n      pinned: this.pinned ? true : undefined,\n    }\n  }\n}\n\nfunction serialiseRect(rect: ReadOnlyRect): [number, number, number, number] {\n  return [rect[0], rect[1], rect[2], rect[3]]\n}\n","import type { Positionable } from \"@/interfaces\"\nimport type { NodeId } from \"@/LGraphNode\"\n\nimport { SubgraphIONodeBase } from \"./SubgraphIONodeBase\"\n\nexport class SubgraphInputNode extends SubgraphIONodeBase implements Positionable {\n  readonly id: NodeId = -10\n\n  get slots() {\n    return this.subgraph.inputs\n  }\n}\n","import type { Point, ReadOnlyRect } from \"@/interfaces\"\n\nimport { SubgraphSlot } from \"./SubgraphSlotBase\"\n\nexport class SubgraphOutput extends SubgraphSlot {\n  get labelPos(): Point {\n    const [x, y, , height] = this.boundingRect\n    return [x + height, y + height * 0.5]\n  }\n\n  override arrange(rect: ReadOnlyRect): void {\n    const [left, top, width, height] = rect\n    const { boundingRect: b, pos } = this\n\n    b[0] = left\n    b[1] = top\n    b[2] = width\n    b[3] = height\n\n    pos[0] = left + height * 0.5\n    pos[1] = top + height * 0.5\n  }\n}\n","import type { Positionable } from \"@/interfaces\"\nimport type { NodeId } from \"@/LGraphNode\"\n\nimport { SubgraphIONodeBase } from \"./SubgraphIONodeBase\"\n\nexport class SubgraphOutputNode extends SubgraphIONodeBase implements Positionable {\n  readonly id: NodeId = -20\n\n  get slots() {\n    return this.subgraph.outputs\n  }\n}\n","import type { ExportedSubgraph, ExposedWidget, Serialisable, SerialisableGraph } from \"@/types/serialisation\"\n\nimport { type BaseLGraph, LGraph } from \"@/LGraph\"\n\nimport { SubgraphInput } from \"./SubgraphInput\"\nimport { SubgraphInputNode } from \"./SubgraphInputNode\"\nimport { SubgraphOutput } from \"./SubgraphOutput\"\nimport { SubgraphOutputNode } from \"./SubgraphOutputNode\"\n\n/** Internal; simplifies type definitions. */\nexport type GraphOrSubgraph = LGraph | Subgraph\n\n/** A subgraph definition. */\nexport class Subgraph extends LGraph implements BaseLGraph, Serialisable<ExportedSubgraph> {\n  /** The display name of the subgraph. */\n  name: string\n\n  readonly inputNode = new SubgraphInputNode(this)\n  readonly outputNode = new SubgraphOutputNode(this)\n\n  /** Ordered list of inputs to the subgraph itself. Similar to a reroute, with the input side in the graph, and the output side in the subgraph. */\n  readonly inputs: SubgraphInput[]\n  /** Ordered list of outputs from the subgraph itself. Similar to a reroute, with the input side in the subgraph, and the output side in the graph. */\n  readonly outputs: SubgraphOutput[]\n  /** A list of node widgets displayed in the parent graph, on the subgraph object. */\n  readonly widgets: ExposedWidget[]\n\n  override get rootGraph(): LGraph {\n    return this.parents[0]\n  }\n\n  /** @inheritdoc */\n  get pathToRootGraph(): readonly [LGraph, ...Subgraph[]] {\n    return [...this.parents, this]\n  }\n\n  constructor(\n    readonly parents: readonly [LGraph, ...Subgraph[]],\n    data: ExportedSubgraph,\n  ) {\n    if (!parents.length) throw new Error(\"Subgraph must have at least one parent\")\n\n    const cloned = structuredClone(data)\n    const { name, inputs, outputs, widgets } = cloned\n    super()\n\n    this.name = name\n    this.inputs = inputs?.map(x => new SubgraphInput(x, this.inputNode)) ?? []\n    this.outputs = outputs?.map(x => new SubgraphOutput(x, this.outputNode)) ?? []\n    this.widgets = widgets ?? []\n\n    this.configure(cloned)\n  }\n\n  override asSerialisable(): ExportedSubgraph & Required<Pick<SerialisableGraph, \"nodes\" | \"groups\" | \"extra\">> {\n    return {\n      id: this.id,\n      version: LGraph.serialisedSchemaVersion,\n      state: this.state,\n      revision: this.revision,\n      config: this.config,\n      name: this.name,\n      inputNode: this.inputNode.asSerialisable(),\n      outputNode: this.outputNode.asSerialisable(),\n      inputs: this.inputs.map(x => x.asSerialisable()),\n      outputs: this.outputs.map(x => x.asSerialisable()),\n      widgets: [...this.widgets],\n      nodes: this.nodes.map(node => node.serialize()),\n      groups: this.groups.map(group => group.serialize()),\n      links: [...this.links.values()].map(x => x.asSerialisable()),\n      extra: this.extra,\n    }\n  }\n}\n","import type { LGraphCanvas } from \"@/LGraphCanvas\"\n\n/**\n * A class that can be added to the render cycle to show pointer / keyboard status symbols.\n *\n * Used to create videos of feature changes.\n *\n * Example usage with ComfyUI_frontend, via console / devtools:\n *\n * ```ts\n * const inputIndicators = new InputIndicators(canvas)\n * // Dispose:\n * inputIndicators.dispose()\n * ```\n */\nexport class InputIndicators implements Disposable {\n  // #region config\n  radius = 8\n  startAngle = 0\n  endAngle = Math.PI * 2\n\n  inactiveColour = \"#ffffff10\"\n  colour1 = \"#ff5f00\"\n  colour2 = \"#00ff7c\"\n  colour3 = \"#dea7ff\"\n  fontString = \"bold 12px Arial\"\n  // #endregion\n\n  // #region state\n  enabled: boolean = true\n\n  shiftDown: boolean = false\n  undoDown: boolean = false\n  redoDown: boolean = false\n  ctrlDown: boolean = false\n  altDown: boolean = false\n  mouse0Down: boolean = false\n  mouse1Down: boolean = false\n  mouse2Down: boolean = false\n\n  x: number = 0\n  y: number = 0\n  // #endregion\n\n  controller?: AbortController\n\n  constructor(public canvas: LGraphCanvas) {\n    this.controller = new AbortController()\n    const { signal } = this.controller\n\n    const element = canvas.canvas\n    const options = { capture: true, signal } satisfies AddEventListenerOptions\n\n    element.addEventListener(\"pointerdown\", this.#onPointerDownOrMove, options)\n    element.addEventListener(\"pointermove\", this.#onPointerDownOrMove, options)\n    element.addEventListener(\"pointerup\", this.#onPointerUp, options)\n    element.addEventListener(\"keydown\", this.#onKeyDownOrUp, options)\n    document.addEventListener(\"keyup\", this.#onKeyDownOrUp, options)\n\n    const origDrawFrontCanvas = canvas.drawFrontCanvas.bind(canvas)\n    signal.addEventListener(\"abort\", () => {\n      canvas.drawFrontCanvas = origDrawFrontCanvas\n    })\n\n    canvas.drawFrontCanvas = () => {\n      origDrawFrontCanvas()\n      this.draw()\n    }\n  }\n\n  #onPointerDownOrMove = this.onPointerDownOrMove.bind(this)\n  onPointerDownOrMove(e: MouseEvent): void {\n    this.mouse0Down = (e.buttons & 1) === 1\n    this.mouse1Down = (e.buttons & 4) === 4\n    this.mouse2Down = (e.buttons & 2) === 2\n\n    this.x = e.clientX\n    this.y = e.clientY\n\n    this.canvas.setDirty(true)\n  }\n\n  #onPointerUp = this.onPointerUp.bind(this)\n  onPointerUp(): void {\n    this.mouse0Down = false\n    this.mouse1Down = false\n    this.mouse2Down = false\n  }\n\n  #onKeyDownOrUp = this.onKeyDownOrUp.bind(this)\n  onKeyDownOrUp(e: KeyboardEvent): void {\n    this.ctrlDown = e.ctrlKey\n    this.altDown = e.altKey\n    this.shiftDown = e.shiftKey\n    this.undoDown = e.ctrlKey && e.code === \"KeyZ\" && e.type === \"keydown\"\n    this.redoDown = e.ctrlKey && e.code === \"KeyY\" && e.type === \"keydown\"\n  }\n\n  draw() {\n    const {\n      canvas: { ctx },\n      radius,\n      startAngle,\n      endAngle,\n      x,\n      y,\n      inactiveColour,\n      colour1,\n      colour2,\n      colour3,\n      fontString,\n    } = this\n\n    const { fillStyle, font } = ctx\n\n    const mouseDotX = x\n    const mouseDotY = y - 80\n\n    const textX = mouseDotX\n    const textY = mouseDotY - 15\n    ctx.font = fontString\n\n    textMarker(textX + 0, textY, \"Shift\", this.shiftDown ? colour1 : inactiveColour)\n    textMarker(textX + 45, textY + 20, \"Alt\", this.altDown ? colour2 : inactiveColour)\n    textMarker(textX + 30, textY, \"Control\", this.ctrlDown ? colour3 : inactiveColour)\n    textMarker(textX - 30, textY, \"â©ï¸\", this.undoDown ? \"#000\" : \"transparent\")\n    textMarker(textX + 45, textY, \"âªï¸\", this.redoDown ? \"#000\" : \"transparent\")\n\n    ctx.beginPath()\n    drawDot(mouseDotX, mouseDotY)\n    drawDot(mouseDotX + 15, mouseDotY)\n    drawDot(mouseDotX + 30, mouseDotY)\n    ctx.fillStyle = inactiveColour\n    ctx.fill()\n\n    const leftButtonColour = this.mouse0Down ? colour1 : inactiveColour\n    const middleButtonColour = this.mouse1Down ? colour2 : inactiveColour\n    const rightButtonColour = this.mouse2Down ? colour3 : inactiveColour\n    if (this.mouse0Down) mouseMarker(mouseDotX, mouseDotY, leftButtonColour)\n    if (this.mouse1Down) mouseMarker(mouseDotX + 15, mouseDotY, middleButtonColour)\n    if (this.mouse2Down) mouseMarker(mouseDotX + 30, mouseDotY, rightButtonColour)\n\n    ctx.fillStyle = fillStyle\n    ctx.font = font\n\n    function textMarker(x: number, y: number, text: string, colour: string) {\n      ctx.fillStyle = colour\n      ctx.fillText(text, x, y)\n    }\n\n    function mouseMarker(x: number, y: number, colour: string) {\n      ctx.beginPath()\n      ctx.fillStyle = colour\n      drawDot(x, y)\n      ctx.fill()\n    }\n\n    function drawDot(x: number, y: number) {\n      ctx.arc(x, y, radius, startAngle, endAngle)\n    }\n  }\n\n  dispose() {\n    this.controller?.abort()\n    this.controller = undefined\n  }\n\n  [Symbol.dispose](): void {\n    this.dispose()\n  }\n}\n","import type { ContextMenuDivElement, IContextMenuOptions, IContextMenuValue } from \"./interfaces\"\n\nimport { LiteGraph } from \"./litegraph\"\n\n// TODO: Replace this pattern with something more modern.\nexport interface ContextMenu<TValue = unknown> {\n  constructor: new (...args: ConstructorParameters<typeof ContextMenu<TValue>>) => ContextMenu<TValue>\n}\n\n/**\n * ContextMenu from LiteGUI\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class ContextMenu<TValue = unknown> {\n  options: IContextMenuOptions<TValue>\n  parentMenu?: ContextMenu<TValue>\n  root: ContextMenuDivElement<TValue>\n  current_submenu?: ContextMenu<TValue>\n  lock?: boolean\n\n  controller: AbortController = new AbortController()\n\n  /**\n   * @todo Interface for values requires functionality change - currently accepts\n   * an array of strings, functions, objects, nulls, or undefined.\n   * @param values (allows object { title: \"Nice text\", callback: function ... })\n   * @param options [optional] Some options:\\\n   * - title: title to show on top of the menu\n   * - callback: function to call when an option is clicked, it receives the item information\n   * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback\n   * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\n   */\n  constructor(values: readonly (string | IContextMenuValue<TValue> | null)[], options: IContextMenuOptions<TValue>) {\n    options ||= {}\n    this.options = options\n\n    // to link a menu with its parent\n    const parent = options.parentMenu\n    if (parent) {\n      if (!(parent instanceof ContextMenu)) {\n        console.error(\"parentMenu must be of class ContextMenu, ignoring it\")\n        options.parentMenu = undefined\n      } else {\n        this.parentMenu = parent\n        this.parentMenu.lock = true\n        this.parentMenu.current_submenu = this\n      }\n      if (parent.options?.className === \"dark\") {\n        options.className = \"dark\"\n      }\n    }\n\n    // use strings because comparing classes between windows doesnt work\n    const eventClass = options.event\n      ? options.event.constructor.name\n      : null\n    if (\n      eventClass !== \"MouseEvent\" &&\n      eventClass !== \"CustomEvent\" &&\n      eventClass !== \"PointerEvent\"\n    ) {\n      console.error(`Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (${eventClass})`)\n      options.event = undefined\n    }\n\n    const root: ContextMenuDivElement<TValue> = document.createElement(\"div\")\n    let classes = \"litegraph litecontextmenu litemenubar-panel\"\n    if (options.className) classes += ` ${options.className}`\n    root.className = classes\n    root.style.minWidth = \"100\"\n    root.style.minHeight = \"100\"\n\n    // Close the context menu when a click occurs outside this context menu or its submenus\n    const { signal } = this.controller\n    const eventOptions = { capture: true, signal }\n\n    if (!this.parentMenu) {\n      document.addEventListener(\"pointerdown\", (e) => {\n        if (e.target instanceof Node && !this.containsNode(e.target)) {\n          this.close()\n        }\n      }, eventOptions)\n    }\n\n    // this prevents the default context browser menu to open in case this menu was created when pressing right button\n    root.addEventListener(\"pointerup\", e => e.preventDefault(), eventOptions)\n\n    // Right button\n    root.addEventListener(\n      \"contextmenu\",\n      (e) => {\n        if (e.button === 2) e.preventDefault()\n      },\n      eventOptions,\n    )\n\n    root.addEventListener(\n      \"pointerdown\",\n      (e) => {\n        if (e.button == 2) {\n          this.close()\n          e.preventDefault()\n        }\n      },\n      eventOptions,\n    )\n\n    this.root = root\n\n    // title\n    if (options.title) {\n      const element = document.createElement(\"div\")\n      element.className = \"litemenu-title\"\n      element.innerHTML = options.title\n      root.append(element)\n    }\n\n    // entries\n    for (let i = 0; i < values.length; i++) {\n      const value = values[i]\n      let name = Array.isArray(values) ? value : String(i)\n\n      if (typeof name !== \"string\") {\n        name = name != null\n          ? (name.content === undefined ? String(name) : name.content)\n          : name\n      }\n\n      this.addItem(name, value, options)\n    }\n\n    // insert before checking position\n    const ownerDocument = (options.event?.target as Node | null | undefined)?.ownerDocument\n    const root_document = ownerDocument || document\n\n    if (root_document.fullscreenElement)\n      root_document.fullscreenElement.append(root)\n    else\n      root_document.body.append(root)\n\n    // compute best position\n    let left = options.left || 0\n    let top = options.top || 0\n    if (options.event) {\n      left = options.event.clientX - 10\n      top = options.event.clientY - 10\n      if (options.title) top -= 20\n\n      if (parent) {\n        const rect = parent.root.getBoundingClientRect()\n        left = rect.left + rect.width\n      }\n\n      const body_rect = document.body.getBoundingClientRect()\n      const root_rect = root.getBoundingClientRect()\n      if (body_rect.height == 0)\n        console.error(\"document.body height is 0. That is dangerous, set html,body { height: 100%; }\")\n\n      if (body_rect.width && left > body_rect.width - root_rect.width - 10)\n        left = body_rect.width - root_rect.width - 10\n      if (body_rect.height && top > body_rect.height - root_rect.height - 10)\n        top = body_rect.height - root_rect.height - 10\n    }\n\n    root.style.left = `${left}px`\n    root.style.top = `${top}px`\n\n    if (LiteGraph.context_menu_scaling && options.scale) {\n      root.style.transform = `scale(${Math.round(options.scale * 4) * 0.25})`\n    }\n  }\n\n  /**\n   * Checks if {@link node} is inside this context menu or any of its submenus\n   * @param node The {@link Node} to check\n   * @param visited A set of visited menus to avoid circular references\n   * @returns `true` if {@link node} is inside this context menu or any of its submenus\n   */\n  containsNode(node: Node, visited: Set<this> = new Set()): boolean {\n    if (visited.has(this)) return false\n    visited.add(this)\n\n    return this.current_submenu?.containsNode(node, visited) || this.root.contains(node)\n  }\n\n  addItem(\n    name: string | null,\n    value: string | IContextMenuValue<TValue> | null,\n    options: IContextMenuOptions<TValue>,\n  ): HTMLElement {\n    options ||= {}\n\n    const element: ContextMenuDivElement<TValue> = document.createElement(\"div\")\n    element.className = \"litemenu-entry submenu\"\n\n    let disabled = false\n\n    if (value === null) {\n      element.classList.add(\"separator\")\n    } else {\n      const innerHtml = name === null ? \"\" : String(name)\n      if (typeof value === \"string\") {\n        element.innerHTML = innerHtml\n      } else {\n        element.innerHTML = value?.title ?? innerHtml\n\n        if (value.disabled) {\n          disabled = true\n          element.classList.add(\"disabled\")\n          element.setAttribute(\"aria-disabled\", \"true\")\n        }\n        if (value.submenu || value.has_submenu) {\n          element.classList.add(\"has_submenu\")\n          element.setAttribute(\"aria-haspopup\", \"true\")\n          element.setAttribute(\"aria-expanded\", \"false\")\n        }\n        if (value.className) element.className += ` ${value.className}`\n      }\n      element.value = value\n      element.setAttribute(\"role\", \"menuitem\")\n\n      if (typeof value === \"function\") {\n        element.dataset[\"value\"] = String(name)\n        element.onclick_callback = value\n      } else {\n        element.dataset[\"value\"] = String(value)\n      }\n    }\n\n    this.root.append(element)\n    if (!disabled) element.addEventListener(\"click\", inner_onclick)\n    if (!disabled && options.autoopen)\n      element.addEventListener(\"pointerenter\", inner_over)\n\n    const setAriaExpanded = () => {\n      const entries = this.root.querySelectorAll(\"div.litemenu-entry.has_submenu\")\n      if (entries) {\n        for (const entry of entries) {\n          entry.setAttribute(\"aria-expanded\", \"false\")\n        }\n      }\n      element.setAttribute(\"aria-expanded\", \"true\")\n    }\n\n    function inner_over(this: ContextMenuDivElement<TValue>, e: MouseEvent) {\n      const value = this.value\n      if (!value || !(value as IContextMenuValue).has_submenu) return\n\n      // if it is a submenu, autoopen like the item was clicked\n      inner_onclick.call(this, e)\n      setAriaExpanded()\n    }\n\n    // menu option clicked\n    const that = this\n    function inner_onclick(this: ContextMenuDivElement<TValue>, e: MouseEvent) {\n      const value = this.value\n      let close_parent = true\n\n      that.current_submenu?.close(e)\n      if (\n        (value as IContextMenuValue)?.has_submenu ||\n        (value as IContextMenuValue)?.submenu\n      ) {\n        setAriaExpanded()\n      }\n\n      // global callback\n      if (options.callback) {\n        const r = options.callback.call(\n          this,\n          value,\n          options,\n          e,\n          that,\n          options.node,\n        )\n        if (r === true) close_parent = false\n      }\n\n      // special cases\n      if (typeof value === \"object\") {\n        if (\n          value.callback &&\n          !options.ignore_item_callbacks &&\n          value.disabled !== true\n        ) {\n          // item callback\n          const r = value.callback.call(\n            this,\n            value,\n            options,\n            e,\n            that,\n            options.extra,\n          )\n          if (r === true) close_parent = false\n        }\n        if (value.submenu) {\n          if (!value.submenu.options) throw \"ContextMenu submenu needs options\"\n\n          new that.constructor(value.submenu.options, {\n            callback: value.submenu.callback,\n            event: e,\n            parentMenu: that,\n            ignore_item_callbacks: value.submenu.ignore_item_callbacks,\n            title: value.submenu.title,\n            extra: value.submenu.extra,\n            autoopen: options.autoopen,\n          })\n          close_parent = false\n        }\n      }\n\n      if (close_parent && !that.lock) that.close()\n    }\n\n    return element\n  }\n\n  close(e?: MouseEvent, ignore_parent_menu?: boolean): void {\n    this.controller.abort()\n    this.root.remove()\n    if (this.parentMenu && !ignore_parent_menu) {\n      this.parentMenu.lock = false\n      this.parentMenu.current_submenu = undefined\n      if (e === undefined) {\n        this.parentMenu.close()\n      } else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {\n        ContextMenu.trigger(\n          this.parentMenu.root,\n          `${LiteGraph.pointerevents_method}leave`,\n          e,\n        )\n      }\n    }\n    this.current_submenu?.close(e, true)\n  }\n\n  /** @deprecated Likely unused, however code search was inconclusive (too many results to check by hand). */\n  // this code is used to trigger events easily (used in the context menu mouseleave\n  static trigger(\n    element: HTMLDivElement,\n    event_name: string,\n    params: MouseEvent,\n  ): CustomEvent {\n    const evt = document.createEvent(\"CustomEvent\")\n    evt.initCustomEvent(event_name, true, true, params)\n    if (element.dispatchEvent) element.dispatchEvent(evt)\n    // else nothing seems binded here so nothing to do\n    return evt\n  }\n\n  // returns the top most menu\n  getTopMenu(): ContextMenu<TValue> {\n    return this.options.parentMenu\n      ? this.options.parentMenu.getTopMenu()\n      : this\n  }\n\n  getFirstEvent(): MouseEvent | undefined {\n    return this.options.parentMenu\n      ? this.options.parentMenu.getFirstEvent()\n      : this.options.event\n  }\n\n  /** @deprecated Unused. */\n  static isCursorOverElement(\n    event: MouseEvent,\n    element: HTMLDivElement,\n  ): boolean {\n    const left = event.clientX\n    const top = event.clientY\n    const rect = element.getBoundingClientRect()\n    if (!rect) return false\n\n    if (\n      top > rect.top &&\n      top < rect.top + rect.height &&\n      left > rect.left &&\n      left < rect.left + rect.width\n    ) {\n      return true\n    }\n    return false\n  }\n}\n","import type { Point, Rect } from \"./interfaces\"\n\nimport { clamp, LGraphCanvas } from \"./litegraph\"\nimport { distance } from \"./measure\"\n\n// used by some widgets to render a curve editor\n\nexport class CurveEditor {\n  points: Point[]\n  selected: number\n  nearest: number\n  size: Rect | null\n  must_update: boolean\n  margin: number\n  _nearest?: number\n\n  constructor(points: Point[]) {\n    this.points = points\n    this.selected = -1\n    this.nearest = -1\n    // stores last size used\n    this.size = null\n    this.must_update = true\n    this.margin = 5\n  }\n\n  static sampleCurve(f: number, points: Point[]): number | undefined {\n    if (!points) return\n\n    for (let i = 0; i < points.length - 1; ++i) {\n      const p = points[i]\n      const pn = points[i + 1]\n      if (pn[0] < f) continue\n\n      const r = pn[0] - p[0]\n      if (Math.abs(r) < 0.000_01) return p[1]\n\n      const local_f = (f - p[0]) / r\n      return p[1] * (1.0 - local_f) + pn[1] * local_f\n    }\n    return 0\n  }\n\n  draw(\n    ctx: CanvasRenderingContext2D,\n    size: Rect,\n    graphcanvas?: LGraphCanvas,\n    background_color?: string,\n    line_color?: string,\n    inactive = false,\n  ): void {\n    const points = this.points\n    if (!points) return\n\n    this.size = size\n    const w = size[0] - this.margin * 2\n    const h = size[1] - this.margin * 2\n\n    line_color = line_color || \"#666\"\n\n    ctx.save()\n    ctx.translate(this.margin, this.margin)\n\n    if (background_color) {\n      ctx.fillStyle = \"#111\"\n      ctx.fillRect(0, 0, w, h)\n      ctx.fillStyle = \"#222\"\n      ctx.fillRect(w * 0.5, 0, 1, h)\n      ctx.strokeStyle = \"#333\"\n      ctx.strokeRect(0, 0, w, h)\n    }\n    ctx.strokeStyle = line_color\n    if (inactive) ctx.globalAlpha = 0.5\n    ctx.beginPath()\n    for (const p of points) {\n      ctx.lineTo(p[0] * w, (1.0 - p[1]) * h)\n    }\n    ctx.stroke()\n    ctx.globalAlpha = 1\n    if (!inactive) {\n      for (const [i, p] of points.entries()) {\n        ctx.fillStyle = this.selected == i\n          ? \"#FFF\"\n          : (this.nearest == i ? \"#DDD\" : \"#AAA\")\n        ctx.beginPath()\n        ctx.arc(p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2)\n        ctx.fill()\n      }\n    }\n    ctx.restore()\n  }\n\n  // localpos is mouse in curve editor space\n  onMouseDown(localpos: Point, graphcanvas: LGraphCanvas): boolean | undefined {\n    const points = this.points\n    if (!points) return\n    if (localpos[1] < 0) return\n\n    // this.captureInput(true);\n    if (this.size == null) throw new Error(\"CurveEditor.size was null or undefined.\")\n    const w = this.size[0] - this.margin * 2\n    const h = this.size[1] - this.margin * 2\n    const x = localpos[0] - this.margin\n    const y = localpos[1] - this.margin\n    const pos: Point = [x, y]\n    const max_dist = 30 / graphcanvas.ds.scale\n    // search closer one\n    this.selected = this.getCloserPoint(pos, max_dist)\n    // create one\n    if (this.selected == -1) {\n      const point: Point = [x / w, 1 - y / h]\n      points.push(point)\n      points.sort(function (a, b) {\n        return a[0] - b[0]\n      })\n      this.selected = points.indexOf(point)\n      this.must_update = true\n    }\n    if (this.selected != -1) return true\n  }\n\n  onMouseMove(localpos: Point, graphcanvas: LGraphCanvas): void {\n    const points = this.points\n    if (!points) return\n\n    const s = this.selected\n    if (s < 0) return\n\n    if (this.size == null) throw new Error(\"CurveEditor.size was null or undefined.\")\n    const x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2)\n    const y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2)\n    const curvepos: Point = [\n      localpos[0] - this.margin,\n      localpos[1] - this.margin,\n    ]\n    const max_dist = 30 / graphcanvas.ds.scale\n    this._nearest = this.getCloserPoint(curvepos, max_dist)\n    const point = points[s]\n    if (point) {\n      const is_edge_point = s == 0 || s == points.length - 1\n      if (\n        !is_edge_point &&\n        (localpos[0] < -10 ||\n          localpos[0] > this.size[0] + 10 ||\n          localpos[1] < -10 ||\n          localpos[1] > this.size[1] + 10)\n      ) {\n        points.splice(s, 1)\n        this.selected = -1\n        return\n      }\n      // not edges\n      if (!is_edge_point) point[0] = clamp(x, 0, 1)\n      else point[0] = s == 0 ? 0 : 1\n      point[1] = 1.0 - clamp(y, 0, 1)\n      points.sort(function (a, b) {\n        return a[0] - b[0]\n      })\n      this.selected = points.indexOf(point)\n      this.must_update = true\n    }\n  }\n\n  // Former params: localpos, graphcanvas\n  onMouseUp(): boolean {\n    this.selected = -1\n    return false\n  }\n\n  getCloserPoint(pos: Point, max_dist: number): number {\n    const points = this.points\n    if (!points) return -1\n\n    max_dist = max_dist || 30\n    if (this.size == null) throw new Error(\"CurveEditor.size was null or undefined.\")\n    const w = this.size[0] - this.margin * 2\n    const h = this.size[1] - this.margin * 2\n    const num = points.length\n    const p2: Point = [0, 0]\n    let min_dist = 1_000_000\n    let closest = -1\n\n    for (let i = 0; i < num; ++i) {\n      const p = points[i]\n      p2[0] = p[0] * w\n      p2[1] = (1.0 - p[1]) * h\n      const dist = distance(pos, p2)\n      if (dist > min_dist || dist > max_dist) continue\n\n      closest = i\n      min_dist = dist\n    }\n    return closest\n  }\n}\n","import type { Dictionary, ISlotType, Rect, WhenNullish } from \"./interfaces\"\n\nimport { InputIndicators } from \"./canvas/InputIndicators\"\nimport { ContextMenu } from \"./ContextMenu\"\nimport { CurveEditor } from \"./CurveEditor\"\nimport { DragAndScale } from \"./DragAndScale\"\nimport { LabelPosition, SlotDirection, SlotShape, SlotType } from \"./draw\"\nimport { LGraph } from \"./LGraph\"\nimport { LGraphCanvas } from \"./LGraphCanvas\"\nimport { LGraphGroup } from \"./LGraphGroup\"\nimport { LGraphNode } from \"./LGraphNode\"\nimport { LLink } from \"./LLink\"\nimport { distance, isInsideRectangle, overlapBounding } from \"./measure\"\nimport { Reroute } from \"./Reroute\"\nimport {\n  LGraphEventMode,\n  LinkDirection,\n  LinkRenderType,\n  NodeSlotType,\n  RenderShape,\n  TitleMode,\n} from \"./types/globalEnums\"\nimport { createUuidv4 } from \"./utils/uuid\"\n\n/**\n * The Global Scope. It contains all the registered node classes.\n */\nexport class LiteGraphGlobal {\n  // Enums\n  SlotShape = SlotShape\n  SlotDirection = SlotDirection\n  SlotType = SlotType\n  LabelPosition = LabelPosition\n\n  /** Used in serialised graphs at one point. */\n  VERSION = 0.4 as const\n\n  CANVAS_GRID_SIZE = 10\n\n  NODE_TITLE_HEIGHT = 30\n  NODE_TITLE_TEXT_Y = 20\n  NODE_SLOT_HEIGHT = 20\n  NODE_WIDGET_HEIGHT = 20\n  NODE_WIDTH = 140\n  NODE_MIN_WIDTH = 50\n  NODE_COLLAPSED_RADIUS = 10\n  NODE_COLLAPSED_WIDTH = 80\n  NODE_TITLE_COLOR = \"#999\"\n  NODE_SELECTED_TITLE_COLOR = \"#FFF\"\n  NODE_TEXT_SIZE = 14\n  NODE_TEXT_COLOR = \"#AAA\"\n  NODE_TEXT_HIGHLIGHT_COLOR = \"#EEE\"\n  NODE_SUBTEXT_SIZE = 12\n  NODE_DEFAULT_COLOR = \"#333\"\n  NODE_DEFAULT_BGCOLOR = \"#353535\"\n  NODE_DEFAULT_BOXCOLOR = \"#666\"\n  NODE_DEFAULT_SHAPE = RenderShape.ROUND\n  NODE_BOX_OUTLINE_COLOR = \"#FFF\"\n  NODE_ERROR_COLOUR = \"#E00\"\n  NODE_FONT = \"Arial\"\n\n  DEFAULT_FONT = \"Arial\"\n  DEFAULT_SHADOW_COLOR = \"rgba(0,0,0,0.5)\"\n\n  DEFAULT_GROUP_FONT = 24\n  DEFAULT_GROUP_FONT_SIZE?: any\n  GROUP_FONT = \"Arial\"\n\n  WIDGET_BGCOLOR = \"#222\"\n  WIDGET_OUTLINE_COLOR = \"#666\"\n  WIDGET_ADVANCED_OUTLINE_COLOR = \"rgba(56, 139, 253, 0.8)\"\n  WIDGET_TEXT_COLOR = \"#DDD\"\n  WIDGET_SECONDARY_TEXT_COLOR = \"#999\"\n  WIDGET_DISABLED_TEXT_COLOR = \"#666\"\n\n  LINK_COLOR = \"#9A9\"\n  EVENT_LINK_COLOR = \"#A86\"\n  CONNECTING_LINK_COLOR = \"#AFA\"\n\n  /** avoid infinite loops */\n  MAX_NUMBER_OF_NODES = 10_000\n  /** default node position */\n  DEFAULT_POSITION = [100, 100]\n  /** ,\"circle\" */\n  VALID_SHAPES = [\"default\", \"box\", \"round\", \"card\"] satisfies (\"default\" | Lowercase<keyof typeof RenderShape>)[]\n  ROUND_RADIUS = 8\n\n  // shapes are used for nodes but also for slots\n  BOX_SHAPE = RenderShape.BOX\n  ROUND_SHAPE = RenderShape.ROUND\n  CIRCLE_SHAPE = RenderShape.CIRCLE\n  CARD_SHAPE = RenderShape.CARD\n  ARROW_SHAPE = RenderShape.ARROW\n  /** intended for slot arrays */\n  GRID_SHAPE = RenderShape.GRID\n\n  // enums\n  INPUT = NodeSlotType.INPUT\n  OUTPUT = NodeSlotType.OUTPUT\n\n  // TODO: -1 can lead to ambiguity in JS; these should be updated to a more explicit constant or Symbol.\n  /** for outputs */\n  EVENT = -1 as const\n  /** for inputs */\n  ACTION = -1 as const\n\n  /** helper, will add \"On Request\" and more in the future */\n  NODE_MODES = [\"Always\", \"On Event\", \"Never\", \"On Trigger\"]\n  /** use with node_box_coloured_by_mode */\n  NODE_MODES_COLORS = [\"#666\", \"#422\", \"#333\", \"#224\", \"#626\"]\n  ALWAYS = LGraphEventMode.ALWAYS\n  ON_EVENT = LGraphEventMode.ON_EVENT\n  NEVER = LGraphEventMode.NEVER\n  ON_TRIGGER = LGraphEventMode.ON_TRIGGER\n\n  UP = LinkDirection.UP\n  DOWN = LinkDirection.DOWN\n  LEFT = LinkDirection.LEFT\n  RIGHT = LinkDirection.RIGHT\n  CENTER = LinkDirection.CENTER\n\n  /** helper */\n  LINK_RENDER_MODES = [\"Straight\", \"Linear\", \"Spline\"]\n  HIDDEN_LINK = LinkRenderType.HIDDEN_LINK\n  STRAIGHT_LINK = LinkRenderType.STRAIGHT_LINK\n  LINEAR_LINK = LinkRenderType.LINEAR_LINK\n  SPLINE_LINK = LinkRenderType.SPLINE_LINK\n\n  NORMAL_TITLE = TitleMode.NORMAL_TITLE\n  NO_TITLE = TitleMode.NO_TITLE\n  TRANSPARENT_TITLE = TitleMode.TRANSPARENT_TITLE\n  AUTOHIDE_TITLE = TitleMode.AUTOHIDE_TITLE\n\n  /** arrange nodes vertically */\n  VERTICAL_LAYOUT = \"vertical\"\n\n  /** used to redirect calls */\n  proxy = null\n  node_images_path = \"\"\n\n  debug = false\n  catch_exceptions = true\n  throw_errors = true\n  /** if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits */\n  allow_scripts = false\n  /** nodetypes by string */\n  registered_node_types: Record<string, typeof LGraphNode> = {}\n  /** @deprecated used for dropping files in the canvas.  It appears the code that enables this was removed, but the object remains and is references by built-in drag drop. */\n  node_types_by_file_extension: Record<string, { type: string }> = {}\n  /** node types by classname */\n  Nodes: Record<string, typeof LGraphNode> = {}\n  /** used to store vars between graphs */\n  Globals = {}\n\n  /** @deprecated Unused and will be deleted. */\n  searchbox_extras: Dictionary<unknown> = {}\n\n  /** [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback */\n  node_box_coloured_when_on = false\n  /** [true!] nodebox based on node mode, visual feedback */\n  node_box_coloured_by_mode = false\n\n  /** [false on mobile] better true if not touch device, TODO add an helper/listener to close if false */\n  dialog_close_on_mouse_leave = false\n  dialog_close_on_mouse_leave_delay = 500\n\n  /** [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys */\n  shift_click_do_break_link_from = false\n  /** [false!]prefer false, way too easy to break links */\n  click_do_break_link_to = false\n  /** [true!] who accidentally ctrl-alt-clicks on an in/output? nobody! that's who! */\n  ctrl_alt_click_do_break_link = true\n  /** [true!] snaps links when dragging connections over valid targets */\n  snaps_for_comfy = true\n  /** [true!] renders a partial border to highlight when a dragged link is snapped to a node */\n  snap_highlights_node = true\n\n  /**\n   * If `true`, items always snap to the grid - modifier keys are ignored.\n   * When {@link snapToGrid} is falsy, a value of `1` is used.\n   * Default: `false`\n   */\n  alwaysSnapToGrid?: boolean\n\n  /**\n   * When set to a positive number, when nodes are moved their positions will\n   * be rounded to the nearest multiple of this value.  Half up.\n   * Default: `undefined`\n   * @todo Not implemented - see {@link LiteGraph.CANVAS_GRID_SIZE}\n   */\n  snapToGrid?: number\n\n  /** [false on mobile] better true if not touch device, TODO add an helper/listener to close if false */\n  search_hide_on_mouse_leave = true\n  /**\n   * [true!] enable filtering slots type in the search widget\n   * !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]\n   */\n  search_filter_enabled = false\n  /** [true!] opens the results list when opening the search widget */\n  search_show_all_on_open = true\n\n  /**\n   * [if want false, use true, run, get vars values to be statically set, than disable]\n   * nodes types and nodeclass association with node types need to be calculated,\n   * if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]\n   */\n  auto_load_slot_types = false\n\n  // set these values if not using auto_load_slot_types\n  /** slot types for nodeclass */\n  registered_slot_in_types: Record<string, { nodes: string[] }> = {}\n  /** slot types for nodeclass */\n  registered_slot_out_types: Record<string, { nodes: string[] }> = {}\n  /** slot types IN */\n  slot_types_in: string[] = []\n  /** slot types OUT */\n  slot_types_out: string[] = []\n  /**\n   * specify for each IN slot type a(/many) default node(s), use single string, array, or object\n   * (with node, title, parameters, ..) like for search\n   */\n  slot_types_default_in: Record<string, string[]> = {}\n  /**\n   * specify for each OUT slot type a(/many) default node(s), use single string, array, or object\n   * (with node, title, parameters, ..) like for search\n   */\n  slot_types_default_out: Record<string, string[]> = {}\n\n  /** [true!] very handy, ALT click to clone and drag the new node */\n  alt_drag_do_clone_nodes = false\n\n  /**\n   * [true!] will create and connect event slots when using action/events connections,\n   * !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this\n   */\n  do_add_triggers_slots = false\n\n  /** [false!] being events, it is strongly reccomended to use them sequentially, one by one */\n  allow_multi_output_for_events = true\n\n  /** [true!] allows to create and connect a ndoe clicking with the third button (wheel) */\n  middle_click_slot_add_default_node = false\n\n  /** [true!] dragging a link to empty space will open a menu, add from list, search or defaults */\n  release_link_on_empty_shows_menu = false\n\n  /** \"mouse\"|\"pointer\" use mouse for retrocompatibility issues? (none found @ now) */\n  pointerevents_method = \"pointer\"\n\n  /**\n   * [true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected\n   * with the inputs of the newly pasted nodes\n   */\n  ctrl_shift_v_paste_connect_unselected_outputs = true\n\n  // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.\n  // use this if you must have node IDs that are unique across all graphs and subgraphs.\n  use_uuids = false\n\n  // Whether to highlight the bounding box of selected groups\n  highlight_selected_group = true\n\n  /** Whether to scale context with the graph when zooming in.  Zooming out never makes context menus smaller. */\n  context_menu_scaling = false\n\n  /**\n   * Debugging flag. Repeats deprecation warnings every time they are reported.\n   * May impact performance.\n   */\n  alwaysRepeatWarnings: boolean = false\n\n  /**\n   * Array of callbacks to execute when Litegraph first reports a deprecated API being used.\n   * @see alwaysRepeatWarnings By default, will not repeat identical messages.\n   */\n  onDeprecationWarning: ((message: string, source?: object) => void)[] = [console.warn]\n\n  /**\n   * If `true`, mouse wheel events will be interpreted as trackpad gestures.\n   * Tested on MacBook M4 Pro.\n   * @default false\n   * @see macGesturesRequireMac\n   */\n  macTrackpadGestures: boolean = false\n\n  /**\n   * If both this setting and {@link macTrackpadGestures} are `true`, trackpad gestures will\n   * only be enabled when the browser user agent includes \"Mac\".\n   * @default true\n   * @see macTrackpadGestures\n   */\n  macGesturesRequireMac: boolean = true\n\n  /**\n   * If `true`, widget labels and values will both be truncated (proportionally to size),\n   * until they fit within the widget.\n   *\n   * Otherwise, the label will be truncated completely before the value is truncated.\n   * @default false\n   */\n  truncateWidgetTextEvenly: boolean = false\n\n  /**\n   * If `true`, widget values will be completely truncated when shrinking a widget,\n   * before truncating widget labels.  {@link truncateWidgetTextEvenly} must be `false`.\n   * @default false\n   */\n  truncateWidgetValuesFirst: boolean = false\n\n  /**\n   * If `true`, the current viewport scale & offset of the first attached canvas will be included with the graph when exporting.\n   * @default true\n   */\n  saveViewportWithGraph: boolean = true\n\n  // TODO: Remove legacy accessors\n  LGraph = LGraph\n  LLink = LLink\n  LGraphNode = LGraphNode\n  LGraphGroup = LGraphGroup\n  DragAndScale = DragAndScale\n  LGraphCanvas = LGraphCanvas\n  ContextMenu = ContextMenu\n  CurveEditor = CurveEditor\n  Reroute = Reroute\n  InputIndicators = InputIndicators\n\n  onNodeTypeRegistered?(type: string, base_class: typeof LGraphNode): void\n  onNodeTypeReplaced?(type: string, base_class: typeof LGraphNode, prev: unknown): void\n\n  /**\n   * Register a node class so it can be listed when the user wants to create a new one\n   * @param type name of the node and path\n   * @param base_class class containing the structure of a node\n   */\n  registerNodeType(type: string, base_class: typeof LGraphNode): void {\n    if (!base_class.prototype)\n      throw \"Cannot register a simple object, it must be a class with a prototype\"\n    base_class.type = type\n\n    if (this.debug) console.log(\"Node registered:\", type)\n\n    const classname = base_class.name\n\n    const pos = type.lastIndexOf(\"/\")\n    base_class.category = type.substring(0, pos)\n\n    base_class.title ||= classname\n\n    // extend class\n    for (const i in LGraphNode.prototype) {\n      // @ts-expect-error #576 This functionality is deprecated and should be removed.\n      base_class.prototype[i] ||= LGraphNode.prototype[i]\n    }\n\n    const prev = this.registered_node_types[type]\n    if (prev && this.debug) {\n      console.log(\"replacing node type:\", type)\n    }\n\n    this.registered_node_types[type] = base_class\n    if (base_class.constructor.name) this.Nodes[classname] = base_class\n\n    this.onNodeTypeRegistered?.(type, base_class)\n    if (prev) this.onNodeTypeReplaced?.(type, base_class, prev)\n\n    // warnings\n    if (base_class.prototype.onPropertyChange)\n      console.warn(`LiteGraph node class ${type} has onPropertyChange method, it must be called onPropertyChanged with d at the end`)\n\n    // TODO one would want to know input and ouput :: this would allow through registerNodeAndSlotType to get all the slots types\n    if (this.auto_load_slot_types) new base_class(base_class.title || \"tmpnode\")\n  }\n\n  /**\n   * removes a node type from the system\n   * @param type name of the node or the node constructor itself\n   */\n  unregisterNodeType(type: string | typeof LGraphNode): void {\n    const base_class = typeof type === \"string\"\n      ? this.registered_node_types[type]\n      : type\n    if (!base_class) throw `node type not found: ${String(type)}`\n\n    delete this.registered_node_types[String(base_class.type)]\n\n    const name = base_class.constructor.name\n    if (name) delete this.Nodes[name]\n  }\n\n  /**\n   * Save a slot type and his node\n   * @param type name of the node or the node constructor itself\n   * @param slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..\n   */\n  registerNodeAndSlotType(\n    type: LGraphNode,\n    slot_type: ISlotType,\n    out?: boolean,\n  ): void {\n    out ||= false\n    // @ts-expect-error Confirm this function no longer supports string types - base_class should always be an instance not a constructor.\n    const base_class = typeof type === \"string\" && this.registered_node_types[type] !== \"anonymous\"\n      ? this.registered_node_types[type]\n      : type\n\n    // @ts-expect-error Confirm this function no longer supports string types - base_class should always be an instance not a constructor.\n    const class_type = base_class.constructor.type\n\n    let allTypes = []\n    if (typeof slot_type === \"string\") {\n      allTypes = slot_type.split(\",\")\n    } else if (slot_type == this.EVENT || slot_type == this.ACTION) {\n      allTypes = [\"_event_\"]\n    } else {\n      allTypes = [\"*\"]\n    }\n\n    for (let slotType of allTypes) {\n      if (slotType === \"\") slotType = \"*\"\n\n      const register = out\n        ? this.registered_slot_out_types\n        : this.registered_slot_in_types\n      register[slotType] ??= { nodes: [] }\n\n      const { nodes } = register[slotType]\n      if (!nodes.includes(class_type)) nodes.push(class_type)\n\n      // check if is a new type\n      const types = out\n        ? this.slot_types_out\n        : this.slot_types_in\n      const type = slotType.toLowerCase()\n\n      if (!types.includes(type)) {\n        types.push(type)\n        types.sort()\n      }\n    }\n  }\n\n  /**\n   * Removes all previously registered node's types\n   */\n  clearRegisteredTypes(): void {\n    this.registered_node_types = {}\n    this.node_types_by_file_extension = {}\n    this.Nodes = {}\n    this.searchbox_extras = {}\n  }\n\n  /**\n   * Create a node of a given type with a name. The node is not attached to any graph yet.\n   * @param type full name of the node class. p.e. \"math/sin\"\n   * @param title a name to distinguish from other nodes\n   * @param options to set options\n   */\n  createNode(\n    type: string,\n    title?: string,\n    options?: Dictionary<unknown>,\n  ): LGraphNode | null {\n    const base_class = this.registered_node_types[type]\n    if (!base_class) {\n      if (this.debug) console.log(`GraphNode type \"${type}\" not registered.`)\n      return null\n    }\n\n    title = title || base_class.title || type\n\n    let node = null\n\n    if (this.catch_exceptions) {\n      try {\n        node = new base_class(title)\n      } catch (error) {\n        console.error(error)\n        return null\n      }\n    } else {\n      node = new base_class(title)\n    }\n\n    node.type = type\n\n    if (!node.title && title) node.title = title\n    node.properties ||= {}\n    node.properties_info ||= []\n    node.flags ||= {}\n    // call onresize?\n    node.size ||= node.computeSize()\n    node.pos ||= [this.DEFAULT_POSITION[0], this.DEFAULT_POSITION[1]]\n    node.mode ||= LGraphEventMode.ALWAYS\n\n    // extra options\n    if (options) {\n      for (const i in options) {\n        // @ts-expect-error #577 Requires interface\n        node[i] = options[i]\n      }\n    }\n\n    // callback\n    node.onNodeCreated?.()\n    return node\n  }\n\n  /**\n   * Returns a registered node type with a given name\n   * @param type full name of the node class. p.e. \"math/sin\"\n   * @returns the node class\n   */\n  getNodeType(type: string): typeof LGraphNode {\n    return this.registered_node_types[type]\n  }\n\n  /**\n   * Returns a list of node types matching one category\n   * @param category category name\n   * @returns array with all the node classes\n   */\n  getNodeTypesInCategory(category: string, filter?: string) {\n    const r = []\n    for (const i in this.registered_node_types) {\n      const type = this.registered_node_types[i]\n      if (type.filter != filter) continue\n\n      if (category == \"\") {\n        if (type.category == null) r.push(type)\n      } else if (type.category == category) {\n        r.push(type)\n      }\n    }\n\n    return r\n  }\n\n  /**\n   * Returns a list with all the node type categories\n   * @param filter only nodes with ctor.filter equal can be shown\n   * @returns array with all the names of the categories\n   */\n  getNodeTypesCategories(filter?: string): string[] {\n    const categories: Dictionary<number> = { \"\": 1 }\n    for (const i in this.registered_node_types) {\n      const type = this.registered_node_types[i]\n      if (type.category && !type.skip_list) {\n        if (type.filter != filter) continue\n\n        categories[type.category] = 1\n      }\n    }\n    const result = []\n    for (const i in categories) {\n      result.push(i)\n    }\n    return result\n  }\n\n  // debug purposes: reloads all the js scripts that matches a wildcard\n  reloadNodes(folder_wildcard: string): void {\n    const tmp = document.getElementsByTagName(\"script\")\n    // weird, this array changes by its own, so we use a copy\n    const script_files = []\n    for (const element of tmp) {\n      script_files.push(element)\n    }\n\n    const docHeadObj = document.getElementsByTagName(\"head\")[0]\n    folder_wildcard = document.location.href + folder_wildcard\n\n    for (const script_file of script_files) {\n      const src = script_file.src\n      if (!src || src.substr(0, folder_wildcard.length) != folder_wildcard)\n        continue\n\n      try {\n        if (this.debug) console.log(\"Reloading:\", src)\n        const dynamicScript = document.createElement(\"script\")\n        dynamicScript.type = \"text/javascript\"\n        dynamicScript.src = src\n        docHeadObj.append(dynamicScript)\n        script_file.remove()\n      } catch (error) {\n        if (this.throw_errors) throw error\n        if (this.debug) console.log(\"Error while reloading\", src)\n      }\n    }\n\n    if (this.debug) console.log(\"Nodes reloaded\")\n  }\n\n  // separated just to improve if it doesn't work\n  /** @deprecated Prefer {@link structuredClone} */\n  cloneObject<T extends object | undefined | null>(obj: T, target?: T): WhenNullish<T, null> {\n    if (obj == null) return null as WhenNullish<T, null>\n\n    const r = JSON.parse(JSON.stringify(obj))\n    if (!target) return r\n\n    for (const i in r) {\n      // @ts-expect-error deprecated\n      target[i] = r[i]\n    }\n    return target\n  }\n\n  /** @see {@link createUuidv4} @inheritdoc */\n  uuidv4 = createUuidv4\n\n  /**\n   * Returns if the types of two slots are compatible (taking into account wildcards, etc)\n   * @param type_a output\n   * @param type_b input\n   * @returns true if they can be connected\n   */\n  isValidConnection(type_a: ISlotType, type_b: ISlotType): boolean {\n    if (type_a == \"\" || type_a === \"*\") type_a = 0\n    if (type_b == \"\" || type_b === \"*\") type_b = 0\n    // If generic in/output, matching types (valid for triggers), or event/action types\n    if (\n      !type_a ||\n      !type_b ||\n      type_a == type_b ||\n      (type_a == this.EVENT && type_b == this.ACTION)\n    ) {\n      return true\n    }\n\n    // Enforce string type to handle toLowerCase call (-1 number not ok)\n    type_a = String(type_a)\n    type_b = String(type_b)\n    type_a = type_a.toLowerCase()\n    type_b = type_b.toLowerCase()\n\n    // For nodes supporting multiple connection types\n    if (!type_a.includes(\",\") && !type_b.includes(\",\"))\n      return type_a == type_b\n\n    // Check all permutations to see if one is valid\n    const supported_types_a = type_a.split(\",\")\n    const supported_types_b = type_b.split(\",\")\n    for (const a of supported_types_a) {\n      for (const b of supported_types_b) {\n        if (this.isValidConnection(a, b))\n          return true\n      }\n    }\n\n    return false\n  }\n\n  // used to create nodes from wrapping functions\n  getParameterNames(func: (...args: any) => any): string[] {\n    return String(func)\n      .replaceAll(/\\/\\/.*$/gm, \"\") // strip single-line comments\n      .replaceAll(/\\s+/g, \"\") // strip white space\n      .replaceAll(/\\/\\*[^*/]*\\*\\//g, \"\") // strip multi-line comments  /**/\n      .split(\"){\", 1)[0]\n      .replace(/^[^(]*\\(/, \"\") // extract the parameters\n      .replaceAll(/=[^,]+/g, \"\") // strip any ES6 defaults\n      .split(\",\")\n      .filter(Boolean) // split & filter [\"\"]\n  }\n\n  /* helper for interaction: pointer, touch, mouse Listeners\n    used by LGraphCanvas DragAndScale ContextMenu */\n  pointerListenerAdd(oDOM: Node, sEvIn: string, fCall: (e: Event) => boolean | void, capture = false): void {\n    if (!oDOM || !oDOM.addEventListener || !sEvIn || typeof fCall !== \"function\") return\n\n    let sMethod = this.pointerevents_method\n    let sEvent = sEvIn\n\n    // UNDER CONSTRUCTION\n    // convert pointerevents to touch event when not available\n    if (sMethod == \"pointer\" && !window.PointerEvent) {\n      console.warn(\"sMethod=='pointer' && !window.PointerEvent\")\n      console.log(`Converting pointer[${sEvent}] : down move up cancel enter TO touchstart touchmove touchend, etc ..`)\n      switch (sEvent) {\n      case \"down\": {\n        sMethod = \"touch\"\n        sEvent = \"start\"\n        break\n      }\n      case \"move\": {\n        sMethod = \"touch\"\n        // sEvent = \"move\";\n        break\n      }\n      case \"up\": {\n        sMethod = \"touch\"\n        sEvent = \"end\"\n        break\n      }\n      case \"cancel\": {\n        sMethod = \"touch\"\n        // sEvent = \"cancel\";\n        break\n      }\n      case \"enter\": {\n        console.log(\"debug: Should I send a move event?\") // ???\n        break\n      }\n      // case \"over\": case \"out\": not used at now\n      default: {\n        console.warn(`PointerEvent not available in this browser ? The event ${sEvent} would not be called`)\n      }\n      }\n    }\n\n    switch (sEvent) {\n    // @ts-expect-error\n    // both pointer and move events\n    case \"down\": case \"up\": case \"move\": case \"over\": case \"out\": case \"enter\":\n    {\n      oDOM.addEventListener(sMethod + sEvent, fCall, capture)\n    }\n    // @ts-expect-error\n    // only pointerevents\n    case \"leave\": case \"cancel\": case \"gotpointercapture\": case \"lostpointercapture\":\n    {\n      if (sMethod != \"mouse\") {\n        return oDOM.addEventListener(sMethod + sEvent, fCall, capture)\n      }\n    }\n    // not \"pointer\" || \"mouse\"\n    default:\n      return oDOM.addEventListener(sEvent, fCall, capture)\n    }\n  }\n\n  pointerListenerRemove(oDOM: Node, sEvent: string, fCall: (e: Event) => boolean | void, capture = false): void {\n    if (!oDOM || !oDOM.removeEventListener || !sEvent || typeof fCall !== \"function\") return\n\n    switch (sEvent) {\n    // @ts-expect-error\n    // both pointer and move events\n    case \"down\": case \"up\": case \"move\": case \"over\": case \"out\": case \"enter\":\n    {\n      if (this.pointerevents_method == \"pointer\" || this.pointerevents_method == \"mouse\") {\n        oDOM.removeEventListener(this.pointerevents_method + sEvent, fCall, capture)\n      }\n    }\n    // @ts-expect-error\n    // only pointerevents\n    case \"leave\": case \"cancel\": case \"gotpointercapture\": case \"lostpointercapture\":\n    {\n      if (this.pointerevents_method == \"pointer\") {\n        return oDOM.removeEventListener(this.pointerevents_method + sEvent, fCall, capture)\n      }\n    }\n    // not \"pointer\" || \"mouse\"\n    default:\n      return oDOM.removeEventListener(sEvent, fCall, capture)\n    }\n  }\n\n  getTime(): number {\n    return performance.now()\n  }\n\n  distance = distance\n\n  colorToString(c: [number, number, number, number]): string {\n    return (\n      `rgba(${\n        Math.round(c[0] * 255).toFixed()\n      },${\n        Math.round(c[1] * 255).toFixed()\n      },${\n        Math.round(c[2] * 255).toFixed()\n      },${\n        c.length == 4 ? c[3].toFixed(2) : \"1.0\"\n      })`\n    )\n  }\n\n  isInsideRectangle = isInsideRectangle\n\n  // [minx,miny,maxx,maxy]\n  growBounding(bounding: Rect, x: number, y: number): void {\n    if (x < bounding[0]) {\n      bounding[0] = x\n    } else if (x > bounding[2]) {\n      bounding[2] = x\n    }\n\n    if (y < bounding[1]) {\n      bounding[1] = y\n    } else if (y > bounding[3]) {\n      bounding[3] = y\n    }\n  }\n\n  overlapBounding = overlapBounding\n\n  // point inside bounding box\n  isInsideBounding(p: number[], bb: number[][]): boolean {\n    if (\n      p[0] < bb[0][0] ||\n      p[1] < bb[0][1] ||\n      p[0] > bb[1][0] ||\n      p[1] > bb[1][1]\n    ) {\n      return false\n    }\n    return true\n  }\n\n  // Convert a hex value to its decimal value - the inputted hex must be in the\n  // format of a hex triplet - the kind we use for HTML colours. The function\n  // will return an array with three values.\n  hex2num(hex: string): number[] {\n    if (hex.charAt(0) == \"#\") {\n      hex = hex.slice(1)\n    // Remove the '#' char - if there is one.\n    }\n    hex = hex.toUpperCase()\n    const hex_alphabets = \"0123456789ABCDEF\"\n    const value = new Array(3)\n    let k = 0\n    let int1, int2\n    for (let i = 0; i < 6; i += 2) {\n      int1 = hex_alphabets.indexOf(hex.charAt(i))\n      int2 = hex_alphabets.indexOf(hex.charAt(i + 1))\n      value[k] = int1 * 16 + int2\n      k++\n    }\n    return value\n  }\n\n  // Give a array with three values as the argument and the function will return\n  // the corresponding hex triplet.\n  num2hex(triplet: number[]): string {\n    const hex_alphabets = \"0123456789ABCDEF\"\n    let hex = \"#\"\n    let int1, int2\n    for (let i = 0; i < 3; i++) {\n      int1 = triplet[i] / 16\n      int2 = triplet[i] % 16\n\n      hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2)\n    }\n    return hex\n  }\n\n  closeAllContextMenus(ref_window: Window = window): void {\n    const elements = [...ref_window.document.querySelectorAll(\".litecontextmenu\")]\n    if (!elements.length) return\n\n    for (const element of elements) {\n      if (\"close\" in element && typeof element.close === \"function\") {\n        element.close()\n      } else {\n        element.remove()\n      }\n    }\n  }\n\n  extendClass(target: any, origin: any): void {\n    for (const i in origin) {\n      // copy class properties\n      if (target.hasOwnProperty(i)) continue\n      target[i] = origin[i]\n    }\n\n    if (origin.prototype) {\n      // copy prototype properties\n      for (const i in origin.prototype) {\n        // only enumerable\n        if (!origin.prototype.hasOwnProperty(i)) continue\n\n        // avoid overwriting existing ones\n        if (target.prototype.hasOwnProperty(i)) continue\n\n        // copy getters\n        if (origin.prototype.__lookupGetter__(i)) {\n          target.prototype.__defineGetter__(\n            i,\n            origin.prototype.__lookupGetter__(i),\n          )\n        } else {\n          target.prototype[i] = origin.prototype[i]\n        }\n\n        // and setters\n        if (origin.prototype.__lookupSetter__(i)) {\n          target.prototype.__defineSetter__(\n            i,\n            origin.prototype.__lookupSetter__(i),\n          )\n        }\n      }\n    }\n  }\n}\n","// @ts-expect-error Polyfill\nSymbol.dispose ??= Symbol(\"Symbol.dispose\")\n// @ts-expect-error Polyfill\nSymbol.asyncDispose ??= Symbol(\"Symbol.asyncDispose\")\n\n// API *************************************************\n// like rect but rounded corners\nexport function loadPolyfills() {\n  if (\n    typeof window != \"undefined\" &&\n    window.CanvasRenderingContext2D &&\n    !window.CanvasRenderingContext2D.prototype.roundRect\n  ) {\n    // @ts-expect-error Slightly broken polyfill - radius_low not impl. anywhere\n    window.CanvasRenderingContext2D.prototype.roundRect = function (\n      x: number,\n      y: number,\n      w: number,\n      h: number,\n      radius: number | number[],\n      radius_low: number | number[],\n    ) {\n      let top_left_radius = 0\n      let top_right_radius = 0\n      let bottom_left_radius = 0\n      let bottom_right_radius = 0\n\n      if (radius === 0) {\n        this.rect(x, y, w, h)\n        return\n      }\n\n      if (radius_low === undefined) radius_low = radius\n\n      // make it compatible with official one\n      if (Array.isArray(radius)) {\n        if (radius.length == 1) {\n          top_left_radius = top_right_radius = bottom_left_radius = bottom_right_radius = radius[0]\n        } else if (radius.length == 2) {\n          top_left_radius = bottom_right_radius = radius[0]\n          top_right_radius = bottom_left_radius = radius[1]\n        } else if (radius.length == 4) {\n          top_left_radius = radius[0]\n          top_right_radius = radius[1]\n          bottom_left_radius = radius[2]\n          bottom_right_radius = radius[3]\n        } else {\n          return\n        }\n      } else {\n        // old using numbers\n        top_left_radius = radius || 0\n        top_right_radius = radius || 0\n\n        const low = !Array.isArray(radius_low) && radius_low ? radius_low : 0\n        bottom_left_radius = low\n        bottom_right_radius = low\n      }\n\n      // top right\n      this.moveTo(x + top_left_radius, y)\n      this.lineTo(x + w - top_right_radius, y)\n      this.quadraticCurveTo(x + w, y, x + w, y + top_right_radius)\n\n      // bottom right\n      this.lineTo(x + w, y + h - bottom_right_radius)\n      this.quadraticCurveTo(\n        x + w,\n        y + h,\n        x + w - bottom_right_radius,\n        y + h,\n      )\n\n      // bottom left\n      this.lineTo(x + bottom_right_radius, y + h)\n      this.quadraticCurveTo(x, y + h, x, y + h - bottom_left_radius)\n\n      // top left\n      this.lineTo(x, y + bottom_left_radius)\n      this.quadraticCurveTo(x, y, x + top_left_radius, y)\n    }\n  }\n\n  if (typeof window != \"undefined\" && !window[\"requestAnimationFrame\"]) {\n    window.requestAnimationFrame =\n      // @ts-expect-error Legacy code\n      window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame ||\n      function (callback) {\n        window.setTimeout(callback, 1000 / 60)\n      }\n  }\n}\n","import type { ContextMenu } from \"./ContextMenu\"\nimport type { ConnectingLink, Point } from \"./interfaces\"\nimport type {\n  IContextMenuOptions,\n  INodeSlot,\n  Size,\n} from \"./interfaces\"\nimport type { LGraphNode } from \"./LGraphNode\"\nimport type { CanvasEventDetail } from \"./types/events\"\nimport type { RenderShape, TitleMode } from \"./types/globalEnums\"\n\n// Must remain above LiteGraphGlobal (circular dependency due to abstract factory behaviour in `configure`)\nexport { Subgraph } from \"./subgraph/Subgraph\"\n\nimport { LiteGraphGlobal } from \"./LiteGraphGlobal\"\nimport { loadPolyfills } from \"./polyfills\"\n\nexport const LiteGraph = new LiteGraphGlobal()\n\n// Load legacy polyfills\nloadPolyfills()\n\n// Backwards compat\n\n// Type definitions for litegraph.js 0.7.0\n// Project: litegraph.js\n// Definitions by: NateScarlet <https://github.com/NateScarlet>\n/** @deprecated Use {@link Point} instead. */\nexport type Vector2 = Point\n/** @deprecated Use {@link Rect} instead. */\nexport type Vector4 = [number, number, number, number]\n\nexport interface IContextMenuItem {\n  content: string\n  callback?: ContextMenuEventListener\n  /** Used as innerHTML for extra child element */\n  title?: string\n  disabled?: boolean\n  has_submenu?: boolean\n  submenu?: {\n    options: IContextMenuItem[]\n  } & IContextMenuOptions\n  className?: string\n}\n\nexport type ContextMenuEventListener = (\n  value: IContextMenuItem,\n  options: IContextMenuOptions,\n  event: MouseEvent,\n  parentMenu: ContextMenu<unknown> | undefined,\n  node: LGraphNode,\n) => boolean | void\n\nexport interface LinkReleaseContext {\n  node_to?: LGraphNode\n  node_from?: LGraphNode\n  slot_from: INodeSlot\n  type_filter_in?: string\n  type_filter_out?: string\n}\n\nexport interface LinkReleaseContextExtended {\n  links: ConnectingLink[]\n}\n\nexport interface LiteGraphCanvasEvent extends CustomEvent<CanvasEventDetail> {}\n\nexport interface LGraphNodeConstructor<T extends LGraphNode = LGraphNode> {\n  new (title: string, type?: string): T\n\n  title: string\n  type: string\n  size?: Size\n  min_height?: number\n  slot_start_y?: number\n  widgets_info?: any\n  collapsable?: boolean\n  color?: string\n  bgcolor?: string\n  shape?: RenderShape\n  title_mode?: TitleMode\n  title_color?: string\n  title_text_color?: string\n  keepAllLinksOnBypass: boolean\n}\n\n// End backwards compat\n\nexport { InputIndicators } from \"./canvas/InputIndicators\"\nexport { isOverNodeInput, isOverNodeOutput } from \"./canvas/measureSlots\"\nexport { CanvasPointer } from \"./CanvasPointer\"\nexport { ContextMenu } from \"./ContextMenu\"\nexport { CurveEditor } from \"./CurveEditor\"\nexport { DragAndScale } from \"./DragAndScale\"\nexport { LabelPosition, SlotDirection, SlotShape, SlotType } from \"./draw\"\nexport { strokeShape } from \"./draw\"\nexport { Rectangle } from \"./infrastructure/Rectangle\"\nexport type {\n  CanvasColour,\n  ColorOption,\n  ConnectingLink,\n  Direction,\n  IBoundaryNodes,\n  IColorable,\n  IContextMenuOptions,\n  IContextMenuValue,\n  IFoundSlot,\n  IInputOrOutput,\n  INodeFlags,\n  INodeInputSlot,\n  INodeOutputSlot,\n  INodeSlot,\n  ISlotType,\n  KeysOfType,\n  LinkNetwork,\n  LinkSegment,\n  MethodNames,\n  PickByType,\n  Point,\n  Positionable,\n  ReadonlyLinkNetwork,\n  ReadOnlyPoint,\n  ReadOnlyRect,\n  Rect,\n  Size,\n} from \"./interfaces\"\nexport { LGraph } from \"./LGraph\"\nexport { BadgePosition, LGraphBadge, type LGraphBadgeOptions } from \"./LGraphBadge\"\nexport { LGraphCanvas, type LGraphCanvasState } from \"./LGraphCanvas\"\nexport { LGraphGroup } from \"./LGraphGroup\"\nexport { LGraphNode, type NodeId } from \"./LGraphNode\"\nexport { type LinkId, LLink } from \"./LLink\"\nexport { clamp, createBounds } from \"./measure\"\nexport { Reroute, type RerouteId } from \"./Reroute\"\nexport type { CanvasPointerEvent } from \"./types/events\"\nexport {\n  CanvasItem,\n  EaseFunction,\n  LGraphEventMode,\n  LinkMarkerShape,\n  RenderShape,\n  TitleMode,\n} from \"./types/globalEnums\"\nexport type {\n  ExportedSubgraph,\n  ExportedSubgraphInstance,\n  ExportedSubgraphIONode,\n  ISerialisedGraph,\n  SerialisableGraph,\n  SerialisableLLink,\n  SubgraphIO,\n} from \"./types/serialisation\"\nexport type { IWidget } from \"./types/widgets\"\nexport { isColorable } from \"./utils/type\"\nexport { createUuidv4 } from \"./utils/uuid\"\nexport { BaseSteppedWidget } from \"./widgets/BaseSteppedWidget\"\nexport { BaseWidget } from \"./widgets/BaseWidget\"\nexport { BooleanWidget } from \"./widgets/BooleanWidget\"\nexport { ButtonWidget } from \"./widgets/ButtonWidget\"\nexport { ComboWidget } from \"./widgets/ComboWidget\"\nexport { KnobWidget } from \"./widgets/KnobWidget\"\nexport { LegacyWidget } from \"./widgets/LegacyWidget\"\nexport { NumberWidget } from \"./widgets/NumberWidget\"\nexport { SliderWidget } from \"./widgets/SliderWidget\"\nexport { TextWidget } from \"./widgets/TextWidget\"\nexport { isComboWidget } from \"./widgets/widgetMap\"\n"],"names":["NodeSlotType","RenderShape","CanvasItem","LinkDirection","LinkRenderType","LinkMarkerShape","TitleMode","LGraphEventMode","EaseFunction","node","reroute","e","x","width","SlotType","SlotShape","SlotDirection","LabelPosition","height","BadgePosition","canvas","v","delta","gradient","newValue","minWidth","widgetWidth","link","graph","network","value","prev_menu","entries","document","window","pointer","pos","options","str_value","name","data","y","type"],"mappings":"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"}