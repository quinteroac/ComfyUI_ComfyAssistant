import { CanvasColour, INodeInputSlot, INodeOutputSlot, LinkNetwork, LinkSegment, Point, Positionable, ReadonlyLinkNetwork, ReadOnlyRect } from './interfaces';
import { LGraphNode, NodeId } from './LGraphNode';
import { Serialisable, SerialisableReroute } from './types/serialisation';
import { LinkId, LLink } from './LLink';
export type RerouteId = number;
/** The input or output slot that an incomplete reroute link is connected to. */
export interface FloatingRerouteSlot {
    /** Floating connection to an input or output */
    slotType: "input" | "output";
}
/**
 * Represents an additional point on the graph that a link path will travel through.  Used for visual organisation only.
 *
 * Requires no disposal or clean up.
 * Stores only primitive values (IDs) to reference other items in its network,
 * and a `WeakRef` to a {@link LinkNetwork} to resolve them.
 */
export declare class Reroute implements Positionable, LinkSegment, Serialisable<SerialisableReroute> {
    #private;
    readonly id: RerouteId;
    static radius: number;
    /** Maximum distance from reroutes to their bezier curve control points. */
    static maxSplineOffset: number;
    static drawIdBadge: boolean;
    static slotRadius: number;
    /** Distance from reroute centre to slot centre. */
    static get slotOffset(): number;
    get parentId(): RerouteId | undefined;
    /** Ignores attempts to create an infinite loop. @inheritdoc */
    set parentId(value: RerouteId | undefined);
    get parent(): Reroute | undefined;
    /** This property is only defined on the last reroute of a floating reroute chain (closest to input end). */
    floating?: FloatingRerouteSlot;
    /** @inheritdoc */
    get pos(): Point;
    set pos(value: Point);
    /** @inheritdoc */
    get boundingRect(): ReadOnlyRect;
    /** The total number of links & floating links using this reroute */
    get totalLinks(): number;
    /** @inheritdoc */
    selected?: boolean;
    /** The ID ({@link LLink.id}) of every link using this reroute */
    linkIds: Set<LinkId>;
    /** The ID ({@link LLink.id}) of every floating link using this reroute */
    floatingLinkIds: Set<LinkId>;
    /** Cached cos */
    cos: number;
    sin: number;
    /** Bezier curve control point for the "target" (input) side of the link */
    controlPoint: Point;
    /** @inheritdoc */
    path?: Path2D;
    /** @inheritdoc */
    _centreAngle?: number;
    /** @inheritdoc */
    _pos: Float32Array;
    /** @inheritdoc */
    _dragging?: boolean;
    /** Colour of the first link that rendered this reroute */
    _colour?: CanvasColour;
    /** Colour of the first link that rendered this reroute */
    get colour(): CanvasColour;
    get isSlotHovered(): boolean;
    get isInputHovered(): boolean;
    get isOutputHovered(): boolean;
    get firstLink(): LLink | undefined;
    get firstFloatingLink(): LLink | undefined;
    /** @inheritdoc */
    get origin_id(): NodeId | undefined;
    /** @inheritdoc */
    get origin_slot(): number | undefined;
    /**
     * Initialises a new link reroute object.
     * @param id Unique identifier for this reroute
     * @param network The network of links this reroute belongs to.  Internally converted to a WeakRef.
     * @param pos Position in graph coordinates
     * @param linkIds Link IDs ({@link LLink.id}) of all links that use this reroute
     */
    constructor(id: RerouteId, network: LinkNetwork, pos?: Point, parentId?: RerouteId, linkIds?: Iterable<LinkId>, floatingLinkIds?: Iterable<LinkId>);
    /**
     * Applies a new parentId to the reroute, and optinoally a new position and linkId.
     * Primarily used for deserialisation.
     * @param parentId The ID of the reroute prior to this reroute, or
     * `undefined` if it is the first reroute connected to a nodes output
     * @param pos The position of this reroute
     * @param linkIds All link IDs that pass through this reroute
     */
    update(parentId: RerouteId | undefined, pos?: Point, linkIds?: Iterable<LinkId>, floating?: FloatingRerouteSlot): void;
    /**
     * Validates the linkIds this reroute has.  Removes broken links.
     * @param links Collection of valid links
     * @returns true if any links remain after validation
     */
    validateLinks(links: ReadonlyMap<LinkId, LLink>, floatingLinks: ReadonlyMap<LinkId, LLink>): boolean;
    /**
     * Retrieves an ordered array of all reroutes from the node output.
     * @param visited Internal.  A set of reroutes that this function
     * has already visited whilst recursing up the chain.
     * @returns An ordered array of all reroutes from the node output to this reroute, inclusive.
     * `null` if an infinite loop is detected.
     * `undefined` if the reroute chain or {@link LinkNetwork} are invalid.
     */
    getReroutes(visited?: Set<Reroute>): Reroute[] | null;
    /**
     * Internal.  Called by {@link LLink.findNextReroute}.  Not intended for use by itself.
     * @param withParentId The rerouteId to look for
     * @param visited A set of reroutes that have already been visited
     * @returns The reroute that was found, `undefined` if no reroute was found, or `null` if an infinite loop was detected.
     */
    findNextReroute(withParentId: RerouteId, visited?: Set<Reroute>): Reroute | null | undefined;
    /**
     * Finds the output node and output slot of the first link passing through this reroute.
     * @returns The output node and output slot of the first link passing through this reroute, or `undefined` if no link is found.
     */
    findSourceOutput(): {
        node: LGraphNode;
        output: INodeOutputSlot;
    } | undefined;
    /**
     * Finds the inputs and nodes of (floating) links passing through this reroute.
     * @returns An array of objects containing the node and input slot of each link passing through this reroute.
     */
    findTargetInputs(): {
        node: LGraphNode;
        input: INodeInputSlot;
        link: LLink;
    }[] | undefined;
    /**
     * Retrieves all floating links passing through this reroute.
     * @param from Filters the links by the currently connected link side.
     * @returns An array of floating links
     */
    getFloatingLinks(from: "input" | "output"): LLink[] | undefined;
    /**
     * Changes the origin node/output of all floating links that pass through this reroute.
     * @param node The new origin node
     * @param output The new origin output slot
     * @param index The slot index of {@link output}
     */
    setFloatingLinkOrigin(node: LGraphNode, output: INodeOutputSlot, index: number): void;
    /** @inheritdoc */
    move(deltaX: number, deltaY: number): void;
    /** @inheritdoc */
    snapToGrid(snapTo: number): boolean;
    removeAllFloatingLinks(): void;
    removeFloatingLink(linkId: LinkId): void;
    /**
     * Removes a link or floating link from this reroute, by matching link object instance equality.
     * @param link The link to remove.
     * @remarks Does not remove the link from the network.
     */
    removeLink(link: LLink): void;
    remove(): void;
    calculateAngle(lastRenderTime: number, network: ReadonlyLinkNetwork, linkStart: Point): void;
    /**
     * Renders the reroute on the canvas.
     * @param ctx Canvas context to draw on
     * @param backgroundPattern The canvas background pattern; used to make floating reroutes appear washed out.
     * @remarks Leaves {@link ctx}.fillStyle, strokeStyle, and lineWidth dirty (perf.).
     */
    draw(ctx: CanvasRenderingContext2D, backgroundPattern?: CanvasPattern): void;
    /**
     * Draws the input and output slots on the canvas, if the slots are visible.
     * @param ctx The canvas context to draw on.
     */
    drawSlots(ctx: CanvasRenderingContext2D): void;
    drawHighlight(ctx: CanvasRenderingContext2D, colour: CanvasColour): void;
    /**
     * Updates visibility of the input and output slots, based on the position of the pointer.
     * @param pos The position of the pointer.
     * @returns `true` if any changes require a redraw.
     */
    updateVisibility(pos: Point): boolean;
    /** Prevents rendering of the input and output slots. */
    hideSlots(): void;
    /**
     * Precisely determines if {@link pos} is inside this reroute.
     * @param pos The position to check (canvas space)
     * @returns `true` if {@link pos} is within the reroute's radius.
     */
    containsPoint(pos: Point): boolean;
    /** @inheritdoc */
    asSerialisable(): SerialisableReroute;
}
