import { ConnectingLink, INodeInputSlot, INodeOutputSlot, ISlotType, Positionable } from '../interfaces';
import { LinkId } from '../LLink';
import { IGenericLinkOrLinks, LGraphNode } from '../LGraphNode';
/**
 * Creates a flat set of all positionable items by recursively iterating through all child items.
 *
 * Does not include or recurse into pinned items.
 * @param items The original set of items to iterate through
 * @returns All unpinned items in the original set, and recursively, their children
 */
export declare function getAllNestedItems(items: ReadonlySet<Positionable>): Set<Positionable>;
/**
 * Iterates through a collection of {@link Positionable} items, returning the first {@link LGraphNode}.
 * @param items The items to search through
 * @returns The first node found in {@link items}, otherwise `undefined`
 */
export declare function findFirstNode(items: Iterable<Positionable>): LGraphNode | undefined;
/** @returns `true` if the provided link ID is currently being dragged. */
export declare function isDraggingLink(linkId: LinkId, connectingLinks: ConnectingLink[] | null | undefined): ConnectingLink | undefined;
type InputOrOutput = (INodeInputSlot | INodeOutputSlot) & IGenericLinkOrLinks;
type FreeSlotResult<T extends InputOrOutput> = {
    index: number;
    slot: T;
} | undefined;
/**
 * Finds the first free in/out slot with any of the comma-delimited types in {@link type}.
 *
 * If no slots are free, falls back in order to:
 * - The first free wildcard slot
 * - The first occupied slot
 * - The first occupied wildcard slot
 * @param slots The iterable of node slots slots to search through
 * @param type The {@link ISlotType type} of slot to find
 * @returns The index and slot if found, otherwise `undefined`.
 */
export declare function findFreeSlotOfType<T extends InputOrOutput>(slots: T[], type: ISlotType): FreeSlotResult<T>;
export {};
