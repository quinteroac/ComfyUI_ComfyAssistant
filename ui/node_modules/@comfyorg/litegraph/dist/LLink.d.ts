import { CanvasColour, INodeInputSlot, INodeOutputSlot, ISlotType, LinkNetwork, LinkSegment, ReadonlyLinkNetwork } from './interfaces';
import { LGraphNode, NodeId } from './LGraphNode';
import { Reroute, RerouteId } from './Reroute';
import { Serialisable, SerialisableLLink } from './types/serialisation';
export type LinkId = number;
export type SerialisedLLinkArray = [
    id: LinkId,
    origin_id: NodeId,
    origin_slot: number,
    target_id: NodeId,
    target_slot: number,
    type: ISlotType
];
export interface ResolvedConnection {
    inputNode: LGraphNode | undefined;
    outputNode: LGraphNode | undefined;
    input: INodeInputSlot | undefined;
    output: INodeOutputSlot | undefined;
    link: LLink;
}
type BasicReadonlyNetwork = Pick<ReadonlyLinkNetwork, "getNodeById" | "links" | "getLink">;
export declare class LLink implements LinkSegment, Serialisable<SerialisableLLink> {
    #private;
    /** Link ID */
    id: LinkId;
    parentId?: RerouteId;
    type: ISlotType;
    /** Output node ID */
    origin_id: NodeId;
    /** Output slot index */
    origin_slot: number;
    /** Input node ID */
    target_id: NodeId;
    /** Input slot index */
    target_slot: number;
    data?: number | string | boolean | {
        toToolTip?(): string;
    };
    _data?: unknown;
    /** Centre point of the link, calculated during render only - can be inaccurate */
    _pos: Float32Array;
    /** @todo Clean up - never implemented in comfy. */
    _last_time?: number;
    /** The last canvas 2D path that was used to render this link */
    path?: Path2D;
    /** @inheritdoc */
    _centreAngle?: number;
    /** @inheritdoc */
    _dragging?: boolean;
    /** Custom colour for this link only */
    get color(): CanvasColour | null | undefined;
    set color(value: CanvasColour);
    get isFloatingOutput(): boolean;
    get isFloatingInput(): boolean;
    get isFloating(): boolean;
    constructor(id: LinkId, type: ISlotType, origin_id: NodeId, origin_slot: number, target_id: NodeId, target_slot: number, parentId?: RerouteId);
    /** @deprecated Use {@link LLink.create} */
    static createFromArray(data: SerialisedLLinkArray): LLink;
    /**
     * LLink static factory: creates a new LLink from the provided data.
     * @param data Serialised LLink data to create the link from
     * @returns A new LLink
     */
    static create(data: SerialisableLLink): LLink;
    /**
     * Gets all reroutes from the output slot to this segment.  If this segment is a reroute, it will not be included.
     * @returns An ordered array of all reroutes from the node output to
     * this reroute or the reroute before it.  Otherwise, an empty array.
     */
    static getReroutes(network: Pick<ReadonlyLinkNetwork, "reroutes">, linkSegment: LinkSegment): Reroute[];
    static getFirstReroute(network: Pick<ReadonlyLinkNetwork, "reroutes">, linkSegment: LinkSegment): Reroute | undefined;
    /**
     * Finds the reroute in the chain after the provided reroute ID.
     * @param network The network this link belongs to
     * @param linkSegment The starting point of the search (input side).
     * Typically the LLink object itself, but can be any link segment.
     * @param rerouteId The matching reroute will have this set as its {@link parentId}.
     * @returns The reroute that was found, `undefined` if no reroute was found, or `null` if an infinite loop was detected.
     */
    static findNextReroute(network: Pick<ReadonlyLinkNetwork, "reroutes">, linkSegment: LinkSegment, rerouteId: RerouteId): Reroute | null | undefined;
    /**
     * Gets the origin node of a link.
     * @param network The network to search
     * @param linkId The ID of the link to get the origin node of
     * @returns The origin node of the link, or `undefined` if the link is not found or the origin node is not found
     */
    static getOriginNode(network: BasicReadonlyNetwork, linkId: LinkId): LGraphNode | undefined;
    /**
     * Gets the target node of a link.
     * @param network The network to search
     * @param linkId The ID of the link to get the target node of
     * @returns The target node of the link, or `undefined` if the link is not found or the target node is not found
     */
    static getTargetNode(network: BasicReadonlyNetwork, linkId: LinkId): LGraphNode | undefined;
    /**
     * Resolves a link ID to the link, node, and slot objects.
     * @param linkId The {@link id} of the link to resolve
     * @param network The link network to search
     * @returns An object containing the input and output nodes, as well as the input and output slots.
     * @remarks This method is heavier than others; it will always resolve all objects.
     * Whilst the performance difference should in most cases be negligible,
     * it is recommended to use simpler methods where appropriate.
     */
    static resolve(linkId: LinkId | null | undefined, network: BasicReadonlyNetwork): ResolvedConnection | undefined;
    /**
     * Resolves a list of link IDs to the link, node, and slot objects.
     * Discards invalid link IDs.
     * @param linkIds An iterable of link {@link id}s to resolve
     * @param network The link network to search
     * @returns An array of resolved connections.  If a link is not found, it is not included in the array.
     * @see {@link LLink.resolve}
     */
    static resolveMany(linkIds: Iterable<LinkId>, network: BasicReadonlyNetwork): ResolvedConnection[];
    /**
     * Resolves the primitive ID values stored in the link to the referenced objects.
     * @param network The link network to search
     * @returns An object containing the input and output nodes, as well as the input and output slots.
     * @remarks This method is heavier than others; it will always resolve all objects.
     * Whilst the performance difference should in most cases be negligible,
     * it is recommended to use simpler methods where appropriate.
     */
    resolve(network: BasicReadonlyNetwork): ResolvedConnection;
    configure(o: LLink | SerialisedLLinkArray): void;
    /**
     * Checks if the specified node id and output index are this link's origin (output side).
     * @param nodeId ID of the node to check
     * @param outputIndex The array index of the node output
     * @returns `true` if the origin matches, otherwise `false`.
     */
    hasOrigin(nodeId: NodeId, outputIndex: number): boolean;
    /**
     * Checks if the specified node id and input index are this link's target (input side).
     * @param nodeId ID of the node to check
     * @param inputIndex The array index of the node input
     * @returns `true` if the target matches, otherwise `false`.
     */
    hasTarget(nodeId: NodeId, inputIndex: number): boolean;
    /**
     * Creates a floating link from this link.
     * @param slotType The side of the link that is still connected
     * @param parentId The parent reroute ID of the link
     * @returns A new LLink that is floating
     */
    toFloating(slotType: "input" | "output", parentId: RerouteId): LLink;
    /**
     * Disconnects a link and removes it from the graph, cleaning up any reroutes that are no longer used
     * @param network The container (LGraph) where reroutes should be updated
     * @param keepReroutes If `undefined`, reroutes will be automatically removed if no links remain.
     * If `input` or `output`, reroutes will not be automatically removed, and retain a connection to the input or output, respectively.
     */
    disconnect(network: LinkNetwork, keepReroutes?: "input" | "output"): void;
    /**
     * @deprecated Prefer {@link LLink.asSerialisable} (returns an object, not an array)
     * @returns An array representing this LLink
     */
    serialize(): SerialisedLLinkArray;
    asSerialisable(): SerialisableLLink;
}
export {};
