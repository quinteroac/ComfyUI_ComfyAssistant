import { RenderLink } from './RenderLink';
import { LinkConnectorEventMap } from '../infrastructure/LinkConnectorEventMap';
import { ConnectingLink, ItemLocator, LinkNetwork, LinkSegment, INodeInputSlot, INodeOutputSlot } from '../interfaces';
import { LGraphNode } from '../LGraphNode';
import { Reroute } from '../Reroute';
import { CanvasPointerEvent } from '../types/events';
import { IBaseWidget } from '../types/widgets';
import { CustomEventTarget } from '../infrastructure/CustomEventTarget';
import { LLink } from '../LLink';
import { FloatingRenderLink } from './FloatingRenderLink';
import { MovingInputLink } from './MovingInputLink';
import { MovingOutputLink } from './MovingOutputLink';
import { ToInputRenderLink } from './ToInputRenderLink';
import { ToOutputRenderLink } from './ToOutputRenderLink';
/**
 * A Litegraph state object for the {@link LinkConnector}.
 * References are only held atomically within a function, never passed.
 * The concrete implementation may be replaced or proxied without side-effects.
 */
export interface LinkConnectorState {
    /**
     * The type of slot that links are being connected **to**.
     * - When `undefined`, no operation is being performed.
     * - A change in this property indicates the start or end of dragging links.
     */
    connectingTo: "input" | "output" | undefined;
    multi: boolean;
    /** When `true`, existing links are being repositioned. Otherwise, new links are being created. */
    draggingExistingLinks: boolean;
    /** When set, connecting links will all snap to this position. */
    snapLinksPos?: [number, number];
}
/** Discriminated union to simplify type narrowing. */
type RenderLinkUnion = MovingInputLink | MovingOutputLink | FloatingRenderLink | ToInputRenderLink | ToOutputRenderLink;
export interface LinkConnectorExport {
    renderLinks: RenderLink[];
    inputLinks: LLink[];
    outputLinks: LLink[];
    floatingLinks: LLink[];
    state: LinkConnectorState;
    network: LinkNetwork;
}
/**
 * Component of {@link LGraphCanvas} that handles connecting and moving links.
 * @see {@link LLink}
 */
export declare class LinkConnector {
    #private;
    /**
     * Link connection state POJO. Source of truth for state of link drag operations.
     *
     * Can be replaced or proxied to allow notifications.
     * Is always dereferenced at the start of an operation.
     */
    state: LinkConnectorState;
    readonly events: CustomEventTarget<LinkConnectorEventMap, "reset" | "before-drop-links" | "after-drop-links" | "before-move-input" | "before-move-output" | "input-moved" | "output-moved" | "link-created" | "dropped-on-reroute" | "dropped-on-node" | "dropped-on-canvas" | "dropped-on-widget">;
    /** Contains information for rendering purposes only. */
    readonly renderLinks: RenderLinkUnion[];
    /** Existing links that are being moved **to** a new input slot. */
    readonly inputLinks: LLink[];
    /** Existing links that are being moved **to** a new output slot. */
    readonly outputLinks: LLink[];
    /** Existing floating links that are being moved to a new slot. */
    readonly floatingLinks: LLink[];
    readonly hiddenReroutes: Set<Reroute>;
    /** The widget beneath the pointer, if it is a valid connection target. */
    overWidget?: IBaseWidget;
    /** The type (returned by downstream callback) for {@link overWidget} */
    overWidgetType?: string;
    /** The reroute beneath the pointer, if it is a valid connection target. */
    overReroute?: Reroute;
    constructor(setConnectingLinks: (value: ConnectingLink[]) => void);
    get isConnecting(): boolean;
    get draggingExistingLinks(): boolean;
    /** Drag an existing link to a different input. */
    moveInputLink(network: LinkNetwork, input: INodeInputSlot): void;
    /** Drag all links from an output to a new output. */
    moveOutputLink(network: LinkNetwork, output: INodeOutputSlot): void;
    /**
     * Drags a new link from an output slot to an input slot.
     * @param network The network that the link being connected belongs to
     * @param node The node the link is being dragged from
     * @param output The output slot that the link is being dragged from
     */
    dragNewFromOutput(network: LinkNetwork, node: LGraphNode, output: INodeOutputSlot, fromReroute?: Reroute): void;
    /**
     * Drags a new link from an input slot to an output slot.
     * @param network The network that the link being connected belongs to
     * @param node The node the link is being dragged from
     * @param input The input slot that the link is being dragged from
     */
    dragNewFromInput(network: LinkNetwork, node: LGraphNode, input: INodeInputSlot, fromReroute?: Reroute): void;
    /**
     * Drags a new link from a reroute to an input slot.
     * @param network The network that the link being connected belongs to
     * @param reroute The reroute that the link is being dragged from
     */
    dragFromReroute(network: LinkNetwork, reroute: Reroute): void;
    /**
     * Drags a new link from a reroute to an output slot.
     * @param network The network that the link being connected belongs to
     * @param reroute The reroute that the link is being dragged from
     */
    dragFromRerouteToOutput(network: LinkNetwork, reroute: Reroute): void;
    dragFromLinkSegment(network: LinkNetwork, linkSegment: LinkSegment): void;
    /**
     * Connects the links being droppe
     * @param event Contains the drop location, in canvas space
     */
    dropLinks(locator: ItemLocator, event: CanvasPointerEvent): void;
    dropOnNode(node: LGraphNode, event: CanvasPointerEvent): void;
    dropOnReroute(reroute: Reroute, event: CanvasPointerEvent): void;
    /** @internal Temporary workaround - requires refactor. */
    _connectOutputToReroute(reroute: Reroute, renderLink: RenderLinkUnion): void;
    dropOnNothing(event: CanvasPointerEvent): void;
    /**
     * Disconnects all moving links.
     * @remarks This is called when the links are dropped on the canvas.
     * May be called by consumers to e.g. drag links into a bin / void.
     */
    disconnectLinks(): void;
    /**
     * Connects the links being dropped onto a node to the first matching slot.
     * @param node The node that the links are being dropped on
     * @param event Contains the drop location, in canvas space
     */
    connectToNode(node: LGraphNode, event: CanvasPointerEvent): void;
    isInputValidDrop(node: LGraphNode, input: INodeInputSlot): boolean;
    isNodeValidDrop(node: LGraphNode): boolean;
    /**
     * Checks if a reroute is a valid drop target for any of the links being connected.
     * @param reroute The reroute that would be dropped on.
     * @returns `true` if any of the current links being connected are valid for the given reroute.
     */
    isRerouteValidDrop(reroute: Reroute): boolean;
    /**
     * Exports the current state of the link connector.
     * @param network The network that the links being connected belong to.
     * @returns A POJO with the state of the link connector, links being connected, and their network.
     * @remarks Other than {@link network}, all properties are shallow cloned.
     */
    export(network: LinkNetwork): LinkConnectorExport;
    /**
     * Adds an event listener that will be automatically removed when the reset event is fired.
     * @param eventName The event to listen for.
     * @param listener The listener to call when the event is fired.
     */
    listenUntilReset<K extends keyof LinkConnectorEventMap>(eventName: K, listener: Parameters<typeof this.events.addEventListener<K>>[1], options?: Parameters<typeof this.events.addEventListener<K>>[2]): void;
    /**
     * Resets everything to its initial state.
     *
     * Effectively cancels moving or connecting links.
     */
    reset(force?: boolean): void;
}
export {};
