{"version":3,"file":"litegraph.umd.js","sources":["../src/utils/uuid.ts","../src/infrastructure/CustomEventTarget.ts","../src/LLink.ts","../src/types/globalEnums.ts","../src/canvas/FloatingRenderLink.ts","../src/canvas/MovingLinkBase.ts","../src/canvas/MovingInputLink.ts","../src/canvas/MovingOutputLink.ts","../src/canvas/ToInputRenderLink.ts","../src/canvas/ToOutputRenderLink.ts","../src/canvas/ToOutputFromRerouteLink.ts","../src/canvas/LinkConnector.ts","../src/measure.ts","../src/canvas/measureSlots.ts","../src/CanvasPointer.ts","../src/DragAndScale.ts","../src/draw.ts","../src/infrastructure/NullGraphError.ts","../src/LGraphIcon.ts","../src/LGraphBadge.ts","../src/node/SlotBase.ts","../src/node/NodeSlot.ts","../src/node/NodeInputSlot.ts","../src/node/NodeOutputSlot.ts","../src/node/slotUtils.ts","../src/strings.ts","../src/utils/collections.ts","../src/utils/feedback.ts","../src/utils/spaceDistribution.ts","../src/utils/type.ts","../src/infrastructure/Rectangle.ts","../src/widgets/BaseWidget.ts","../src/widgets/BooleanWidget.ts","../src/widgets/ButtonWidget.ts","../src/widgets/BaseSteppedWidget.ts","../src/widgets/ComboWidget.ts","../src/utils/widget.ts","../src/widgets/KnobWidget.ts","../src/widgets/LegacyWidget.ts","../src/widgets/NumberWidget.ts","../src/widgets/SliderWidget.ts","../src/widgets/TextWidget.ts","../src/widgets/widgetMap.ts","../src/LGraphNode.ts","../src/LGraphGroup.ts","../src/Reroute.ts","../src/utils/arrange.ts","../src/LGraphCanvas.ts","../src/MapProxyHandler.ts","../src/LGraph.ts","../src/subgraph/SubgraphSlotBase.ts","../src/subgraph/SubgraphInput.ts","../src/subgraph/SubgraphIONodeBase.ts","../src/subgraph/SubgraphInputNode.ts","../src/subgraph/SubgraphOutput.ts","../src/subgraph/SubgraphOutputNode.ts","../src/subgraph/Subgraph.ts","../src/canvas/InputIndicators.ts","../src/ContextMenu.ts","../src/CurveEditor.ts","../src/LiteGraphGlobal.ts","../src/polyfills.ts","../src/litegraph.ts"],"sourcesContent":["// Using a template string for this is resulting in complex type workarounds. No current benefit beyond dev reading.\nexport type UUID = string\n\n/** Special-case zero-UUID, consisting entirely of zeros. Used as a default value. */\nexport const zeroUuid = \"00000000-0000-0000-0000-000000000000\"\n\n/** Pre-allocated storage for uuid random values. */\nconst randomStorage = new Uint32Array(31)\n\n/**\n * Creates a UUIDv4 string.\n * @returns A new UUIDv4 string\n * @remarks\n * Original implementation from https://gist.github.com/jed/982883?permalink_comment_id=852670#gistcomment-852670\n *\n * Prefers the {@link crypto.randomUUID} method if available, falling back to\n * {@link crypto.getRandomValues}, then finally the legacy {@link Math.random} method.\n */\nexport function createUuidv4(): UUID {\n  if (typeof crypto?.randomUUID === \"function\") return crypto.randomUUID()\n  if (typeof crypto?.getRandomValues === \"function\") {\n    const random = crypto.getRandomValues(randomStorage)\n    let i = 0\n    return \"10000000-1000-4000-8000-100000000000\".replaceAll(/[018]/g, a =>\n      (Number(a) ^ ((random[i++] * 3.725_290_298_461_914e-9) >> (Number(a) * 0.25))).toString(16))\n  }\n  return \"10000000-1000-4000-8000-100000000000\".replaceAll(/[018]/g, a =>\n    (Number(a) ^ ((Math.random() * 16) >> (Number(a) * 0.25))).toString(16))\n}\n","import type { NeverNever, PickNevers } from \"@/types/utility\"\n\ntype EventListeners<T> = {\n  readonly [K in keyof T]: ((this: EventTarget, ev: CustomEvent<T[K]>) => any) | EventListenerObject | null\n}\n\n/**\n * Has strongly-typed overrides of {@link EventTarget.addEventListener} and {@link EventTarget.removeEventListener}.\n */\nexport interface ICustomEventTarget<\n  EventMap extends Record<Keys, unknown>,\n  Keys extends keyof EventMap & string = keyof EventMap & string,\n> {\n  addEventListener<K extends Keys>(\n    type: K,\n    listener: EventListeners<EventMap>[K],\n    options?: boolean | AddEventListenerOptions,\n  ): void\n\n  removeEventListener<K extends Keys>(\n    type: K,\n    listener: EventListeners<EventMap>[K],\n    options?: boolean | EventListenerOptions,\n  ): void\n\n  /** @deprecated Use {@link dispatch}. */\n  dispatchEvent(event: never): boolean\n}\n\n/**\n * Capable of dispatching strongly-typed events via {@link dispatch}.\n * Overloads are used to ensure detail param is correctly optional.\n */\nexport interface CustomEventDispatcher<\n  EventMap extends Record<Keys, unknown>,\n  Keys extends keyof EventMap & string = keyof EventMap & string,\n> {\n  dispatch<T extends keyof NeverNever<EventMap>>(type: T, detail: EventMap[T]): boolean\n  dispatch<T extends keyof PickNevers<EventMap>>(type: T): boolean\n}\n\n/**\n * A strongly-typed, custom {@link EventTarget} that can dispatch and listen for events.\n *\n * 1. Define an event map\n *    ```ts\n *    export interface CustomEventMap {\n *      \"my-event\": { message: string }\n *      \"simple-event\": never\n *    }\n *    ```\n *\n * 2. Create an event emitter\n *    ```ts\n *    // By subclassing\n *    class MyClass extends CustomEventTarget<CustomEventMap> {\n *      // ...\n *    }\n *\n *    // Or simply create an instance:\n *    const events = new CustomEventTarget<CustomEventMap>()\n *    ```\n *\n * 3. Dispatch events\n *    ```ts\n *    // Extended class\n *    const myClass = new MyClass()\n *    myClass.dispatch(\"my-event\", { message: \"Hello, world!\" })\n *    myClass.dispatch(\"simple-event\")\n *\n *    // Instance\n *    const events = new CustomEventTarget<CustomEventMap>()\n *    events.dispatch(\"my-event\", { message: \"Hello, world!\" })\n *    events.dispatch(\"simple-event\")\n *    ```\n */\nexport class CustomEventTarget<\n  EventMap extends Record<Keys, unknown>,\n  Keys extends keyof EventMap & string = keyof EventMap & string,\n>\n  extends EventTarget implements ICustomEventTarget<EventMap, Keys> {\n  /**\n   * Type-safe event dispatching.\n   * @see {@link EventTarget.dispatchEvent}\n   * @param type Name of the event to dispatch\n   * @param detail A custom object to send with the event\n   * @returns `true` if the event was dispatched successfully, otherwise `false`.\n   */\n  dispatch<T extends keyof NeverNever<EventMap>>(type: T, detail: EventMap[T]): boolean\n  dispatch<T extends keyof PickNevers<EventMap>>(type: T): boolean\n  dispatch<T extends keyof EventMap>(type: T, detail?: EventMap[T]) {\n    const event = new CustomEvent(type as string, { detail, cancelable: true })\n    return super.dispatchEvent(event)\n  }\n\n  override addEventListener<K extends Keys>(\n    type: K,\n    listener: EventListeners<EventMap>[K],\n    options?: boolean | AddEventListenerOptions,\n  ): void {\n    // Assertion: Contravariance on CustomEvent => Event\n    super.addEventListener(type as string, listener as EventListener, options)\n  }\n\n  override removeEventListener<K extends Keys>(\n    type: K,\n    listener: EventListeners<EventMap>[K],\n    options?: boolean | EventListenerOptions,\n  ): void {\n    // Assertion: Contravariance on CustomEvent => Event\n    super.removeEventListener(type as string, listener as EventListener, options)\n  }\n\n  /** @deprecated Use {@link dispatch}. */\n  override dispatchEvent(event: never): boolean {\n    return super.dispatchEvent(event)\n  }\n}\n","import type {\n  CanvasColour,\n  INodeInputSlot,\n  INodeOutputSlot,\n  ISlotType,\n  LinkNetwork,\n  LinkSegment,\n  ReadonlyLinkNetwork,\n} from \"./interfaces\"\nimport type { LGraphNode, NodeId } from \"./LGraphNode\"\nimport type { Reroute, RerouteId } from \"./Reroute\"\nimport type { Serialisable, SerialisableLLink } from \"./types/serialisation\"\n\nexport type LinkId = number\n\nexport type SerialisedLLinkArray = [\n  id: LinkId,\n  origin_id: NodeId,\n  origin_slot: number,\n  target_id: NodeId,\n  target_slot: number,\n  type: ISlotType,\n]\n\nexport interface ResolvedConnection {\n  inputNode: LGraphNode | undefined\n  outputNode: LGraphNode | undefined\n  input: INodeInputSlot | undefined\n  output: INodeOutputSlot | undefined\n  link: LLink\n}\n\ntype BasicReadonlyNetwork = Pick<ReadonlyLinkNetwork, \"getNodeById\" | \"links\" | \"getLink\">\n\n// this is the class in charge of storing link information\nexport class LLink implements LinkSegment, Serialisable<SerialisableLLink> {\n  /** Link ID */\n  id: LinkId\n  parentId?: RerouteId\n  type: ISlotType\n  /** Output node ID */\n  origin_id: NodeId\n  /** Output slot index */\n  origin_slot: number\n  /** Input node ID */\n  target_id: NodeId\n  /** Input slot index */\n  target_slot: number\n\n  data?: number | string | boolean | { toToolTip?(): string }\n  _data?: unknown\n  /** Centre point of the link, calculated during render only - can be inaccurate */\n  _pos: Float32Array\n  /** @todo Clean up - never implemented in comfy. */\n  _last_time?: number\n  /** The last canvas 2D path that was used to render this link */\n  path?: Path2D\n  /** @inheritdoc */\n  _centreAngle?: number\n\n  /** @inheritdoc */\n  _dragging?: boolean\n\n  #color?: CanvasColour | null\n  /** Custom colour for this link only */\n  public get color(): CanvasColour | null | undefined {\n    return this.#color\n  }\n\n  public set color(value: CanvasColour) {\n    this.#color = value === \"\" ? null : value\n  }\n\n  public get isFloatingOutput(): boolean {\n    return this.origin_id === -1 && this.origin_slot === -1\n  }\n\n  public get isFloatingInput(): boolean {\n    return this.target_id === -1 && this.target_slot === -1\n  }\n\n  public get isFloating(): boolean {\n    return this.isFloatingOutput || this.isFloatingInput\n  }\n\n  constructor(\n    id: LinkId,\n    type: ISlotType,\n    origin_id: NodeId,\n    origin_slot: number,\n    target_id: NodeId,\n    target_slot: number,\n    parentId?: RerouteId,\n  ) {\n    this.id = id\n    this.type = type\n    this.origin_id = origin_id\n    this.origin_slot = origin_slot\n    this.target_id = target_id\n    this.target_slot = target_slot\n    this.parentId = parentId\n\n    this._data = null\n    // center\n    this._pos = new Float32Array(2)\n  }\n\n  /** @deprecated Use {@link LLink.create} */\n  static createFromArray(data: SerialisedLLinkArray): LLink {\n    return new LLink(data[0], data[5], data[1], data[2], data[3], data[4])\n  }\n\n  /**\n   * LLink static factory: creates a new LLink from the provided data.\n   * @param data Serialised LLink data to create the link from\n   * @returns A new LLink\n   */\n  static create(data: SerialisableLLink): LLink {\n    return new LLink(\n      data.id,\n      data.type,\n      data.origin_id,\n      data.origin_slot,\n      data.target_id,\n      data.target_slot,\n      data.parentId,\n    )\n  }\n\n  /**\n   * Gets all reroutes from the output slot to this segment.  If this segment is a reroute, it will not be included.\n   * @returns An ordered array of all reroutes from the node output to\n   * this reroute or the reroute before it.  Otherwise, an empty array.\n   */\n  static getReroutes(\n    network: Pick<ReadonlyLinkNetwork, \"reroutes\">,\n    linkSegment: LinkSegment,\n  ): Reroute[] {\n    if (!linkSegment.parentId) return []\n    return network.reroutes\n      .get(linkSegment.parentId)\n      ?.getReroutes() ?? []\n  }\n\n  static getFirstReroute(\n    network: Pick<ReadonlyLinkNetwork, \"reroutes\">,\n    linkSegment: LinkSegment,\n  ): Reroute | undefined {\n    return LLink.getReroutes(network, linkSegment).at(0)\n  }\n\n  /**\n   * Finds the reroute in the chain after the provided reroute ID.\n   * @param network The network this link belongs to\n   * @param linkSegment The starting point of the search (input side).\n   * Typically the LLink object itself, but can be any link segment.\n   * @param rerouteId The matching reroute will have this set as its {@link parentId}.\n   * @returns The reroute that was found, `undefined` if no reroute was found, or `null` if an infinite loop was detected.\n   */\n  static findNextReroute(\n    network: Pick<ReadonlyLinkNetwork, \"reroutes\">,\n    linkSegment: LinkSegment,\n    rerouteId: RerouteId,\n  ): Reroute | null | undefined {\n    if (!linkSegment.parentId) return\n    return network.reroutes\n      .get(linkSegment.parentId)\n      ?.findNextReroute(rerouteId)\n  }\n\n  /**\n   * Gets the origin node of a link.\n   * @param network The network to search\n   * @param linkId The ID of the link to get the origin node of\n   * @returns The origin node of the link, or `undefined` if the link is not found or the origin node is not found\n   */\n  static getOriginNode(network: BasicReadonlyNetwork, linkId: LinkId): LGraphNode | undefined {\n    const id = network.links.get(linkId)?.origin_id\n    return network.getNodeById(id) ?? undefined\n  }\n\n  /**\n   * Gets the target node of a link.\n   * @param network The network to search\n   * @param linkId The ID of the link to get the target node of\n   * @returns The target node of the link, or `undefined` if the link is not found or the target node is not found\n   */\n  static getTargetNode(network: BasicReadonlyNetwork, linkId: LinkId): LGraphNode | undefined {\n    const id = network.links.get(linkId)?.target_id\n    return network.getNodeById(id) ?? undefined\n  }\n\n  /**\n   * Resolves a link ID to the link, node, and slot objects.\n   * @param linkId The {@link id} of the link to resolve\n   * @param network The link network to search\n   * @returns An object containing the input and output nodes, as well as the input and output slots.\n   * @remarks This method is heavier than others; it will always resolve all objects.\n   * Whilst the performance difference should in most cases be negligible,\n   * it is recommended to use simpler methods where appropriate.\n   */\n  static resolve(linkId: LinkId | null | undefined, network: BasicReadonlyNetwork): ResolvedConnection | undefined {\n    return network.getLink(linkId)?.resolve(network)\n  }\n\n  /**\n   * Resolves a list of link IDs to the link, node, and slot objects.\n   * Discards invalid link IDs.\n   * @param linkIds An iterable of link {@link id}s to resolve\n   * @param network The link network to search\n   * @returns An array of resolved connections.  If a link is not found, it is not included in the array.\n   * @see {@link LLink.resolve}\n   */\n  static resolveMany(linkIds: Iterable<LinkId>, network: BasicReadonlyNetwork): ResolvedConnection[] {\n    const resolved: ResolvedConnection[] = []\n    for (const id of linkIds) {\n      const r = network.getLink(id)?.resolve(network)\n      if (r) resolved.push(r)\n    }\n    return resolved\n  }\n\n  /**\n   * Resolves the primitive ID values stored in the link to the referenced objects.\n   * @param network The link network to search\n   * @returns An object containing the input and output nodes, as well as the input and output slots.\n   * @remarks This method is heavier than others; it will always resolve all objects.\n   * Whilst the performance difference should in most cases be negligible,\n   * it is recommended to use simpler methods where appropriate.\n   */\n  resolve(network: BasicReadonlyNetwork): ResolvedConnection {\n    const inputNode = this.target_id === -1 ? undefined : network.getNodeById(this.target_id) ?? undefined\n    const outputNode = this.origin_id === -1 ? undefined : network.getNodeById(this.origin_id) ?? undefined\n    const input = inputNode?.inputs[this.target_slot]\n    const output = outputNode?.outputs[this.origin_slot]\n    return { inputNode, outputNode, input, output, link: this }\n  }\n\n  configure(o: LLink | SerialisedLLinkArray) {\n    if (Array.isArray(o)) {\n      this.id = o[0]\n      this.origin_id = o[1]\n      this.origin_slot = o[2]\n      this.target_id = o[3]\n      this.target_slot = o[4]\n      this.type = o[5]\n    } else {\n      this.id = o.id\n      this.type = o.type\n      this.origin_id = o.origin_id\n      this.origin_slot = o.origin_slot\n      this.target_id = o.target_id\n      this.target_slot = o.target_slot\n      this.parentId = o.parentId\n    }\n  }\n\n  /**\n   * Checks if the specified node id and output index are this link's origin (output side).\n   * @param nodeId ID of the node to check\n   * @param outputIndex The array index of the node output\n   * @returns `true` if the origin matches, otherwise `false`.\n   */\n  hasOrigin(nodeId: NodeId, outputIndex: number): boolean {\n    return this.origin_id === nodeId && this.origin_slot === outputIndex\n  }\n\n  /**\n   * Checks if the specified node id and input index are this link's target (input side).\n   * @param nodeId ID of the node to check\n   * @param inputIndex The array index of the node input\n   * @returns `true` if the target matches, otherwise `false`.\n   */\n  hasTarget(nodeId: NodeId, inputIndex: number): boolean {\n    return this.target_id === nodeId && this.target_slot === inputIndex\n  }\n\n  /**\n   * Creates a floating link from this link.\n   * @param slotType The side of the link that is still connected\n   * @param parentId The parent reroute ID of the link\n   * @returns A new LLink that is floating\n   */\n  toFloating(slotType: \"input\" | \"output\", parentId: RerouteId): LLink {\n    const exported = this.asSerialisable()\n    exported.id = -1\n    exported.parentId = parentId\n\n    if (slotType === \"input\") {\n      exported.origin_id = -1\n      exported.origin_slot = -1\n    } else {\n      exported.target_id = -1\n      exported.target_slot = -1\n    }\n\n    return LLink.create(exported)\n  }\n\n  /**\n   * Disconnects a link and removes it from the graph, cleaning up any reroutes that are no longer used\n   * @param network The container (LGraph) where reroutes should be updated\n   * @param keepReroutes If `undefined`, reroutes will be automatically removed if no links remain.\n   * If `input` or `output`, reroutes will not be automatically removed, and retain a connection to the input or output, respectively.\n   */\n  disconnect(network: LinkNetwork, keepReroutes?: \"input\" | \"output\"): void {\n    const reroutes = LLink.getReroutes(network, this)\n\n    const lastReroute = reroutes.at(-1)\n\n    // When floating from output, 1-to-1 ratio of floating link to final reroute (tree-like)\n    const outputFloating = keepReroutes === \"output\" &&\n      lastReroute?.linkIds.size === 1 &&\n      lastReroute.floatingLinkIds.size === 0\n\n    // When floating from inputs, the final (input side) reroute may have many floating links\n    if (outputFloating || (keepReroutes === \"input\" && lastReroute)) {\n      const newLink = LLink.create(this)\n      newLink.id = -1\n\n      if (keepReroutes === \"input\") {\n        newLink.origin_id = -1\n        newLink.origin_slot = -1\n\n        lastReroute.floating = { slotType: \"input\" }\n      } else {\n        newLink.target_id = -1\n        newLink.target_slot = -1\n\n        lastReroute.floating = { slotType: \"output\" }\n      }\n\n      network.addFloatingLink(newLink)\n    }\n\n    for (const reroute of reroutes) {\n      reroute.linkIds.delete(this.id)\n      if (!keepReroutes && !reroute.totalLinks) {\n        network.reroutes.delete(reroute.id)\n      }\n    }\n    network.links.delete(this.id)\n  }\n\n  /**\n   * @deprecated Prefer {@link LLink.asSerialisable} (returns an object, not an array)\n   * @returns An array representing this LLink\n   */\n  serialize(): SerialisedLLinkArray {\n    return [\n      this.id,\n      this.origin_id,\n      this.origin_slot,\n      this.target_id,\n      this.target_slot,\n      this.type,\n    ]\n  }\n\n  asSerialisable(): SerialisableLLink {\n    const copy: SerialisableLLink = {\n      id: this.id,\n      origin_id: this.origin_id,\n      origin_slot: this.origin_slot,\n      target_id: this.target_id,\n      target_slot: this.target_slot,\n      type: this.type,\n    }\n    if (this.parentId) copy.parentId = this.parentId\n    return copy\n  }\n}\n","/** Node slot type - input or output */\nexport enum NodeSlotType {\n  INPUT = 1,\n  OUTPUT = 2,\n}\n\n/** Shape that an object will render as - used by nodes and slots */\nexport enum RenderShape {\n  /** Rectangle with square corners */\n  BOX = 1,\n  /** Rounded rectangle */\n  ROUND = 2,\n  /** Circle is circle */\n  CIRCLE = 3,\n  /** Two rounded corners: top left & bottom right */\n  CARD = 4,\n  /** Slot shape: Arrow */\n  ARROW = 5,\n  /** Slot shape: Grid */\n  GRID = 6,\n  /** Slot shape: Hollow circle  */\n  HollowCircle = 7,\n}\n\n/** Bit flags used to indicate what the pointer is currently hovering over. */\nexport enum CanvasItem {\n  /** No items / none */\n  Nothing = 0,\n  /** At least one node */\n  Node = 1,\n  /** At least one group */\n  Group = 1 << 1,\n  /** A reroute (not its path) */\n  Reroute = 1 << 2,\n  /** The path of a link */\n  Link = 1 << 3,\n  /** A resize in the bottom-right corner */\n  ResizeSe = 1 << 4,\n  /** A reroute slot */\n  RerouteSlot = 1 << 5,\n}\n\n/** The direction that a link point will flow towards - e.g. horizontal outputs are right by default */\nexport enum LinkDirection {\n  NONE = 0,\n  UP = 1,\n  DOWN = 2,\n  LEFT = 3,\n  RIGHT = 4,\n  CENTER = 5,\n}\n\n/** The path calculation that links follow */\nexport enum LinkRenderType {\n  HIDDEN_LINK = -1,\n  /** Juts out from the input & output a little @see LinkDirection, then a straight line between them */\n  STRAIGHT_LINK = 0,\n  /** 90Â° angles, clean and box-like */\n  LINEAR_LINK = 1,\n  /** Smooth curved links - default */\n  SPLINE_LINK = 2,\n}\n\n/** The marker in the middle of a link */\nexport enum LinkMarkerShape {\n  /** Do not display markers */\n  None = 0,\n  /** Circles (default) */\n  Circle = 1,\n  /** Directional arrows */\n  Arrow = 2,\n}\n\nexport enum TitleMode {\n  NORMAL_TITLE = 0,\n  NO_TITLE = 1,\n  TRANSPARENT_TITLE = 2,\n  AUTOHIDE_TITLE = 3,\n}\n\nexport enum LGraphEventMode {\n  ALWAYS = 0,\n  ON_EVENT = 1,\n  NEVER = 2,\n  ON_TRIGGER = 3,\n  BYPASS = 4,\n}\n\nexport enum EaseFunction {\n  LINEAR = \"linear\",\n  EASE_IN_QUAD = \"easeInQuad\",\n  EASE_OUT_QUAD = \"easeOutQuad\",\n  EASE_IN_OUT_QUAD = \"easeInOutQuad\",\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeOutputSlot, LinkNetwork } from \"@/interfaces\"\nimport type { INodeInputSlot } from \"@/interfaces\"\nimport type { Point } from \"@/interfaces\"\nimport type { LGraphNode, NodeId } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\n/**\n * Represents a floating link that is currently being dragged from one slot to another.\n *\n * This is a heavier, but short-lived convenience data structure. All refs to FloatingRenderLinks should be discarded on drop.\n * @remarks\n * At time of writing, Litegraph is using several different styles and methods to handle link dragging.\n *\n * Once the library has undergone more substantial changes to the way links are managed,\n * many properties of this class will be superfluous and removable.\n */\nexport class FloatingRenderLink implements RenderLink {\n  readonly node: LGraphNode\n  readonly fromSlot: INodeOutputSlot | INodeInputSlot\n  readonly fromPos: Point\n  readonly fromDirection: LinkDirection\n  readonly fromSlotIndex: number\n\n  readonly outputNodeId: NodeId = -1\n  readonly outputNode?: LGraphNode\n  readonly outputSlot?: INodeOutputSlot\n  readonly outputIndex: number = -1\n  readonly outputPos?: Point\n\n  readonly inputNodeId: NodeId = -1\n  readonly inputNode?: LGraphNode\n  readonly inputSlot?: INodeInputSlot\n  readonly inputIndex: number = -1\n  readonly inputPos?: Point\n\n  constructor(\n    readonly network: LinkNetwork,\n    readonly link: LLink,\n    readonly toType: \"input\" | \"output\",\n    readonly fromReroute: Reroute,\n    readonly dragDirection: LinkDirection = LinkDirection.CENTER,\n  ) {\n    const {\n      origin_id: outputNodeId,\n      target_id: inputNodeId,\n      origin_slot: outputIndex,\n      target_slot: inputIndex,\n    } = link\n\n    if (outputNodeId !== -1) {\n      // Output connected\n      const outputNode = network.getNodeById(outputNodeId) ?? undefined\n      if (!outputNode) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Output node [${outputNodeId}] not found.`)\n\n      const outputSlot = outputNode?.outputs.at(outputIndex)\n      if (!outputSlot) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Output slot [${outputIndex}] not found.`)\n\n      this.outputNodeId = outputNodeId\n      this.outputNode = outputNode\n      this.outputSlot = outputSlot\n      this.outputIndex = outputIndex\n      this.outputPos = outputNode.getOutputPos(outputIndex)\n\n      // RenderLink props\n      this.node = outputNode\n      this.fromSlot = outputSlot\n      this.fromPos = fromReroute?.pos ?? this.outputPos\n      this.fromDirection = LinkDirection.LEFT\n      this.dragDirection = LinkDirection.RIGHT\n      this.fromSlotIndex = outputIndex\n    } else {\n      // Input connected\n      const inputNode = network.getNodeById(inputNodeId) ?? undefined\n      if (!inputNode) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Input node [${inputNodeId}] not found.`)\n\n      const inputSlot = inputNode?.inputs.at(inputIndex)\n      if (!inputSlot) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Input slot [${inputIndex}] not found.`)\n\n      this.inputNodeId = inputNodeId\n      this.inputNode = inputNode\n      this.inputSlot = inputSlot\n      this.inputIndex = inputIndex\n      this.inputPos = inputNode.getInputPos(inputIndex)\n\n      // RenderLink props\n      this.node = inputNode\n      this.fromSlot = inputSlot\n      this.fromDirection = LinkDirection.RIGHT\n      this.fromSlotIndex = inputIndex\n    }\n    this.fromPos = fromReroute.pos\n  }\n\n  canConnectToInput(): boolean {\n    return this.toType === \"input\"\n  }\n\n  canConnectToOutput(): boolean {\n    return this.toType === \"output\"\n  }\n\n  canConnectToReroute(reroute: Reroute): boolean {\n    if (this.toType === \"input\") {\n      if (reroute.origin_id === this.inputNode?.id) return false\n    } else {\n      if (reroute.origin_id === this.outputNode?.id) return false\n    }\n    return true\n  }\n\n  connectToInput(node: LGraphNode, input: INodeInputSlot, _events?: CustomEventTarget<LinkConnectorEventMap>): void {\n    const floatingLink = this.link\n    floatingLink.target_id = node.id\n    floatingLink.target_slot = node.inputs.indexOf(input)\n\n    node.disconnectInput(node.inputs.indexOf(input))\n\n    this.fromSlot._floatingLinks?.delete(floatingLink)\n    input._floatingLinks ??= new Set()\n    input._floatingLinks.add(floatingLink)\n  }\n\n  connectToOutput(node: LGraphNode, output: INodeOutputSlot, _events?: CustomEventTarget<LinkConnectorEventMap>): void {\n    const floatingLink = this.link\n    floatingLink.origin_id = node.id\n    floatingLink.origin_slot = node.outputs.indexOf(output)\n\n    this.fromSlot._floatingLinks?.delete(floatingLink)\n    output._floatingLinks ??= new Set()\n    output._floatingLinks.add(floatingLink)\n  }\n\n  connectToRerouteInput(\n    reroute: Reroute,\n    { node: inputNode, input }: { node: LGraphNode, input: INodeInputSlot },\n    events: CustomEventTarget<LinkConnectorEventMap>,\n  ) {\n    const floatingLink = this.link\n    floatingLink.target_id = inputNode.id\n    floatingLink.target_slot = inputNode.inputs.indexOf(input)\n\n    this.fromSlot._floatingLinks?.delete(floatingLink)\n    input._floatingLinks ??= new Set()\n    input._floatingLinks.add(floatingLink)\n\n    events.dispatch(\"input-moved\", this)\n  }\n\n  connectToRerouteOutput(\n    reroute: Reroute,\n    outputNode: LGraphNode,\n    output: INodeOutputSlot,\n    events: CustomEventTarget<LinkConnectorEventMap>,\n  ) {\n    const floatingLink = this.link\n    floatingLink.origin_id = outputNode.id\n    floatingLink.origin_slot = outputNode.outputs.indexOf(output)\n\n    this.fromSlot._floatingLinks?.delete(floatingLink)\n    output._floatingLinks ??= new Set()\n    output._floatingLinks.add(floatingLink)\n\n    events.dispatch(\"output-moved\", this)\n  }\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode, NodeId } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\n/**\n * Represents an existing link that is currently being dragged by the user from one slot to another.\n *\n * This is a heavier, but short-lived convenience data structure.\n * All refs to {@link MovingInputLink} and {@link MovingOutputLink} should be discarded on drop.\n * @remarks\n * At time of writing, Litegraph is using several different styles and methods to handle link dragging.\n *\n * Once the library has undergone more substantial changes to the way links are managed,\n * many properties of this class will be superfluous and removable.\n */\n\nexport abstract class MovingLinkBase implements RenderLink {\n  abstract readonly node: LGraphNode\n  abstract readonly fromSlot: INodeOutputSlot | INodeInputSlot\n  abstract readonly fromPos: Point\n  abstract readonly fromDirection: LinkDirection\n  abstract readonly fromSlotIndex: number\n\n  readonly outputNodeId: NodeId\n  readonly outputNode: LGraphNode\n  readonly outputSlot: INodeOutputSlot\n  readonly outputIndex: number\n  readonly outputPos: Point\n\n  readonly inputNodeId: NodeId\n  readonly inputNode: LGraphNode\n  readonly inputSlot: INodeInputSlot\n  readonly inputIndex: number\n  readonly inputPos: Point\n\n  constructor(\n    readonly network: LinkNetwork,\n    readonly link: LLink,\n    readonly toType: \"input\" | \"output\",\n    readonly fromReroute?: Reroute,\n    readonly dragDirection: LinkDirection = LinkDirection.CENTER,\n  ) {\n    const {\n      origin_id: outputNodeId,\n      target_id: inputNodeId,\n      origin_slot: outputIndex,\n      target_slot: inputIndex,\n    } = link\n\n    // Store output info\n    const outputNode = network.getNodeById(outputNodeId) ?? undefined\n    if (!outputNode) throw new Error(`Creating MovingRenderLink for link [${link.id}] failed: Output node [${outputNodeId}] not found.`)\n\n    const outputSlot = outputNode.outputs.at(outputIndex)\n    if (!outputSlot) throw new Error(`Creating MovingRenderLink for link [${link.id}] failed: Output slot [${outputIndex}] not found.`)\n\n    this.outputNodeId = outputNodeId\n    this.outputNode = outputNode\n    this.outputSlot = outputSlot\n    this.outputIndex = outputIndex\n    this.outputPos = outputNode.getOutputPos(outputIndex)\n\n    // Store input info\n    const inputNode = network.getNodeById(inputNodeId) ?? undefined\n    if (!inputNode) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Input node [${inputNodeId}] not found.`)\n\n    const inputSlot = inputNode.inputs.at(inputIndex)\n    if (!inputSlot) throw new Error(`Creating DraggingRenderLink for link [${link.id}] failed: Input slot [${inputIndex}] not found.`)\n\n    this.inputNodeId = inputNodeId\n    this.inputNode = inputNode\n    this.inputSlot = inputSlot\n    this.inputIndex = inputIndex\n    this.inputPos = inputNode.getInputPos(inputIndex)\n  }\n\n  abstract connectToInput(node: LGraphNode, input: INodeInputSlot, events?: CustomEventTarget<LinkConnectorEventMap>): void\n  abstract connectToOutput(node: LGraphNode, output: INodeOutputSlot, events?: CustomEventTarget<LinkConnectorEventMap>): void\n  abstract connectToRerouteInput(reroute: Reroute, { node, input, link }: { node: LGraphNode, input: INodeInputSlot, link: LLink }, events: CustomEventTarget<LinkConnectorEventMap>, originalReroutes: Reroute[]): void\n  abstract connectToRerouteOutput(reroute: Reroute, outputNode: LGraphNode, output: INodeOutputSlot, events: CustomEventTarget<LinkConnectorEventMap>): void\n\n  abstract disconnect(): boolean\n}\n","import type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\nimport { MovingLinkBase } from \"./MovingLinkBase\"\n\nexport class MovingInputLink extends MovingLinkBase {\n  override readonly toType = \"input\"\n\n  readonly node: LGraphNode\n  readonly fromSlot: INodeOutputSlot\n  readonly fromPos: Point\n  readonly fromDirection: LinkDirection\n  readonly fromSlotIndex: number\n\n  constructor(network: LinkNetwork, link: LLink, fromReroute?: Reroute, dragDirection: LinkDirection = LinkDirection.CENTER) {\n    super(network, link, \"input\", fromReroute, dragDirection)\n\n    this.node = this.outputNode\n    this.fromSlot = this.outputSlot\n    this.fromPos = fromReroute?.pos ?? this.outputPos\n    this.fromDirection = LinkDirection.NONE\n    this.fromSlotIndex = this.outputIndex\n  }\n\n  canConnectToInput(inputNode: LGraphNode, input: INodeInputSlot): boolean {\n    return this.node.canConnectTo(inputNode, input, this.outputSlot)\n  }\n\n  canConnectToOutput(): false {\n    return false\n  }\n\n  canConnectToReroute(reroute: Reroute): boolean {\n    return reroute.origin_id !== this.inputNode.id\n  }\n\n  connectToInput(inputNode: LGraphNode, input: INodeInputSlot, events: CustomEventTarget<LinkConnectorEventMap>): LLink | null | undefined {\n    if (input === this.inputSlot) return\n\n    this.inputNode.disconnectInput(this.inputIndex, true)\n    const link = this.outputNode.connectSlots(this.outputSlot, inputNode, input, this.fromReroute?.id)\n    if (link) events.dispatch(\"input-moved\", this)\n    return link\n  }\n\n  connectToOutput(): never {\n    throw new Error(\"MovingInputLink cannot connect to an output.\")\n  }\n\n  connectToRerouteInput(\n    reroute: Reroute,\n    { node: inputNode, input, link: existingLink }: { node: LGraphNode, input: INodeInputSlot, link: LLink },\n    events: CustomEventTarget<LinkConnectorEventMap>,\n    originalReroutes: Reroute[],\n  ): void {\n    const { outputNode, outputSlot, fromReroute } = this\n\n    // Clean up reroutes\n    for (const reroute of originalReroutes) {\n      if (reroute.id === this.link.parentId) break\n\n      if (reroute.totalLinks === 1) reroute.remove()\n    }\n    // Set the parentId of the reroute we dropped on, to the reroute we dragged from\n    reroute.parentId = fromReroute?.id\n\n    const newLink = outputNode.connectSlots(outputSlot, inputNode, input, existingLink.parentId)\n    if (newLink) events.dispatch(\"input-moved\", this)\n  }\n\n  connectToRerouteOutput(): never {\n    throw new Error(\"MovingInputLink cannot connect to an output.\")\n  }\n\n  disconnect(): boolean {\n    return this.inputNode.disconnectInput(this.inputIndex, true)\n  }\n}\n","import type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\nimport { MovingLinkBase } from \"./MovingLinkBase\"\n\nexport class MovingOutputLink extends MovingLinkBase {\n  override readonly toType = \"output\"\n\n  readonly node: LGraphNode\n  readonly fromSlot: INodeInputSlot\n  readonly fromPos: Point\n  readonly fromDirection: LinkDirection\n  readonly fromSlotIndex: number\n\n  constructor(network: LinkNetwork, link: LLink, fromReroute?: Reroute, dragDirection: LinkDirection = LinkDirection.CENTER) {\n    super(network, link, \"output\", fromReroute, dragDirection)\n\n    this.node = this.inputNode\n    this.fromSlot = this.inputSlot\n    this.fromPos = fromReroute?.pos ?? this.inputPos\n    this.fromDirection = LinkDirection.LEFT\n    this.fromSlotIndex = this.inputIndex\n  }\n\n  canConnectToInput(): false {\n    return false\n  }\n\n  canConnectToOutput(outputNode: LGraphNode, output: INodeOutputSlot): boolean {\n    return outputNode.canConnectTo(this.node, this.inputSlot, output)\n  }\n\n  canConnectToReroute(reroute: Reroute): boolean {\n    return reroute.origin_id !== this.outputNode.id\n  }\n\n  connectToInput(): never {\n    throw new Error(\"MovingOutputLink cannot connect to an input.\")\n  }\n\n  connectToOutput(outputNode: LGraphNode, output: INodeOutputSlot, events: CustomEventTarget<LinkConnectorEventMap>): LLink | null | undefined {\n    if (output === this.outputSlot) return\n\n    const link = outputNode.connectSlots(output, this.inputNode, this.inputSlot, this.link.parentId)\n    if (link) events.dispatch(\"output-moved\", this)\n    return link\n  }\n\n  connectToRerouteInput(): never {\n    throw new Error(\"MovingOutputLink cannot connect to an input.\")\n  }\n\n  connectToRerouteOutput(\n    reroute: Reroute,\n    outputNode: LGraphNode,\n    output: INodeOutputSlot,\n    events: CustomEventTarget<LinkConnectorEventMap>,\n  ): void {\n    // Moving output side of links\n    const { inputNode, inputSlot, fromReroute } = this\n\n    // Creating a new link removes floating prop - check before connecting\n    const floatingTerminus = reroute?.floating?.slotType === \"output\"\n\n    // Connect the first reroute of the link being dragged to the reroute being dropped on\n    if (fromReroute) {\n      fromReroute.parentId = reroute.id\n    } else {\n      // If there are no reroutes, directly connect the link\n      this.link.parentId = reroute.id\n    }\n    // Use the last reroute id on the link to retain all reroutes\n    outputNode.connectSlots(output, inputNode, inputSlot, this.link.parentId)\n\n    // Connecting from the final reroute of a floating reroute chain\n    if (floatingTerminus) reroute.removeAllFloatingLinks()\n\n    events.dispatch(\"output-moved\", this)\n  }\n\n  disconnect(): boolean {\n    return this.outputNode.disconnectOutput(this.outputIndex, this.inputNode)\n  }\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LLink } from \"@/LLink\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\n/** Connecting TO an input slot. */\n\nexport class ToInputRenderLink implements RenderLink {\n  readonly toType = \"input\"\n  readonly fromPos: Point\n  readonly fromSlotIndex: number\n  fromDirection: LinkDirection = LinkDirection.RIGHT\n\n  constructor(\n    readonly network: LinkNetwork,\n    readonly node: LGraphNode,\n    readonly fromSlot: INodeOutputSlot,\n    readonly fromReroute?: Reroute,\n    public dragDirection: LinkDirection = LinkDirection.CENTER,\n  ) {\n    const outputIndex = node.outputs.indexOf(fromSlot)\n    if (outputIndex === -1) throw new Error(`Creating render link for node [${this.node.id}] failed: Slot index not found.`)\n\n    this.fromSlotIndex = outputIndex\n    this.fromPos = fromReroute\n      ? fromReroute.pos\n      : this.node.getOutputPos(outputIndex)\n  }\n\n  canConnectToInput(inputNode: LGraphNode, input: INodeInputSlot): boolean {\n    return this.node.canConnectTo(inputNode, input, this.fromSlot)\n  }\n\n  canConnectToOutput(): false {\n    return false\n  }\n\n  connectToInput(node: LGraphNode, input: INodeInputSlot, events: CustomEventTarget<LinkConnectorEventMap>) {\n    const { node: outputNode, fromSlot, fromReroute } = this\n    if (node === outputNode) return\n\n    const newLink = outputNode.connectSlots(fromSlot, node, input, fromReroute?.id)\n    events.dispatch(\"link-created\", newLink)\n  }\n\n  connectToRerouteInput(\n    reroute: Reroute,\n    {\n      node: inputNode,\n      input,\n      link,\n    }: { node: LGraphNode, input: INodeInputSlot, link: LLink },\n    events: CustomEventTarget<LinkConnectorEventMap>,\n    originalReroutes: Reroute[],\n  ) {\n    const { node: outputNode, fromSlot, fromReroute } = this\n\n    // Check before creating new link overwrites the value\n    const floatingTerminus = fromReroute?.floating?.slotType === \"output\"\n\n    // Set the parentId of the reroute we dropped on, to the reroute we dragged from\n    reroute.parentId = fromReroute?.id\n\n    const newLink = outputNode.connectSlots(fromSlot, inputNode, input, link.parentId)\n\n    // Connecting from the final reroute of a floating reroute chain\n    if (floatingTerminus) fromReroute.removeAllFloatingLinks()\n\n    // Clean up reroutes\n    for (const reroute of originalReroutes) {\n      if (reroute.id === fromReroute?.id) break\n\n      reroute.removeLink(link)\n      if (reroute.totalLinks === 0) {\n        if (link.isFloating) {\n          // Cannot float from both sides - remove\n          reroute.remove()\n        } else {\n          // Convert to floating\n          const cl = link.toFloating(\"output\", reroute.id)\n          this.network.addFloatingLink(cl)\n          reroute.floating = { slotType: \"output\" }\n        }\n      }\n    }\n    events.dispatch(\"link-created\", newLink)\n  }\n\n  connectToOutput() {\n    throw new Error(\"ToInputRenderLink cannot connect to an output.\")\n  }\n\n  connectToRerouteOutput() {\n    throw new Error(\"ToInputRenderLink cannot connect to an output.\")\n  }\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { LinkDirection } from \"@/types/globalEnums\"\n\n/** Connecting TO an output slot. */\n\nexport class ToOutputRenderLink implements RenderLink {\n  readonly toType = \"output\"\n  readonly fromPos: Point\n  readonly fromSlotIndex: number\n  fromDirection: LinkDirection = LinkDirection.LEFT\n\n  constructor(\n    readonly network: LinkNetwork,\n    readonly node: LGraphNode,\n    readonly fromSlot: INodeInputSlot,\n    readonly fromReroute?: Reroute,\n    public dragDirection: LinkDirection = LinkDirection.CENTER,\n  ) {\n    const inputIndex = node.inputs.indexOf(fromSlot)\n    if (inputIndex === -1) throw new Error(`Creating render link for node [${this.node.id}] failed: Slot index not found.`)\n\n    this.fromSlotIndex = inputIndex\n    this.fromPos = fromReroute\n      ? fromReroute.pos\n      : this.node.getInputPos(inputIndex)\n  }\n\n  canConnectToInput(): false {\n    return false\n  }\n\n  canConnectToOutput(outputNode: LGraphNode, output: INodeOutputSlot): boolean {\n    return this.node.canConnectTo(outputNode, this.fromSlot, output)\n  }\n\n  canConnectToReroute(reroute: Reroute): boolean {\n    if (reroute.origin_id === this.node.id) return false\n    return true\n  }\n\n  connectToOutput(node: LGraphNode, output: INodeOutputSlot, events: CustomEventTarget<LinkConnectorEventMap>) {\n    const { node: inputNode, fromSlot, fromReroute } = this\n    if (!inputNode) return\n\n    const newLink = node.connectSlots(output, inputNode, fromSlot, fromReroute?.id)\n    events.dispatch(\"link-created\", newLink)\n  }\n\n  connectToRerouteOutput(\n    reroute: Reroute,\n    outputNode: LGraphNode,\n    output: INodeOutputSlot,\n    events: CustomEventTarget<LinkConnectorEventMap>,\n  ): void {\n    const { node: inputNode, fromSlot } = this\n    const newLink = outputNode.connectSlots(output, inputNode, fromSlot, reroute?.id)\n    events.dispatch(\"link-created\", newLink)\n  }\n\n  connectToInput() {\n    throw new Error(\"ToOutputRenderLink cannot connect to an input.\")\n  }\n\n  connectToRerouteInput() {\n    throw new Error(\"ToOutputRenderLink cannot connect to an input.\")\n  }\n}\n","import type { LinkConnector } from \"./LinkConnector\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { INodeInputSlot, INodeOutputSlot, LinkNetwork } from \"@/litegraph\"\nimport type { Reroute } from \"@/Reroute\"\n\nimport { ToInputRenderLink } from \"./ToInputRenderLink\"\nimport { ToOutputRenderLink } from \"./ToOutputRenderLink\"\n\n/**\n * @internal A workaround class to support connecting to reroutes to node outputs.\n */\nexport class ToOutputFromRerouteLink extends ToOutputRenderLink {\n  constructor(\n    network: LinkNetwork,\n    node: LGraphNode,\n    fromSlot: INodeInputSlot,\n    override readonly fromReroute: Reroute,\n    readonly linkConnector: LinkConnector,\n  ) {\n    super(network, node, fromSlot, fromReroute)\n  }\n\n  override canConnectToReroute(): false {\n    return false\n  }\n\n  override connectToOutput(node: LGraphNode, output: INodeOutputSlot) {\n    const nuRenderLink = new ToInputRenderLink(this.network, node, output)\n    this.linkConnector._connectOutputToReroute(this.fromReroute, nuRenderLink)\n  }\n}\n","import type { RenderLink } from \"./RenderLink\"\nimport type { LinkConnectorEventMap } from \"@/infrastructure/LinkConnectorEventMap\"\nimport type { ConnectingLink, ItemLocator, LinkNetwork, LinkSegment } from \"@/interfaces\"\nimport type { INodeInputSlot, INodeOutputSlot } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { Reroute } from \"@/Reroute\"\nimport type { CanvasPointerEvent } from \"@/types/events\"\nimport type { IBaseWidget } from \"@/types/widgets\"\n\nimport { CustomEventTarget } from \"@/infrastructure/CustomEventTarget\"\nimport { LLink } from \"@/LLink\"\nimport { LinkDirection } from \"@/types/globalEnums\"\n\nimport { FloatingRenderLink } from \"./FloatingRenderLink\"\nimport { MovingInputLink } from \"./MovingInputLink\"\nimport { MovingLinkBase } from \"./MovingLinkBase\"\nimport { MovingOutputLink } from \"./MovingOutputLink\"\nimport { ToInputRenderLink } from \"./ToInputRenderLink\"\nimport { ToOutputFromRerouteLink } from \"./ToOutputFromRerouteLink\"\nimport { ToOutputRenderLink } from \"./ToOutputRenderLink\"\n\n/**\n * A Litegraph state object for the {@link LinkConnector}.\n * References are only held atomically within a function, never passed.\n * The concrete implementation may be replaced or proxied without side-effects.\n */\nexport interface LinkConnectorState {\n  /**\n   * The type of slot that links are being connected **to**.\n   * - When `undefined`, no operation is being performed.\n   * - A change in this property indicates the start or end of dragging links.\n   */\n  connectingTo: \"input\" | \"output\" | undefined\n  multi: boolean\n  /** When `true`, existing links are being repositioned. Otherwise, new links are being created. */\n  draggingExistingLinks: boolean\n  /** When set, connecting links will all snap to this position. */\n  snapLinksPos?: [number, number]\n}\n\n/** Discriminated union to simplify type narrowing. */\ntype RenderLinkUnion = MovingInputLink | MovingOutputLink | FloatingRenderLink | ToInputRenderLink | ToOutputRenderLink\n\nexport interface LinkConnectorExport {\n  renderLinks: RenderLink[]\n  inputLinks: LLink[]\n  outputLinks: LLink[]\n  floatingLinks: LLink[]\n  state: LinkConnectorState\n  network: LinkNetwork\n}\n\n/**\n * Component of {@link LGraphCanvas} that handles connecting and moving links.\n * @see {@link LLink}\n */\nexport class LinkConnector {\n  /**\n   * Link connection state POJO. Source of truth for state of link drag operations.\n   *\n   * Can be replaced or proxied to allow notifications.\n   * Is always dereferenced at the start of an operation.\n   */\n  state: LinkConnectorState = {\n    connectingTo: undefined,\n    multi: false,\n    draggingExistingLinks: false,\n    snapLinksPos: undefined,\n  }\n\n  readonly events = new CustomEventTarget<LinkConnectorEventMap>()\n\n  /** Contains information for rendering purposes only. */\n  readonly renderLinks: RenderLinkUnion[] = []\n\n  /** Existing links that are being moved **to** a new input slot. */\n  readonly inputLinks: LLink[] = []\n  /** Existing links that are being moved **to** a new output slot. */\n  readonly outputLinks: LLink[] = []\n  /** Existing floating links that are being moved to a new slot. */\n  readonly floatingLinks: LLink[] = []\n\n  readonly hiddenReroutes: Set<Reroute> = new Set()\n\n  /** The widget beneath the pointer, if it is a valid connection target. */\n  overWidget?: IBaseWidget\n  /** The type (returned by downstream callback) for {@link overWidget} */\n  overWidgetType?: string\n\n  /** The reroute beneath the pointer, if it is a valid connection target. */\n  overReroute?: Reroute\n\n  readonly #setConnectingLinks: (value: ConnectingLink[]) => void\n\n  constructor(setConnectingLinks: (value: ConnectingLink[]) => void) {\n    this.#setConnectingLinks = setConnectingLinks\n  }\n\n  get isConnecting() {\n    return this.state.connectingTo !== undefined\n  }\n\n  get draggingExistingLinks() {\n    return this.state.draggingExistingLinks\n  }\n\n  /** Drag an existing link to a different input. */\n  moveInputLink(network: LinkNetwork, input: INodeInputSlot): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state, inputLinks, renderLinks } = this\n\n    const linkId = input.link\n    if (linkId == null) {\n      // No link connected, check for a floating link\n      const floatingLink = input._floatingLinks?.values().next().value\n      if (floatingLink?.parentId == null) return\n\n      try {\n        const reroute = network.reroutes.get(floatingLink.parentId)\n        if (!reroute) throw new Error(`Invalid reroute id: [${floatingLink.parentId}] for floating link id: [${floatingLink.id}].`)\n\n        const renderLink = new FloatingRenderLink(network, floatingLink, \"input\", reroute)\n        const mayContinue = this.events.dispatch(\"before-move-input\", renderLink)\n        if (mayContinue === false) return\n\n        renderLinks.push(renderLink)\n      } catch (error) {\n        console.warn(`Could not create render link for link id: [${floatingLink.id}].`, floatingLink, error)\n      }\n\n      floatingLink._dragging = true\n      this.floatingLinks.push(floatingLink)\n    } else {\n      const link = network.links.get(linkId)\n      if (!link) return\n\n      try {\n        const reroute = network.getReroute(link.parentId)\n        const renderLink = new MovingInputLink(network, link, reroute)\n\n        const mayContinue = this.events.dispatch(\"before-move-input\", renderLink)\n        if (mayContinue === false) return\n\n        renderLinks.push(renderLink)\n\n        this.listenUntilReset(\"input-moved\", (e) => {\n          e.detail.link.disconnect(network, \"output\")\n        })\n      } catch (error) {\n        console.warn(`Could not create render link for link id: [${link.id}].`, link, error)\n        return\n      }\n\n      link._dragging = true\n      inputLinks.push(link)\n    }\n\n    state.connectingTo = \"input\"\n    state.draggingExistingLinks = true\n\n    this.#setLegacyLinks(false)\n  }\n\n  /** Drag all links from an output to a new output. */\n  moveOutputLink(network: LinkNetwork, output: INodeOutputSlot): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state, renderLinks } = this\n\n    // Floating links\n    if (output._floatingLinks?.size) {\n      for (const floatingLink of output._floatingLinks.values()) {\n        try {\n          const reroute = LLink.getFirstReroute(network, floatingLink)\n          if (!reroute) throw new Error(`Invalid reroute id: [${floatingLink.parentId}] for floating link id: [${floatingLink.id}].`)\n\n          const renderLink = new FloatingRenderLink(network, floatingLink, \"output\", reroute)\n          const mayContinue = this.events.dispatch(\"before-move-output\", renderLink)\n          if (mayContinue === false) continue\n\n          renderLinks.push(renderLink)\n          this.floatingLinks.push(floatingLink)\n        } catch (error) {\n          console.warn(`Could not create render link for link id: [${floatingLink.id}].`, floatingLink, error)\n        }\n      }\n    }\n\n    // Normal links\n    if (output.links?.length) {\n      for (const linkId of output.links) {\n        const link = network.links.get(linkId)\n        if (!link) continue\n\n        const firstReroute = LLink.getFirstReroute(network, link)\n        if (firstReroute) {\n          firstReroute._dragging = true\n          this.hiddenReroutes.add(firstReroute)\n        } else {\n          link._dragging = true\n        }\n        this.outputLinks.push(link)\n\n        try {\n          const renderLink = new MovingOutputLink(network, link, firstReroute, LinkDirection.RIGHT)\n\n          const mayContinue = this.events.dispatch(\"before-move-output\", renderLink)\n          if (mayContinue === false) continue\n\n          renderLinks.push(renderLink)\n        } catch (error) {\n          console.warn(`Could not create render link for link id: [${link.id}].`, link, error)\n          continue\n        }\n      }\n    }\n\n    if (renderLinks.length === 0) return\n\n    state.draggingExistingLinks = true\n    state.multi = true\n    state.connectingTo = \"output\"\n\n    this.#setLegacyLinks(true)\n  }\n\n  /**\n   * Drags a new link from an output slot to an input slot.\n   * @param network The network that the link being connected belongs to\n   * @param node The node the link is being dragged from\n   * @param output The output slot that the link is being dragged from\n   */\n  dragNewFromOutput(network: LinkNetwork, node: LGraphNode, output: INodeOutputSlot, fromReroute?: Reroute): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state } = this\n    const renderLink = new ToInputRenderLink(network, node, output, fromReroute)\n    this.renderLinks.push(renderLink)\n\n    state.connectingTo = \"input\"\n\n    this.#setLegacyLinks(false)\n  }\n\n  /**\n   * Drags a new link from an input slot to an output slot.\n   * @param network The network that the link being connected belongs to\n   * @param node The node the link is being dragged from\n   * @param input The input slot that the link is being dragged from\n   */\n  dragNewFromInput(network: LinkNetwork, node: LGraphNode, input: INodeInputSlot, fromReroute?: Reroute): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state } = this\n    const renderLink = new ToOutputRenderLink(network, node, input, fromReroute)\n    this.renderLinks.push(renderLink)\n\n    state.connectingTo = \"output\"\n\n    this.#setLegacyLinks(true)\n  }\n\n  /**\n   * Drags a new link from a reroute to an input slot.\n   * @param network The network that the link being connected belongs to\n   * @param reroute The reroute that the link is being dragged from\n   */\n  dragFromReroute(network: LinkNetwork, reroute: Reroute): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const link = reroute.firstLink ?? reroute.firstFloatingLink\n    if (!link) {\n      console.warn(\"No link found for reroute.\")\n      return\n    }\n\n    const outputNode = network.getNodeById(link.origin_id)\n    if (!outputNode) {\n      console.warn(\"No output node found for link.\", link)\n      return\n    }\n\n    const outputSlot = outputNode.outputs.at(link.origin_slot)\n    if (!outputSlot) {\n      console.warn(\"No output slot found for link.\", link)\n      return\n    }\n\n    const renderLink = new ToInputRenderLink(network, outputNode, outputSlot, reroute)\n    renderLink.fromDirection = LinkDirection.NONE\n    this.renderLinks.push(renderLink)\n\n    this.state.connectingTo = \"input\"\n\n    this.#setLegacyLinks(false)\n  }\n\n  /**\n   * Drags a new link from a reroute to an output slot.\n   * @param network The network that the link being connected belongs to\n   * @param reroute The reroute that the link is being dragged from\n   */\n  dragFromRerouteToOutput(network: LinkNetwork, reroute: Reroute): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const link = reroute.firstLink ?? reroute.firstFloatingLink\n    if (!link) {\n      console.warn(\"No link found for reroute.\")\n      return\n    }\n\n    const inputNode = network.getNodeById(link.target_id)\n    if (!inputNode) {\n      console.warn(\"No input node found for link.\", link)\n      return\n    }\n\n    const inputSlot = inputNode.inputs.at(link.target_slot)\n    if (!inputSlot) {\n      console.warn(\"No input slot found for link.\", link)\n      return\n    }\n\n    const renderLink = new ToOutputFromRerouteLink(network, inputNode, inputSlot, reroute, this)\n    renderLink.fromDirection = LinkDirection.LEFT\n    this.renderLinks.push(renderLink)\n\n    this.state.connectingTo = \"output\"\n\n    this.#setLegacyLinks(true)\n  }\n\n  dragFromLinkSegment(network: LinkNetwork, linkSegment: LinkSegment): void {\n    if (this.isConnecting) throw new Error(\"Already dragging links.\")\n\n    const { state } = this\n    if (linkSegment.origin_id == null || linkSegment.origin_slot == null) return\n\n    const node = network.getNodeById(linkSegment.origin_id)\n    if (!node) return\n\n    const slot = node.outputs.at(linkSegment.origin_slot)\n    if (!slot) return\n\n    const reroute = network.getReroute(linkSegment.parentId)\n    const renderLink = new ToInputRenderLink(network, node, slot, reroute)\n    renderLink.fromDirection = LinkDirection.NONE\n    this.renderLinks.push(renderLink)\n\n    state.connectingTo = \"input\"\n\n    this.#setLegacyLinks(false)\n  }\n\n  /**\n   * Connects the links being droppe\n   * @param event Contains the drop location, in canvas space\n   */\n  dropLinks(locator: ItemLocator, event: CanvasPointerEvent): void {\n    if (!this.isConnecting) {\n      console.warn(\"Attempted to drop links when not connecting to anything.\")\n      return\n    }\n\n    const { renderLinks } = this\n    const mayContinue = this.events.dispatch(\"before-drop-links\", { renderLinks, event })\n    if (mayContinue === false) return\n\n    const { canvasX, canvasY } = event\n    const node = locator.getNodeOnPos(canvasX, canvasY) ?? undefined\n    if (node) {\n      this.dropOnNode(node, event)\n    } else {\n      // Get reroute if no node is found\n      const reroute = locator.getRerouteOnPos(canvasX, canvasY)\n      // Drop output->input link on reroute is not impl.\n      if (reroute && this.isRerouteValidDrop(reroute)) {\n        this.dropOnReroute(reroute, event)\n      } else {\n        this.dropOnNothing(event)\n      }\n    }\n\n    this.events.dispatch(\"after-drop-links\", { renderLinks, event })\n  }\n\n  dropOnNode(node: LGraphNode, event: CanvasPointerEvent) {\n    const { renderLinks, state } = this\n    const { connectingTo } = state\n    const { canvasX, canvasY } = event\n\n    // Do nothing if every connection would loop back\n    if (renderLinks.every(link => link.node === node)) return\n\n    // To output\n    if (connectingTo === \"output\") {\n      const output = node.getOutputOnPos([canvasX, canvasY])\n\n      if (output) {\n        this.#dropOnOutput(node, output)\n      } else {\n        this.connectToNode(node, event)\n      }\n    // To input\n    } else if (connectingTo === \"input\") {\n      const input = node.getInputOnPos([canvasX, canvasY])\n      const inputOrSocket = input ?? node.getSlotFromWidget(this.overWidget)\n\n      // Input slot\n      if (inputOrSocket) {\n        this.#dropOnInput(node, inputOrSocket)\n      } else {\n        // Node background / title\n        this.connectToNode(node, event)\n      }\n    }\n  }\n\n  dropOnReroute(reroute: Reroute, event: CanvasPointerEvent): void {\n    const mayContinue = this.events.dispatch(\"dropped-on-reroute\", { reroute, event })\n    if (mayContinue === false) return\n\n    // Connecting to input\n    if (this.state.connectingTo === \"input\") {\n      if (this.renderLinks.length !== 1) throw new Error(`Attempted to connect ${this.renderLinks.length} input links to a reroute.`)\n\n      const renderLink = this.renderLinks[0]\n      this._connectOutputToReroute(reroute, renderLink)\n\n      return\n    }\n\n    // Connecting to output\n    for (const link of this.renderLinks) {\n      if (link.toType !== \"output\") continue\n\n      const result = reroute.findSourceOutput()\n      if (!result) continue\n\n      const { node, output } = result\n      if (!link.canConnectToOutput(node, output)) continue\n\n      link.connectToRerouteOutput(reroute, node, output, this.events)\n    }\n  }\n\n  /** @internal Temporary workaround - requires refactor. */\n  _connectOutputToReroute(reroute: Reroute, renderLink: RenderLinkUnion): void {\n    const results = reroute.findTargetInputs()\n    if (!results?.length) return\n\n    const maybeReroutes = reroute.getReroutes()\n    if (maybeReroutes === null) throw new Error(\"Reroute loop detected.\")\n\n    const originalReroutes = maybeReroutes.slice(0, -1).reverse()\n\n    // From reroute to reroute\n    if (renderLink instanceof ToInputRenderLink) {\n      const { node, fromSlot, fromSlotIndex, fromReroute } = renderLink\n\n      reroute.setFloatingLinkOrigin(node, fromSlot, fromSlotIndex)\n\n      // Clean floating link IDs from reroutes about to be removed from the chain\n      if (fromReroute != null) {\n        for (const originalReroute of originalReroutes) {\n          if (originalReroute.id === fromReroute.id) break\n\n          for (const linkId of reroute.floatingLinkIds) {\n            originalReroute.floatingLinkIds.delete(linkId)\n          }\n        }\n      }\n    }\n\n    // Filter before any connections are re-created\n    const filtered = results.filter(result => renderLink.toType === \"input\" && canConnectInputLinkToReroute(renderLink, result.node, result.input, reroute))\n\n    for (const result of filtered) {\n      renderLink.connectToRerouteInput(reroute, result, this.events, originalReroutes)\n    }\n\n    return\n  }\n\n  dropOnNothing(event: CanvasPointerEvent): void {\n    // For external event only.\n    const mayContinue = this.events.dispatch(\"dropped-on-canvas\", event)\n    if (mayContinue === false) return\n\n    this.disconnectLinks()\n  }\n\n  /**\n   * Disconnects all moving links.\n   * @remarks This is called when the links are dropped on the canvas.\n   * May be called by consumers to e.g. drag links into a bin / void.\n   */\n  disconnectLinks(): void {\n    for (const link of this.renderLinks) {\n      if (link instanceof MovingLinkBase) {\n        link.disconnect()\n      }\n    }\n  }\n\n  /**\n   * Connects the links being dropped onto a node to the first matching slot.\n   * @param node The node that the links are being dropped on\n   * @param event Contains the drop location, in canvas space\n   */\n  connectToNode(node: LGraphNode, event: CanvasPointerEvent): void {\n    const { state: { connectingTo } } = this\n\n    const mayContinue = this.events.dispatch(\"dropped-on-node\", { node, event })\n    if (mayContinue === false) return\n\n    // Assume all links are the same type, disallow loopback\n    const firstLink = this.renderLinks[0]\n    if (!firstLink) return\n\n    // Use a single type check before looping; ensures all dropped links go to the same slot\n    if (connectingTo === \"output\") {\n      // Dropping new output link\n      const output = node.findOutputByType(firstLink.fromSlot.type)?.slot\n      if (!output) {\n        console.warn(`Could not find slot for link type: [${firstLink.fromSlot.type}].`)\n        return\n      }\n\n      this.#dropOnOutput(node, output)\n    } else if (connectingTo === \"input\") {\n      // Dropping new input link\n      const input = node.findInputByType(firstLink.fromSlot.type)?.slot\n      if (!input) {\n        console.warn(`Could not find slot for link type: [${firstLink.fromSlot.type}].`)\n        return\n      }\n\n      this.#dropOnInput(node, input)\n    }\n  }\n\n  #dropOnInput(node: LGraphNode, input: INodeInputSlot): void {\n    for (const link of this.renderLinks) {\n      if (!link.canConnectToInput(node, input)) continue\n\n      link.connectToInput(node, input, this.events)\n    }\n  }\n\n  #dropOnOutput(node: LGraphNode, output: INodeOutputSlot): void {\n    for (const link of this.renderLinks) {\n      if (!link.canConnectToOutput(node, output)) {\n        if (link instanceof MovingOutputLink && link.link.parentId !== undefined) {\n          // Reconnect link without reroutes\n          link.outputNode.connectSlots(link.outputSlot, link.inputNode, link.inputSlot, undefined!)\n        }\n        continue\n      }\n\n      link.connectToOutput(node, output, this.events)\n    }\n  }\n\n  isInputValidDrop(node: LGraphNode, input: INodeInputSlot): boolean {\n    return this.renderLinks.some(link => link.canConnectToInput(node, input))\n  }\n\n  isNodeValidDrop(node: LGraphNode): boolean {\n    if (this.state.connectingTo === \"output\") {\n      return node.outputs.some(output => this.renderLinks.some(link => link.canConnectToOutput(node, output)))\n    }\n\n    return node.inputs.some(input => this.renderLinks.some(link => link.canConnectToInput(node, input)))\n  }\n\n  /**\n   * Checks if a reroute is a valid drop target for any of the links being connected.\n   * @param reroute The reroute that would be dropped on.\n   * @returns `true` if any of the current links being connected are valid for the given reroute.\n   */\n  isRerouteValidDrop(reroute: Reroute): boolean {\n    if (this.state.connectingTo === \"input\") {\n      const results = reroute.findTargetInputs()\n      if (!results?.length) return false\n\n      for (const { node, input } of results) {\n        for (const renderLink of this.renderLinks) {\n          if (renderLink.toType !== \"input\") continue\n          if (canConnectInputLinkToReroute(renderLink, node, input, reroute)) return true\n        }\n      }\n    } else {\n      const result = reroute.findSourceOutput()\n      if (!result) return false\n\n      const { node, output } = result\n\n      for (const renderLink of this.renderLinks) {\n        if (renderLink.toType !== \"output\") continue\n        if (!renderLink.canConnectToReroute(reroute)) continue\n        if (renderLink.canConnectToOutput(node, output)) return true\n      }\n    }\n\n    return false\n  }\n\n  /** Sets connecting_links, used by some extensions still. */\n  #setLegacyLinks(fromSlotIsInput: boolean): void {\n    const links = this.renderLinks.map((link) => {\n      const input = fromSlotIsInput ? link.fromSlot as INodeInputSlot : null\n      const output = fromSlotIsInput ? null : link.fromSlot as INodeOutputSlot\n\n      const afterRerouteId = link instanceof MovingLinkBase ? link.link?.parentId : link.fromReroute?.id\n\n      return {\n        node: link.node,\n        slot: link.fromSlotIndex,\n        input,\n        output,\n        pos: link.fromPos,\n        afterRerouteId,\n      } satisfies ConnectingLink\n    })\n    this.#setConnectingLinks(links)\n  }\n\n  /**\n   * Exports the current state of the link connector.\n   * @param network The network that the links being connected belong to.\n   * @returns A POJO with the state of the link connector, links being connected, and their network.\n   * @remarks Other than {@link network}, all properties are shallow cloned.\n   */\n  export(network: LinkNetwork): LinkConnectorExport {\n    return {\n      renderLinks: [...this.renderLinks],\n      inputLinks: [...this.inputLinks],\n      outputLinks: [...this.outputLinks],\n      floatingLinks: [...this.floatingLinks],\n      state: { ...this.state },\n      network,\n    }\n  }\n\n  /**\n   * Adds an event listener that will be automatically removed when the reset event is fired.\n   * @param eventName The event to listen for.\n   * @param listener The listener to call when the event is fired.\n   */\n  listenUntilReset<K extends keyof LinkConnectorEventMap>(\n    eventName: K,\n    listener: Parameters<typeof this.events.addEventListener<K>>[1],\n    options?: Parameters<typeof this.events.addEventListener<K>>[2],\n  ) {\n    this.events.addEventListener(eventName, listener, options)\n    this.events.addEventListener(\"reset\", () => this.events.removeEventListener(eventName, listener), { once: true })\n  }\n\n  /**\n   * Resets everything to its initial state.\n   *\n   * Effectively cancels moving or connecting links.\n   */\n  reset(force = false): void {\n    const mayContinue = this.events.dispatch(\"reset\", force)\n    if (mayContinue === false) return\n\n    const { state, outputLinks, inputLinks, hiddenReroutes, renderLinks, floatingLinks } = this\n\n    if (!force && state.connectingTo === undefined) return\n    state.connectingTo = undefined\n\n    for (const link of outputLinks) delete link._dragging\n    for (const link of inputLinks) delete link._dragging\n    for (const link of floatingLinks) delete link._dragging\n    for (const reroute of hiddenReroutes) delete reroute._dragging\n\n    renderLinks.length = 0\n    inputLinks.length = 0\n    outputLinks.length = 0\n    floatingLinks.length = 0\n    hiddenReroutes.clear()\n    state.multi = false\n    state.draggingExistingLinks = false\n    state.snapLinksPos = undefined\n  }\n}\n\n/** Validates that a single {@link RenderLink} can be dropped on the specified reroute. */\nfunction canConnectInputLinkToReroute(\n  link: ToInputRenderLink | MovingInputLink | FloatingRenderLink,\n  inputNode: LGraphNode,\n  input: INodeInputSlot,\n  reroute: Reroute,\n): boolean {\n  const { fromReroute } = link\n\n  if (\n    !link.canConnectToInput(inputNode, input) ||\n    // Would result in no change\n    fromReroute?.id === reroute.id ||\n    // Cannot connect from child to parent reroute\n    fromReroute?.getReroutes()?.includes(reroute)\n  ) {\n    return false\n  }\n\n  // Would result in no change\n  if (link instanceof ToInputRenderLink) {\n    if (reroute.parentId == null) {\n      // Link would make no change - output to reroute\n      if (reroute.firstLink?.hasOrigin(link.node.id, link.fromSlotIndex)) return false\n    } else if (link.fromReroute?.id === reroute.parentId) {\n      return false\n    }\n  }\n  return true\n}\n","import type {\n  HasBoundingRect,\n  Point,\n  ReadOnlyPoint,\n  ReadOnlyRect,\n  Rect,\n} from \"./interfaces\"\n\nimport { LinkDirection } from \"./types/globalEnums\"\n\n/**\n * Calculates the distance between two points (2D vector)\n * @param a Point a as `x, y`\n * @param b Point b as `x, y`\n * @returns Distance between point {@link a} & {@link b}\n */\nexport function distance(a: ReadOnlyPoint, b: ReadOnlyPoint): number {\n  return Math.sqrt(\n    (b[0] - a[0]) * (b[0] - a[0]) + (b[1] - a[1]) * (b[1] - a[1]),\n  )\n}\n\n/**\n * Calculates the distance2 (squared) between two points (2D vector).\n * Much faster when only comparing distances (closest/furthest point).\n * @param x1 Origin point X\n * @param y1 Origin point Y\n * @param x2 Destination point X\n * @param y2 Destination point Y\n * @returns Distance2 (squared) between point [{@link x1}, {@link y1}] & [{@link x2}, {@link y2}]\n */\nexport function dist2(x1: number, y1: number, x2: number, y2: number): number {\n  return ((x2 - x1) * (x2 - x1)) + ((y2 - y1) * (y2 - y1))\n}\n\n/**\n * Determines whether a point is inside a rectangle.\n *\n * Otherwise identical to {@link isInsideRectangle}, it also returns `true` if `x` equals `left` or `y` equals `top`.\n * @param x Point x\n * @param y Point y\n * @param left Rect x\n * @param top Rect y\n * @param width Rect width\n * @param height Rect height\n * @returns `true` if the point is inside the rect, otherwise `false`\n */\nexport function isInRectangle(\n  x: number,\n  y: number,\n  left: number,\n  top: number,\n  width: number,\n  height: number,\n): boolean {\n  return x >= left &&\n    x < left + width &&\n    y >= top &&\n    y < top + height\n}\n\n/**\n * Determines whether a {@link Point} is inside a {@link Rect}.\n * @param point The point to check, as `x, y`\n * @param rect The rectangle, as `x, y, width, height`\n * @returns `true` if the point is inside the rect, otherwise `false`\n */\nexport function isPointInRect(point: ReadOnlyPoint, rect: ReadOnlyRect): boolean {\n  return point[0] >= rect[0] &&\n    point[0] < rect[0] + rect[2] &&\n    point[1] >= rect[1] &&\n    point[1] < rect[1] + rect[3]\n}\n\n/**\n * Determines whether the point represented by {@link x}, {@link y} is inside a {@link Rect}.\n * @param x X co-ordinate of the point to check\n * @param y Y co-ordinate of the point to check\n * @param rect The rectangle, as `x, y, width, height`\n * @returns `true` if the point is inside the rect, otherwise `false`\n */\nexport function isInRect(x: number, y: number, rect: ReadOnlyRect): boolean {\n  return x >= rect[0] &&\n    x < rect[0] + rect[2] &&\n    y >= rect[1] &&\n    y < rect[1] + rect[3]\n}\n\n/**\n * Determines whether a point (`x, y`) is inside a rectangle.\n *\n * This is the original litegraph implementation.  It returns `false` if `x` is equal to `left`, or `y` is equal to `top`.\n * @deprecated\n * Use {@link isInRectangle} to match inclusive of top left.\n * This function returns a false negative when an integer point (e.g. pixel) is on the leftmost or uppermost edge of a rectangle.\n * @param x Point x\n * @param y Point y\n * @param left Rect x\n * @param top Rect y\n * @param width Rect width\n * @param height Rect height\n * @returns `true` if the point is inside the rect, otherwise `false`\n */\nexport function isInsideRectangle(\n  x: number,\n  y: number,\n  left: number,\n  top: number,\n  width: number,\n  height: number,\n): boolean {\n  return left < x &&\n    left + width > x &&\n    top < y &&\n    top + height > y\n}\n\n/**\n * Determines if two rectangles have any overlap\n * @param a Rectangle A as `x, y, width, height`\n * @param b Rectangle B as `x, y, width, height`\n * @returns `true` if rectangles overlap, otherwise `false`\n */\nexport function overlapBounding(a: ReadOnlyRect, b: ReadOnlyRect): boolean {\n  const aRight = a[0] + a[2]\n  const aBottom = a[1] + a[3]\n  const bRight = b[0] + b[2]\n  const bBottom = b[1] + b[3]\n\n  return a[0] > bRight ||\n    a[1] > bBottom ||\n    aRight < b[0] ||\n    aBottom < b[1]\n    ? false\n    : true\n}\n\n/**\n * Returns the centre of a rectangle.\n * @param rect The rectangle, as `x, y, width, height`\n * @returns The centre of the rectangle, as `x, y`\n */\nexport function getCentre(rect: ReadOnlyRect): Point {\n  return [\n    rect[0] + (rect[2] * 0.5),\n    rect[1] + (rect[3] * 0.5),\n  ]\n}\n\n/**\n * Determines if rectangle {@link a} contains the centre point of rectangle {@link b}.\n * @param a Container rectangle A as `x, y, width, height`\n * @param b Sub-rectangle B as `x, y, width, height`\n * @returns `true` if {@link a} contains most of {@link b}, otherwise `false`\n */\nexport function containsCentre(a: ReadOnlyRect, b: ReadOnlyRect): boolean {\n  const centreX = b[0] + (b[2] * 0.5)\n  const centreY = b[1] + (b[3] * 0.5)\n  return isInRect(centreX, centreY, a)\n}\n\n/**\n * Determines if rectangle {@link a} wholly contains rectangle {@link b}.\n * @param a Container rectangle A as `x, y, width, height`\n * @param b Sub-rectangle B as `x, y, width, height`\n * @returns `true` if {@link a} wholly contains {@link b}, otherwise `false`\n */\nexport function containsRect(a: ReadOnlyRect, b: ReadOnlyRect): boolean {\n  const aRight = a[0] + a[2]\n  const aBottom = a[1] + a[3]\n  const bRight = b[0] + b[2]\n  const bBottom = b[1] + b[3]\n\n  const identical = a[0] === b[0] &&\n    a[1] === b[1] &&\n    aRight === bRight &&\n    aBottom === bBottom\n\n  return !identical &&\n    a[0] <= b[0] &&\n    a[1] <= b[1] &&\n    aRight >= bRight &&\n    aBottom >= bBottom\n}\n\n/**\n * Adds an offset in the specified direction to {@link out}\n * @param amount Amount of offset to add\n * @param direction Direction to add the offset to\n * @param out The {@link Point} to add the offset to\n */\nexport function addDirectionalOffset(\n  amount: number,\n  direction: LinkDirection,\n  out: Point,\n): void {\n  switch (direction) {\n  case LinkDirection.LEFT:\n    out[0] -= amount\n    return\n  case LinkDirection.RIGHT:\n    out[0] += amount\n    return\n  case LinkDirection.UP:\n    out[1] -= amount\n    return\n  case LinkDirection.DOWN:\n    out[1] += amount\n    return\n    // LinkDirection.CENTER: Nothing to do.\n  }\n}\n\n/**\n * Rotates an offset in 90Â° increments.\n *\n * Swaps/flips axis values of a 2D vector offset - effectively rotating\n * {@link offset} by 90Â°\n * @param offset The zero-based offset to rotate\n * @param from Direction to rotate from\n * @param to Direction to rotate to\n */\nexport function rotateLink(\n  offset: Point,\n  from: LinkDirection,\n  to: LinkDirection,\n): void {\n  let x: number\n  let y: number\n\n  // Normalise to left\n  switch (from) {\n  case to:\n  case LinkDirection.CENTER:\n  case LinkDirection.NONE:\n  default:\n    // Nothing to do\n    return\n\n  case LinkDirection.LEFT:\n    x = offset[0]\n    y = offset[1]\n    break\n  case LinkDirection.RIGHT:\n    x = -offset[0]\n    y = -offset[1]\n    break\n  case LinkDirection.UP:\n    x = -offset[1]\n    y = offset[0]\n    break\n  case LinkDirection.DOWN:\n    x = offset[1]\n    y = -offset[0]\n    break\n  }\n\n  // Apply new direction\n  switch (to) {\n  case LinkDirection.CENTER:\n  case LinkDirection.NONE:\n    // Nothing to do\n    return\n\n  case LinkDirection.LEFT:\n    offset[0] = x\n    offset[1] = y\n    break\n  case LinkDirection.RIGHT:\n    offset[0] = -x\n    offset[1] = -y\n    break\n  case LinkDirection.UP:\n    offset[0] = y\n    offset[1] = -x\n    break\n  case LinkDirection.DOWN:\n    offset[0] = -y\n    offset[1] = x\n    break\n  }\n}\n\n/**\n * Check if a point is to to the left or right of a line.\n * Project a line from lineStart -> lineEnd.  Determine if point is to the left\n * or right of that projection.\n * {@link https://www.geeksforgeeks.org/orientation-3-ordered-points/}\n * @param lineStart The start point of the line\n * @param lineEnd The end point of the line\n * @param x X co-ordinate of the point to check\n * @param y Y co-ordinate of the point to check\n * @returns 0 if all three points are in a straight line, a negative value if\n * point is to the left of the projected line, or positive if the point is to\n * the right\n */\nexport function getOrientation(\n  lineStart: ReadOnlyPoint,\n  lineEnd: ReadOnlyPoint,\n  x: number,\n  y: number,\n): number {\n  return ((lineEnd[1] - lineStart[1]) * (x - lineEnd[0])) -\n    ((lineEnd[0] - lineStart[0]) * (y - lineEnd[1]))\n}\n\n/**\n * @param out The array to store the point in\n * @param a Start point\n * @param b End point\n * @param controlA Start curve control point\n * @param controlB End curve control point\n * @param t Time: factor of distance to travel along the curve (e.g 0.25 is 25% along the curve)\n */\nexport function findPointOnCurve(\n  out: Point,\n  a: ReadOnlyPoint,\n  b: ReadOnlyPoint,\n  controlA: ReadOnlyPoint,\n  controlB: ReadOnlyPoint,\n  t: number = 0.5,\n): void {\n  const iT = 1 - t\n\n  const c1 = iT * iT * iT\n  const c2 = 3 * (iT * iT) * t\n  const c3 = 3 * iT * (t * t)\n  const c4 = t * t * t\n\n  out[0] = (c1 * a[0]) + (c2 * controlA[0]) + (c3 * controlB[0]) + (c4 * b[0])\n  out[1] = (c1 * a[1]) + (c2 * controlA[1]) + (c3 * controlB[1]) + (c4 * b[1])\n}\n\nexport function createBounds(\n  objects: Iterable<HasBoundingRect>,\n  padding: number = 10,\n): ReadOnlyRect | null {\n  const bounds = new Float32Array([Infinity, Infinity, -Infinity, -Infinity])\n\n  for (const obj of objects) {\n    const rect = obj.boundingRect\n    bounds[0] = Math.min(bounds[0], rect[0])\n    bounds[1] = Math.min(bounds[1], rect[1])\n    bounds[2] = Math.max(bounds[2], rect[0] + rect[2])\n    bounds[3] = Math.max(bounds[3], rect[1] + rect[3])\n  }\n  if (!bounds.every(x => isFinite(x))) return null\n\n  return [\n    bounds[0] - padding,\n    bounds[1] - padding,\n    bounds[2] - bounds[0] + (2 * padding),\n    bounds[3] - bounds[1] + (2 * padding),\n  ]\n}\n\n/**\n * Snaps the provided {@link Point} or {@link Rect} ({@link pos}) to a grid of size {@link snapTo}.\n * @param pos The point that will be snapped\n * @param snapTo The value to round up/down by (multiples thereof)\n * @returns `true` if snapTo is truthy, otherwise `false`\n * @remarks `NaN` propagates through this function and does not affect return value.\n */\nexport function snapPoint(pos: Point | Rect, snapTo: number): boolean {\n  if (!snapTo) return false\n\n  pos[0] = snapTo * Math.round(pos[0] / snapTo)\n  pos[1] = snapTo * Math.round(pos[1] / snapTo)\n  return true\n}\n\nexport function clamp(value: number, min: number, max: number): number {\n  return value < min ? min : (value > max ? max : value)\n}\n","import type { INodeInputSlot, INodeOutputSlot, Point } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\n\nimport { isInRectangle } from \"@/measure\"\n\nexport function getNodeInputOnPos(node: LGraphNode, x: number, y: number): { index: number, input: INodeInputSlot, pos: Point } | undefined {\n  const { inputs } = node\n  if (!inputs) return\n\n  for (const [index, input] of inputs.entries()) {\n    const pos = node.getInputPos(index)\n\n    // TODO: Find a cheap way to measure text, and do it on node label change instead of here\n    // Input icon width + text approximation\n    const nameLength = input.label?.length ?? input.localized_name?.length ?? input.name?.length\n    const width = 20 + (nameLength || 3) * 7\n\n    if (isInRectangle(\n      x,\n      y,\n      pos[0] - 10,\n      pos[1] - 10,\n      width,\n      20,\n    )) {\n      return { index, input, pos }\n    }\n  }\n}\n\nexport function getNodeOutputOnPos(node: LGraphNode, x: number, y: number): { index: number, output: INodeOutputSlot, pos: Point } | undefined {\n  const { outputs } = node\n  if (!outputs) return\n\n  for (const [index, output] of outputs.entries()) {\n    const pos = node.getOutputPos(index)\n\n    if (isInRectangle(\n      x,\n      y,\n      pos[0] - 10,\n      pos[1] - 10,\n      40,\n      20,\n    )) {\n      return { index, output, pos }\n    }\n  }\n}\n\n/**\n * Returns the input slot index if the given position (in graph space) is on top of a node input slot.\n * A helper function - originally on the prototype of LGraphCanvas.\n */\nexport function isOverNodeInput(\n  node: LGraphNode,\n  canvasx: number,\n  canvasy: number,\n  slot_pos?: Point,\n): number {\n  const result = getNodeInputOnPos(node, canvasx, canvasy)\n  if (!result) return -1\n\n  if (slot_pos) {\n    slot_pos[0] = result.pos[0]\n    slot_pos[1] = result.pos[1]\n  }\n  return result.index\n}\n\n/**\n * Returns the output slot index if the given position (in graph space) is on top of a node output slot.\n * A helper function - originally on the prototype of LGraphCanvas.\n */\nexport function isOverNodeOutput(\n  node: LGraphNode,\n  canvasx: number,\n  canvasy: number,\n  slot_pos?: Point,\n): number {\n  const result = getNodeOutputOnPos(node, canvasx, canvasy)\n  if (!result) return -1\n\n  if (slot_pos) {\n    slot_pos[0] = result.pos[0]\n    slot_pos[1] = result.pos[1]\n  }\n  return result.index\n}\n","import type { CanvasPointerEvent } from \"./types/events\"\n\nimport { dist2 } from \"./measure\"\n\n/**\n * Allows click and drag actions to be declared ahead of time during a pointerdown event.\n *\n * By default, it retains the most recent event of each type until it is reset (on pointerup).\n * - {@link eDown}\n * - {@link eMove}\n * - {@link eUp}\n *\n * Depending on whether the user clicks or drags the pointer, only the appropriate callbacks are called:\n * - {@link onClick}\n * - {@link onDoubleClick}\n * - {@link onDragStart}\n * - {@link onDrag}\n * - {@link onDragEnd}\n * - {@link finally}\n * @see\n * - {@link LGraphCanvas.processMouseDown}\n * - {@link LGraphCanvas.processMouseMove}\n * - {@link LGraphCanvas.processMouseUp}\n */\nexport class CanvasPointer {\n  /** Maximum time in milliseconds to ignore click drift */\n  static bufferTime = 150\n\n  /** Maximum gap between pointerup and pointerdown events to be considered as a double click */\n  static doubleClickTime = 300\n\n  /** Maximum offset from click location */\n  static get maxClickDrift() {\n    return this.#maxClickDrift\n  }\n\n  static set maxClickDrift(value) {\n    this.#maxClickDrift = value\n    this.#maxClickDrift2 = value * value\n  }\n\n  static #maxClickDrift = 6\n  /** {@link maxClickDrift} squared.  Used to calculate click drift without `sqrt`. */\n  static #maxClickDrift2 = this.#maxClickDrift ** 2\n\n  /** The element this PointerState should capture input against when dragging. */\n  element: Element\n  /** Pointer ID used by drag capture. */\n  pointerId?: number\n\n  /** Set to true when if the pointer moves far enough after a down event, before the corresponding up event is fired. */\n  dragStarted: boolean = false\n\n  /** The {@link eUp} from the last successful click */\n  eLastDown?: CanvasPointerEvent\n\n  /** Used downstream for touch event support. */\n  isDouble: boolean = false\n  /** Used downstream for touch event support. */\n  isDown: boolean = false\n\n  /**\n   * If `true`, {@link eDown}, {@link eMove}, and {@link eUp} will be set to\n   * `undefined` when {@link reset} is called.\n   *\n   * Default: `true`\n   */\n  clearEventsOnReset: boolean = true\n\n  /** The last pointerdown event for the primary button */\n  eDown?: CanvasPointerEvent\n  /** The last pointermove event for the primary button */\n  eMove?: CanvasPointerEvent\n  /** The last pointerup event for the primary button */\n  eUp?: CanvasPointerEvent\n\n  /**\n   * If set, as soon as the mouse moves outside the click drift threshold, this action is run once.\n   * @param pointer [DEPRECATED] This parameter will be removed in a future release.\n   * @param eMove The pointermove event of this ongoing drag action.\n   *\n   * It is possible for no `pointermove` events to occur, but still be far from\n   * the original `pointerdown` event. In this case, {@link eMove} will be null, and\n   * {@link onDragEnd} will be called immediately after {@link onDragStart}.\n   */\n  onDragStart?(pointer: this, eMove?: CanvasPointerEvent): unknown\n\n  /**\n   * Called on pointermove whilst dragging.\n   * @param eMove The pointermove event of this ongoing drag action\n   */\n  onDrag?(eMove: CanvasPointerEvent): unknown\n\n  /**\n   * Called on pointerup after dragging (i.e. not called if clicked).\n   * @param upEvent The pointerup or pointermove event that triggered this callback\n   */\n  onDragEnd?(upEvent: CanvasPointerEvent): unknown\n\n  /**\n   * Callback that will be run once, the next time a pointerup event appears to be a normal click.\n   * @param upEvent The pointerup or pointermove event that triggered this callback\n   */\n  onClick?(upEvent: CanvasPointerEvent): unknown\n\n  /**\n   * Callback that will be run once, the next time a pointerup event appears to be a normal click.\n   * @param upEvent The pointerup or pointermove event that triggered this callback\n   */\n  onDoubleClick?(upEvent: CanvasPointerEvent): unknown\n\n  /**\n   * Run-once callback, called at the end of any click or drag, whether or not it was successful in any way.\n   *\n   * The setter of this callback will call the existing value before replacing it.\n   * Therefore, simply setting this value twice will execute the first callback.\n   */\n  get finally() {\n    return this.#finally\n  }\n\n  set finally(value) {\n    try {\n      this.#finally?.()\n    } finally {\n      this.#finally = value\n    }\n  }\n\n  #finally?: () => unknown\n\n  constructor(element: Element) {\n    this.element = element\n  }\n\n  /**\n   * Callback for `pointerdown` events.  To be used as the event handler (or called by it).\n   * @param e The `pointerdown` event\n   */\n  down(e: CanvasPointerEvent): void {\n    this.reset()\n    this.eDown = e\n    this.pointerId = e.pointerId\n    this.element.setPointerCapture(e.pointerId)\n  }\n\n  /**\n   * Callback for `pointermove` events.  To be used as the event handler (or called by it).\n   * @param e The `pointermove` event\n   */\n  move(e: CanvasPointerEvent): void {\n    const { eDown } = this\n    if (!eDown) return\n\n    // No buttons down, but eDown exists - clean up & leave\n    if (!e.buttons) {\n      this.reset()\n      return\n    }\n\n    // Primary button released - treat as pointerup.\n    if (!(e.buttons & eDown.buttons)) {\n      this.#completeClick(e)\n      this.reset()\n      return\n    }\n    this.eMove = e\n    this.onDrag?.(e)\n\n    // Dragging, but no callback to run\n    if (this.dragStarted) return\n\n    const longerThanBufferTime = e.timeStamp - eDown.timeStamp > CanvasPointer.bufferTime\n    if (longerThanBufferTime || !this.#hasSamePosition(e, eDown)) {\n      this.#setDragStarted(e)\n    }\n  }\n\n  /**\n   * Callback for `pointerup` events.  To be used as the event handler (or called by it).\n   * @param e The `pointerup` event\n   */\n  up(e: CanvasPointerEvent): boolean {\n    if (e.button !== this.eDown?.button) return false\n\n    this.#completeClick(e)\n    const { dragStarted } = this\n    this.reset()\n    return !dragStarted\n  }\n\n  #completeClick(e: CanvasPointerEvent): void {\n    const { eDown } = this\n    if (!eDown) return\n\n    this.eUp = e\n\n    if (this.dragStarted) {\n      // A move event already started drag\n      this.onDragEnd?.(e)\n    } else if (!this.#hasSamePosition(e, eDown)) {\n      // Teleport without a move event (e.g. tab out, move, tab back)\n      this.#setDragStarted()\n      this.onDragEnd?.(e)\n    } else if (this.onDoubleClick && this.#isDoubleClick()) {\n      // Double-click event\n      this.onDoubleClick(e)\n      this.eLastDown = undefined\n    } else {\n      // Normal click event\n      this.onClick?.(e)\n      this.eLastDown = eDown\n    }\n  }\n\n  /**\n   * Checks if two events occurred near each other - not further apart than the maximum click drift.\n   * @param a The first event to compare\n   * @param b The second event to compare\n   * @param tolerance2 The maximum distance (squared) before the positions are considered different\n   * @returns `true` if the two events were no more than {@link maxClickDrift} apart, otherwise `false`\n   */\n  #hasSamePosition(\n    a: PointerEvent,\n    b: PointerEvent,\n    tolerance2 = CanvasPointer.#maxClickDrift2,\n  ): boolean {\n    const drift = dist2(a.clientX, a.clientY, b.clientX, b.clientY)\n    return drift <= tolerance2\n  }\n\n  /**\n   * Checks whether the pointer is currently past the max click drift threshold.\n   * @returns `true` if the latest pointer event is past the the click drift threshold\n   */\n  #isDoubleClick(): boolean {\n    const { eDown, eLastDown } = this\n    if (!eDown || !eLastDown) return false\n\n    // Use thrice the drift distance for double-click gap\n    const tolerance2 = (3 * CanvasPointer.#maxClickDrift) ** 2\n    const diff = eDown.timeStamp - eLastDown.timeStamp\n    return diff > 0 &&\n      diff < CanvasPointer.doubleClickTime &&\n      this.#hasSamePosition(eDown, eLastDown, tolerance2)\n  }\n\n  #setDragStarted(eMove?: CanvasPointerEvent): void {\n    this.dragStarted = true\n    this.onDragStart?.(this, eMove)\n    delete this.onDragStart\n  }\n\n  /**\n   * Resets the state of this {@link CanvasPointer} instance.\n   *\n   * The {@link finally} callback is first executed, then all callbacks and intra-click\n   * state is cleared.\n   */\n  reset(): void {\n    // The setter executes the callback before clearing it\n    this.finally = undefined\n    delete this.onClick\n    delete this.onDoubleClick\n    delete this.onDragStart\n    delete this.onDrag\n    delete this.onDragEnd\n\n    this.isDown = false\n    this.isDouble = false\n    this.dragStarted = false\n\n    if (this.clearEventsOnReset) {\n      this.eDown = undefined\n      this.eMove = undefined\n      this.eUp = undefined\n    }\n\n    const { element, pointerId } = this\n    this.pointerId = undefined\n    if (typeof pointerId === \"number\" && element.hasPointerCapture(pointerId)) {\n      element.releasePointerCapture(pointerId)\n    }\n  }\n}\n","import type { Point, ReadOnlyRect, Rect } from \"./interfaces\"\n\nimport { EaseFunction, Rectangle } from \"./litegraph\"\n\nexport interface DragAndScaleState {\n  /**\n   * The offset from the top-left of the current canvas viewport to `[0, 0]` in graph space.\n   * Or said another way, the inverse offset of the viewport.\n   */\n  offset: [number, number]\n  /** The scale of the graph. */\n  scale: number\n}\n\nexport type AnimationOptions = {\n  /** Duration of the animation in milliseconds. */\n  duration?: number\n  /** Relative target zoom level. 1 means the view is fit exactly on the bounding box. */\n  zoom?: number\n  /** The animation easing function (curve) */\n  easing?: EaseFunction\n}\n\nexport class DragAndScale {\n  /**\n   * The state of this DragAndScale instance.\n   *\n   * Implemented as a POCO that can be proxied without side-effects.\n   */\n  state: DragAndScaleState\n  lastState: DragAndScaleState = {\n    offset: [0, 0],\n    scale: 0,\n  }\n\n  /** Maximum scale (zoom in) */\n  max_scale: number\n  /** Minimum scale (zoom out) */\n  min_scale: number\n  enabled: boolean\n  last_mouse: Point\n  element: HTMLCanvasElement\n  visible_area: Rectangle\n  dragging?: boolean\n  viewport?: Rect\n\n  onredraw?(das: DragAndScale): void\n  onChanged?(scale: number, offset: Point): void\n\n  get offset(): [number, number] {\n    return this.state.offset\n  }\n\n  set offset(value: Point) {\n    this.state.offset[0] = value[0]\n    this.state.offset[1] = value[1]\n  }\n\n  get scale(): number {\n    return this.state.scale\n  }\n\n  set scale(value: number) {\n    this.state.scale = value\n  }\n\n  constructor(element: HTMLCanvasElement) {\n    this.state = {\n      offset: [0, 0],\n      scale: 1,\n    }\n    this.max_scale = 10\n    this.min_scale = 0.1\n    this.enabled = true\n    this.last_mouse = [0, 0]\n    this.visible_area = new Rectangle()\n\n    this.element = element\n  }\n\n  /**\n   * Returns `true` if the current state has changed from the previous state.\n   * @returns `true` if the current state has changed from the previous state, otherwise `false`.\n   */\n  #stateHasChanged(): boolean {\n    const current = this.state\n    const previous = this.lastState\n\n    return current.scale !== previous.scale ||\n      current.offset[0] !== previous.offset[0] ||\n      current.offset[1] !== previous.offset[1]\n  }\n\n  computeVisibleArea(viewport: Rect | undefined): void {\n    const { scale, offset } = this\n\n    if (this.#stateHasChanged()) {\n      this.onChanged?.(scale, offset)\n      copyState(this.state, this.lastState)\n    }\n\n    if (!this.element) {\n      this.visible_area[0] = this.visible_area[1] = this.visible_area[2] = this.visible_area[3] = 0\n      return\n    }\n    let width = this.element.width\n    let height = this.element.height\n    let startx = -offset[0]\n    let starty = -offset[1]\n    if (viewport) {\n      startx += viewport[0] / scale\n      starty += viewport[1] / scale\n      width = viewport[2]\n      height = viewport[3]\n    }\n    const endx = startx + width / scale\n    const endy = starty + height / scale\n    this.visible_area[0] = startx\n    this.visible_area[1] = starty\n    this.visible_area[2] = endx - startx\n    this.visible_area[3] = endy - starty\n  }\n\n  toCanvasContext(ctx: CanvasRenderingContext2D): void {\n    ctx.scale(this.scale, this.scale)\n    ctx.translate(this.offset[0], this.offset[1])\n  }\n\n  convertOffsetToCanvas(pos: Point): Point {\n    return [\n      (pos[0] + this.offset[0]) * this.scale,\n      (pos[1] + this.offset[1]) * this.scale,\n    ]\n  }\n\n  convertCanvasToOffset(pos: Point, out?: Point): Point {\n    out = out || [0, 0]\n    out[0] = pos[0] / this.scale - this.offset[0]\n    out[1] = pos[1] / this.scale - this.offset[1]\n    return out\n  }\n\n  /** @deprecated Has not been kept up to date */\n  mouseDrag(x: number, y: number): void {\n    this.offset[0] += x / this.scale\n    this.offset[1] += y / this.scale\n\n    this.onredraw?.(this)\n  }\n\n  changeScale(value: number, zooming_center?: Point, roundToScaleOne = true): void {\n    if (value < this.min_scale) {\n      value = this.min_scale\n    } else if (value > this.max_scale) {\n      value = this.max_scale\n    }\n    if (value == this.scale) return\n\n    const rect = this.element.getBoundingClientRect()\n    if (!rect) return\n\n    zooming_center = zooming_center ?? [rect.width * 0.5, rect.height * 0.5]\n\n    const normalizedCenter: Point = [\n      zooming_center[0] - rect.x,\n      zooming_center[1] - rect.y,\n    ]\n    const center = this.convertCanvasToOffset(normalizedCenter)\n    this.scale = value\n    if (roundToScaleOne && Math.abs(this.scale - 1) < 0.01) this.scale = 1\n    const new_center = this.convertCanvasToOffset(normalizedCenter)\n    const delta_offset = [\n      new_center[0] - center[0],\n      new_center[1] - center[1],\n    ]\n\n    this.offset[0] += delta_offset[0]\n    this.offset[1] += delta_offset[1]\n\n    this.onredraw?.(this)\n  }\n\n  changeDeltaScale(value: number, zooming_center?: Point): void {\n    this.changeScale(this.scale * value, zooming_center)\n  }\n\n  /**\n   * Fits the view to the specified bounds.\n   * @param bounds The bounds to fit the view to, defined by a rectangle.\n   */\n  fitToBounds(bounds: ReadOnlyRect, { zoom = 0.75 }: { zoom?: number } = {}): void {\n    const cw = this.element.width / window.devicePixelRatio\n    const ch = this.element.height / window.devicePixelRatio\n    let targetScale = this.scale\n\n    if (zoom > 0) {\n      const targetScaleX = (zoom * cw) / Math.max(bounds[2], 300)\n      const targetScaleY = (zoom * ch) / Math.max(bounds[3], 300)\n\n      // Choose the smaller scale to ensure the node fits into the viewport\n      // Ensure we don't go over the max scale\n      targetScale = Math.min(targetScaleX, targetScaleY, this.max_scale)\n    }\n\n    const scaledWidth = cw / targetScale\n    const scaledHeight = ch / targetScale\n\n    // Calculate the target position to center the bounds in the viewport\n    const targetX = -bounds[0] - (bounds[2] * 0.5) + (scaledWidth * 0.5)\n    const targetY = -bounds[1] - (bounds[3] * 0.5) + (scaledHeight * 0.5)\n\n    // Apply the changes immediately\n    this.offset[0] = targetX\n    this.offset[1] = targetY\n    this.scale = targetScale\n  }\n\n  /**\n   * Starts an animation to fit the view around the specified selection of nodes.\n   * @param bounds The bounds to animate the view to, defined by a rectangle.\n   */\n  animateToBounds(\n    bounds: ReadOnlyRect,\n    setDirty: () => void,\n    {\n      duration = 350,\n      zoom = 0.75,\n      easing = EaseFunction.EASE_IN_OUT_QUAD,\n    }: AnimationOptions = {},\n  ) {\n    if (!(duration > 0)) throw new RangeError(\"Duration must be greater than 0\")\n\n    const easeFunctions = {\n      linear: (t: number) => t,\n      easeInQuad: (t: number) => t * t,\n      easeOutQuad: (t: number) => t * (2 - t),\n      easeInOutQuad: (t: number) => (t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t),\n    }\n    const easeFunction = easeFunctions[easing] ?? easeFunctions.linear\n\n    const startTimestamp = performance.now()\n    const cw = this.element.width / window.devicePixelRatio\n    const ch = this.element.height / window.devicePixelRatio\n    const startX = this.offset[0]\n    const startY = this.offset[1]\n    const startX2 = startX - (cw / this.scale)\n    const startY2 = startY - (ch / this.scale)\n    const startScale = this.scale\n    let targetScale = startScale\n\n    if (zoom > 0) {\n      const targetScaleX = (zoom * cw) / Math.max(bounds[2], 300)\n      const targetScaleY = (zoom * ch) / Math.max(bounds[3], 300)\n\n      // Choose the smaller scale to ensure the node fits into the viewport\n      // Ensure we don't go over the max scale\n      targetScale = Math.min(targetScaleX, targetScaleY, this.max_scale)\n    }\n    const scaledWidth = cw / targetScale\n    const scaledHeight = ch / targetScale\n\n    const targetX = -bounds[0] - (bounds[2] * 0.5) + (scaledWidth * 0.5)\n    const targetY = -bounds[1] - (bounds[3] * 0.5) + (scaledHeight * 0.5)\n    const targetX2 = targetX - scaledWidth\n    const targetY2 = targetY - scaledHeight\n\n    const animate = (timestamp: number) => {\n      const elapsed = timestamp - startTimestamp\n      const progress = Math.min(elapsed / duration, 1)\n      const easedProgress = easeFunction(progress)\n\n      const currentX = startX + ((targetX - startX) * easedProgress)\n      const currentY = startY + ((targetY - startY) * easedProgress)\n      this.offset[0] = currentX\n      this.offset[1] = currentY\n\n      if (zoom > 0) {\n        const currentX2 = startX2 + ((targetX2 - startX2) * easedProgress)\n        const currentY2 = startY2 + ((targetY2 - startY2) * easedProgress)\n        const currentWidth = Math.abs(currentX2 - currentX)\n        const currentHeight = Math.abs(currentY2 - currentY)\n\n        this.scale = Math.min(cw / currentWidth, ch / currentHeight)\n      }\n\n      setDirty()\n\n      if (progress < 1) {\n        animationId = requestAnimationFrame(animate)\n      } else {\n        cancelAnimationFrame(animationId)\n      }\n    }\n    let animationId = requestAnimationFrame(animate)\n  }\n\n  reset(): void {\n    this.scale = 1\n    this.offset[0] = 0\n    this.offset[1] = 0\n  }\n}\n\n/**\n * Copies the values of one state into another, preserving references.\n * @param from The state to copy values from.\n * @param to The state to copy values into.\n */\nfunction copyState(from: DragAndScaleState, to: DragAndScaleState): void {\n  to.scale = from.scale\n  to.offset[0] = from.offset[0]\n  to.offset[1] = from.offset[1]\n}\n","import type { Rectangle } from \"./infrastructure/Rectangle\"\nimport type { CanvasColour, Rect } from \"./interfaces\"\n\nimport { LiteGraph } from \"./litegraph\"\nimport { LinkDirection, RenderShape, TitleMode } from \"./types/globalEnums\"\n\nconst ELLIPSIS = \"\\u2026\"\nconst TWO_DOT_LEADER = \"\\u2025\"\nconst ONE_DOT_LEADER = \"\\u2024\"\n\nexport enum SlotType {\n  Array = \"array\",\n  Event = -1,\n}\n\n/** @see RenderShape */\nexport enum SlotShape {\n  Box = RenderShape.BOX,\n  Arrow = RenderShape.ARROW,\n  Grid = RenderShape.GRID,\n  Circle = RenderShape.CIRCLE,\n  HollowCircle = RenderShape.HollowCircle,\n}\n\n/** @see LinkDirection */\nexport enum SlotDirection {\n  Up = LinkDirection.UP,\n  Right = LinkDirection.RIGHT,\n  Down = LinkDirection.DOWN,\n  Left = LinkDirection.LEFT,\n}\n\nexport enum LabelPosition {\n  Left = \"left\",\n  Right = \"right\",\n}\n\nexport interface IDrawBoundingOptions {\n  /** The shape to render */\n  shape?: RenderShape\n  /** The radius of the rounded corners for {@link RenderShape.ROUND} and {@link RenderShape.CARD} */\n  round_radius?: number\n  /** Shape will extend above the Y-axis 0 by this amount @deprecated This is node-specific: it should be removed entirely, and behaviour defined by the caller more explicitly */\n  title_height?: number\n  /** @deprecated This is node-specific: it should be removed entirely, and behaviour defined by the caller more explicitly */\n  title_mode?: TitleMode\n  /** The color that should be drawn */\n  color?: CanvasColour\n  /** The distance between the edge of the {@link area} and the middle of the line */\n  padding?: number\n  /** @deprecated This is node-specific: it should be removed entirely, and behaviour defined by the caller more explicitly */\n  collapsed?: boolean\n  /** Thickness of the line drawn (`lineWidth`) */\n  lineWidth?: number\n}\n\nexport interface IDrawTextInAreaOptions {\n  /** The canvas to draw the text on. */\n  ctx: CanvasRenderingContext2D\n  /** The text to draw. */\n  text: string\n  /** The area the text will be drawn in. */\n  area: Rectangle\n  /** The alignment of the text. */\n  align?: \"left\" | \"right\" | \"center\"\n}\n\n/**\n * Draws only the path of a shape on the canvas, without filling.\n * Used to draw indicators for node status, e.g. \"selected\".\n * @param ctx The 2D context to draw on\n * @param area The position and size of the shape to render\n */\nexport function strokeShape(\n  ctx: CanvasRenderingContext2D,\n  area: Rect,\n  {\n    shape = RenderShape.BOX,\n    round_radius,\n    title_height,\n    title_mode = TitleMode.NORMAL_TITLE,\n    color,\n    padding = 6,\n    collapsed = false,\n    lineWidth: thickness = 1,\n  }: IDrawBoundingOptions = {},\n): void {\n  // These param defaults are not compile-time static, and must be re-evaluated at runtime\n  round_radius ??= LiteGraph.ROUND_RADIUS\n  color ??= LiteGraph.NODE_BOX_OUTLINE_COLOR\n\n  // Adjust area if title is transparent\n  if (title_mode === TitleMode.TRANSPARENT_TITLE) {\n    const height = title_height ?? LiteGraph.NODE_TITLE_HEIGHT\n    area[1] -= height\n    area[3] += height\n  }\n\n  // Set up context\n  const { lineWidth, strokeStyle } = ctx\n  ctx.lineWidth = thickness\n  ctx.globalAlpha = 0.8\n  ctx.strokeStyle = color\n  ctx.beginPath()\n\n  // Draw shape based on type\n  const [x, y, width, height] = area\n  switch (shape) {\n  case RenderShape.BOX: {\n    ctx.rect(\n      x - padding,\n      y - padding,\n      width + 2 * padding,\n      height + 2 * padding,\n    )\n    break\n  }\n  case RenderShape.ROUND:\n  case RenderShape.CARD: {\n    const radius = round_radius + padding\n    const isCollapsed = shape === RenderShape.CARD && collapsed\n    const cornerRadii =\n        isCollapsed || shape === RenderShape.ROUND\n          ? [radius]\n          : [radius, 2, radius, 2]\n    ctx.roundRect(\n      x - padding,\n      y - padding,\n      width + 2 * padding,\n      height + 2 * padding,\n      cornerRadii,\n    )\n    break\n  }\n  case RenderShape.CIRCLE: {\n    const centerX = x + width / 2\n    const centerY = y + height / 2\n    const radius = Math.max(width, height) / 2 + padding\n    ctx.arc(centerX, centerY, radius, 0, Math.PI * 2)\n    break\n  }\n  }\n\n  // Stroke the shape\n  ctx.stroke()\n\n  // Reset context\n  ctx.lineWidth = lineWidth\n  ctx.strokeStyle = strokeStyle\n\n  // TODO: Store and reset value properly.  Callers currently expect this behaviour (e.g. muted nodes).\n  ctx.globalAlpha = 1\n}\n\n/**\n * Truncates text using binary search to fit within a given width, appending an ellipsis if needed.\n * @param ctx The canvas rendering context.\n * @param text The text to truncate.\n * @param maxWidth The maximum width the text (plus ellipsis) can occupy.\n * @returns The truncated text, or the original text if it fits.\n */\nfunction truncateTextToWidth(ctx: CanvasRenderingContext2D, text: string, maxWidth: number): string {\n  if (!(maxWidth > 0)) return \"\"\n\n  // Text fits\n  const fullWidth = ctx.measureText(text).width\n  if (fullWidth <= maxWidth) return text\n\n  const ellipsisWidth = ctx.measureText(ELLIPSIS).width * 0.75\n\n  // Can't even fit ellipsis\n  if (ellipsisWidth > maxWidth) {\n    const twoDotsWidth = ctx.measureText(TWO_DOT_LEADER).width * 0.75\n    if (twoDotsWidth < maxWidth) return TWO_DOT_LEADER\n\n    const oneDotWidth = ctx.measureText(ONE_DOT_LEADER).width * 0.75\n    return oneDotWidth < maxWidth ? ONE_DOT_LEADER : \"\"\n  }\n\n  let min = 0\n  let max = text.length\n  let bestLen = 0\n\n  // Binary search for the longest substring that fits with the ellipsis\n  while (min <= max) {\n    const mid = Math.floor((min + max) * 0.5)\n\n    // Avoid measuring empty string + ellipsis\n    if (mid === 0) {\n      min = mid + 1\n      continue\n    }\n\n    const sub = text.substring(0, mid)\n    const currentWidth = ctx.measureText(sub).width + ellipsisWidth\n\n    if (currentWidth <= maxWidth) {\n      // This length fits, try potentially longer\n      bestLen = mid\n      min = mid + 1\n    } else {\n      // Too long, try shorter\n      max = mid - 1\n    }\n  }\n\n  return bestLen === 0\n    ? ELLIPSIS\n    : text.substring(0, bestLen) + ELLIPSIS\n}\n\n/**\n * Draws text within an area, truncating it and adding an ellipsis if necessary.\n */\nexport function drawTextInArea({ ctx, text, area, align = \"left\" }: IDrawTextInAreaOptions) {\n  const { left, right, bottom, width, centreX } = area\n\n  // Text already fits\n  const fullWidth = ctx.measureText(text).width\n  if (fullWidth <= width) {\n    ctx.textAlign = align\n    const x = align === \"left\" ? left : (align === \"right\" ? right : centreX)\n    ctx.fillText(text, x, bottom)\n    return\n  }\n\n  // Need to truncate text\n  const truncated = truncateTextToWidth(ctx, text, width)\n  if (truncated.length === 0) return\n\n  // Draw text - left-aligned to prevent bouncing during resize\n  ctx.textAlign = \"left\"\n  ctx.fillText(truncated.slice(0, -1), left, bottom)\n  ctx.rect(left, bottom, width, 1)\n\n  // Draw the ellipsis, right-aligned to the button\n  ctx.textAlign = \"right\"\n  const ellipsis = truncated.at(-1)!\n  ctx.fillText(ellipsis, right, bottom, ctx.measureText(ellipsis).width * 0.75)\n}\n","export class NullGraphError extends Error {\n  constructor(message: string = \"Attempted to access LGraph reference that was null or undefined.\", cause?: Error) {\n    super(message, { cause })\n    this.name = \"NullGraphError\"\n  }\n}\n","export interface LGraphIconOptions {\n  unicode: string\n  fontFamily?: string\n  color?: string\n  bgColor?: string\n  fontSize?: number\n  circlePadding?: number\n  xOffset?: number\n  yOffset?: number\n}\n\nexport class LGraphIcon {\n  unicode: string\n  fontFamily: string\n  color: string\n  bgColor?: string\n  fontSize: number\n  circlePadding: number\n  xOffset: number\n  yOffset: number\n\n  constructor({\n    unicode,\n    fontFamily = \"PrimeIcons\",\n    color = \"#e6c200\",\n    bgColor,\n    fontSize = 16,\n    circlePadding = 2,\n    xOffset = 0,\n    yOffset = 0,\n  }: LGraphIconOptions) {\n    this.unicode = unicode\n    this.fontFamily = fontFamily\n    this.color = color\n    this.bgColor = bgColor\n    this.fontSize = fontSize\n    this.circlePadding = circlePadding\n    this.xOffset = xOffset\n    this.yOffset = yOffset\n  }\n\n  draw(ctx: CanvasRenderingContext2D, x: number, y: number) {\n    x += this.xOffset\n    y += this.yOffset\n\n    const { font, textBaseline, textAlign, fillStyle } = ctx\n\n    ctx.font = `${this.fontSize}px '${this.fontFamily}'`\n    ctx.textBaseline = \"middle\"\n    ctx.textAlign = \"center\"\n    const iconRadius = this.fontSize / 2 + this.circlePadding\n    // Draw icon background circle if bgColor is set\n    if (this.bgColor) {\n      ctx.beginPath()\n      ctx.arc(x + iconRadius, y, iconRadius, 0, 2 * Math.PI)\n      ctx.fillStyle = this.bgColor\n      ctx.fill()\n    }\n    // Draw icon\n    ctx.fillStyle = this.color\n    ctx.fillText(this.unicode, x + iconRadius, y)\n\n    ctx.font = font\n    ctx.textBaseline = textBaseline\n    ctx.textAlign = textAlign\n    ctx.fillStyle = fillStyle\n  }\n}\n","import { LGraphIcon, type LGraphIconOptions } from \"./LGraphIcon\"\n\nexport enum BadgePosition {\n  TopLeft = \"top-left\",\n  TopRight = \"top-right\",\n}\n\nexport interface LGraphBadgeOptions {\n  text: string\n  fgColor?: string\n  bgColor?: string\n  fontSize?: number\n  padding?: number\n  height?: number\n  cornerRadius?: number\n  iconOptions?: LGraphIconOptions\n  xOffset?: number\n  yOffset?: number\n}\n\nexport class LGraphBadge {\n  text: string\n  fgColor: string\n  bgColor: string\n  fontSize: number\n  padding: number\n  height: number\n  cornerRadius: number\n  icon?: LGraphIcon\n  xOffset: number\n  yOffset: number\n\n  constructor({\n    text,\n    fgColor = \"white\",\n    bgColor = \"#0F1F0F\",\n    fontSize = 12,\n    padding = 6,\n    height = 20,\n    cornerRadius = 5,\n    iconOptions,\n    xOffset = 0,\n    yOffset = 0,\n  }: LGraphBadgeOptions) {\n    this.text = text\n    this.fgColor = fgColor\n    this.bgColor = bgColor\n    this.fontSize = fontSize\n    this.padding = padding\n    this.height = height\n    this.cornerRadius = cornerRadius\n    if (iconOptions) {\n      this.icon = new LGraphIcon(iconOptions)\n    }\n    this.xOffset = xOffset\n    this.yOffset = yOffset\n  }\n\n  get visible() {\n    return this.text.length > 0 || !!this.icon\n  }\n\n  getWidth(ctx: CanvasRenderingContext2D) {\n    if (!this.visible) return 0\n    const { font } = ctx\n    let iconWidth = 0\n    if (this.icon) {\n      ctx.font = `${this.icon.fontSize}px '${this.icon.fontFamily}'`\n      iconWidth = ctx.measureText(this.icon.unicode).width + this.padding\n    }\n    ctx.font = `${this.fontSize}px sans-serif`\n    const textWidth = this.text ? ctx.measureText(this.text).width : 0\n    ctx.font = font\n    return iconWidth + textWidth + this.padding * 2\n  }\n\n  draw(\n    ctx: CanvasRenderingContext2D,\n    x: number,\n    y: number,\n  ): void {\n    if (!this.visible) return\n\n    x += this.xOffset\n    y += this.yOffset\n\n    const { font, fillStyle, textBaseline, textAlign } = ctx\n\n    ctx.font = `${this.fontSize}px sans-serif`\n    const badgeWidth = this.getWidth(ctx)\n    const badgeX = 0\n\n    // Draw badge background\n    ctx.fillStyle = this.bgColor\n    ctx.beginPath()\n    if (ctx.roundRect) {\n      ctx.roundRect(x + badgeX, y, badgeWidth, this.height, this.cornerRadius)\n    } else {\n      // Fallback for browsers that don't support roundRect\n      ctx.rect(x + badgeX, y, badgeWidth, this.height)\n    }\n    ctx.fill()\n\n    let drawX = x + badgeX + this.padding\n    const centerY = y + this.height / 2\n\n    // Draw icon if present\n    if (this.icon) {\n      this.icon.draw(ctx, drawX, centerY)\n      drawX += this.icon.fontSize + this.padding / 2 + 4\n    }\n\n    // Draw badge text\n    if (this.text) {\n      ctx.fillStyle = this.fgColor\n      ctx.textBaseline = \"middle\"\n      ctx.textAlign = \"left\"\n      ctx.fillText(this.text, drawX, centerY + 1)\n    }\n\n    ctx.font = font\n    ctx.fillStyle = fillStyle\n    ctx.textBaseline = textBaseline\n    ctx.textAlign = textAlign\n  }\n}\n","import type { CanvasColour, DefaultConnectionColors, INodeSlot, ISlotType, IWidgetLocator, Point, Rect } from \"@/interfaces\"\nimport type { LLink } from \"@/LLink\"\nimport type { RenderShape } from \"@/types/globalEnums\"\nimport type { LinkDirection } from \"@/types/globalEnums\"\n\n/** Base class for all input & output slots. */\n\nexport abstract class SlotBase implements INodeSlot {\n  name: string\n  localized_name?: string\n  label?: string\n  type: ISlotType\n  dir?: LinkDirection\n  removable?: boolean\n  shape?: RenderShape\n  color_off?: CanvasColour\n  color_on?: CanvasColour\n  locked?: boolean\n  nameLocked?: boolean\n  widget?: IWidgetLocator\n  _floatingLinks?: Set<LLink>\n  hasErrors?: boolean\n\n  /** The centre point of the slot. */\n  abstract pos?: Point\n  readonly boundingRect: Rect\n\n  constructor(name: string, type: ISlotType, boundingRect: Rect) {\n    this.name = name\n    this.type = type\n    this.boundingRect = boundingRect\n  }\n\n  abstract get isConnected(): boolean\n\n  renderingColor(colorContext: DefaultConnectionColors): CanvasColour {\n    return this.isConnected\n      ? this.color_on || colorContext.getConnectedColor(this.type)\n      : this.color_off || colorContext.getDisconnectedColor(this.type)\n  }\n}\n","import type { CanvasColour, DefaultConnectionColors, INodeInputSlot, INodeOutputSlot, INodeSlot, OptionalProps, Point, ReadOnlyPoint } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\n\nimport { LabelPosition, SlotShape, SlotType } from \"@/draw\"\nimport { LiteGraph } from \"@/litegraph\"\nimport { getCentre } from \"@/measure\"\nimport { LinkDirection, RenderShape } from \"@/types/globalEnums\"\n\nimport { NodeInputSlot } from \"./NodeInputSlot\"\nimport { SlotBase } from \"./SlotBase\"\n\nexport interface IDrawOptions {\n  colorContext: DefaultConnectionColors\n  labelPosition?: LabelPosition\n  lowQuality?: boolean\n  doStroke?: boolean\n  highlight?: boolean\n}\n\n/** Shared base class for {@link LGraphNode} input and output slots. */\nexport abstract class NodeSlot extends SlotBase implements INodeSlot {\n  pos?: Point\n\n  /** The offset from the parent node to the centre point of this slot. */\n  get #centreOffset(): ReadOnlyPoint {\n    const nodePos = this.node.pos\n    const { boundingRect } = this\n\n    // Use height; widget input slots may be thinner.\n    const diameter = boundingRect[3]\n\n    return getCentre([\n      boundingRect[0] - nodePos[0],\n      boundingRect[1] - nodePos[1],\n      diameter,\n      diameter,\n    ])\n  }\n\n  /** The center point of this slot when the node is collapsed. */\n  abstract get collapsedPos(): ReadOnlyPoint\n\n  #node: LGraphNode\n  get node(): LGraphNode {\n    return this.#node\n  }\n\n  get highlightColor(): CanvasColour {\n    return LiteGraph.NODE_TEXT_HIGHLIGHT_COLOR ?? LiteGraph.NODE_SELECTED_TITLE_COLOR ?? LiteGraph.NODE_TEXT_COLOR\n  }\n\n  abstract get isWidgetInputSlot(): boolean\n\n  constructor(slot: OptionalProps<INodeSlot, \"boundingRect\">, node: LGraphNode) {\n    super(slot.name, slot.type, slot.boundingRect ?? [0, 0, 0, 0])\n\n    Object.assign(this, slot)\n    this.#node = node\n  }\n\n  /**\n   * Whether this slot is a valid target for a dragging link.\n   * @param fromSlot The slot that the link is being connected from.\n   */\n  abstract isValidTarget(fromSlot: INodeInputSlot | INodeOutputSlot): boolean\n\n  /**\n   * The label to display in the UI.\n   */\n  get renderingLabel(): string {\n    return this.label || this.localized_name || this.name || \"\"\n  }\n\n  draw(\n    ctx: CanvasRenderingContext2D,\n    {\n      colorContext,\n      labelPosition = LabelPosition.Right,\n      lowQuality = false,\n      highlight = false,\n      doStroke = false,\n    }: IDrawOptions,\n  ) {\n    // Save the current fillStyle and strokeStyle\n    const originalFillStyle = ctx.fillStyle\n    const originalStrokeStyle = ctx.strokeStyle\n    const originalLineWidth = ctx.lineWidth\n\n    const labelColor = highlight\n      ? this.highlightColor\n      : LiteGraph.NODE_TEXT_COLOR\n\n    const pos = this.#centreOffset\n    const slot_type = this.type\n    const slot_shape = (\n      slot_type === SlotType.Array ? SlotShape.Grid : this.shape\n    ) as SlotShape\n\n    ctx.beginPath()\n    let doFill = true\n\n    ctx.fillStyle = this.renderingColor(colorContext)\n    ctx.lineWidth = 1\n    if (slot_type === SlotType.Event || slot_shape === SlotShape.Box) {\n      ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10)\n    } else if (slot_shape === SlotShape.Arrow) {\n      ctx.moveTo(pos[0] + 8, pos[1] + 0.5)\n      ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5)\n      ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5)\n      ctx.closePath()\n    } else if (slot_shape === SlotShape.Grid) {\n      const gridSize = 3\n      const cellSize = 2\n      const spacing = 3\n\n      for (let x = 0; x < gridSize; x++) {\n        for (let y = 0; y < gridSize; y++) {\n          ctx.rect(\n            pos[0] - 4 + x * spacing,\n            pos[1] - 4 + y * spacing,\n            cellSize,\n            cellSize,\n          )\n        }\n      }\n      doStroke = false\n    } else {\n      // Default rendering for circle, hollow circle.\n      if (lowQuality) {\n        ctx.rect(pos[0] - 4, pos[1] - 4, 8, 8)\n      } else {\n        let radius: number\n        if (slot_shape === SlotShape.HollowCircle) {\n          doFill = false\n          doStroke = true\n          ctx.lineWidth = 3\n          ctx.strokeStyle = ctx.fillStyle\n          radius = highlight ? 4 : 3\n        } else {\n          // Normal circle\n          radius = highlight ? 5 : 4\n        }\n        ctx.arc(pos[0], pos[1], radius, 0, Math.PI * 2)\n      }\n    }\n\n    if (doFill) ctx.fill()\n    if (!lowQuality && doStroke) ctx.stroke()\n\n    // render slot label\n    const hideLabel = lowQuality || this.isWidgetInputSlot\n    if (!hideLabel) {\n      const text = this.renderingLabel\n      if (text) {\n        // TODO: Finish impl.  Highlight text on mouseover unless we're connecting links.\n        ctx.fillStyle = labelColor\n\n        if (labelPosition === LabelPosition.Right) {\n          if (this.dir == LinkDirection.UP) {\n            ctx.fillText(text, pos[0], pos[1] - 10)\n          } else {\n            ctx.fillText(text, pos[0] + 10, pos[1] + 5)\n          }\n        } else {\n          if (this.dir == LinkDirection.DOWN) {\n            ctx.fillText(text, pos[0], pos[1] - 8)\n          } else {\n            ctx.fillText(text, pos[0] - 10, pos[1] + 5)\n          }\n        }\n      }\n    }\n\n    // Draw a red circle if the slot has errors.\n    if (this.hasErrors) {\n      ctx.lineWidth = 2\n      ctx.strokeStyle = \"red\"\n      ctx.beginPath()\n      ctx.arc(pos[0], pos[1], 12, 0, Math.PI * 2)\n      ctx.stroke()\n    }\n\n    // Restore the original fillStyle and strokeStyle\n    ctx.fillStyle = originalFillStyle\n    ctx.strokeStyle = originalStrokeStyle\n    ctx.lineWidth = originalLineWidth\n  }\n\n  drawCollapsed(ctx: CanvasRenderingContext2D) {\n    const [x, y] = this.collapsedPos\n\n    // Save original styles\n    const { fillStyle } = ctx\n\n    ctx.fillStyle = \"#686\"\n    ctx.beginPath()\n\n    if (this.type === SlotType.Event || this.shape === RenderShape.BOX) {\n      ctx.rect(x - 7 + 0.5, y - 4, 14, 8)\n    } else if (this.shape === RenderShape.ARROW) {\n      // Adjust arrow direction based on whether this is an input or output slot\n      const isInput = this instanceof NodeInputSlot\n      if (isInput) {\n        ctx.moveTo(x + 8, y)\n        ctx.lineTo(x - 4, y - 4)\n        ctx.lineTo(x - 4, y + 4)\n      } else {\n        ctx.moveTo(x + 6, y)\n        ctx.lineTo(x - 6, y - 4)\n        ctx.lineTo(x - 6, y + 4)\n      }\n      ctx.closePath()\n    } else {\n      ctx.arc(x, y, 4, 0, Math.PI * 2)\n    }\n    ctx.fill()\n\n    // Restore original styles\n    ctx.fillStyle = fillStyle\n  }\n}\n","import type { INodeInputSlot, INodeOutputSlot, OptionalProps, ReadOnlyPoint } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LinkId } from \"@/LLink\"\n\nimport { LabelPosition } from \"@/draw\"\nimport { LiteGraph } from \"@/litegraph\"\nimport { type IDrawOptions, NodeSlot } from \"@/node/NodeSlot\"\n\nexport class NodeInputSlot extends NodeSlot implements INodeInputSlot {\n  link: LinkId | null\n\n  get isWidgetInputSlot(): boolean {\n    return !!this.widget\n  }\n\n  get collapsedPos(): ReadOnlyPoint {\n    return [0, LiteGraph.NODE_TITLE_HEIGHT * -0.5]\n  }\n\n  constructor(slot: OptionalProps<INodeInputSlot, \"boundingRect\">, node: LGraphNode) {\n    super(slot, node)\n    this.link = slot.link\n  }\n\n  override get isConnected(): boolean {\n    return this.link != null\n  }\n\n  override isValidTarget(fromSlot: INodeInputSlot | INodeOutputSlot): boolean {\n    return \"links\" in fromSlot && LiteGraph.isValidConnection(this.type, fromSlot.type)\n  }\n\n  override draw(ctx: CanvasRenderingContext2D, options: Omit<IDrawOptions, \"doStroke\" | \"labelPosition\">) {\n    const { textAlign } = ctx\n    ctx.textAlign = \"left\"\n\n    super.draw(ctx, {\n      ...options,\n      labelPosition: LabelPosition.Right,\n      doStroke: false,\n    })\n\n    ctx.textAlign = textAlign\n  }\n}\n","import type { INodeInputSlot, INodeOutputSlot, OptionalProps, ReadOnlyPoint } from \"@/interfaces\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { LinkId } from \"@/LLink\"\n\nimport { LabelPosition } from \"@/draw\"\nimport { LiteGraph } from \"@/litegraph\"\nimport { type IDrawOptions, NodeSlot } from \"@/node/NodeSlot\"\n\nexport class NodeOutputSlot extends NodeSlot implements INodeOutputSlot {\n  #node: LGraphNode\n\n  links: LinkId[] | null\n  _data?: unknown\n  slot_index?: number\n\n  get isWidgetInputSlot(): false {\n    return false\n  }\n\n  get collapsedPos(): ReadOnlyPoint {\n    return [\n      this.#node._collapsed_width ?? LiteGraph.NODE_COLLAPSED_WIDTH,\n      LiteGraph.NODE_TITLE_HEIGHT * -0.5,\n    ]\n  }\n\n  constructor(slot: OptionalProps<INodeOutputSlot, \"boundingRect\">, node: LGraphNode) {\n    super(slot, node)\n    this.links = slot.links\n    this._data = slot._data\n    this.slot_index = slot.slot_index\n    this.#node = node\n  }\n\n  override isValidTarget(fromSlot: INodeInputSlot | INodeOutputSlot): boolean {\n    return \"link\" in fromSlot && LiteGraph.isValidConnection(this.type, fromSlot.type)\n  }\n\n  override get isConnected(): boolean {\n    return this.links != null && this.links.length > 0\n  }\n\n  override draw(ctx: CanvasRenderingContext2D, options: Omit<IDrawOptions, \"doStroke\" | \"labelPosition\">) {\n    const { textAlign, strokeStyle } = ctx\n    ctx.textAlign = \"right\"\n    ctx.strokeStyle = \"black\"\n\n    super.draw(ctx, {\n      ...options,\n      labelPosition: LabelPosition.Left,\n      doStroke: true,\n    })\n\n    ctx.textAlign = textAlign\n    ctx.strokeStyle = strokeStyle\n  }\n}\n","import type { IWidgetInputSlot, SharedIntersection } from \"@/interfaces\"\nimport type { INodeInputSlot, INodeOutputSlot, INodeSlot, IWidget } from \"@/litegraph\"\nimport type { ISerialisableNodeInput, ISerialisableNodeOutput } from \"@/types/serialisation\"\n\ntype CommonIoSlotProps = SharedIntersection<ISerialisableNodeInput, ISerialisableNodeOutput>\n\nexport function shallowCloneCommonProps(slot: CommonIoSlotProps): CommonIoSlotProps {\n  const { color_off, color_on, dir, label, localized_name, locked, name, nameLocked, removable, shape, type } = slot\n  return { color_off, color_on, dir, label, localized_name, locked, name, nameLocked, removable, shape, type }\n}\n\nexport function inputAsSerialisable(slot: INodeInputSlot): ISerialisableNodeInput {\n  const { link } = slot\n  const widgetOrPos = slot.widget\n    ? { widget: { name: slot.widget.name } }\n    : { pos: slot.pos }\n\n  return {\n    ...shallowCloneCommonProps(slot),\n    ...widgetOrPos,\n    link,\n  }\n}\n\nexport function outputAsSerialisable(slot: INodeOutputSlot & { widget?: IWidget }): ISerialisableNodeOutput {\n  const { pos, slot_index, links, widget } = slot\n  // Output widgets do not exist in Litegraph; this is a temporary downstream workaround.\n  const outputWidget = widget\n    ? { widget: { name: widget.name } }\n    : null\n\n  return {\n    ...shallowCloneCommonProps(slot),\n    ...outputWidget,\n    pos,\n    slot_index,\n    links,\n  }\n}\n\nexport function isINodeInputSlot(slot: INodeSlot): slot is INodeInputSlot {\n  return \"link\" in slot\n}\n\nexport function isINodeOutputSlot(slot: INodeSlot): slot is INodeOutputSlot {\n  return \"links\" in slot\n}\n\n/**\n * Type guard: Whether this input slot is attached to a widget.\n * @param slot The slot to check.\n */\n\nexport function isWidgetInputSlot(slot: INodeInputSlot): slot is IWidgetInputSlot {\n  return !!slot.widget\n}\n","import type { ISlotType } from \"./litegraph\"\n\n/**\n * Uses the standard String() function to coerce to string, unless the value is null or undefined - then null.\n * @param value The value to convert\n * @returns String(value) or null\n */\nexport function stringOrNull(value: unknown): string | null {\n  return value == null ? null : String(value)\n}\n\n/**\n * Uses the standard String() function to coerce to string, unless the value is null or undefined - then an empty string\n * @param value The value to convert\n * @returns String(value) or \"\"\n */\nexport function stringOrEmpty(value: unknown): string {\n  return value == null ? \"\" : String(value)\n}\n\nexport function parseSlotTypes(type: ISlotType): string[] {\n  return type == \"\" || type == \"0\" ? [\"*\"] : String(type).toLowerCase().split(\",\")\n}\n","import type { ConnectingLink, INodeInputSlot, INodeOutputSlot, ISlotType, Positionable } from \"../interfaces\"\nimport type { LinkId } from \"@/LLink\"\n\nimport { type IGenericLinkOrLinks, LGraphNode } from \"@/LGraphNode\"\nimport { parseSlotTypes } from \"@/strings\"\n\n/**\n * Creates a flat set of all positionable items by recursively iterating through all child items.\n *\n * Does not include or recurse into pinned items.\n * @param items The original set of items to iterate through\n * @returns All unpinned items in the original set, and recursively, their children\n */\nexport function getAllNestedItems(items: ReadonlySet<Positionable>): Set<Positionable> {\n  const allItems = new Set<Positionable>()\n  if (items) {\n    for (const item of items) addRecursively(item, allItems)\n  }\n  return allItems\n\n  function addRecursively(item: Positionable, flatSet: Set<Positionable>): void {\n    if (flatSet.has(item) || item.pinned) return\n    flatSet.add(item)\n    if (item.children) {\n      for (const child of item.children) addRecursively(child, flatSet)\n    }\n  }\n}\n\n/**\n * Iterates through a collection of {@link Positionable} items, returning the first {@link LGraphNode}.\n * @param items The items to search through\n * @returns The first node found in {@link items}, otherwise `undefined`\n */\nexport function findFirstNode(items: Iterable<Positionable>): LGraphNode | undefined {\n  for (const item of items) {\n    if (item instanceof LGraphNode) return item\n  }\n}\n\n/** @returns `true` if the provided link ID is currently being dragged. */\nexport function isDraggingLink(linkId: LinkId, connectingLinks: ConnectingLink[] | null | undefined): ConnectingLink | undefined {\n  if (connectingLinks == null) return\n\n  for (const connectingLink of connectingLinks) {\n    if (connectingLink.link == null) continue\n    if (linkId === connectingLink.link.id) return connectingLink\n  }\n}\n\ntype InputOrOutput = (INodeInputSlot | INodeOutputSlot) & IGenericLinkOrLinks\ntype FreeSlotResult<T extends InputOrOutput> = { index: number, slot: T } | undefined\n\n/**\n * Finds the first free in/out slot with any of the comma-delimited types in {@link type}.\n *\n * If no slots are free, falls back in order to:\n * - The first free wildcard slot\n * - The first occupied slot\n * - The first occupied wildcard slot\n * @param slots The iterable of node slots slots to search through\n * @param type The {@link ISlotType type} of slot to find\n * @returns The index and slot if found, otherwise `undefined`.\n */\nexport function findFreeSlotOfType<T extends InputOrOutput>(\n  slots: T[],\n  type: ISlotType,\n): FreeSlotResult<T> {\n  if (!slots?.length) return\n\n  let occupiedSlot: FreeSlotResult<T>\n  let wildSlot: FreeSlotResult<T>\n  let occupiedWildSlot: FreeSlotResult<T>\n\n  const validTypes = parseSlotTypes(type)\n\n  for (const [index, slot] of slots.entries()) {\n    const slotTypes = parseSlotTypes(slot.type)\n\n    for (const validType of validTypes) {\n      for (const slotType of slotTypes) {\n        if (slotType === validType) {\n          if (slot.link == null && !slot.links?.length) {\n            // Exact match - short circuit\n            return { index, slot }\n          }\n          // In case we can't find a free slot.\n          occupiedSlot ??= { index, slot }\n        } else if (!wildSlot && (validType === \"*\" || slotType === \"*\")) {\n          // Save the first free wildcard slot as a fallback\n          if (slot.link == null && !slot.links?.length) {\n            wildSlot = { index, slot }\n          } else {\n            occupiedWildSlot ??= { index, slot }\n          }\n        }\n      }\n    }\n  }\n  return wildSlot ?? occupiedSlot ?? occupiedWildSlot\n}\n","import { LiteGraph } from \"@/litegraph\"\n\n/** Guard against unbound allocation. */\nconst UNIQUE_MESSAGE_LIMIT = 10_000\nconst sentWarnings: Set<string> = new Set()\n\n/**\n * Warns that a deprecated function has been used via the public\n * {@link onDeprecationWarning} / {@link onEveryDeprecationWarning} callback arrays.\n * @param message Plain-language detail about what has been deprecated. This **should not** include unique data; use {@link source}.\n * @param source A reference object to include alongside the message, e.g. `this`.\n */\nexport function warnDeprecated(message: string, source?: object): void {\n  if (!LiteGraph.alwaysRepeatWarnings) {\n    // Do not repeat\n    if (sentWarnings.has(message)) return\n\n    // Hard limit of unique messages per session\n    if (sentWarnings.size > UNIQUE_MESSAGE_LIMIT) return\n\n    sentWarnings.add(message)\n  }\n\n  for (const callback of LiteGraph.onDeprecationWarning) {\n    callback(message, source)\n  }\n}\n","export interface SpaceRequest {\n  minSize: number\n  maxSize?: number\n}\n\n/**\n * Distributes available space among items with min/max size constraints\n * @param totalSpace Total space available to distribute\n * @param requests Array of space requests with size constraints\n * @returns Array of space allocations\n */\nexport function distributeSpace(\n  totalSpace: number,\n  requests: SpaceRequest[],\n): number[] {\n  // Handle edge cases\n  if (requests.length === 0) return []\n\n  // Calculate total minimum space needed\n  const totalMinSize = requests.reduce((sum, req) => sum + req.minSize, 0)\n\n  // If we can't meet minimum requirements, return the minimum sizes\n  if (totalSpace < totalMinSize) {\n    return requests.map(req => req.minSize)\n  }\n\n  // Initialize allocations with minimum sizes\n  let allocations = requests.map(req => ({\n    computedSize: req.minSize,\n    maxSize: req.maxSize ?? Infinity,\n    remaining: (req.maxSize ?? Infinity) - req.minSize,\n  }))\n\n  // Calculate remaining space to distribute\n  let remainingSpace = totalSpace - totalMinSize\n\n  // Distribute remaining space iteratively\n  while (\n    remainingSpace > 0 &&\n    allocations.some(alloc => alloc.remaining > 0)\n  ) {\n    // Count items that can still grow\n    const growableItems = allocations.filter(\n      alloc => alloc.remaining > 0,\n    ).length\n\n    if (growableItems === 0) break\n\n    // Calculate fair share per item\n    const sharePerItem = remainingSpace / growableItems\n\n    // Track how much space was actually used in this iteration\n    let spaceUsedThisRound = 0\n\n    // Distribute space\n    allocations = allocations.map((alloc) => {\n      if (alloc.remaining <= 0) return alloc\n\n      const growth = Math.min(sharePerItem, alloc.remaining)\n      spaceUsedThisRound += growth\n\n      return {\n        ...alloc,\n        computedSize: alloc.computedSize + growth,\n        remaining: alloc.remaining - growth,\n      }\n    })\n\n    remainingSpace -= spaceUsedThisRound\n\n    // Break if we couldn't distribute any more space\n    if (spaceUsedThisRound === 0) break\n  }\n\n  // Return only the computed sizes\n  return allocations.map(({ computedSize }) => computedSize)\n}\n","import type { IColorable } from \"@/interfaces\"\n\n/**\n * Converts a plain object to a class instance if it is not already an instance of the class.\n *\n * Requires specific constructor signature; first parameter must be the object to convert.\n * @param cls The class to convert to\n * @param args The object to convert, followed by any other constructor arguments\n * @returns The class instance\n */\nexport function toClass<P, C extends P, Args extends unknown[]>(\n  cls: new (instance: P, ...args: Args) => C,\n  ...args: [P, ...Args]\n): C {\n  return args[0] instanceof cls ? args[0] : new cls(...args)\n}\n\n/**\n * Checks if an object is an instance of {@link IColorable}.\n */\nexport function isColorable(obj: unknown): obj is IColorable {\n  return typeof obj === \"object\" && obj !== null && \"setColorOption\" in obj && \"getColorOption\" in obj\n}\n","import type { Point, ReadOnlyPoint, ReadOnlyRect, ReadOnlySize, Size } from \"@/interfaces\"\n\n/**\n * A rectangle, represented as a float64 array of 4 numbers: [x, y, width, height].\n *\n * This class is a subclass of Float64Array, and so has all the methods of that class.  Notably,\n * {@link Rectangle.from} can be used to convert a {@link ReadOnlyRect}.\n *\n * Sub-array properties ({@link Float64Array.subarray}):\n * - {@link pos}: The position of the top-left corner of the rectangle.\n * - {@link size}: The size of the rectangle.\n */\nexport class Rectangle extends Float64Array {\n  #pos: Point | undefined\n  #size: Size | undefined\n\n  constructor(x: number = 0, y: number = 0, width: number = 0, height: number = 0) {\n    super(4)\n\n    this[0] = x\n    this[1] = y\n    this[2] = width\n    this[3] = height\n  }\n\n  override subarray(begin: number = 0, end?: number): Float64Array<ArrayBuffer> {\n    const byteOffset = begin << 3\n    const length = end === undefined ? end : end - begin\n    return new Float64Array(this.buffer, byteOffset, length)\n  }\n\n  /**\n   * A reference to the position of the top-left corner of this rectangle.\n   *\n   * Updating the values of the returned object will update this rectangle.\n   */\n  get pos(): Point {\n    this.#pos ??= this.subarray(0, 2)\n    return this.#pos\n  }\n\n  set pos(value: ReadOnlyPoint) {\n    this[0] = value[0]\n    this[1] = value[1]\n  }\n\n  /**\n   * A reference to the size of this rectangle.\n   *\n   * Updating the values of the returned object will update this rectangle.\n   */\n  get size(): Size {\n    this.#size ??= this.subarray(2, 4)\n    return this.#size\n  }\n\n  set size(value: ReadOnlySize) {\n    this[2] = value[0]\n    this[3] = value[1]\n  }\n\n  // #region Property accessors\n  /** The x co-ordinate of the top-left corner of this rectangle. */\n  get x() {\n    return this[0]\n  }\n\n  set x(value: number) {\n    this[0] = value\n  }\n\n  /** The y co-ordinate of the top-left corner of this rectangle. */\n  get y() {\n    return this[1]\n  }\n\n  set y(value: number) {\n    this[1] = value\n  }\n\n  /** The width of this rectangle. */\n  get width() {\n    return this[2]\n  }\n\n  set width(value: number) {\n    this[2] = value\n  }\n\n  /** The height of this rectangle. */\n  get height() {\n    return this[3]\n  }\n\n  set height(value: number) {\n    this[3] = value\n  }\n\n  /** The x co-ordinate of the left edge of this rectangle. */\n  get left() {\n    return this[0]\n  }\n\n  set left(value: number) {\n    this[0] = value\n  }\n\n  /** The y co-ordinate of the top edge of this rectangle. */\n  get top() {\n    return this[1]\n  }\n\n  set top(value: number) {\n    this[1] = value\n  }\n\n  /** The x co-ordinate of the right edge of this rectangle. */\n  get right() {\n    return this[0] + this[2]\n  }\n\n  set right(value: number) {\n    this[0] = value - this[2]\n  }\n\n  /** The y co-ordinate of the bottom edge of this rectangle. */\n  get bottom() {\n    return this[1] + this[3]\n  }\n\n  set bottom(value: number) {\n    this[1] = value - this[3]\n  }\n\n  /** The x co-ordinate of the centre of this rectangle. */\n  get centreX() {\n    return this[0] + (this[2] * 0.5)\n  }\n\n  /** The y co-ordinate of the centre of this rectangle. */\n  get centreY() {\n    return this[1] + (this[3] * 0.5)\n  }\n  // #endregion Property accessors\n\n  /**\n   * Updates the rectangle to the values of {@link rect}.\n   * @param rect The rectangle to update to.\n   */\n  updateTo(rect: ReadOnlyRect) {\n    this[0] = rect[0]\n    this[1] = rect[1]\n    this[2] = rect[2]\n    this[3] = rect[3]\n  }\n\n  /**\n   * Checks if the point [{@link x}, {@link y}] is inside this rectangle.\n   * @param x The x-coordinate to check\n   * @param y The y-coordinate to check\n   * @returns `true` if the point is inside this rectangle, otherwise `false`.\n   */\n  containsXy(x: number, y: number): boolean {\n    const { x: left, y: top, width, height } = this\n    return left <= x &&\n      top <= y &&\n      left + width >= x &&\n      top + height >= y\n  }\n\n  /**\n   * Checks if {@link point} is inside this rectangle.\n   * @param point The point to check\n   * @returns `true` if {@link point} is inside this rectangle, otherwise `false`.\n   */\n  containsPoint(point: ReadOnlyPoint): boolean {\n    return this.x <= point[0] &&\n      this.y <= point[1] &&\n      this.x + this.width >= point[0] &&\n      this.y + this.height >= point[1]\n  }\n\n  /**\n   * Checks if {@link rect} is inside this rectangle.\n   * @param rect The rectangle to check\n   * @returns `true` if {@link rect} is inside this rectangle, otherwise `false`.\n   */\n  containsRect(rect: ReadOnlyRect): boolean {\n    return this.x <= rect[0] &&\n      this.y <= rect[1] &&\n      this.x + this.width >= rect[0] + rect[2] &&\n      this.y + this.height >= rect[1] + rect[3]\n  }\n\n  /**\n   * Checks if {@link rect} overlaps with this rectangle.\n   * @param rect The rectangle to check\n   * @returns `true` if {@link rect} overlaps with this rectangle, otherwise `false`.\n   */\n  overlaps(rect: ReadOnlyRect): boolean {\n    return this.x < rect[0] + rect[2] &&\n      this.y < rect[1] + rect[3] &&\n      this.x + this.width > rect[0] &&\n      this.y + this.height > rect[1]\n  }\n\n  /** @returns The centre point of this rectangle, as a new {@link Point}. */\n  getCentre(): Point {\n    return [this.centreX, this.centreY]\n  }\n\n  /** @returns The area of this rectangle. */\n  getArea(): number {\n    return this.width * this.height\n  }\n\n  /** @returns The perimeter of this rectangle. */\n  getPerimeter(): number {\n    return 2 * (this.width + this.height)\n  }\n\n  /** @returns The top-left corner of this rectangle, as a new {@link Point}. */\n  getTopLeft(): Point {\n    return [this[0], this[1]]\n  }\n\n  /** @returns The bottom-right corner of this rectangle, as a new {@link Point}. */\n  getBottomRight(): Point {\n    return [this.right, this.bottom]\n  }\n\n  /** @returns The width and height of this rectangle, as a new {@link Size}. */\n  getSize(): Size {\n    return [this[2], this[3]]\n  }\n\n  /** @returns The offset from the top-left of this rectangle to the point [{@link x}, {@link y}], as a new {@link Point}. */\n  getOffsetTo([x, y]: ReadOnlyPoint): Point {\n    return [x - this[0], y - this[1]]\n  }\n\n  /** @returns The offset from the point [{@link x}, {@link y}] to the top-left of this rectangle, as a new {@link Point}. */\n  getOffsetFrom([x, y]: ReadOnlyPoint): Point {\n    return [this[0] - x, this[1] - y]\n  }\n\n  /** Sets the width without moving the right edge (changes position) */\n  setWidthRightAnchored(width: number) {\n    const currentWidth = this[2]\n    this[2] = width\n    this[0] += currentWidth - width\n  }\n\n  /** Sets the height without moving the bottom edge (changes position) */\n  setHeightBottomAnchored(height: number) {\n    const currentHeight = this[3]\n    this[3] = height\n    this[1] += currentHeight - height\n  }\n\n  /** Alias of {@link export}. */\n  toArray() { return this.export() }\n\n  /** @returns A new, untyped array (serializable) containing the values of this rectangle. */\n  export(): [number, number, number, number] {\n    return [this[0], this[1], this[2], this[3]]\n  }\n\n  /** Draws a debug outline of this rectangle. */\n  _drawDebug(ctx: CanvasRenderingContext2D, colour = \"red\") {\n    const { strokeStyle, lineWidth } = ctx\n    try {\n      ctx.strokeStyle = colour\n      ctx.lineWidth = 0.5\n      ctx.beginPath()\n      ctx.strokeRect(this[0], this[1], this[2], this[3])\n    } finally {\n      ctx.strokeStyle = strokeStyle\n      ctx.lineWidth = lineWidth\n    }\n  }\n}\n","import type { Point } from \"@/interfaces\"\nimport type { CanvasPointer, LGraphCanvas, LGraphNode, Size } from \"@/litegraph\"\nimport type { CanvasMouseEvent, CanvasPointerEvent } from \"@/types/events\"\nimport type { IBaseWidget } from \"@/types/widgets\"\n\nimport { drawTextInArea } from \"@/draw\"\nimport { Rectangle } from \"@/infrastructure/Rectangle\"\nimport { LiteGraph } from \"@/litegraph\"\n\nexport interface DrawWidgetOptions {\n  /** The width of the node where this widget will be displayed. */\n  width: number\n  /** Synonym for \"low quality\". */\n  showText?: boolean\n}\n\nexport interface DrawTruncatingTextOptions extends DrawWidgetOptions {\n  /** The canvas context to draw the text on. */\n  ctx: CanvasRenderingContext2D\n  /** The amount of padding to add to the left of the text. */\n  leftPadding?: number\n  /** The amount of padding to add to the right of the text. */\n  rightPadding?: number\n}\n\nexport interface WidgetEventOptions {\n  e: CanvasMouseEvent\n  node: LGraphNode\n  canvas: LGraphCanvas\n}\n\nexport abstract class BaseWidget<TWidget extends IBaseWidget = IBaseWidget> implements IBaseWidget {\n  /** From node edge to widget edge */\n  static margin = 15\n  /** From widget edge to tip of arrow button */\n  static arrowMargin = 6\n  /** Arrow button width */\n  static arrowWidth = 10\n  /** Absolute minimum display width of widget values */\n  static minValueWidth = 42\n  /** Minimum gap between label and value */\n  static labelValueGap = 5\n\n  declare computedHeight?: number\n  declare serialize?: boolean\n  computeLayoutSize?(node: LGraphNode): {\n    minHeight: number\n    maxHeight?: number\n    minWidth: number\n    maxWidth?: number\n  }\n\n  #node: LGraphNode\n  /** The node that this widget belongs to. */\n  get node() {\n    return this.#node\n  }\n\n  linkedWidgets?: IBaseWidget[]\n  name: string\n  options: TWidget[\"options\"]\n  label?: string\n  type: TWidget[\"type\"]\n  y: number = 0\n  last_y?: number\n  width?: number\n  disabled?: boolean\n  computedDisabled?: boolean\n  hidden?: boolean\n  advanced?: boolean\n  tooltip?: string\n  element?: HTMLElement\n  callback?(\n    value: any,\n    canvas?: LGraphCanvas,\n    node?: LGraphNode,\n    pos?: Point,\n    e?: CanvasMouseEvent,\n  ): void\n  mouse?(event: CanvasPointerEvent, pointerOffset: Point, node: LGraphNode): boolean\n  computeSize?(width?: number): Size\n  onPointerDown?(pointer: CanvasPointer, node: LGraphNode, canvas: LGraphCanvas): boolean\n\n  #value?: TWidget[\"value\"]\n  get value(): TWidget[\"value\"] {\n    return this.#value\n  }\n\n  set value(value: TWidget[\"value\"]) {\n    this.#value = value\n  }\n\n  constructor(widget: TWidget & { node: LGraphNode })\n  constructor(widget: TWidget, node: LGraphNode)\n  constructor(widget: TWidget & { node: LGraphNode }, node?: LGraphNode) {\n    // Private fields\n    this.#node = node ?? widget.node\n\n    // The set and get functions for DOM widget values are hacked on to the options object;\n    // attempting to set value before options will throw.\n    // https://github.com/Comfy-Org/ComfyUI_frontend/blob/df86da3d672628a452baed3df3347a52c0c8d378/src/scripts/domWidget.ts#L125\n    this.name = widget.name\n    this.options = widget.options\n    this.type = widget.type\n\n    // `node` has no setter - Object.assign will throw.\n    // TODO: Resolve this workaround. Ref: https://github.com/Comfy-Org/litegraph.js/issues/1022\n    // @ts-expect-error Prevent naming conflicts with custom nodes.\n    // eslint-disable-next-line unused-imports/no-unused-vars\n    const { node: _, outline_color, background_color, height, text_color, secondary_text_color, disabledTextColor, displayName, displayValue, labelBaseline, ...safeValues } = widget\n\n    Object.assign(this, safeValues)\n  }\n\n  get outline_color() {\n    return this.advanced ? LiteGraph.WIDGET_ADVANCED_OUTLINE_COLOR : LiteGraph.WIDGET_OUTLINE_COLOR\n  }\n\n  get background_color() {\n    return LiteGraph.WIDGET_BGCOLOR\n  }\n\n  get height() {\n    return LiteGraph.NODE_WIDGET_HEIGHT\n  }\n\n  get text_color() {\n    return LiteGraph.WIDGET_TEXT_COLOR\n  }\n\n  get secondary_text_color() {\n    return LiteGraph.WIDGET_SECONDARY_TEXT_COLOR\n  }\n\n  get disabledTextColor() {\n    return LiteGraph.WIDGET_DISABLED_TEXT_COLOR\n  }\n\n  get displayName() {\n    return this.label || this.name\n  }\n\n  // TODO: Resolve this workaround. Ref: https://github.com/Comfy-Org/litegraph.js/issues/1022\n  get _displayValue(): string {\n    return String(this.value)\n  }\n\n  get labelBaseline() {\n    return this.y + this.height * 0.7\n  }\n\n  /**\n   * Draws the widget\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   * @remarks Not naming this `draw` as `draw` conflicts with the `draw` method in\n   * custom widgets.\n   */\n  abstract drawWidget(ctx: CanvasRenderingContext2D, options: DrawWidgetOptions): void\n\n  /**\n   * Draws the standard widget shape - elongated capsule. The path of the widget shape is not\n   * cleared, and may be used for further drawing.\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   * @remarks Leaves {@link ctx} dirty.\n   */\n  protected drawWidgetShape(ctx: CanvasRenderingContext2D, { width, showText }: DrawWidgetOptions): void {\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    ctx.textAlign = \"left\"\n    ctx.strokeStyle = this.outline_color\n    ctx.fillStyle = this.background_color\n    ctx.beginPath()\n\n    if (showText) {\n      ctx.roundRect(margin, y, width - margin * 2, height, [height * 0.5])\n    } else {\n      ctx.rect(margin, y, width - margin * 2, height)\n    }\n    ctx.fill()\n    if (showText && !this.computedDisabled) ctx.stroke()\n  }\n\n  /**\n   * A shared routine for drawing a label and value as text, truncated\n   * if they exceed the available width.\n   */\n  protected drawTruncatingText({\n    ctx,\n    width,\n    leftPadding = 5,\n    rightPadding = 20,\n  }: DrawTruncatingTextOptions): void {\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    // Measure label and value\n    const { displayName, _displayValue } = this\n    const labelWidth = ctx.measureText(displayName).width\n    const valueWidth = ctx.measureText(_displayValue).width\n\n    const gap = BaseWidget.labelValueGap\n    const x = margin * 2 + leftPadding\n\n    const totalWidth = width - x - 2 * margin - rightPadding\n    const requiredWidth = labelWidth + gap + valueWidth\n\n    const area = new Rectangle(x, y, totalWidth, height * 0.7)\n\n    ctx.fillStyle = this.secondary_text_color\n\n    if (requiredWidth <= totalWidth) {\n      // Draw label & value normally\n      drawTextInArea({ ctx, text: displayName, area, align: \"left\" })\n    } else if (LiteGraph.truncateWidgetTextEvenly) {\n      // Label + value will not fit - scale evenly to fit\n      const scale = (totalWidth - gap) / (requiredWidth - gap)\n      area.width = labelWidth * scale\n\n      drawTextInArea({ ctx, text: displayName, area, align: \"left\" })\n\n      // Move the area to the right to render the value\n      area.right = x + totalWidth\n      area.setWidthRightAnchored(valueWidth * scale)\n    } else if (LiteGraph.truncateWidgetValuesFirst) {\n      // Label + value will not fit - use legacy scaling of value first\n      const cappedLabelWidth = Math.min(labelWidth, totalWidth)\n\n      area.width = cappedLabelWidth\n      drawTextInArea({ ctx, text: displayName, area, align: \"left\" })\n\n      area.right = x + totalWidth\n      area.setWidthRightAnchored(Math.max(totalWidth - gap - cappedLabelWidth, 0))\n    } else {\n      // Label + value will not fit - scale label first\n      const cappedValueWidth = Math.min(valueWidth, totalWidth)\n\n      area.width = Math.max(totalWidth - gap - cappedValueWidth, 0)\n      drawTextInArea({ ctx, text: displayName, area, align: \"left\" })\n\n      area.right = x + totalWidth\n      area.setWidthRightAnchored(cappedValueWidth)\n    }\n    ctx.fillStyle = this.text_color\n    drawTextInArea({ ctx, text: _displayValue, area, align: \"right\" })\n  }\n\n  /**\n   * Handles the click event for the widget\n   * @param options The options for handling the click event\n   */\n  abstract onClick(options: WidgetEventOptions): void\n\n  /**\n   * Handles the drag event for the widget\n   * @param options The options for handling the drag event\n   */\n  onDrag?(options: WidgetEventOptions): void\n\n  /**\n   * Sets the value of the widget\n   * @param value The value to set\n   * @param options The options for setting the value\n   */\n  setValue(value: TWidget[\"value\"], { e, node, canvas }: WidgetEventOptions): void {\n    const oldValue = this.value\n    if (value === this.value) return\n\n    const v = this.type === \"number\" ? Number(value) : value\n    this.value = v\n    if (\n      this.options?.property &&\n      node.properties[this.options.property] !== undefined\n    ) {\n      node.setProperty(this.options.property, v)\n    }\n    const pos = canvas.graph_mouse\n    this.callback?.(this.value, canvas, node, pos, e)\n\n    node.onWidgetChanged?.(this.name ?? \"\", v, oldValue, this)\n    if (node.graph) node.graph._version++\n  }\n}\n","import type { IBooleanWidget } from \"@/types/widgets\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class BooleanWidget extends BaseWidget<IBooleanWidget> implements IBooleanWidget {\n  override type = \"toggle\" as const\n\n  override drawWidget(ctx: CanvasRenderingContext2D, {\n    width,\n    showText = true,\n  }: DrawWidgetOptions) {\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    this.drawWidgetShape(ctx, { width, showText })\n\n    ctx.fillStyle = this.value ? \"#89A\" : \"#333\"\n    ctx.beginPath()\n    ctx.arc(\n      width - margin * 2,\n      y + height * 0.5,\n      height * 0.36,\n      0,\n      Math.PI * 2,\n    )\n    ctx.fill()\n\n    if (showText) {\n      this.drawLabel(ctx, margin * 2)\n      this.drawValue(ctx, width - 40)\n    }\n  }\n\n  drawLabel(ctx: CanvasRenderingContext2D, x: number): void {\n    // Draw label\n    ctx.fillStyle = this.secondary_text_color\n    const { displayName } = this\n    if (displayName) ctx.fillText(displayName, x, this.labelBaseline)\n  }\n\n  drawValue(ctx: CanvasRenderingContext2D, x: number): void {\n    // Draw value\n    ctx.fillStyle = this.value ? this.text_color : this.secondary_text_color\n    ctx.textAlign = \"right\"\n    const value = this.value ? this.options.on || \"true\" : this.options.off || \"false\"\n    ctx.fillText(value, x, this.labelBaseline)\n  }\n\n  override onClick(options: WidgetEventOptions) {\n    this.setValue(!this.value, options)\n  }\n}\n","import type { LGraphNode } from \"@/LGraphNode\"\nimport type { IButtonWidget } from \"@/types/widgets\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class ButtonWidget extends BaseWidget<IButtonWidget> implements IButtonWidget {\n  override type = \"button\" as const\n  clicked: boolean\n\n  constructor(widget: IButtonWidget, node: LGraphNode) {\n    super(widget, node)\n    this.clicked ??= false\n  }\n\n  /**\n   * Draws the widget\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   */\n  override drawWidget(ctx: CanvasRenderingContext2D, {\n    width,\n    showText = true,\n  }: DrawWidgetOptions) {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    // Draw button background\n    ctx.fillStyle = this.background_color\n    if (this.clicked) {\n      ctx.fillStyle = \"#AAA\"\n      this.clicked = false\n    }\n    ctx.fillRect(margin, y, width - margin * 2, height)\n\n    // Draw button outline if not disabled\n    if (showText && !this.computedDisabled) {\n      ctx.strokeStyle = this.outline_color\n      ctx.strokeRect(margin, y, width - margin * 2, height)\n    }\n\n    // Draw button text\n    if (showText) this.drawLabel(ctx, width * 0.5)\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n\n  drawLabel(ctx: CanvasRenderingContext2D, x: number): void {\n    ctx.textAlign = \"center\"\n    ctx.fillStyle = this.text_color\n    ctx.fillText(this.displayName, x, this.y + this.height * 0.7)\n  }\n\n  override onClick({ e, node, canvas }: WidgetEventOptions) {\n    const pos = canvas.graph_mouse\n\n    // Set clicked state and mark canvas as dirty\n    this.clicked = true\n    canvas.setDirty(true)\n\n    // Call the callback with widget instance and other context\n    this.callback?.(this, canvas, node, pos, e)\n  }\n}\n","import type { IBaseWidget } from \"@/types/widgets\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\n/**\n * Base class for widgets that have increment and decrement buttons.\n */\nexport abstract class BaseSteppedWidget<TWidget extends IBaseWidget = IBaseWidget> extends BaseWidget<TWidget> {\n  /**\n   * Whether the widget can increment its value\n   * @returns `true` if the widget can increment its value, otherwise `false`\n   */\n  abstract canIncrement(): boolean\n  /**\n   * Whether the widget can decrement its value\n   * @returns `true` if the widget can decrement its value, otherwise `false`\n   */\n  abstract canDecrement(): boolean\n  /**\n   * Increment the value of the widget\n   * @param options The options for the widget event\n   */\n  abstract incrementValue(options: WidgetEventOptions): void\n  /**\n   * Decrement the value of the widget\n   * @param options The options for the widget event\n   */\n  abstract decrementValue(options: WidgetEventOptions): void\n\n  /**\n   * Draw the arrow buttons for the widget\n   * @param ctx The canvas rendering context\n   * @param width The width of the widget\n   */\n  drawArrowButtons(ctx: CanvasRenderingContext2D, width: number) {\n    const { height, text_color, disabledTextColor, y } = this\n    const { arrowMargin, arrowWidth, margin } = BaseWidget\n    const arrowTipX = margin + arrowMargin\n    const arrowInnerX = arrowTipX + arrowWidth\n\n    // Draw left arrow\n    ctx.fillStyle = this.canDecrement() ? text_color : disabledTextColor\n    ctx.beginPath()\n    ctx.moveTo(arrowInnerX, y + 5)\n    ctx.lineTo(arrowTipX, y + height * 0.5)\n    ctx.lineTo(arrowInnerX, y + height - 5)\n    ctx.fill()\n\n    // Draw right arrow\n    ctx.fillStyle = this.canIncrement() ? text_color : disabledTextColor\n    ctx.beginPath()\n    ctx.moveTo(width - arrowInnerX, y + 5)\n    ctx.lineTo(width - arrowTipX, y + height * 0.5)\n    ctx.lineTo(width - arrowInnerX, y + height - 5)\n    ctx.fill()\n  }\n\n  override drawWidget(ctx: CanvasRenderingContext2D, options: DrawWidgetOptions) {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    this.drawWidgetShape(ctx, options)\n    if (options.showText) {\n      if (!this.computedDisabled) this.drawArrowButtons(ctx, options.width)\n\n      this.drawTruncatingText({ ctx, width: options.width })\n    }\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n}\n","import type { WidgetEventOptions } from \"./BaseWidget\"\nimport type { LGraphNode } from \"@/LGraphNode\"\nimport type { IComboWidget, IStringComboWidget } from \"@/types/widgets\"\n\nimport { clamp, LiteGraph } from \"@/litegraph\"\nimport { warnDeprecated } from \"@/utils/feedback\"\n\nimport { BaseSteppedWidget } from \"./BaseSteppedWidget\"\n\n/**\n * This is used as an (invalid) assertion to resolve issues with legacy duck-typed values.\n *\n * Function style in use by:\n * https://github.com/kijai/ComfyUI-KJNodes/blob/c3dc82108a2a86c17094107ead61d63f8c76200e/web/js/setgetnodes.js#L401-L404\n */\ntype Values = string[] | Record<string, string> | ((widget?: ComboWidget, node?: LGraphNode) => string[])\n\nfunction toArray(values: Values): string[] {\n  return Array.isArray(values) ? values : Object.keys(values)\n}\n\nexport class ComboWidget extends BaseSteppedWidget<IStringComboWidget | IComboWidget> implements IComboWidget {\n  override type = \"combo\" as const\n\n  override get _displayValue() {\n    const { values: rawValues } = this.options\n    if (rawValues) {\n      const values = typeof rawValues === \"function\" ? rawValues() : rawValues\n\n      if (values && !Array.isArray(values)) {\n        return values[this.value]\n      }\n    }\n    return typeof this.value === \"number\" ? String(this.value) : this.value\n  }\n\n  #getValues(node: LGraphNode): Values {\n    const { values } = this.options\n    if (values == null) throw new Error(\"[ComboWidget]: values is required\")\n\n    return typeof values === \"function\"\n      ? values(this, node)\n      : values\n  }\n\n  /**\n   * Checks if the value is {@link Array.at at} the given index in the combo list.\n   * @param increment `true` if checking the use of the increment button, `false` for decrement\n   * @returns `true` if the value is at the given index, otherwise `false`.\n   */\n  #canUseButton(increment: boolean): boolean {\n    const { values } = this.options\n    // If using legacy duck-typed method, false is the most permissive return value\n    if (typeof values === \"function\") return false\n\n    const valuesArray = toArray(values)\n    if (!(valuesArray.length > 1)) return false\n\n    // Edge case where the value is both the first and last item in the list\n    const firstValue = valuesArray.at(0)\n    const lastValue = valuesArray.at(-1)\n    if (firstValue === lastValue) return true\n\n    return this.value !== (increment ? lastValue : firstValue)\n  }\n\n  /**\n   * Returns `true` if the current value is not the last value in the list.\n   * Handles edge case where the value is both the first and last item in the list.\n   */\n  override canIncrement(): boolean {\n    return this.#canUseButton(true)\n  }\n\n  override canDecrement(): boolean {\n    return this.#canUseButton(false)\n  }\n\n  override incrementValue(options: WidgetEventOptions): void {\n    this.#tryChangeValue(1, options)\n  }\n\n  override decrementValue(options: WidgetEventOptions): void {\n    this.#tryChangeValue(-1, options)\n  }\n\n  #tryChangeValue(delta: number, options: WidgetEventOptions): void {\n    const values = this.#getValues(options.node)\n    const indexedValues = toArray(values)\n\n    // avoids double click event\n    options.canvas.last_mouseclick = 0\n\n    const foundIndex = typeof values === \"object\"\n      ? indexedValues.indexOf(String(this.value)) + delta\n      // @ts-expect-error handle non-string values\n      : indexedValues.indexOf(this.value) + delta\n\n    const index = clamp(foundIndex, 0, indexedValues.length - 1)\n\n    const value = Array.isArray(values)\n      ? values[index]\n      : index\n    this.setValue(value, options)\n  }\n\n  override onClick({ e, node, canvas }: WidgetEventOptions) {\n    const x = e.canvasX - node.pos[0]\n    const width = this.width || node.size[0]\n\n    // Deprecated functionality (warning as of v0.14.5)\n    if (typeof this.options.values === \"function\") {\n      warnDeprecated(\"Using a function for values is deprecated. Use an array of unique values instead.\")\n    }\n\n    // Determine if clicked on left/right arrows\n    if (x < 40) return this.decrementValue({ e, node, canvas })\n    if (x > width - 40) return this.incrementValue({ e, node, canvas })\n\n    // Otherwise, show dropdown menu\n    const values = this.#getValues(node)\n    const values_list = toArray(values)\n\n    // Handle center click - show dropdown menu\n    const text_values = values != values_list ? Object.values(values) : values\n    new LiteGraph.ContextMenu(text_values, {\n      scale: Math.max(1, canvas.ds.scale),\n      event: e,\n      className: \"dark\",\n      callback: (value: string) => {\n        this.setValue(\n          values != values_list\n            ? text_values.indexOf(value)\n            : value,\n          { e, node, canvas },\n        )\n      },\n    })\n  }\n}\n","import type { IWidgetOptions } from \"@/types/widgets\"\n\n/**\n * The step value for numeric widgets.\n * Use {@link IWidgetOptions.step2} if available, otherwise fallback to\n * {@link IWidgetOptions.step} which is scaled up by 10x in the legacy frontend logic.\n */\nexport function getWidgetStep(options: IWidgetOptions<unknown>): number {\n  return options.step2 || ((options.step || 10) * 0.1)\n}\n","import type { IKnobWidget } from \"@/types/widgets\"\n\nimport { clamp } from \"@/litegraph\"\nimport { getWidgetStep } from \"@/utils/widget\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class KnobWidget extends BaseWidget<IKnobWidget> implements IKnobWidget {\n  override type = \"knob\" as const\n\n  /**\n   * Compute the layout size of the widget.\n   * @returns The layout size of the widget.\n   */\n  override computeLayoutSize(): {\n    minHeight: number\n    maxHeight?: number\n    minWidth: number\n    maxWidth?: number\n  } {\n    return {\n      minHeight: 60,\n      minWidth: 20,\n      maxHeight: 1_000_000,\n      maxWidth: 1_000_000,\n    }\n  }\n\n  override get height(): number {\n    return this.computedHeight || super.height\n  }\n\n  drawWidget(\n    ctx: CanvasRenderingContext2D,\n    {\n      width,\n      showText = true,\n    }: DrawWidgetOptions,\n  ): void {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    const { y } = this\n    const { margin } = BaseWidget\n\n    const { gradient_stops = \"rgb(14, 182, 201); rgb(0, 216, 72)\" } = this.options\n    const effective_height = this.computedHeight || this.height\n    // Draw background\n    const size_modifier =\n      Math.min(this.computedHeight || this.height, this.width || 20) / 20 // TODO: replace magic numbers\n    const arc_center = { x: width / 2, y: effective_height / 2 + y }\n    ctx.lineWidth =\n      (Math.min(width, effective_height) - margin * size_modifier) / 6\n    const arc_size =\n      (Math.min(width, effective_height) -\n        margin * size_modifier -\n        ctx.lineWidth) / 2\n    {\n      const gradient = ctx.createRadialGradient(\n        arc_center.x,\n        arc_center.y,\n        arc_size + ctx.lineWidth,\n        0,\n        0,\n        arc_size + ctx.lineWidth,\n      )\n      gradient.addColorStop(0, \"rgb(29, 29, 29)\")\n      gradient.addColorStop(1, \"rgb(116, 116, 116)\")\n      ctx.fillStyle = gradient\n    }\n    ctx.beginPath()\n\n    {\n      ctx.arc(\n        arc_center.x,\n        arc_center.y,\n        arc_size + ctx.lineWidth / 2,\n        0,\n        Math.PI * 2,\n        false,\n      )\n      ctx.fill()\n      ctx.closePath()\n    }\n\n    // Draw knob's background\n    const arc = {\n      start_angle: Math.PI * 0.6,\n      end_angle: Math.PI * 2.4,\n    }\n    ctx.beginPath()\n    {\n      const gradient = ctx.createRadialGradient(\n        arc_center.x,\n        arc_center.y,\n        arc_size + ctx.lineWidth,\n        0,\n        0,\n        arc_size + ctx.lineWidth,\n      )\n      gradient.addColorStop(0, \"rgb(99, 99, 99)\")\n      gradient.addColorStop(1, \"rgb(36, 36, 36)\")\n      ctx.strokeStyle = gradient\n    }\n    ctx.arc(\n      arc_center.x,\n      arc_center.y,\n      arc_size,\n      arc.start_angle,\n      arc.end_angle,\n      false,\n    )\n    ctx.stroke()\n    ctx.closePath()\n\n    const range = this.options.max - this.options.min\n    let nvalue = (this.value - this.options.min) / range\n    nvalue = clamp(nvalue, 0, 1)\n\n    // Draw value\n    ctx.beginPath()\n    const gradient = ctx.createConicGradient(\n      arc.start_angle,\n      arc_center.x,\n      arc_center.y,\n    )\n    const gs = gradient_stops.split(\";\")\n    for (const [index, stop] of gs.entries()) {\n      gradient.addColorStop(index, stop.trim())\n    }\n\n    ctx.strokeStyle = gradient\n    const value_end_angle =\n      (arc.end_angle - arc.start_angle) * nvalue + arc.start_angle\n    ctx.arc(\n      arc_center.x,\n      arc_center.y,\n      arc_size,\n      arc.start_angle,\n      value_end_angle,\n      false,\n    )\n    ctx.stroke()\n    ctx.closePath()\n\n    // Draw outline if not disabled\n    if (showText && !this.computedDisabled) {\n      ctx.strokeStyle = this.outline_color\n      // Draw value\n      ctx.beginPath()\n      ctx.strokeStyle = this.outline_color\n      ctx.arc(\n        arc_center.x,\n        arc_center.y,\n        arc_size + ctx.lineWidth / 2,\n        0,\n        Math.PI * 2,\n        false,\n      )\n      ctx.lineWidth = 1\n      ctx.stroke()\n      ctx.closePath()\n    }\n\n    // Draw marker if present\n    // TODO: TBD later when options work\n\n    // Draw text\n    if (showText) {\n      ctx.textAlign = \"center\"\n      ctx.fillStyle = this.text_color\n      const fixedValue = Number(this.value).toFixed(this.options.precision ?? 3)\n      ctx.fillText(\n        `${this.label || this.name}\\n${fixedValue}`,\n        width * 0.5,\n        y + effective_height * 0.5,\n      )\n    }\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n\n  onClick(): void {\n    this.current_drag_offset = 0\n  }\n\n  current_drag_offset = 0\n  override onDrag(options: WidgetEventOptions): void {\n    if (this.options.read_only) return\n    const { e } = options\n    const step = getWidgetStep(this.options)\n    // Shift to move by 10% increments\n    const range = (this.options.max - this.options.min)\n    const range_10_percent = range / 10\n    const range_1_percent = range / 100\n    const step_for = {\n      delta_x: step,\n      shift: range_10_percent > step ? range_10_percent - (range_10_percent % step) : step,\n      delta_y: range_1_percent > step ? range_1_percent - (range_1_percent % step) : step, // 1% increments\n    }\n\n    const use_y = Math.abs(e.movementY) > Math.abs(e.movementX)\n    const delta = use_y ? -e.movementY : e.movementX // Y is inverted so that UP increases the value\n    const drag_threshold = 15\n    // Calculate new value based on drag movement\n    this.current_drag_offset += delta\n    let adjustment = 0\n    if (this.current_drag_offset > drag_threshold) {\n      adjustment += 1\n      this.current_drag_offset -= drag_threshold\n    } else if (this.current_drag_offset < -drag_threshold) {\n      adjustment -= 1\n      this.current_drag_offset += drag_threshold\n    }\n\n    const step_with_shift_modifier = e.shiftKey\n      ? step_for.shift\n      : (use_y\n        ? step_for.delta_y\n        : step)\n\n    const deltaValue = adjustment * step_with_shift_modifier\n    const newValue = clamp(\n      this.value + deltaValue,\n      this.options.min,\n      this.options.max,\n    )\n    if (newValue !== this.value) {\n      this.setValue(newValue, options)\n    }\n  }\n}\n","import type { LGraphNode } from \"@/LGraphNode\"\nimport type { IBaseWidget } from \"@/types/widgets\"\n\nimport { LiteGraph } from \"@/litegraph\"\n\nimport { BaseWidget, type DrawWidgetOptions } from \"./BaseWidget\"\n\n/**\n * Wraps a legacy POJO custom widget, so that all widgets may be called via the same internal interface.\n *\n * Support will eventually be removed.\n * @remarks Expect this class to undergo breaking changes without warning.\n */\nexport class LegacyWidget<TWidget extends IBaseWidget = IBaseWidget> extends BaseWidget<TWidget> implements IBaseWidget {\n  draw?(\n    ctx: CanvasRenderingContext2D,\n    node: LGraphNode,\n    widget_width: number,\n    y: number,\n    H: number,\n    lowQuality?: boolean,\n  ): void\n\n  override drawWidget(ctx: CanvasRenderingContext2D, options: DrawWidgetOptions) {\n    const H = LiteGraph.NODE_WIDGET_HEIGHT\n    this.draw?.(ctx, this.node, options.width, this.y, H, !!options.showText)\n  }\n\n  override onClick() {\n    console.warn(\"Custom widget wrapper onClick was just called. Handling for third party widgets is done via LGraphCanvas - the mouse callback.\")\n  }\n}\n","import type { WidgetEventOptions } from \"./BaseWidget\"\nimport type { INumericWidget } from \"@/types/widgets\"\n\nimport { getWidgetStep } from \"@/utils/widget\"\n\nimport { BaseSteppedWidget } from \"./BaseSteppedWidget\"\n\nexport class NumberWidget extends BaseSteppedWidget<INumericWidget> implements INumericWidget {\n  override type = \"number\" as const\n\n  override get _displayValue() {\n    return Number(this.value).toFixed(\n      this.options.precision !== undefined\n        ? this.options.precision\n        : 3,\n    )\n  }\n\n  override canIncrement(): boolean {\n    const { max } = this.options\n    return max == null || this.value < max\n  }\n\n  override canDecrement(): boolean {\n    const { min } = this.options\n    return min == null || this.value > min\n  }\n\n  override incrementValue(options: WidgetEventOptions): void {\n    this.setValue(this.value + getWidgetStep(this.options), options)\n  }\n\n  override decrementValue(options: WidgetEventOptions): void {\n    this.setValue(this.value - getWidgetStep(this.options), options)\n  }\n\n  override setValue(value: number, options: WidgetEventOptions) {\n    let newValue = value\n    if (this.options.min != null && newValue < this.options.min) {\n      newValue = this.options.min\n    }\n    if (this.options.max != null && newValue > this.options.max) {\n      newValue = this.options.max\n    }\n    super.setValue(newValue, options)\n  }\n\n  override onClick({ e, node, canvas }: WidgetEventOptions) {\n    const x = e.canvasX - node.pos[0]\n    const width = this.width || node.size[0]\n\n    // Determine if clicked on left/right arrows\n    const delta = x < 40\n      ? -1\n      : (x > width - 40\n        ? 1\n        : 0)\n\n    if (delta) {\n      // Handle left/right arrow clicks\n      this.setValue(this.value + delta * getWidgetStep(this.options), { e, node, canvas })\n      return\n    }\n\n    // Handle center click - show prompt\n    canvas.prompt(\"Value\", this.value, (v: string) => {\n      // Check if v is a valid equation or a number\n      if (/^[\\d\\s()*+/-]+|\\d+\\.\\d+$/.test(v)) {\n        // Solve the equation if possible\n        try {\n          v = eval(v)\n        } catch {}\n      }\n      const newValue = Number(v)\n      if (!isNaN(newValue)) {\n        this.setValue(newValue, { e, node, canvas })\n      }\n    }, e)\n  }\n\n  /**\n   * Handles drag events for the number widget\n   * @param options The options for handling the drag event\n   */\n  override onDrag({ e, node, canvas }: WidgetEventOptions) {\n    const width = this.width || node.width\n    const x = e.canvasX - node.pos[0]\n    const delta = x < 40\n      ? -1\n      : (x > width - 40\n        ? 1\n        : 0)\n\n    if (delta && (x > -3 && x < width + 3)) return\n    this.setValue(this.value + (e.deltaX ?? 0) * getWidgetStep(this.options), { e, node, canvas })\n  }\n}\n","import type { ISliderWidget } from \"@/types/widgets\"\n\nimport { clamp } from \"@/litegraph\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class SliderWidget extends BaseWidget<ISliderWidget> implements ISliderWidget {\n  override type = \"slider\" as const\n\n  marker?: number\n\n  /**\n   * Draws the widget\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   */\n  override drawWidget(ctx: CanvasRenderingContext2D, {\n    width,\n    showText = true,\n  }: DrawWidgetOptions) {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    const { height, y } = this\n    const { margin } = BaseWidget\n\n    // Draw background\n    ctx.fillStyle = this.background_color\n    ctx.fillRect(margin, y, width - margin * 2, height)\n\n    // Calculate normalized value\n    const range = this.options.max - this.options.min\n    let nvalue = (this.value - this.options.min) / range\n    nvalue = clamp(nvalue, 0, 1)\n\n    // Draw slider bar\n    ctx.fillStyle = this.options.slider_color ?? \"#678\"\n    ctx.fillRect(margin, y, nvalue * (width - margin * 2), height)\n\n    // Draw outline if not disabled\n    if (showText && !this.computedDisabled) {\n      ctx.strokeStyle = this.outline_color\n      ctx.strokeRect(margin, y, width - margin * 2, height)\n    }\n\n    // Draw marker if present\n    if (this.marker != null) {\n      let marker_nvalue = (this.marker - this.options.min) / range\n      marker_nvalue = clamp(marker_nvalue, 0, 1)\n      ctx.fillStyle = this.options.marker_color ?? \"#AA9\"\n      ctx.fillRect(\n        margin + marker_nvalue * (width - margin * 2),\n        y,\n        2,\n        height,\n      )\n    }\n\n    // Draw text\n    if (showText) {\n      ctx.textAlign = \"center\"\n      ctx.fillStyle = this.text_color\n      const fixedValue = Number(this.value).toFixed(this.options.precision ?? 3)\n      ctx.fillText(\n        `${this.label || this.name}  ${fixedValue}`,\n        width * 0.5,\n        y + height * 0.7,\n      )\n    }\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n\n  /**\n   * Handles click events for the slider widget\n   */\n  override onClick(options: WidgetEventOptions) {\n    if (this.options.read_only) return\n\n    const { e, node } = options\n    const width = this.width || node.size[0]\n    const x = e.canvasX - node.pos[0]\n\n    // Calculate new value based on click position\n    const slideFactor = clamp((x - 15) / (width - 30), 0, 1)\n    const newValue = this.options.min + (this.options.max - this.options.min) * slideFactor\n\n    if (newValue !== this.value) {\n      this.setValue(newValue, options)\n    }\n  }\n\n  /**\n   * Handles drag events for the slider widget\n   */\n  override onDrag(options: WidgetEventOptions) {\n    if (this.options.read_only) return false\n\n    const { e, node } = options\n    const width = this.width || node.size[0]\n    const x = e.canvasX - node.pos[0]\n\n    // Calculate new value based on drag position\n    const slideFactor = clamp((x - 15) / (width - 30), 0, 1)\n    const newValue = this.options.min + (this.options.max - this.options.min) * slideFactor\n\n    if (newValue !== this.value) {\n      this.setValue(newValue, options)\n    }\n  }\n}\n","import type { LGraphNode } from \"@/LGraphNode\"\nimport type { IStringWidget } from \"@/types/widgets\"\n\nimport { BaseWidget, type DrawWidgetOptions, type WidgetEventOptions } from \"./BaseWidget\"\n\nexport class TextWidget extends BaseWidget<IStringWidget> implements IStringWidget {\n  constructor(widget: IStringWidget, node: LGraphNode) {\n    super(widget, node)\n    this.type ??= \"string\"\n    this.value = widget.value?.toString() ?? \"\"\n  }\n\n  /**\n   * Draws the widget\n   * @param ctx The canvas context\n   * @param options The options for drawing the widget\n   */\n  override drawWidget(ctx: CanvasRenderingContext2D, {\n    width,\n    showText = true,\n  }: DrawWidgetOptions) {\n    // Store original context attributes\n    const { fillStyle, strokeStyle, textAlign } = ctx\n\n    this.drawWidgetShape(ctx, { width, showText })\n\n    if (showText) {\n      this.drawTruncatingText({ ctx, width, leftPadding: 0, rightPadding: 0 })\n    }\n\n    // Restore original context attributes\n    Object.assign(ctx, { textAlign, strokeStyle, fillStyle })\n  }\n\n  override onClick({ e, node, canvas }: WidgetEventOptions) {\n    // Show prompt dialog for text input\n    canvas.prompt(\n      \"Value\",\n      this.value,\n      (v: string) => {\n        if (v !== null) {\n          this.setValue(v, { e, node, canvas })\n        }\n      },\n      e,\n      this.options?.multiline ?? false,\n    )\n  }\n}\n","import type { LGraphNode } from \"@/LGraphNode\"\nimport type {\n  IBaseWidget,\n  IBooleanWidget,\n  IButtonWidget,\n  IComboWidget,\n  ICustomWidget,\n  IKnobWidget,\n  INumericWidget,\n  ISliderWidget,\n  IStringWidget,\n  IWidget,\n  TWidgetType,\n} from \"@/types/widgets\"\n\nimport { toClass } from \"@/utils/type\"\n\nimport { BaseWidget } from \"./BaseWidget\"\nimport { BooleanWidget } from \"./BooleanWidget\"\nimport { ButtonWidget } from \"./ButtonWidget\"\nimport { ComboWidget } from \"./ComboWidget\"\nimport { KnobWidget } from \"./KnobWidget\"\nimport { LegacyWidget } from \"./LegacyWidget\"\nimport { NumberWidget } from \"./NumberWidget\"\nimport { SliderWidget } from \"./SliderWidget\"\nimport { TextWidget } from \"./TextWidget\"\n\nexport type WidgetTypeMap = {\n  button: ButtonWidget\n  toggle: BooleanWidget\n  slider: SliderWidget\n  knob: KnobWidget\n  combo: ComboWidget\n  number: NumberWidget\n  string: TextWidget\n  text: TextWidget\n  custom: LegacyWidget\n  [key: string]: BaseWidget\n}\n\n/**\n * Convert a widget POJO to a proper widget instance.\n * @param widget The POJO to convert.\n * @param node The node the widget belongs to.\n * @param wrapLegacyWidgets Whether to wrap legacy widgets in a `LegacyWidget` instance.\n * @returns A concrete widget instance.\n */\nexport function toConcreteWidget<TWidget extends IWidget | IBaseWidget>(\n  widget: TWidget,\n  node: LGraphNode,\n  wrapLegacyWidgets?: true,\n): WidgetTypeMap[TWidget[\"type\"]]\nexport function toConcreteWidget<TWidget extends IWidget | IBaseWidget>(\n  widget: TWidget,\n  node: LGraphNode,\n  wrapLegacyWidgets: false): WidgetTypeMap[TWidget[\"type\"]] | undefined\nexport function toConcreteWidget<TWidget extends IWidget | IBaseWidget>(\n  widget: TWidget,\n  node: LGraphNode,\n  wrapLegacyWidgets = true,\n): WidgetTypeMap[TWidget[\"type\"]] | undefined {\n  // Assertion: TypeScript has no concept of \"all strings except X\"\n  type RemoveBaseWidgetType<T> = T extends { type: TWidgetType } ? T : never\n  const narrowedWidget = widget as RemoveBaseWidgetType<TWidget>\n\n  switch (narrowedWidget.type) {\n  case \"button\": return toClass(ButtonWidget, narrowedWidget, node)\n  case \"toggle\": return toClass(BooleanWidget, narrowedWidget, node)\n  case \"slider\": return toClass(SliderWidget, narrowedWidget, node)\n  case \"knob\": return toClass(KnobWidget, narrowedWidget, node)\n  case \"combo\": return toClass(ComboWidget, narrowedWidget, node)\n  case \"number\": return toClass(NumberWidget, narrowedWidget, node)\n  case \"string\": return toClass(TextWidget, narrowedWidget, node)\n  case \"text\": return toClass(TextWidget, narrowedWidget, node)\n  default: {\n    if (wrapLegacyWidgets) return toClass(LegacyWidget, widget, node)\n  }\n  }\n}\n\n// #region Type Guards\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IButtonWidget}. */\nexport function isButtonWidget(widget: IBaseWidget): widget is IButtonWidget {\n  return widget.type === \"button\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IBooleanWidget}. */\nexport function isBooleanWidget(widget: IBaseWidget): widget is IBooleanWidget {\n  return widget.type === \"toggle\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link ISliderWidget}. */\nexport function isSliderWidget(widget: IBaseWidget): widget is ISliderWidget {\n  return widget.type === \"slider\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IKnobWidget}. */\nexport function isKnobWidget(widget: IBaseWidget): widget is IKnobWidget {\n  return widget.type === \"knob\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IComboWidget}. */\nexport function isComboWidget(widget: IBaseWidget): widget is IComboWidget {\n  return widget.type === \"combo\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link INumericWidget}. */\nexport function isNumberWidget(widget: IBaseWidget): widget is INumericWidget {\n  return widget.type === \"number\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link IStringWidget}. */\nexport function isStringWidget(widget: IBaseWidget): widget is IStringWidget {\n  return widget.type === \"string\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link ITextWidget}. */\nexport function isTextWidget(widget: IBaseWidget): widget is IStringWidget {\n  return widget.type === \"text\"\n}\n\n/** Type guard: Narrow **from {@link IBaseWidget}** to {@link ICustomWidget}. */\nexport function isCustomWidget(widget: IBaseWidget): widget is ICustomWidget {\n  return widget.type === \"custom\"\n}\n\n// #endregion Type Guards\n","import type { DragAndScale } from \"./DragAndScale\"\nimport type { IDrawBoundingOptions } from \"./draw\"\nimport type {\n  ColorOption,\n  DefaultConnectionColors,\n  Dictionary,\n  IColorable,\n  IContextMenuValue,\n  IFoundSlot,\n  INodeFlags,\n  INodeInputSlot,\n  INodeOutputSlot,\n  INodeSlot,\n  INodeSlotContextItem,\n  IPinnable,\n  ISlotType,\n  Point,\n  Positionable,\n  ReadOnlyRect,\n  Rect,\n  Size,\n} from \"./interfaces\"\nimport type { LGraph } from \"./LGraph\"\nimport type { Reroute, RerouteId } from \"./Reroute\"\nimport type { CanvasMouseEvent } from \"./types/events\"\nimport type { ISerialisedNode } from \"./types/serialisation\"\nimport type { IBaseWidget, IWidgetOptions, TWidgetType, TWidgetValue } from \"./types/widgets\"\n\nimport { getNodeInputOnPos, getNodeOutputOnPos } from \"./canvas/measureSlots\"\nimport { NullGraphError } from \"./infrastructure/NullGraphError\"\nimport { BadgePosition, LGraphBadge } from \"./LGraphBadge\"\nimport { LGraphCanvas } from \"./LGraphCanvas\"\nimport { type LGraphNodeConstructor, LiteGraph } from \"./litegraph\"\nimport { LLink } from \"./LLink\"\nimport { createBounds, isInRect, isInRectangle, isPointInRect, snapPoint } from \"./measure\"\nimport { NodeInputSlot } from \"./node/NodeInputSlot\"\nimport { NodeOutputSlot } from \"./node/NodeOutputSlot\"\nimport { inputAsSerialisable, isINodeInputSlot, isWidgetInputSlot, outputAsSerialisable } from \"./node/slotUtils\"\nimport {\n  LGraphEventMode,\n  NodeSlotType,\n  RenderShape,\n  TitleMode,\n} from \"./types/globalEnums\"\nimport { findFreeSlotOfType } from \"./utils/collections\"\nimport { warnDeprecated } from \"./utils/feedback\"\nimport { distributeSpace } from \"./utils/spaceDistribution\"\nimport { toClass } from \"./utils/type\"\nimport { BaseWidget } from \"./widgets/BaseWidget\"\nimport { toConcreteWidget, type WidgetTypeMap } from \"./widgets/widgetMap\"\n\n// #region Types\n\nexport type NodeId = number | string\n\nexport type NodeProperty = string | number | boolean | object\n\nexport interface INodePropertyInfo {\n  name: string\n  type?: string\n  default_value: NodeProperty | undefined\n}\n\nexport interface IMouseOverData {\n  inputId?: number\n  outputId?: number\n  overWidget?: IBaseWidget\n}\n\nexport interface ConnectByTypeOptions {\n  /** @deprecated Events */\n  createEventInCase?: boolean\n  /** Allow our wildcard slot to connect to typed slots on remote node. Default: true */\n  wildcardToTyped?: boolean\n  /** Allow our typed slot to connect to wildcard slots on remote node. Default: true */\n  typedToWildcard?: boolean\n  /** The {@link Reroute.id} that the connection is being dragged from. */\n  afterRerouteId?: RerouteId\n}\n\n/** Internal type used for type safety when implementing generic checks for inputs & outputs */\nexport interface IGenericLinkOrLinks {\n  links?: INodeOutputSlot[\"links\"]\n  link?: INodeInputSlot[\"link\"]\n}\n\nexport interface FindFreeSlotOptions {\n  /** Slots matching these types will be ignored.  Default: [] */\n  typesNotAccepted?: ISlotType[]\n  /** If true, the slot itself is returned instead of the index.  Default: false */\n  returnObj?: boolean\n}\n\ninterface DrawSlotsOptions {\n  fromSlot?: INodeInputSlot | INodeOutputSlot\n  colorContext: DefaultConnectionColors\n  editorAlpha: number\n  lowQuality: boolean\n}\n\ninterface DrawWidgetsOptions {\n  lowQuality?: boolean\n  editorAlpha?: number\n}\n\ninterface DrawTitleOptions {\n  scale: number\n  title_height?: number\n  low_quality?: boolean\n}\n\ninterface DrawTitleTextOptions extends DrawTitleOptions {\n  default_title_color: string\n}\n\ninterface DrawTitleBoxOptions extends DrawTitleOptions {\n  box_size?: number\n}\n\n/*\ntitle: string\npos: [x,y]\nsize: [x,y]\n\ninput|output: every connection\n    +  { name:string, type:string, pos: [x,y]=Optional, direction: \"input\"|\"output\", links: Array });\n\ngeneral properties:\n    + clip_area: if you render outside the node, it will be clipped\n    + unsafe_execution: not allowed for safe execution\n    + skip_repeated_outputs: when adding new outputs, it wont show if there is one already connected\n    + resizable: if set to false it wont be resizable with the mouse\n    + widgets_start_y: widgets start at y distance from the top of the node\n\nflags object:\n    + collapsed: if it is collapsed\n\nsupported callbacks:\n    + onAdded: when added to graph (warning: this is called BEFORE the node is configured when loading)\n    + onRemoved: when removed from graph\n    + onStart: when the graph starts playing\n    + onStop: when the graph stops playing\n    + onDrawForeground: render the inside widgets inside the node\n    + onDrawBackground: render the background area inside the node (only in edit mode)\n    + onMouseDown\n    + onMouseMove\n    + onMouseUp\n    + onMouseEnter\n    + onMouseLeave\n    + onExecute: execute the node\n    + onPropertyChanged: when a property is changed in the panel (return true to skip default behaviour)\n    + onGetInputs: returns an array of possible inputs\n    + onGetOutputs: returns an array of possible outputs\n    + onBounding: in case this node has a bigger bounding than the node itself (the callback receives the bounding as [x,y,w,h])\n    + onDblClick: double clicked in the node\n    + onNodeTitleDblClick: double clicked in the node title\n    + onInputDblClick: input slot double clicked (can be used to automatically create a node connected)\n    + onOutputDblClick: output slot double clicked (can be used to automatically create a node connected)\n    + onConfigure: called after the node has been configured\n    + onSerialize: to add extra info when serializing (the callback receives the object that should be filled with the data)\n    + onSelected\n    + onDeselected\n    + onDropItem : DOM item dropped over the node\n    + onDropFile : file dropped over the node\n    + onConnectInput : if returns false the incoming connection will be canceled\n    + onConnectionsChange : a connection changed (new one or removed) (NodeSlotType.INPUT or NodeSlotType.OUTPUT, slot, true if connected, link_info, input_info )\n    + onAction: action slot triggered\n    + getExtraMenuOptions: to add option to context menu\n*/\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport interface LGraphNode {\n  constructor: LGraphNodeConstructor\n}\n\n// #endregion Types\n\n/**\n * Base class for all nodes\n * @param title a name for the node\n * @param type a type for the node\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class LGraphNode implements Positionable, IPinnable, IColorable {\n  // Static properties used by dynamic child classes\n  static title?: string\n  static MAX_CONSOLE?: number\n  static type?: string\n  static category?: string\n  static filter?: string\n  static skip_list?: boolean\n\n  /** Default setting for {@link LGraphNode.connectInputToOutput}. @see {@link INodeFlags.keepAllLinksOnBypass} */\n  static keepAllLinksOnBypass: boolean = false\n\n  /** The title text of the node. */\n  title: string\n  /**\n   * The font style used to render the node's title text.\n   */\n  get titleFontStyle(): string {\n    return `${LiteGraph.NODE_TEXT_SIZE}px ${LiteGraph.NODE_FONT}`\n  }\n\n  get innerFontStyle(): string {\n    return `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px ${LiteGraph.NODE_FONT}`\n  }\n\n  graph: LGraph | null = null\n  id: NodeId\n  type: string = \"\"\n  inputs: INodeInputSlot[] = []\n  outputs: INodeOutputSlot[] = []\n\n  #concreteInputs: NodeInputSlot[] = []\n  #concreteOutputs: NodeOutputSlot[] = []\n\n  properties: Dictionary<NodeProperty | undefined> = {}\n  properties_info: INodePropertyInfo[] = []\n  flags: INodeFlags = {}\n  widgets?: IBaseWidget[]\n  /**\n   * The amount of space available for widgets to grow into.\n   * @see {@link layoutWidgets}\n   */\n  freeWidgetSpace?: number\n\n  locked?: boolean\n\n  /** Execution order, automatically computed during run @see {@link LGraph.computeExecutionOrder} */\n  order: number = 0\n  mode: LGraphEventMode = LGraphEventMode.ALWAYS\n  last_serialization?: ISerialisedNode\n  serialize_widgets?: boolean\n  /**\n   * The overridden fg color used to render the node.\n   * @see {@link renderingColor}\n   */\n  color?: string\n  /**\n   * The overridden bg color used to render the node.\n   * @see {@link renderingBgColor}\n   */\n  bgcolor?: string\n  /**\n   * The overridden box color used to render the node.\n   * @see {@link renderingBoxColor}\n   */\n  boxcolor?: string\n\n  /** The fg color used to render the node. */\n  get renderingColor(): string {\n    return this.color || this.constructor.color || LiteGraph.NODE_DEFAULT_COLOR\n  }\n\n  /** The bg color used to render the node. */\n  get renderingBgColor(): string {\n    return this.bgcolor || this.constructor.bgcolor || LiteGraph.NODE_DEFAULT_BGCOLOR\n  }\n\n  /** The box color used to render the node. */\n  get renderingBoxColor(): string {\n    if (this.boxcolor) return this.boxcolor\n\n    if (LiteGraph.node_box_coloured_when_on) {\n      if (this.action_triggered) return \"#FFF\"\n      if (this.execute_triggered) return \"#AAA\"\n    }\n\n    if (LiteGraph.node_box_coloured_by_mode) {\n      const modeColour = LiteGraph.NODE_MODES_COLORS[this.mode ?? LGraphEventMode.ALWAYS]\n      if (modeColour) return modeColour\n    }\n    return LiteGraph.NODE_DEFAULT_BOXCOLOR\n  }\n\n  /** @inheritdoc {@link IColorable.setColorOption} */\n  setColorOption(colorOption: ColorOption | null): void {\n    if (colorOption == null) {\n      delete this.color\n      delete this.bgcolor\n    } else {\n      this.color = colorOption.color\n      this.bgcolor = colorOption.bgcolor\n    }\n  }\n\n  /** @inheritdoc {@link IColorable.getColorOption} */\n  getColorOption(): ColorOption | null {\n    return Object.values(LGraphCanvas.node_colors).find(\n      colorOption =>\n        colorOption.color === this.color && colorOption.bgcolor === this.bgcolor,\n    ) ?? null\n  }\n\n  /**\n   * The stroke styles that should be applied to the node.\n   */\n  strokeStyles: Record<string, (this: LGraphNode) => IDrawBoundingOptions | undefined>\n\n  /**\n   * The progress of node execution. Used to render a progress bar. Value between 0 and 1.\n   */\n  progress?: number\n\n  exec_version?: number\n  action_call?: string\n  execute_triggered?: number\n  action_triggered?: number\n  widgets_up?: boolean\n  widgets_start_y?: number\n  lostFocusAt?: number\n  gotFocusAt?: number\n  badges: (LGraphBadge | (() => LGraphBadge))[] = []\n  badgePosition: BadgePosition = BadgePosition.TopLeft\n  onOutputRemoved?(this: LGraphNode, slot: number): void\n  onInputRemoved?(this: LGraphNode, slot: number, input: INodeInputSlot): void\n  /**\n   * The width of the node when collapsed.\n   * Updated by {@link LGraphCanvas.drawNode}\n   */\n  _collapsed_width?: number\n  /** Called once at the start of every frame.  Caller may change the values in {@link out}, which will be reflected in {@link boundingRect}. */\n  onBounding?(this: LGraphNode, out: Rect): void\n  console?: string[]\n  _level?: number\n  _shape?: RenderShape\n  mouseOver?: IMouseOverData\n  redraw_on_mouse?: boolean\n  resizable?: boolean\n  clonable?: boolean\n  _relative_id?: number\n  clip_area?: boolean\n  ignore_remove?: boolean\n  has_errors?: boolean\n  removable?: boolean\n  block_delete?: boolean\n  selected?: boolean\n  showAdvanced?: boolean\n\n  /** @inheritdoc {@link renderArea} */\n  #renderArea: Float32Array = new Float32Array(4)\n  /**\n   * Rect describing the node area, including shadows and any protrusions.\n   * Determines if the node is visible.  Calculated once at the start of every frame.\n   */\n  get renderArea(): ReadOnlyRect {\n    return this.#renderArea\n  }\n\n  /** @inheritdoc {@link boundingRect} */\n  #boundingRect: Float32Array = new Float32Array(4)\n  /**\n   * Cached node position & area as `x, y, width, height`.  Includes changes made by {@link onBounding}, if present.\n   *\n   * Determines the node hitbox and other rendering effects.  Calculated once at the start of every frame.\n   */\n  get boundingRect(): ReadOnlyRect {\n    return this.#boundingRect\n  }\n\n  /** {@link pos} and {@link size} values are backed by this {@link Rect}. */\n  _posSize: Float32Array = new Float32Array(4)\n  _pos: Point = this._posSize.subarray(0, 2)\n  _size: Size = this._posSize.subarray(2, 4)\n\n  public get pos() {\n    return this._pos\n  }\n\n  /** Node position does not necessarily correlate to the top-left corner. */\n  public set pos(value) {\n    if (!value || value.length < 2) return\n\n    this._pos[0] = value[0]\n    this._pos[1] = value[1]\n  }\n\n  public get size() {\n    return this._size\n  }\n\n  public set size(value) {\n    if (!value || value.length < 2) return\n\n    this._size[0] = value[0]\n    this._size[1] = value[1]\n  }\n\n  /**\n   * The size of the node used for rendering.\n   */\n  get renderingSize(): Size {\n    return this.flags.collapsed ? [this._collapsed_width ?? 0, 0] : this._size\n  }\n\n  get shape(): RenderShape | undefined {\n    return this._shape\n  }\n\n  set shape(v: RenderShape | \"default\" | \"box\" | \"round\" | \"circle\" | \"card\") {\n    switch (v) {\n    case \"default\":\n      delete this._shape\n      break\n    case \"box\":\n      this._shape = RenderShape.BOX\n      break\n    case \"round\":\n      this._shape = RenderShape.ROUND\n      break\n    case \"circle\":\n      this._shape = RenderShape.CIRCLE\n      break\n    case \"card\":\n      this._shape = RenderShape.CARD\n      break\n    default:\n      this._shape = v\n    }\n  }\n\n  /**\n   * The shape of the node used for rendering. @see {@link RenderShape}\n   */\n  get renderingShape(): RenderShape {\n    return this._shape || this.constructor.shape || LiteGraph.NODE_DEFAULT_SHAPE\n  }\n\n  public get is_selected(): boolean | undefined {\n    return this.selected\n  }\n\n  public set is_selected(value: boolean) {\n    this.selected = value\n  }\n\n  public get title_mode(): TitleMode {\n    return this.constructor.title_mode ?? TitleMode.NORMAL_TITLE\n  }\n\n  onConnectInput?(\n    this: LGraphNode,\n    target_slot: number,\n    type: unknown,\n    output: INodeOutputSlot,\n    node: LGraphNode,\n    slot: number,\n  ): boolean\n  onConnectOutput?(\n    this: LGraphNode,\n    slot: number,\n    type: unknown,\n    input: INodeInputSlot,\n    target_node: number | LGraphNode,\n    target_slot: number,\n  ): boolean\n  onResize?(this: LGraphNode, size: Size): void\n  onPropertyChanged?(\n    this: LGraphNode,\n    name: string,\n    value: unknown,\n    prev_value?: unknown,\n  ): boolean\n  /** Called for each connection that is created, updated, or removed. This includes \"restored\" connections when deserialising. */\n  onConnectionsChange?(\n    this: LGraphNode,\n    type: ISlotType,\n    index: number,\n    isConnected: boolean,\n    link_info: LLink | null | undefined,\n    inputOrOutput: INodeInputSlot | INodeOutputSlot,\n  ): void\n  onInputAdded?(this: LGraphNode, input: INodeInputSlot): void\n  onOutputAdded?(this: LGraphNode, output: INodeOutputSlot): void\n  onConfigure?(this: LGraphNode, serialisedNode: ISerialisedNode): void\n  onSerialize?(this: LGraphNode, serialised: ISerialisedNode): any\n  onExecute?(\n    this: LGraphNode,\n    param?: unknown,\n    options?: { action_call?: any },\n  ): void\n  onAction?(\n    this: LGraphNode,\n    action: string,\n    param: unknown,\n    options: { action_call?: string },\n  ): void\n  onDrawBackground?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n  ): void\n  onNodeCreated?(this: LGraphNode): void\n  /**\n   * Callback invoked by {@link connect} to override the target slot index.\n   * Its return value overrides the target index selection.\n   * @param target_slot The current input slot index\n   * @param requested_slot The originally requested slot index - could be negative, or if using (deprecated) name search, a string\n   * @returns {number | null} If a number is returned, the connection will be made to that input index.\n   * If an invalid index or non-number (false, null, NaN etc) is returned, the connection will be cancelled.\n   */\n  onBeforeConnectInput?(\n    this: LGraphNode,\n    target_slot: number,\n    requested_slot?: number | string,\n  ): number | false | null\n  onShowCustomPanelInfo?(this: LGraphNode, panel: any): void\n  onAddPropertyToPanel?(this: LGraphNode, pName: string, panel: any): boolean\n  onWidgetChanged?(\n    this: LGraphNode,\n    name: string,\n    value: unknown,\n    old_value: unknown,\n    w: IBaseWidget,\n  ): void\n  onDeselected?(this: LGraphNode): void\n  onKeyUp?(this: LGraphNode, e: KeyboardEvent): void\n  onKeyDown?(this: LGraphNode, e: KeyboardEvent): void\n  onSelected?(this: LGraphNode): void\n  getExtraMenuOptions?(\n    this: LGraphNode,\n    canvas: LGraphCanvas,\n    options: (IContextMenuValue<unknown> | null)[],\n  ): (IContextMenuValue<unknown> | null)[]\n  getMenuOptions?(this: LGraphNode, canvas: LGraphCanvas): IContextMenuValue[]\n  onAdded?(this: LGraphNode, graph: LGraph): void\n  onDrawCollapsed?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    cavnas: LGraphCanvas,\n  ): boolean\n  onDrawForeground?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    canvas: LGraphCanvas,\n    canvasElement: HTMLCanvasElement,\n  ): void\n  onMouseLeave?(this: LGraphNode, e: CanvasMouseEvent): void\n  /**\n   * Override the default slot menu options.\n   */\n  getSlotMenuOptions?(this: LGraphNode, slot: IFoundSlot): IContextMenuValue[]\n  /**\n   * Add extra menu options to the slot context menu.\n   */\n  getExtraSlotMenuOptions?(this: LGraphNode, slot: IFoundSlot): IContextMenuValue[]\n\n  // FIXME: Re-typing\n  onDropItem?(this: LGraphNode, event: Event): boolean\n  onDropData?(\n    this: LGraphNode,\n    data: string | ArrayBuffer,\n    filename: any,\n    file: any,\n  ): void\n  onDropFile?(this: LGraphNode, file: any): void\n  onInputClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void\n  onInputDblClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void\n  onOutputClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void\n  onOutputDblClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void\n  // TODO: Return type\n  onGetPropertyInfo?(this: LGraphNode, property: string): any\n  onNodeOutputAdd?(this: LGraphNode, value: unknown): void\n  onNodeInputAdd?(this: LGraphNode, value: unknown): void\n  onMenuNodeInputs?(\n    this: LGraphNode,\n    entries: (IContextMenuValue<INodeSlotContextItem> | null)[],\n  ): (IContextMenuValue<INodeSlotContextItem> | null)[]\n  onMenuNodeOutputs?(\n    this: LGraphNode,\n    entries: (IContextMenuValue<INodeSlotContextItem> | null)[],\n  ): (IContextMenuValue<INodeSlotContextItem> | null)[]\n  onMouseUp?(this: LGraphNode, e: CanvasMouseEvent, pos: Point): void\n  onMouseEnter?(this: LGraphNode, e: CanvasMouseEvent): void\n  /** Blocks drag if return value is truthy. @param pos Offset from {@link LGraphNode.pos}. */\n  onMouseDown?(\n    this: LGraphNode,\n    e: CanvasMouseEvent,\n    pos: Point,\n    canvas: LGraphCanvas,\n  ): boolean\n  /** @param pos Offset from {@link LGraphNode.pos}. */\n  onDblClick?(\n    this: LGraphNode,\n    e: CanvasMouseEvent,\n    pos: Point,\n    canvas: LGraphCanvas,\n  ): void\n  /** @param pos Offset from {@link LGraphNode.pos}. */\n  onNodeTitleDblClick?(\n    this: LGraphNode,\n    e: CanvasMouseEvent,\n    pos: Point,\n    canvas: LGraphCanvas,\n  ): void\n  onDrawTitle?(this: LGraphNode, ctx: CanvasRenderingContext2D): void\n  onDrawTitleText?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    title_height: number,\n    size: Size,\n    scale: number,\n    title_text_font: string,\n    selected?: boolean,\n  ): void\n  onDrawTitleBox?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    title_height: number,\n    size: Size,\n    scale: number,\n  ): void\n  onDrawTitleBar?(\n    this: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    title_height: number,\n    size: Size,\n    scale: number,\n    fgcolor: any,\n  ): void\n  onRemoved?(this: LGraphNode): void\n  onMouseMove?(\n    this: LGraphNode,\n    e: MouseEvent,\n    pos: Point,\n    arg2: LGraphCanvas,\n  ): void\n  onPropertyChange?(this: LGraphNode): void\n  updateOutputData?(this: LGraphNode, origin_slot: number): void\n\n  #getErrorStrokeStyle(this: LGraphNode): IDrawBoundingOptions | undefined {\n    if (this.has_errors) {\n      return {\n        padding: 12,\n        lineWidth: 10,\n        color: LiteGraph.NODE_ERROR_COLOUR,\n      }\n    }\n  }\n\n  #getSelectedStrokeStyle(this: LGraphNode): IDrawBoundingOptions | undefined {\n    if (this.selected) {\n      return {\n        padding: this.has_errors ? 20 : undefined,\n      }\n    }\n  }\n\n  constructor(title: string, type?: string) {\n    this.id = LiteGraph.use_uuids ? LiteGraph.uuidv4() : -1\n    this.title = title || \"Unnamed\"\n    this.type = type ?? \"\"\n    this.size = [LiteGraph.NODE_WIDTH, 60]\n    this.pos = [10, 10]\n    this.strokeStyles = {\n      error: this.#getErrorStrokeStyle,\n      selected: this.#getSelectedStrokeStyle,\n    }\n  }\n\n  /**\n   * configure a node from an object containing the serialized info\n   */\n  configure(info: ISerialisedNode): void {\n    if (this.graph) {\n      this.graph._version++\n    }\n    for (const j in info) {\n      if (j == \"properties\") {\n        // i don't want to clone properties, I want to reuse the old container\n        for (const k in info.properties) {\n          this.properties[k] = info.properties[k]\n          this.onPropertyChanged?.(k, info.properties[k])\n        }\n        continue\n      }\n\n      // @ts-expect-error #594\n      if (info[j] == null) {\n        continue\n      // @ts-expect-error #594\n      } else if (typeof info[j] == \"object\") {\n        // @ts-expect-error #594\n        if (this[j]?.configure) {\n          // @ts-expect-error #594\n          this[j]?.configure(info[j])\n        } else {\n          // @ts-expect-error #594\n          this[j] = LiteGraph.cloneObject(info[j], this[j])\n        }\n      } else {\n        // value\n        // @ts-expect-error #594\n        this[j] = info[j]\n      }\n    }\n\n    if (!info.title) {\n      this.title = this.constructor.title\n    }\n\n    this.inputs ??= []\n    this.inputs = this.inputs.map(input => toClass(NodeInputSlot, input, this))\n    for (const [i, input] of this.inputs.entries()) {\n      const link = this.graph && input.link != null\n        ? this.graph._links.get(input.link)\n        : null\n      this.onConnectionsChange?.(NodeSlotType.INPUT, i, true, link, input)\n      this.onInputAdded?.(input)\n    }\n\n    this.outputs ??= []\n    this.outputs = this.outputs.map(output => toClass(NodeOutputSlot, output, this))\n    for (const [i, output] of this.outputs.entries()) {\n      if (!output.links) continue\n\n      for (const linkId of output.links) {\n        const link = this.graph\n          ? this.graph._links.get(linkId)\n          : null\n        this.onConnectionsChange?.(NodeSlotType.OUTPUT, i, true, link, output)\n      }\n      this.onOutputAdded?.(output)\n    }\n\n    if (this.widgets) {\n      for (const w of this.widgets) {\n        if (!w) continue\n\n        if (w.options?.property && this.properties[w.options.property] != undefined)\n          w.value = JSON.parse(JSON.stringify(this.properties[w.options.property]))\n      }\n\n      if (info.widgets_values) {\n        const widgetsWithValue = this.widgets.filter(w => w.serialize !== false)\n        for (let i = 0; i < info.widgets_values.length; ++i) {\n          const widget = widgetsWithValue[i]\n          if (widget) {\n            widget.value = info.widgets_values[i]\n          }\n        }\n      }\n    }\n\n    // Sync the state of this.resizable.\n    if (this.pinned) this.resizable = false\n\n    this.onConfigure?.(info)\n  }\n\n  /**\n   * serialize the content\n   */\n  serialize(): ISerialisedNode {\n    // create serialization object\n    const o: ISerialisedNode = {\n      id: this.id,\n      type: this.type,\n      pos: [this.pos[0], this.pos[1]],\n      size: [this.size[0], this.size[1]],\n      flags: LiteGraph.cloneObject(this.flags),\n      order: this.order,\n      mode: this.mode,\n      showAdvanced: this.showAdvanced,\n    }\n\n    // special case for when there were errors\n    if (this.constructor === LGraphNode && this.last_serialization)\n      return this.last_serialization\n\n    if (this.inputs) o.inputs = this.inputs.map(input => inputAsSerialisable(input))\n    if (this.outputs) o.outputs = this.outputs.map(output => outputAsSerialisable(output))\n\n    if (this.title && this.title != this.constructor.title) o.title = this.title\n\n    if (this.properties) o.properties = LiteGraph.cloneObject(this.properties)\n\n    const { widgets } = this\n    if (widgets && this.serialize_widgets) {\n      o.widgets_values = []\n      for (const [i, widget] of widgets.entries()) {\n        if (widget.serialize === false) continue\n        // @ts-expect-error #595 No-null\n        o.widgets_values[i] = widget ? widget.value : null\n      }\n    }\n\n    if (!o.type) o.type = this.constructor.type\n\n    if (this.color) o.color = this.color\n    if (this.bgcolor) o.bgcolor = this.bgcolor\n    if (this.boxcolor) o.boxcolor = this.boxcolor\n    if (this.shape) o.shape = this.shape\n\n    if (this.onSerialize?.(o)) console.warn(\"node onSerialize shouldnt return anything, data should be stored in the object pass in the first parameter\")\n\n    return o\n  }\n\n  /* Creates a clone of this node */\n  clone(): LGraphNode | null {\n    if (this.type == null) return null\n    const node = LiteGraph.createNode(this.type)\n    if (!node) return null\n\n    // we clone it because serialize returns shared containers\n    const data = LiteGraph.cloneObject(this.serialize())\n    const { inputs, outputs } = data\n\n    // remove links\n    if (inputs) {\n      for (const input of inputs) {\n        input.link = null\n      }\n    }\n\n    if (outputs) {\n      for (const { links } of outputs) {\n        if (links) links.length = 0\n      }\n    }\n\n    // @ts-expect-error Exceptional case: id is removed so that the graph can assign a new one on add.\n    delete data.id\n\n    if (LiteGraph.use_uuids) data.id = LiteGraph.uuidv4()\n\n    node.configure(data)\n\n    return node\n  }\n\n  /**\n   * serialize and stringify\n   */\n  toString(): string {\n    return JSON.stringify(this.serialize())\n  }\n\n  /**\n   * get the title string\n   */\n  getTitle(): string {\n    return this.title || this.constructor.title\n  }\n\n  /**\n   * sets the value of a property\n   * @param name\n   * @param value\n   */\n  setProperty(name: string, value: TWidgetValue): void {\n    this.properties ||= {}\n    if (value === this.properties[name]) return\n\n    const prev_value = this.properties[name]\n    this.properties[name] = value\n    // abort change\n    if (this.onPropertyChanged?.(name, value, prev_value) === false)\n      this.properties[name] = prev_value\n\n    if (this.widgets) {\n      for (const w of this.widgets) {\n        if (!w) continue\n\n        if (w.options.property == name) {\n          w.value = value\n          break\n        }\n      }\n    }\n  }\n\n  /**\n   * sets the output data\n   * @param slot\n   * @param data\n   */\n  setOutputData(slot: number, data: number | string | boolean | { toToolTip?(): string }): void {\n    const { outputs } = this\n    if (!outputs) return\n\n    // this maybe slow and a niche case\n    if (slot == -1 || slot >= outputs.length) return\n\n    const output_info = outputs[slot]\n    if (!output_info) return\n\n    // store data in the output itself in case we want to debug\n    output_info._data = data\n\n    if (!this.graph) throw new NullGraphError()\n\n    // if there are connections, pass the data to the connections\n    const { links } = outputs[slot]\n    if (links) {\n      for (const id of links) {\n        const link = this.graph._links.get(id)\n        if (link) link.data = data\n      }\n    }\n  }\n\n  /**\n   * sets the output data type, useful when you want to be able to overwrite the data type\n   */\n  setOutputDataType(slot: number, type: ISlotType): void {\n    const { outputs } = this\n    if (!outputs || (slot == -1 || slot >= outputs.length)) return\n\n    const output_info = outputs[slot]\n    if (!output_info) return\n    // store data in the output itself in case we want to debug\n    output_info.type = type\n\n    if (!this.graph) throw new NullGraphError()\n\n    // if there are connections, pass the data to the connections\n    const { links } = outputs[slot]\n    if (links) {\n      for (const id of links) {\n        const link = this.graph._links.get(id)\n        if (link) link.type = type\n      }\n    }\n  }\n\n  /**\n   * Retrieves the input data (data traveling through the connection) from one slot\n   * @param slot\n   * @param force_update if set to true it will force the connected node of this slot to output data into this link\n   * @returns data or if it is not connected returns undefined\n   */\n  getInputData(slot: number, force_update?: boolean): unknown {\n    if (!this.inputs) return\n\n    if (slot >= this.inputs.length || this.inputs[slot].link == null) return\n    if (!this.graph) throw new NullGraphError()\n\n    const link_id = this.inputs[slot].link\n    const link = this.graph._links.get(link_id)\n    // bug: weird case but it happens sometimes\n    if (!link) return null\n\n    if (!force_update) return link.data\n\n    // special case: used to extract data from the incoming connection before the graph has been executed\n    const node = this.graph.getNodeById(link.origin_id)\n    if (!node) return link.data\n\n    if (node.updateOutputData) {\n      node.updateOutputData(link.origin_slot)\n    } else {\n      node.onExecute?.()\n    }\n\n    return link.data\n  }\n\n  /**\n   * Retrieves the input data type (in case this supports multiple input types)\n   * @param slot\n   * @returns datatype in string format\n   */\n  getInputDataType(slot: number): ISlotType | null {\n    if (!this.inputs) return null\n    if (slot >= this.inputs.length || this.inputs[slot].link == null) return null\n    if (!this.graph) throw new NullGraphError()\n\n    const link_id = this.inputs[slot].link\n    const link = this.graph._links.get(link_id)\n    // bug: weird case but it happens sometimes\n    if (!link) return null\n\n    const node = this.graph.getNodeById(link.origin_id)\n    if (!node) return link.type\n\n    const output_info = node.outputs[link.origin_slot]\n    return output_info\n      ? output_info.type\n      : null\n  }\n\n  /**\n   * Retrieves the input data from one slot using its name instead of slot number\n   * @param slot_name\n   * @param force_update if set to true it will force the connected node of this slot to output data into this link\n   * @returns data or if it is not connected returns null\n   */\n  getInputDataByName(slot_name: string, force_update: boolean): unknown {\n    const slot = this.findInputSlot(slot_name)\n    return slot == -1\n      ? null\n      : this.getInputData(slot, force_update)\n  }\n\n  /**\n   * tells you if there is a connection in one input slot\n   * @param slot The 0-based index of the input to check\n   * @returns `true` if the input slot has a link ID (does not perform validation)\n   */\n  isInputConnected(slot: number): boolean {\n    if (!this.inputs) return false\n    return slot < this.inputs.length && this.inputs[slot].link != null\n  }\n\n  /**\n   * tells you info about an input connection (which node, type, etc)\n   * @returns object or null { link: id, name: string, type: string or 0 }\n   */\n  getInputInfo(slot: number): INodeInputSlot | null {\n    return !this.inputs || !(slot < this.inputs.length)\n      ? null\n      : this.inputs[slot]\n  }\n\n  /**\n   * Returns the link info in the connection of an input slot\n   * @returns object or null\n   */\n  getInputLink(slot: number): LLink | null {\n    if (!this.inputs) return null\n\n    if (slot < this.inputs.length) {\n      if (!this.graph) throw new NullGraphError()\n\n      const input = this.inputs[slot]\n      if (input.link != null) {\n        return this.graph._links.get(input.link) ?? null\n      }\n    }\n    return null\n  }\n\n  /**\n   * returns the node connected in the input slot\n   * @returns node or null\n   */\n  getInputNode(slot: number): LGraphNode | null {\n    if (!this.inputs) return null\n    if (slot >= this.inputs.length) return null\n\n    const input = this.inputs[slot]\n    if (!input || input.link === null) return null\n    if (!this.graph) throw new NullGraphError()\n\n    const link_info = this.graph._links.get(input.link)\n    if (!link_info) return null\n\n    return this.graph.getNodeById(link_info.origin_id)\n  }\n\n  /**\n   * returns the value of an input with this name, otherwise checks if there is a property with that name\n   * @returns value\n   */\n  getInputOrProperty(name: string): unknown {\n    const { inputs } = this\n    if (!inputs?.length) {\n      return this.properties ? this.properties[name] : null\n    }\n    if (!this.graph) throw new NullGraphError()\n\n    for (const input of inputs) {\n      if (name == input.name && input.link != null) {\n        const link = this.graph._links.get(input.link)\n        if (link) return link.data\n      }\n    }\n    return this.properties[name]\n  }\n\n  /**\n   * tells you the last output data that went in that slot\n   * @returns object or null\n   */\n  getOutputData(slot: number): unknown {\n    if (!this.outputs) return null\n    if (slot >= this.outputs.length) return null\n\n    const info = this.outputs[slot]\n    return info._data\n  }\n\n  /**\n   * tells you info about an output connection (which node, type, etc)\n   * @returns object or null { name: string, type: string, links: [ ids of links in number ] }\n   */\n  getOutputInfo(slot: number): INodeOutputSlot | null {\n    return !this.outputs || !(slot < this.outputs.length)\n      ? null\n      : this.outputs[slot]\n  }\n\n  /**\n   * tells you if there is a connection in one output slot\n   */\n  isOutputConnected(slot: number): boolean {\n    if (!this.outputs) return false\n    return slot < this.outputs.length && Number(this.outputs[slot].links?.length) > 0\n  }\n\n  /**\n   * tells you if there is any connection in the output slots\n   */\n  isAnyOutputConnected(): boolean {\n    const { outputs } = this\n    if (!outputs) return false\n\n    for (const output of outputs) {\n      if (output.links?.length) return true\n    }\n    return false\n  }\n\n  /**\n   * retrieves all the nodes connected to this output slot\n   */\n  getOutputNodes(slot: number): LGraphNode[] | null {\n    const { outputs } = this\n    if (!outputs || outputs.length == 0) return null\n\n    if (slot >= outputs.length) return null\n\n    const { links } = outputs[slot]\n    if (!links || links.length == 0) return null\n    if (!this.graph) throw new NullGraphError()\n\n    const r: LGraphNode[] = []\n    for (const id of links) {\n      const link = this.graph._links.get(id)\n      if (link) {\n        const target_node = this.graph.getNodeById(link.target_id)\n        if (target_node) {\n          r.push(target_node)\n        }\n      }\n    }\n    return r\n  }\n\n  addOnTriggerInput(): number {\n    const trigS = this.findInputSlot(\"onTrigger\")\n    if (trigS == -1) {\n      this.addInput(\"onTrigger\", LiteGraph.EVENT, {\n        nameLocked: true,\n      })\n      return this.findInputSlot(\"onTrigger\")\n    }\n    return trigS\n  }\n\n  addOnExecutedOutput(): number {\n    const trigS = this.findOutputSlot(\"onExecuted\")\n    if (trigS == -1) {\n      this.addOutput(\"onExecuted\", LiteGraph.ACTION, {\n        nameLocked: true,\n      })\n      return this.findOutputSlot(\"onExecuted\")\n    }\n    return trigS\n  }\n\n  onAfterExecuteNode(param: unknown, options?: { action_call?: any }) {\n    const trigS = this.findOutputSlot(\"onExecuted\")\n    if (trigS != -1) {\n      this.triggerSlot(trigS, param, null, options)\n    }\n  }\n\n  changeMode(modeTo: number): boolean {\n    switch (modeTo) {\n    case LGraphEventMode.ON_EVENT:\n      break\n\n    case LGraphEventMode.ON_TRIGGER:\n      this.addOnTriggerInput()\n      this.addOnExecutedOutput()\n      break\n\n    case LGraphEventMode.NEVER:\n      break\n\n    case LGraphEventMode.ALWAYS:\n      break\n\n      // @ts-expect-error Not impl.\n    case LiteGraph.ON_REQUEST:\n      break\n\n    default:\n      return false\n      break\n    }\n    this.mode = modeTo\n    return true\n  }\n\n  /**\n   * Triggers the node code execution, place a boolean/counter to mark the node as being executed\n   */\n  doExecute(param?: unknown, options?: { action_call?: any }): void {\n    options = options || {}\n    if (this.onExecute) {\n      // enable this to give the event an ID\n      options.action_call ||= `${this.id}_exec_${Math.floor(Math.random() * 9999)}`\n      if (!this.graph) throw new NullGraphError()\n\n      // @ts-expect-error Technically it works when id is a string. Array gets props.\n      this.graph.nodes_executing[this.id] = true\n      this.onExecute(param, options)\n      // @ts-expect-error deprecated\n      this.graph.nodes_executing[this.id] = false\n\n      // save execution/action ref\n      this.exec_version = this.graph.iteration\n      if (options?.action_call) {\n        this.action_call = options.action_call\n        // @ts-expect-error deprecated\n        this.graph.nodes_executedAction[this.id] = options.action_call\n      }\n    }\n    // the nFrames it will be used (-- each step), means \"how old\" is the event\n    this.execute_triggered = 2\n    this.onAfterExecuteNode?.(param, options)\n  }\n\n  /**\n   * Triggers an action, wrapped by logics to control execution flow\n   * @param action name\n   */\n  actionDo(\n    action: string,\n    param: unknown,\n    options: { action_call?: string },\n  ): void {\n    options = options || {}\n    if (this.onAction) {\n      // enable this to give the event an ID\n      options.action_call ||= `${this.id}_${action || \"action\"}_${Math.floor(Math.random() * 9999)}`\n      if (!this.graph) throw new NullGraphError()\n\n      // @ts-expect-error deprecated\n      this.graph.nodes_actioning[this.id] = action || \"actioning\"\n      this.onAction(action, param, options)\n      // @ts-expect-error deprecated\n      this.graph.nodes_actioning[this.id] = false\n\n      // save execution/action ref\n      if (options?.action_call) {\n        this.action_call = options.action_call\n        // @ts-expect-error deprecated\n        this.graph.nodes_executedAction[this.id] = options.action_call\n      }\n    }\n    // the nFrames it will be used (-- each step), means \"how old\" is the event\n    this.action_triggered = 2\n    this.onAfterExecuteNode?.(param, options)\n  }\n\n  /**\n   * Triggers an event in this node, this will trigger any output with the same name\n   * @param action name ( \"on_play\", ... ) if action is equivalent to false then the event is send to all\n   */\n  trigger(\n    action: string,\n    param: unknown,\n    options: { action_call?: any },\n  ): void {\n    const { outputs } = this\n    if (!outputs || !outputs.length) {\n      return\n    }\n\n    if (this.graph) this.graph._last_trigger_time = LiteGraph.getTime()\n\n    for (const [i, output] of outputs.entries()) {\n      if (\n        !output ||\n        output.type !== LiteGraph.EVENT ||\n        (action && output.name != action)\n      ) {\n        continue\n      }\n      this.triggerSlot(i, param, null, options)\n    }\n  }\n\n  /**\n   * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes\n   * @param slot the index of the output slot\n   * @param link_id [optional] in case you want to trigger and specific output link in a slot\n   */\n  triggerSlot(\n    slot: number,\n    param: unknown,\n    link_id: number | null,\n    options?: { action_call?: any },\n  ): void {\n    options = options || {}\n    if (!this.outputs) return\n\n    if (slot == null) {\n      console.error(\"slot must be a number\")\n      return\n    }\n\n    if (typeof slot !== \"number\")\n      console.warn(\"slot must be a number, use node.trigger('name') if you want to use a string\")\n\n    const output = this.outputs[slot]\n    if (!output) return\n\n    const links = output.links\n    if (!links || !links.length) return\n\n    if (!this.graph) throw new NullGraphError()\n    this.graph._last_trigger_time = LiteGraph.getTime()\n\n    // for every link attached here\n    for (const id of links) {\n      // to skip links\n      if (link_id != null && link_id != id) continue\n\n      const link_info = this.graph._links.get(id)\n      // not connected\n      if (!link_info) continue\n\n      link_info._last_time = LiteGraph.getTime()\n      const node = this.graph.getNodeById(link_info.target_id)\n      // node not found?\n      if (!node) continue\n\n      if (node.mode === LGraphEventMode.ON_TRIGGER) {\n        // generate unique trigger ID if not present\n        if (!options.action_call)\n          options.action_call = `${this.id}_trigg_${Math.floor(Math.random() * 9999)}`\n        // -- wrapping node.onExecute(param); --\n        node.doExecute?.(param, options)\n      } else if (node.onAction) {\n        // generate unique action ID if not present\n        if (!options.action_call)\n          options.action_call = `${this.id}_act_${Math.floor(Math.random() * 9999)}`\n        // pass the action name\n        const target_connection = node.inputs[link_info.target_slot]\n        node.actionDo(target_connection.name, param, options)\n      }\n    }\n  }\n\n  /**\n   * clears the trigger slot animation\n   * @param slot the index of the output slot\n   * @param link_id [optional] in case you want to trigger and specific output link in a slot\n   */\n  clearTriggeredSlot(slot: number, link_id: number): void {\n    if (!this.outputs) return\n\n    const output = this.outputs[slot]\n    if (!output) return\n\n    const links = output.links\n    if (!links || !links.length) return\n\n    if (!this.graph) throw new NullGraphError()\n\n    // for every link attached here\n    for (const id of links) {\n      // to skip links\n      if (link_id != null && link_id != id) continue\n\n      const link_info = this.graph._links.get(id)\n      // not connected\n      if (!link_info) continue\n\n      link_info._last_time = 0\n    }\n  }\n\n  /**\n   * changes node size and triggers callback\n   */\n  setSize(size: Size): void {\n    this.size = size\n    this.onResize?.(this.size)\n  }\n\n  /**\n   * Expands the node size to fit its content.\n   */\n  expandToFitContent(): void {\n    const newSize = this.computeSize()\n    this.setSize([\n      Math.max(this.size[0], newSize[0]),\n      Math.max(this.size[1], newSize[1]),\n    ])\n  }\n\n  /**\n   * add a new property to this node\n   * @param type string defining the output type (\"vec3\",\"number\",...)\n   * @param extra_info this can be used to have special properties of the property (like values, etc)\n   */\n  addProperty(\n    name: string,\n    default_value: NodeProperty | undefined,\n    type?: string,\n    extra_info?: Partial<INodePropertyInfo>,\n  ): INodePropertyInfo {\n    const o: INodePropertyInfo = { name, type, default_value }\n    if (extra_info) Object.assign(o, extra_info)\n\n    this.properties_info ||= []\n    this.properties_info.push(o)\n    this.properties ||= {}\n    this.properties[name] = default_value\n    return o\n  }\n\n  /**\n   * add a new output slot to use in this node\n   * @param type string defining the output type (\"vec3\",\"number\",...)\n   * @param extra_info this can be used to have special properties of an output (label, special color, position, etc)\n   */\n  addOutput<TProperties extends Partial<INodeOutputSlot>>(\n    name: string,\n    type: ISlotType,\n    extra_info?: TProperties,\n  ): INodeOutputSlot & TProperties {\n    const output = Object.assign(\n      new NodeOutputSlot({ name, type, links: null }, this),\n      extra_info,\n    )\n\n    this.outputs ||= []\n    this.outputs.push(output)\n    this.onOutputAdded?.(output)\n\n    if (LiteGraph.auto_load_slot_types)\n      LiteGraph.registerNodeAndSlotType(this, type, true)\n\n    this.expandToFitContent()\n    this.setDirtyCanvas(true, true)\n    return output\n  }\n\n  /**\n   * remove an existing output slot\n   */\n  removeOutput(slot: number): void {\n    this.disconnectOutput(slot)\n    const { outputs } = this\n    outputs.splice(slot, 1)\n\n    for (let i = slot; i < outputs.length; ++i) {\n      const output = outputs[i]\n      if (!output || !output.links) continue\n\n      for (const linkId of output.links) {\n        if (!this.graph) throw new NullGraphError()\n\n        const link = this.graph._links.get(linkId)\n        if (link) link.origin_slot--\n      }\n    }\n\n    this.onOutputRemoved?.(slot)\n    this.setDirtyCanvas(true, true)\n  }\n\n  /**\n   * add a new input slot to use in this node\n   * @param type string defining the input type (\"vec3\",\"number\",...), it its a generic one use 0\n   * @param extra_info this can be used to have special properties of an input (label, color, position, etc)\n   */\n  addInput<TProperties extends Partial<INodeInputSlot>>(name: string, type: ISlotType, extra_info?: TProperties): INodeInputSlot & TProperties {\n    type ||= 0\n\n    const input = Object.assign(\n      new NodeInputSlot({ name, type, link: null }, this),\n      extra_info,\n    )\n\n    this.inputs ||= []\n    this.inputs.push(input)\n    this.expandToFitContent()\n\n    this.onInputAdded?.(input)\n    LiteGraph.registerNodeAndSlotType(this, type)\n\n    this.setDirtyCanvas(true, true)\n    return input\n  }\n\n  /**\n   * remove an existing input slot\n   */\n  removeInput(slot: number): void {\n    this.disconnectInput(slot, true)\n    const { inputs } = this\n    const slot_info = inputs.splice(slot, 1)\n\n    for (let i = slot; i < inputs.length; ++i) {\n      const input = inputs[i]\n      if (!input?.link) continue\n\n      if (!this.graph) throw new NullGraphError()\n      const link = this.graph._links.get(input.link)\n      if (link) link.target_slot--\n    }\n    this.onInputRemoved?.(slot, slot_info[0])\n    this.setDirtyCanvas(true, true)\n  }\n\n  /**\n   * computes the minimum size of a node according to its inputs and output slots\n   * @returns the total size\n   */\n  computeSize(out?: Size): Size {\n    const ctorSize = this.constructor.size\n    if (ctorSize) return [ctorSize[0], ctorSize[1]]\n\n    const { inputs, outputs, widgets } = this\n    let rows = Math.max(\n      inputs ? inputs.filter(input => !isWidgetInputSlot(input)).length : 1,\n      outputs ? outputs.length : 1,\n    )\n    const size = out || new Float32Array([0, 0])\n    rows = Math.max(rows, 1)\n    // although it should be graphcanvas.inner_text_font size\n    const font_size = LiteGraph.NODE_TEXT_SIZE\n\n    const padLeft = LiteGraph.NODE_TITLE_HEIGHT\n    const padRight = padLeft * 0.33\n    const title_width = padLeft + compute_text_size(this.title, this.titleFontStyle) + padRight\n    let input_width = 0\n    let widgetWidth = 0\n    let output_width = 0\n\n    if (inputs) {\n      for (const input of inputs) {\n        const text = input.label || input.localized_name || input.name || \"\"\n        const text_width = compute_text_size(text, this.innerFontStyle)\n        if (isWidgetInputSlot(input)) {\n          const widget = this.getWidgetFromSlot(input)\n          if (widget && !this.isWidgetVisible(widget)) continue\n\n          if (text_width > widgetWidth) widgetWidth = text_width\n        } else {\n          if (text_width > input_width) input_width = text_width\n        }\n      }\n    }\n\n    if (outputs) {\n      for (const output of outputs) {\n        const text = output.label || output.localized_name || output.name || \"\"\n        const text_width = compute_text_size(text, this.innerFontStyle)\n        if (output_width < text_width)\n          output_width = text_width\n      }\n    }\n\n    const minWidth = LiteGraph.NODE_WIDTH * (widgets?.length ? 1.5 : 1)\n    // Text + slot width + centre padding\n    const centrePadding = input_width && output_width ? 5 : 0\n    const slotsWidth = input_width + output_width + (2 * LiteGraph.NODE_SLOT_HEIGHT) + centrePadding\n\n    // Total distance from edge of node to the inner edge of the widget 'previous' arrow button\n    const widgetMargin = BaseWidget.margin + BaseWidget.arrowMargin + BaseWidget.arrowWidth\n    const widgetPadding = BaseWidget.minValueWidth + (2 * widgetMargin)\n    if (widgetWidth) widgetWidth += widgetPadding\n\n    size[0] = Math.max(slotsWidth, widgetWidth, title_width, minWidth)\n    size[1] = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT\n\n    // Get widget height & expand size if necessary\n    let widgets_height = 0\n    if (widgets?.length) {\n      for (const widget of widgets) {\n        if (!this.isWidgetVisible(widget)) continue\n\n        let widget_height = 0\n        if (widget.computeSize) {\n          widget_height += widget.computeSize(size[0])[1]\n        } else if (widget.computeLayoutSize) {\n          // Expand widget width if necessary\n          const { minHeight, minWidth } = widget.computeLayoutSize(this)\n          const widgetWidth = minWidth + widgetPadding\n          if (widgetWidth > size[0]) size[0] = widgetWidth\n\n          widget_height += minHeight\n        } else {\n          widget_height += LiteGraph.NODE_WIDGET_HEIGHT\n        }\n        widgets_height += widget_height + 4\n      }\n      widgets_height += 8\n    }\n\n    // compute height using widgets height\n    if (this.widgets_up)\n      size[1] = Math.max(size[1], widgets_height)\n    else if (this.widgets_start_y != null)\n      size[1] = Math.max(size[1], widgets_height + this.widgets_start_y)\n    else\n      size[1] += widgets_height\n\n    function compute_text_size(text: string, fontStyle: string) {\n      return LGraphCanvas._measureText?.(text, fontStyle) ??\n        font_size * (text?.length ?? 0) * 0.6\n    }\n\n    if (this.constructor.min_height && size[1] < this.constructor.min_height) {\n      size[1] = this.constructor.min_height\n    }\n\n    // margin\n    size[1] += 6\n\n    return size\n  }\n\n  inResizeCorner(canvasX: number, canvasY: number): boolean {\n    const rows = this.outputs ? this.outputs.length : 1\n    const outputs_offset = (this.constructor.slot_start_y || 0) + rows * LiteGraph.NODE_SLOT_HEIGHT\n    return isInRectangle(\n      canvasX,\n      canvasY,\n      this.pos[0] + this.size[0] - 15,\n      this.pos[1] + Math.max(this.size[1] - 15, outputs_offset),\n      20,\n      20,\n    )\n  }\n\n  /**\n   * returns all the info available about a property of this node.\n   * @param property name of the property\n   * @returns the object with all the available info\n   */\n  getPropertyInfo(property: string) {\n    let info = null\n\n    // there are several ways to define info about a property\n    // legacy mode\n    const { properties_info } = this\n    if (properties_info) {\n      for (const propInfo of properties_info) {\n        if (propInfo.name == property) {\n          info = propInfo\n          break\n        }\n      }\n    }\n    // litescene mode using the constructor\n    // @ts-expect-error deprecated https://github.com/Comfy-Org/litegraph.js/issues/639\n    if (this.constructor[`@${property}`]) info = this.constructor[`@${property}`]\n\n    if (this.constructor.widgets_info?.[property])\n      info = this.constructor.widgets_info[property]\n\n    // litescene mode using the constructor\n    if (!info && this.onGetPropertyInfo) {\n      info = this.onGetPropertyInfo(property)\n    }\n\n    info ||= {}\n    info.type ||= typeof this.properties[property]\n    if (info.widget == \"combo\") info.type = \"enum\"\n\n    return info\n  }\n\n  /**\n   * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties\n   * @param type the widget type\n   * @param name the text to show on the widget\n   * @param value the default value\n   * @param callback function to call when it changes (optionally, it can be the name of the property to modify)\n   * @param options the object that contains special properties of this widget\n   * @returns the created widget object\n   */\n  addWidget<Type extends TWidgetType, TValue extends WidgetTypeMap[Type][\"value\"]>(\n    type: Type,\n    name: string,\n    value: TValue,\n    callback: IBaseWidget[\"callback\"] | string | null,\n    options?: IWidgetOptions | string,\n  ): WidgetTypeMap[Type] | IBaseWidget {\n    this.widgets ||= []\n\n    if (!options && callback && typeof callback === \"object\") {\n      options = callback\n      callback = null\n    }\n\n    // options can be the property name\n    options ||= {}\n    if (typeof options === \"string\")\n      options = { property: options }\n\n    // callback can be the property name\n    if (callback && typeof callback === \"string\") {\n      options.property = callback\n      callback = null\n    }\n\n    const w: IBaseWidget & { type: Type } = {\n      // @ts-expect-error\n      type: type.toLowerCase(),\n      name: name,\n      value: value,\n      callback: typeof callback !== \"function\" ? undefined : callback,\n      options,\n      y: 0,\n    }\n\n    if (w.options.y !== undefined) {\n      w.y = w.options.y\n    }\n\n    if (!callback && !w.options.callback && !w.options.property) {\n      console.warn(\"LiteGraph addWidget(...) without a callback or property assigned\")\n    }\n    if (type == \"combo\" && !w.options.values) {\n      throw \"LiteGraph addWidget('combo',...) requires to pass values in options: { values:['red','blue'] }\"\n    }\n\n    const widget = this.addCustomWidget(w)\n    this.expandToFitContent()\n    return widget\n  }\n\n  addCustomWidget<TPlainWidget extends IBaseWidget>(\n    custom_widget: TPlainWidget,\n  ): TPlainWidget | WidgetTypeMap[TPlainWidget[\"type\"]] {\n    this.widgets ||= []\n    const widget = toConcreteWidget(custom_widget, this, false) ?? custom_widget\n    this.widgets.push(widget)\n    return widget\n  }\n\n  move(deltaX: number, deltaY: number): void {\n    if (this.pinned) return\n\n    this.pos[0] += deltaX\n    this.pos[1] += deltaY\n  }\n\n  /**\n   * Internal method to measure the node for rendering.  Prefer {@link boundingRect} where possible.\n   *\n   * Populates {@link out} with the results in graph space.\n   * Populates {@link _collapsed_width} with the collapsed width if the node is collapsed.\n   * Adjusts for title and collapsed status, but does not call {@link onBounding}.\n   * @param out `x, y, width, height` are written to this array.\n   * @param ctx The canvas context to use for measuring text.\n   */\n  measure(out: Rect, ctx: CanvasRenderingContext2D): void {\n    const titleMode = this.title_mode\n    const renderTitle =\n      titleMode != TitleMode.TRANSPARENT_TITLE &&\n      titleMode != TitleMode.NO_TITLE\n    const titleHeight = renderTitle ? LiteGraph.NODE_TITLE_HEIGHT : 0\n\n    out[0] = this.pos[0]\n    out[1] = this.pos[1] + -titleHeight\n    if (!this.flags?.collapsed) {\n      out[2] = this.size[0]\n      out[3] = this.size[1] + titleHeight\n    } else {\n      ctx.font = this.innerFontStyle\n      this._collapsed_width = Math.min(\n        this.size[0],\n        ctx.measureText(this.getTitle() ?? \"\").width + LiteGraph.NODE_TITLE_HEIGHT * 2,\n      )\n      out[2] = (this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH)\n      out[3] = LiteGraph.NODE_TITLE_HEIGHT\n    }\n  }\n\n  /**\n   * returns the bounding of the object, used for rendering purposes\n   * @param out {Float32Array[4]?} [optional] a place to store the output, to free garbage\n   * @param includeExternal {boolean?} [optional] set to true to\n   * include the shadow and connection points in the bounding calculation\n   * @returns the bounding box in format of [topleft_cornerx, topleft_cornery, width, height]\n   */\n  getBounding(out?: Rect, includeExternal?: boolean): Rect {\n    out ||= new Float32Array(4)\n\n    const rect = includeExternal ? this.renderArea : this.boundingRect\n    out[0] = rect[0]\n    out[1] = rect[1]\n    out[2] = rect[2]\n    out[3] = rect[3]\n\n    return out\n  }\n\n  /**\n   * Calculates the render area of this node, populating both {@link boundingRect} and {@link renderArea}.\n   * Called automatically at the start of every frame.\n   */\n  updateArea(ctx: CanvasRenderingContext2D): void {\n    const bounds = this.#boundingRect\n    this.measure(bounds, ctx)\n    this.onBounding?.(bounds)\n\n    const renderArea = this.#renderArea\n    renderArea.set(bounds)\n    // 4 offset for collapsed node connection points\n    renderArea[0] -= 4\n    renderArea[1] -= 4\n    // Add shadow & left offset\n    renderArea[2] += 6 + 4\n    // Add shadow & top offsets\n    renderArea[3] += 5 + 4\n  }\n\n  /**\n   * checks if a point is inside the shape of a node\n   */\n  isPointInside(x: number, y: number): boolean {\n    return isInRect(x, y, this.boundingRect)\n  }\n\n  /**\n   * Checks if the provided point is inside this node's collapse button area.\n   * @param x X co-ordinate to check\n   * @param y Y co-ordinate to check\n   * @returns true if the x,y point is in the collapse button area, otherwise false\n   */\n  isPointInCollapse(x: number, y: number): boolean {\n    const squareLength = LiteGraph.NODE_TITLE_HEIGHT\n    return isInRectangle(\n      x,\n      y,\n      this.pos[0],\n      this.pos[1] - squareLength,\n      squareLength,\n      squareLength,\n    )\n  }\n\n  /**\n   * Returns the input slot at the given position. Uses full 20 height, and approximates the label length.\n   * @param pos The graph co-ordinates to check\n   * @returns The input slot at the given position if found, otherwise `undefined`.\n   */\n  getInputOnPos(pos: Point): INodeInputSlot | undefined {\n    return getNodeInputOnPos(this, pos[0], pos[1])?.input\n  }\n\n  /**\n   * Returns the output slot at the given position. Uses full 20x20 box for the slot.\n   * @param pos The graph co-ordinates to check\n   * @returns The output slot at the given position if found, otherwise `undefined`.\n   */\n  getOutputOnPos(pos: Point): INodeOutputSlot | undefined {\n    return getNodeOutputOnPos(this, pos[0], pos[1])?.output\n  }\n\n  /**\n   * Returns the input or output slot at the given position.\n   *\n   * Tries {@link getNodeInputOnPos} first, then {@link getNodeOutputOnPos}.\n   * @param pos The graph co-ordinates to check\n   * @returns The input or output slot at the given position if found, otherwise `undefined`.\n   */\n  getSlotOnPos(pos: Point): INodeInputSlot | INodeOutputSlot | undefined {\n    if (!isPointInRect(pos, this.boundingRect)) return\n\n    return this.getInputOnPos(pos) ?? this.getOutputOnPos(pos)\n  }\n\n  /**\n   * @deprecated Use {@link getSlotOnPos} instead.\n   * checks if a point is inside a node slot, and returns info about which slot\n   * @param x\n   * @param y\n   * @returns if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }\n   */\n  getSlotInPosition(x: number, y: number): IFoundSlot | null {\n    // search for inputs\n    const { inputs, outputs } = this\n\n    if (inputs) {\n      for (const [i, input] of inputs.entries()) {\n        const pos = this.getInputPos(i)\n        if (isInRectangle(x, y, pos[0] - 10, pos[1] - 10, 20, 20)) {\n          return { input, slot: i, link_pos: pos }\n        }\n      }\n    }\n\n    if (outputs) {\n      for (const [i, output] of outputs.entries()) {\n        const pos = this.getOutputPos(i)\n        if (isInRectangle(x, y, pos[0] - 10, pos[1] - 10, 20, 20)) {\n          return { output, slot: i, link_pos: pos }\n        }\n      }\n    }\n\n    return null\n  }\n\n  /**\n   * Gets the widget on this node at the given co-ordinates.\n   * @param canvasX X co-ordinate in graph space\n   * @param canvasY Y co-ordinate in graph space\n   * @returns The widget found, otherwise `null`\n   */\n  getWidgetOnPos(\n    canvasX: number,\n    canvasY: number,\n    includeDisabled = false,\n  ): IBaseWidget | undefined {\n    const { widgets, pos, size } = this\n    if (!widgets?.length) return\n\n    const x = canvasX - pos[0]\n    const y = canvasY - pos[1]\n    const nodeWidth = size[0]\n\n    for (const widget of widgets) {\n      if (\n        (widget.computedDisabled && !includeDisabled) ||\n        !this.isWidgetVisible(widget)\n      ) {\n        continue\n      }\n\n      const h = widget.computedHeight ??\n        widget.computeSize?.(nodeWidth)[1] ??\n        LiteGraph.NODE_WIDGET_HEIGHT\n\n      const w = widget.width || nodeWidth\n      if (\n        widget.last_y !== undefined &&\n        isInRectangle(x, y, 6, widget.last_y, w - 12, h)\n      ) {\n        return widget\n      }\n    }\n  }\n\n  /**\n   * Returns the input slot with a given name (used for dynamic slots), -1 if not found\n   * @param name the name of the slot to find\n   * @param returnObj if the obj itself wanted\n   * @returns the slot (-1 if not found)\n   */\n  findInputSlot<TReturn extends false>(name: string, returnObj?: TReturn): number\n  findInputSlot<TReturn extends true>(name: string, returnObj?: TReturn): INodeInputSlot\n  findInputSlot(name: string, returnObj: boolean = false) {\n    const { inputs } = this\n    if (!inputs) return -1\n\n    for (const [i, input] of inputs.entries()) {\n      if (name == input.name) {\n        return !returnObj ? i : input\n      }\n    }\n    return -1\n  }\n\n  /**\n   * returns the output slot with a given name (used for dynamic slots), -1 if not found\n   * @param name the name of the slot to find\n   * @param returnObj if the obj itself wanted\n   * @returns the slot (-1 if not found)\n   */\n  findOutputSlot<TReturn extends false>(name: string, returnObj?: TReturn): number\n  findOutputSlot<TReturn extends true>(name: string, returnObj?: TReturn): INodeOutputSlot\n  findOutputSlot(name: string, returnObj: boolean = false) {\n    const { outputs } = this\n    if (!outputs) return -1\n\n    for (const [i, output] of outputs.entries()) {\n      if (name == output.name) {\n        return !returnObj ? i : output\n      }\n    }\n    return -1\n  }\n\n  /**\n   * Finds the first free input slot.\n   * @param optsIn\n   * @returns The index of the first matching slot, the slot itself if returnObj is true, or -1 if not found.\n   */\n  findInputSlotFree<TReturn extends false>(\n    optsIn?: FindFreeSlotOptions & { returnObj?: TReturn },\n  ): number\n  findInputSlotFree<TReturn extends true>(\n    optsIn?: FindFreeSlotOptions & { returnObj?: TReturn },\n  ): INodeInputSlot | -1\n  findInputSlotFree(optsIn?: FindFreeSlotOptions) {\n    return this.#findFreeSlot(this.inputs, optsIn)\n  }\n\n  /**\n   * Finds the first free output slot.\n   * @param optsIn\n   * @returns The index of the first matching slot, the slot itself if returnObj is true, or -1 if not found.\n   */\n  findOutputSlotFree<TReturn extends false>(\n    optsIn?: FindFreeSlotOptions & { returnObj?: TReturn },\n  ): number\n  findOutputSlotFree<TReturn extends true>(\n    optsIn?: FindFreeSlotOptions & { returnObj?: TReturn },\n  ): INodeOutputSlot | -1\n  findOutputSlotFree(optsIn?: FindFreeSlotOptions) {\n    return this.#findFreeSlot(this.outputs, optsIn)\n  }\n\n  /**\n   * Finds the next free slot\n   * @param slots The slots to search, i.e. this.inputs or this.outputs\n   */\n  #findFreeSlot<TSlot extends INodeInputSlot | INodeOutputSlot>(\n    slots: TSlot[],\n    options?: FindFreeSlotOptions,\n  ): TSlot | number {\n    const defaults = {\n      returnObj: false,\n      typesNotAccepted: [],\n    }\n    const opts = Object.assign(defaults, options || {})\n    const length = slots?.length\n    if (!(length > 0)) return -1\n\n    for (let i = 0; i < length; ++i) {\n      const slot: TSlot & IGenericLinkOrLinks = slots[i]\n      if (!slot || slot.link || slot.links?.length) continue\n      if (opts.typesNotAccepted?.includes?.(slot.type)) continue\n      return !opts.returnObj ? i : slot\n    }\n    return -1\n  }\n\n  /**\n   * findSlotByType for INPUTS\n   */\n  findInputSlotByType<TReturn extends false>(\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): number\n  findInputSlotByType<TReturn extends true>(\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): INodeInputSlot\n  findInputSlotByType(\n    type: ISlotType,\n    returnObj?: boolean,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ) {\n    return this.#findSlotByType(\n      this.inputs,\n      type,\n      returnObj,\n      preferFreeSlot,\n      doNotUseOccupied,\n    )\n  }\n\n  /**\n   * findSlotByType for OUTPUTS\n   */\n  findOutputSlotByType<TReturn extends false>(\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): number\n  findOutputSlotByType<TReturn extends true>(\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): INodeOutputSlot\n  findOutputSlotByType(\n    type: ISlotType,\n    returnObj?: boolean,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ) {\n    return this.#findSlotByType(\n      this.outputs,\n      type,\n      returnObj,\n      preferFreeSlot,\n      doNotUseOccupied,\n    )\n  }\n\n  /**\n   * returns the output (or input) slot with a given type, -1 if not found\n   * @param input uise inputs instead of outputs\n   * @param type the type of the slot to find\n   * @param returnObj if the obj itself wanted\n   * @param preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)\n   * @returns the slot (-1 if not found)\n   */\n  findSlotByType<TSlot extends true | false, TReturn extends false>(\n    input: TSlot,\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): number\n  findSlotByType<TSlot extends true, TReturn extends true>(\n    input: TSlot,\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): INodeInputSlot | -1\n  findSlotByType<TSlot extends false, TReturn extends true>(\n    input: TSlot,\n    type: ISlotType,\n    returnObj?: TReturn,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): INodeOutputSlot | -1\n  findSlotByType(\n    input: boolean,\n    type: ISlotType,\n    returnObj?: boolean,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): number | INodeOutputSlot | INodeInputSlot {\n    return input\n      ? this.#findSlotByType(\n        this.inputs,\n        type,\n        returnObj,\n        preferFreeSlot,\n        doNotUseOccupied,\n      )\n      : this.#findSlotByType(\n        this.outputs,\n        type,\n        returnObj,\n        preferFreeSlot,\n        doNotUseOccupied,\n      )\n  }\n\n  /**\n   * Finds a matching slot from those provided, returning the slot itself or its index in {@link slots}.\n   * @param slots Slots to search (this.inputs or this.outputs)\n   * @param type Type of slot to look for\n   * @param returnObj If true, returns the slot itself.  Otherwise, the index.\n   * @param preferFreeSlot Prefer a free slot, but if none are found, fall back to an occupied slot.\n   * @param doNotUseOccupied Do not fall back to occupied slots.\n   * @see {findSlotByType}\n   * @see {findOutputSlotByType}\n   * @see {findInputSlotByType}\n   * @returns If a match is found, the slot if returnObj is true, otherwise the index.  If no matches are found, -1\n   */\n  #findSlotByType<TSlot extends INodeInputSlot | INodeOutputSlot>(\n    slots: TSlot[],\n    type: ISlotType,\n    returnObj?: boolean,\n    preferFreeSlot?: boolean,\n    doNotUseOccupied?: boolean,\n  ): TSlot | number {\n    const length = slots?.length\n    if (!length) return -1\n\n    // Empty string and * match anything (type:  0)\n    if (type == \"\" || type == \"*\") type = 0\n    const sourceTypes = String(type).toLowerCase().split(\",\")\n\n    // Run the search\n    let occupiedSlot: number | TSlot | null = null\n    for (let i = 0; i < length; ++i) {\n      const slot: TSlot & IGenericLinkOrLinks = slots[i]\n      const destTypes = slot.type == \"0\" || slot.type == \"*\"\n        ? [\"0\"]\n        : String(slot.type).toLowerCase().split(\",\")\n\n      for (const sourceType of sourceTypes) {\n        // TODO: Remove _event_ entirely.\n        const source = sourceType == \"_event_\" ? LiteGraph.EVENT : sourceType\n\n        for (const destType of destTypes) {\n          const dest = destType == \"_event_\" ? LiteGraph.EVENT : destType\n\n          if (source == dest || source === \"*\" || dest === \"*\") {\n            if (preferFreeSlot && (slot.links?.length || slot.link != null)) {\n              // In case we can't find a free slot.\n              occupiedSlot ??= returnObj ? slot : i\n              continue\n            }\n            return returnObj ? slot : i\n          }\n        }\n      }\n    }\n\n    return doNotUseOccupied ? -1 : occupiedSlot ?? -1\n  }\n\n  /**\n   * Determines the slot index to connect to when attempting to connect by type.\n   * @param findInputs If true, searches for an input.  Otherwise, an output.\n   * @param node The node at the other end of the connection.\n   * @param slotType The type of slot at the other end of the connection.\n   * @param options Search restrictions to adhere to.\n   * @see {connectByType}\n   * @see {connectByTypeOutput}\n   */\n  findConnectByTypeSlot(\n    findInputs: boolean,\n    node: LGraphNode,\n    slotType: ISlotType,\n    options?: ConnectByTypeOptions,\n  ): number | undefined {\n    // LEGACY: Old options names\n    if (options && typeof options === \"object\") {\n      if (\"firstFreeIfInputGeneralInCase\" in options) options.wildcardToTyped = !!options.firstFreeIfInputGeneralInCase\n      if (\"firstFreeIfOutputGeneralInCase\" in options) options.wildcardToTyped = !!options.firstFreeIfOutputGeneralInCase\n      if (\"generalTypeInCase\" in options) options.typedToWildcard = !!options.generalTypeInCase\n    }\n    const optsDef: ConnectByTypeOptions = {\n      createEventInCase: true,\n      wildcardToTyped: true,\n      typedToWildcard: true,\n    }\n    const opts = Object.assign(optsDef, options)\n\n    if (!this.graph) throw new NullGraphError()\n\n    if (node && typeof node === \"number\") {\n      const nodeById = this.graph.getNodeById(node)\n      if (!nodeById) return\n\n      node = nodeById\n    }\n    const slot = node.findSlotByType(findInputs, slotType, false, true)\n    if (slot >= 0 && slot !== null) return slot\n\n    // TODO: Remove or reimpl. events.  WILL CREATE THE onTrigger IN SLOT\n    if (opts.createEventInCase && slotType == LiteGraph.EVENT) {\n      if (findInputs) return -1\n      if (LiteGraph.do_add_triggers_slots) return node.addOnExecutedOutput()\n    }\n\n    // connect to the first general output slot if not found a specific type and\n    if (opts.typedToWildcard) {\n      const generalSlot = node.findSlotByType(findInputs, 0, false, true, true)\n      if (generalSlot >= 0) return generalSlot\n    }\n    // connect to the first free input slot if not found a specific type and this output is general\n    if (\n      opts.wildcardToTyped &&\n      (slotType == 0 || slotType == \"*\" || slotType == \"\")\n    ) {\n      const opt = { typesNotAccepted: [LiteGraph.EVENT] }\n      const nonEventSlot = findInputs\n        ? node.findInputSlotFree(opt)\n        : node.findOutputSlotFree(opt)\n      if (nonEventSlot >= 0) return nonEventSlot\n    }\n  }\n\n  /**\n   * Finds the first free output slot with any of the comma-delimited types in {@link type}.\n   *\n   * If no slots are free, falls back in order to:\n   * - The first free wildcard slot\n   * - The first occupied slot\n   * - The first occupied wildcard slot\n   * @param type The {@link ISlotType type} of slot to find\n   * @returns The index and slot if found, otherwise `undefined`.\n   */\n  findOutputByType(type: ISlotType): { index: number, slot: INodeOutputSlot } | undefined {\n    return findFreeSlotOfType(this.outputs, type)\n  }\n\n  /**\n   * Finds the first free input slot with any of the comma-delimited types in {@link type}.\n   *\n   * If no slots are free, falls back in order to:\n   * - The first free wildcard slot\n   * - The first occupied slot\n   * - The first occupied wildcard slot\n   * @param type The {@link ISlotType type} of slot to find\n   * @returns The index and slot if found, otherwise `undefined`.\n   */\n  findInputByType(type: ISlotType): { index: number, slot: INodeInputSlot } | undefined {\n    return findFreeSlotOfType(this.inputs, type)\n  }\n\n  /**\n   * connect this node output to the input of another node BY TYPE\n   * @param slot (could be the number of the slot or the string with the name of the slot)\n   * @param target_node the target node\n   * @param target_slotType the input slot type of the target node\n   * @returns the link_info is created, otherwise null\n   */\n  connectByType(\n    slot: number | string,\n    target_node: LGraphNode,\n    target_slotType: ISlotType,\n    optsIn?: ConnectByTypeOptions,\n  ): LLink | null {\n    const slotIndex = this.findConnectByTypeSlot(\n      true,\n      target_node,\n      target_slotType,\n      optsIn,\n    )\n    if (slotIndex !== undefined)\n      return this.connect(slot, target_node, slotIndex, optsIn?.afterRerouteId)\n\n    console.debug(\"[connectByType]: no way to connect type:\", target_slotType, \"to node:\", target_node)\n    return null\n  }\n\n  /**\n   * connect this node input to the output of another node BY TYPE\n   * @param slot (could be the number of the slot or the string with the name of the slot)\n   * @param source_node the target node\n   * @param source_slotType the output slot type of the target node\n   * @returns the link_info is created, otherwise null\n   */\n  connectByTypeOutput(\n    slot: number | string,\n    source_node: LGraphNode,\n    source_slotType: ISlotType,\n    optsIn?: ConnectByTypeOptions,\n  ): LLink | null {\n    // LEGACY: Old options names\n    if (typeof optsIn === \"object\") {\n      if (\"firstFreeIfInputGeneralInCase\" in optsIn) optsIn.wildcardToTyped = !!optsIn.firstFreeIfInputGeneralInCase\n      if (\"generalTypeInCase\" in optsIn) optsIn.typedToWildcard = !!optsIn.generalTypeInCase\n    }\n    const slotIndex = this.findConnectByTypeSlot(\n      false,\n      source_node,\n      source_slotType,\n      optsIn,\n    )\n    if (slotIndex !== undefined)\n      return source_node.connect(slotIndex, this, slot, optsIn?.afterRerouteId)\n\n    console.debug(\"[connectByType]: no way to connect type:\", source_slotType, \"to node:\", source_node)\n    return null\n  }\n\n  canConnectTo(\n    node: LGraphNode,\n    toSlot: INodeInputSlot,\n    fromSlot: INodeOutputSlot,\n  ) {\n    return this.id !== node.id && LiteGraph.isValidConnection(fromSlot.type, toSlot.type)\n  }\n\n  /**\n   * Connect an output of this node to an input of another node\n   * @param slot (could be the number of the slot or the string with the name of the slot)\n   * @param target_node the target node\n   * @param target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)\n   * @returns the link_info is created, otherwise null\n   */\n  connect(\n    slot: number | string,\n    target_node: LGraphNode,\n    target_slot: ISlotType,\n    afterRerouteId?: RerouteId,\n  ): LLink | null {\n    // Allow legacy API support for searching target_slot by string, without mutating the input variables\n    let targetIndex: number | null\n\n    const { graph, outputs } = this\n    if (!graph) {\n      // could be connected before adding it to a graph\n      // due to link ids being associated with graphs\n      console.log(\"Connect: Error, node doesn't belong to any graph. Nodes must be added first to a graph before connecting them.\")\n      return null\n    }\n\n    // seek for the output slot\n    if (typeof slot === \"string\") {\n      slot = this.findOutputSlot(slot)\n      if (slot == -1) {\n        if (LiteGraph.debug) console.log(`Connect: Error, no slot of name ${slot}`)\n        return null\n      }\n    } else if (!outputs || slot >= outputs.length) {\n      if (LiteGraph.debug) console.log(\"Connect: Error, slot number not found\")\n      return null\n    }\n\n    if (target_node && typeof target_node === \"number\") {\n      const nodeById = graph.getNodeById(target_node)\n      if (!nodeById) throw \"target node is null\"\n\n      target_node = nodeById\n    }\n    if (!target_node) throw \"target node is null\"\n\n    // avoid loopback\n    if (target_node == this) return null\n\n    // you can specify the slot by name\n    if (typeof target_slot === \"string\") {\n      targetIndex = target_node.findInputSlot(target_slot)\n      if (targetIndex == -1) {\n        if (LiteGraph.debug) console.log(`Connect: Error, no slot of name ${targetIndex}`)\n        return null\n      }\n    } else if (target_slot === LiteGraph.EVENT) {\n      // TODO: Events\n      if (LiteGraph.do_add_triggers_slots) {\n        target_node.changeMode(LGraphEventMode.ON_TRIGGER)\n        targetIndex = target_node.findInputSlot(\"onTrigger\")\n      } else {\n        return null\n      }\n    } else if (typeof target_slot === \"number\") {\n      targetIndex = target_slot\n    } else {\n      targetIndex = 0\n    }\n\n    // Allow target node to change slot\n    if (target_node.onBeforeConnectInput) {\n      // This way node can choose another slot (or make a new one?)\n      const requestedIndex = target_node.onBeforeConnectInput(targetIndex, target_slot)\n      targetIndex = typeof requestedIndex === \"number\" ? requestedIndex : null\n    }\n\n    if (\n      targetIndex === null ||\n      !target_node.inputs ||\n      targetIndex >= target_node.inputs.length\n    ) {\n      if (LiteGraph.debug) console.log(\"Connect: Error, slot number not found\")\n      return null\n    }\n\n    const input = target_node.inputs[targetIndex]\n    const output = outputs[slot]\n\n    if (!output) return null\n\n    if (output.links?.length) {\n      if (output.type === LiteGraph.EVENT && !LiteGraph.allow_multi_output_for_events) {\n        graph.beforeChange()\n        // @ts-expect-error Unused param\n        this.disconnectOutput(slot, false, { doProcessChange: false })\n      }\n    }\n\n    const link = this.connectSlots(output, target_node, input, afterRerouteId)\n    return link ?? null\n  }\n\n  /**\n   * Connect two slots between two nodes\n   * @param output The output slot to connect\n   * @param inputNode The node that the input slot is on\n   * @param input The input slot to connect\n   * @param afterRerouteId The reroute ID to use for the link\n   * @returns The link that was created, or null if the connection was blocked\n   */\n  connectSlots(\n    output: INodeOutputSlot,\n    inputNode: LGraphNode,\n    input: INodeInputSlot,\n    afterRerouteId: RerouteId | undefined,\n  ): LLink | null | undefined {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const outputIndex = this.outputs.indexOf(output)\n    if (outputIndex === -1) {\n      console.warn(\"connectSlots: output not found\")\n      return\n    }\n    const inputIndex = inputNode.inputs.indexOf(input)\n    if (inputIndex === -1) {\n      console.warn(\"connectSlots: input not found\")\n      return\n    }\n\n    // check targetSlot and check connection types\n    if (!LiteGraph.isValidConnection(output.type, input.type)) {\n      this.setDirtyCanvas(false, true)\n      return null\n    }\n\n    // Allow nodes to block connection\n    if (inputNode.onConnectInput?.(inputIndex, output.type, output, this, outputIndex) === false)\n      return null\n    if (this.onConnectOutput?.(outputIndex, input.type, input, inputNode, inputIndex) === false)\n      return null\n\n    // if there is something already plugged there, disconnect\n    if (inputNode.inputs[inputIndex]?.link != null) {\n      graph.beforeChange()\n      inputNode.disconnectInput(inputIndex, true)\n    }\n\n    const link = new LLink(\n      ++graph.state.lastLinkId,\n      input.type || output.type,\n      this.id,\n      outputIndex,\n      inputNode.id,\n      inputIndex,\n      afterRerouteId,\n    )\n\n    // add to graph links list\n    graph._links.set(link.id, link)\n\n    // connect in output\n    output.links ??= []\n    output.links.push(link.id)\n    // connect in input\n    inputNode.inputs[inputIndex].link = link.id\n\n    // Reroutes\n    const reroutes = LLink.getReroutes(graph, link)\n    for (const reroute of reroutes) {\n      reroute.linkIds.add(link.id)\n      if (reroute.floating) delete reroute.floating\n      reroute._dragging = undefined\n    }\n\n    // If this is the terminus of a floating link, remove it\n    const lastReroute = reroutes.at(-1)\n    if (lastReroute) {\n      for (const linkId of lastReroute.floatingLinkIds) {\n        const link = graph.floatingLinks.get(linkId)\n        if (link?.parentId === lastReroute.id) {\n          graph.removeFloatingLink(link)\n        }\n      }\n    }\n    graph._version++\n\n    // link has been created now, so its updated\n    this.onConnectionsChange?.(\n      NodeSlotType.OUTPUT,\n      outputIndex,\n      true,\n      link,\n      output,\n    )\n\n    inputNode.onConnectionsChange?.(\n      NodeSlotType.INPUT,\n      inputIndex,\n      true,\n      link,\n      input,\n    )\n\n    this.setDirtyCanvas(false, true)\n    graph.afterChange()\n    graph.connectionChange(this)\n\n    return link\n  }\n\n  connectFloatingReroute(pos: Point, slot: INodeInputSlot | INodeOutputSlot, afterRerouteId?: RerouteId): Reroute {\n    const { graph, id } = this\n    if (!graph) throw new NullGraphError()\n\n    // Assertion: It's either there or it isn't.\n    const inputIndex = this.inputs.indexOf(slot as INodeInputSlot)\n    const outputIndex = this.outputs.indexOf(slot as INodeOutputSlot)\n    if (inputIndex === -1 && outputIndex === -1) throw new Error(\"Invalid slot\")\n\n    const slotType = outputIndex === -1 ? \"input\" : \"output\"\n\n    const reroute = graph.setReroute({\n      pos,\n      parentId: afterRerouteId,\n      linkIds: [],\n      floating: { slotType },\n    })\n\n    const parentReroute = graph.getReroute(afterRerouteId)\n    const fromLastFloatingReroute = parentReroute?.floating?.slotType === \"output\"\n\n    // Adding from an ouput, or a floating reroute that is NOT the tip of an existing floating chain\n    if (afterRerouteId == null || !fromLastFloatingReroute) {\n      const link = new LLink(\n        -1,\n        slot.type,\n        outputIndex === -1 ? -1 : id,\n        outputIndex,\n        inputIndex === -1 ? -1 : id,\n        inputIndex,\n      )\n      link.parentId = reroute.id\n      graph.addFloatingLink(link)\n      return reroute\n    }\n\n    // Adding a new floating reroute from the tip of a floating chain.\n    if (!parentReroute) throw new Error(\"[connectFloatingReroute] Parent reroute not found\")\n\n    const link = parentReroute.getFloatingLinks(\"output\")?.[0]\n    if (!link) throw new Error(\"[connectFloatingReroute] Floating link not found\")\n\n    reroute.floatingLinkIds.add(link.id)\n    link.parentId = reroute.id\n    delete parentReroute.floating\n    return reroute\n  }\n\n  /**\n   * disconnect one output to an specific node\n   * @param slot (could be the number of the slot or the string with the name of the slot)\n   * @param target_node the target node to which this slot is connected [Optional,\n   * if not target_node is specified all nodes will be disconnected]\n   * @returns if it was disconnected successfully\n   */\n  disconnectOutput(slot: string | number, target_node?: LGraphNode): boolean {\n    if (typeof slot === \"string\") {\n      slot = this.findOutputSlot(slot)\n      if (slot == -1) {\n        if (LiteGraph.debug) console.log(`Connect: Error, no slot of name ${slot}`)\n        return false\n      }\n    } else if (!this.outputs || slot >= this.outputs.length) {\n      if (LiteGraph.debug) console.log(\"Connect: Error, slot number not found\")\n      return false\n    }\n\n    // get output slot\n    const output = this.outputs[slot]\n    if (!output) return false\n\n    if (output._floatingLinks) {\n      for (const link of output._floatingLinks) {\n        if (link.hasOrigin(this.id, slot)) {\n          this.graph?.removeFloatingLink(link)\n        }\n      }\n    }\n\n    if (!output.links || output.links.length == 0) return false\n    const { links } = output\n\n    // one of the output links in this slot\n    const graph = this.graph\n    if (!graph) throw new NullGraphError()\n\n    if (target_node) {\n      const target = typeof target_node === \"number\"\n        ? graph.getNodeById(target_node)\n        : target_node\n      if (!target) throw \"Target Node not found\"\n\n      for (const [i, link_id] of links.entries()) {\n        const link_info = graph._links.get(link_id)\n        if (link_info?.target_id != target.id) continue\n\n        // is the link we are searching for...\n        // remove here\n        links.splice(i, 1)\n        const input = target.inputs[link_info.target_slot]\n        // remove there\n        input.link = null\n\n        // remove the link from the links pool\n        link_info.disconnect(graph, \"input\")\n        graph._version++\n\n        // link_info hasn't been modified so its ok\n        target.onConnectionsChange?.(\n          NodeSlotType.INPUT,\n          link_info.target_slot,\n          false,\n          link_info,\n          input,\n        )\n        this.onConnectionsChange?.(\n          NodeSlotType.OUTPUT,\n          slot,\n          false,\n          link_info,\n          output,\n        )\n\n        break\n      }\n    } else {\n      // all the links in this output slot\n      for (const link_id of links) {\n        const link_info = graph._links.get(link_id)\n        if (!link_info) continue\n\n        const target = graph.getNodeById(link_info.target_id)\n        graph._version++\n\n        if (target) {\n          const input = target.inputs[link_info.target_slot]\n          // remove other side link\n          input.link = null\n\n          // link_info hasn't been modified so its ok\n          target.onConnectionsChange?.(\n            NodeSlotType.INPUT,\n            link_info.target_slot,\n            false,\n            link_info,\n            input,\n          )\n        }\n        // remove the link from the links pool\n        link_info.disconnect(graph, \"input\")\n\n        this.onConnectionsChange?.(\n          NodeSlotType.OUTPUT,\n          slot,\n          false,\n          link_info,\n          output,\n        )\n      }\n      output.links = null\n    }\n\n    this.setDirtyCanvas(false, true)\n    graph.connectionChange(this)\n    return true\n  }\n\n  /**\n   * Disconnect one input\n   * @param slot Input slot index, or the name of the slot\n   * @param keepReroutes If `true`, reroutes will not be garbage collected.\n   * @returns true if disconnected successfully or already disconnected, otherwise false\n   */\n  disconnectInput(slot: number | string, keepReroutes?: boolean): boolean {\n    // Allow search by string\n    if (typeof slot === \"string\") {\n      slot = this.findInputSlot(slot)\n      if (slot == -1) {\n        if (LiteGraph.debug) console.log(`Connect: Error, no slot of name ${slot}`)\n        return false\n      }\n    } else if (!this.inputs || slot >= this.inputs.length) {\n      if (LiteGraph.debug) {\n        console.log(\"Connect: Error, slot number not found\")\n      }\n      return false\n    }\n\n    const input = this.inputs[slot]\n    if (!input) return false\n\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    // Break floating links\n    if (input._floatingLinks?.size) {\n      for (const link of input._floatingLinks) {\n        graph.removeFloatingLink(link)\n      }\n    }\n\n    const link_id = this.inputs[slot].link\n    if (link_id != null) {\n      this.inputs[slot].link = null\n\n      // remove other side\n      const link_info = graph._links.get(link_id)\n      if (link_info) {\n        const target_node = graph.getNodeById(link_info.origin_id)\n        if (!target_node) return false\n\n        const output = target_node.outputs[link_info.origin_slot]\n        if (!(output?.links?.length)) return false\n\n        // search in the inputs list for this link\n        let i = 0\n        for (const l = output.links.length; i < l; i++) {\n          if (output.links[i] == link_id) {\n            output.links.splice(i, 1)\n            break\n          }\n        }\n\n        link_info.disconnect(graph, keepReroutes ? \"output\" : undefined)\n        if (graph) graph._version++\n\n        this.onConnectionsChange?.(\n          NodeSlotType.INPUT,\n          slot,\n          false,\n          link_info,\n          input,\n        )\n        target_node.onConnectionsChange?.(\n          NodeSlotType.OUTPUT,\n          i,\n          false,\n          link_info,\n          output,\n        )\n      }\n    }\n\n    this.setDirtyCanvas(false, true)\n    graph?.connectionChange(this)\n    return true\n  }\n\n  /**\n   * @deprecated Use {@link getInputPos} or {@link getOutputPos} instead.\n   * returns the center of a connection point in canvas coords\n   * @param is_input true if if a input slot, false if it is an output\n   * @param slot_number (could be the number of the slot or the string with the name of the slot)\n   * @param out [optional] a place to store the output, to free garbage\n   * @returns the position\n   */\n  getConnectionPos(is_input: boolean, slot_number: number, out?: Point): Point {\n    out ||= new Float32Array(2)\n\n    const { pos: [nodeX, nodeY], inputs, outputs } = this\n\n    if (this.flags.collapsed) {\n      const w = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH\n      out[0] = is_input ? nodeX : nodeX + w\n      out[1] = nodeY - LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      return out\n    }\n\n    // weird feature that never got finished\n    if (is_input && slot_number == -1) {\n      out[0] = nodeX + LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      out[1] = nodeY + LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      return out\n    }\n\n    // hard-coded pos\n    const inputPos = inputs?.[slot_number]?.pos\n    const outputPos = outputs?.[slot_number]?.pos\n\n    if (is_input && inputPos) {\n      out[0] = nodeX + inputPos[0]\n      out[1] = nodeY + inputPos[1]\n      return out\n    } else if (!is_input && outputPos) {\n      out[0] = nodeX + outputPos[0]\n      out[1] = nodeY + outputPos[1]\n      return out\n    }\n\n    // default vertical slots\n    const offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    const slotIndex = is_input\n      ? this.#defaultVerticalInputs.indexOf(this.inputs[slot_number])\n      : this.#defaultVerticalOutputs.indexOf(this.outputs[slot_number])\n\n    out[0] = is_input\n      ? nodeX + offset\n      : nodeX + this.size[0] + 1 - offset\n    out[1] =\n      nodeY +\n      (slotIndex + 0.7) * LiteGraph.NODE_SLOT_HEIGHT +\n      (this.constructor.slot_start_y || 0)\n    return out\n  }\n\n  /**\n   * @internal The inputs that are not positioned with absolute coordinates.\n   */\n  get #defaultVerticalInputs() {\n    return this.inputs.filter(\n      slot => !slot.pos && !(this.widgets?.length && isWidgetInputSlot(slot)),\n    )\n  }\n\n  /**\n   * @internal The outputs that are not positioned with absolute coordinates.\n   */\n  get #defaultVerticalOutputs() {\n    return this.outputs.filter((slot: INodeOutputSlot) => !slot.pos)\n  }\n\n  /**\n   * Gets the position of an input slot, in graph co-ordinates.\n   *\n   * This method is preferred over the legacy {@link getConnectionPos} method.\n   * @param slot Input slot index\n   * @returns Position of the input slot\n   */\n  getInputPos(slot: number): Point {\n    return this.getInputSlotPos(this.inputs[slot])\n  }\n\n  /**\n   * Gets the position of an input slot, in graph co-ordinates.\n   * @param input The actual node input object\n   * @returns Position of the centre of the input slot in graph co-ordinates.\n   */\n  getInputSlotPos(input: INodeInputSlot): Point {\n    const { pos: [nodeX, nodeY] } = this\n\n    if (this.flags.collapsed) {\n      const halfTitle = LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      return [nodeX, nodeY - halfTitle]\n    }\n\n    const { pos } = input\n    if (pos) return [nodeX + pos[0], nodeY + pos[1]]\n\n    // default vertical slots\n    const offsetX = LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    const nodeOffsetY = this.constructor.slot_start_y || 0\n    const slotIndex = this.#defaultVerticalInputs.indexOf(input)\n    const slotY = (slotIndex + 0.7) * LiteGraph.NODE_SLOT_HEIGHT\n\n    return [nodeX + offsetX, nodeY + slotY + nodeOffsetY]\n  }\n\n  /**\n   * Gets the position of an output slot, in graph co-ordinates.\n   *\n   * This method is preferred over the legacy {@link getConnectionPos} method.\n   * @param slot Output slot index\n   * @returns Position of the output slot\n   */\n  getOutputPos(slot: number): Point {\n    const { pos: [nodeX, nodeY], outputs, size: [width] } = this\n\n    if (this.flags.collapsed) {\n      const width = this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH\n      const halfTitle = LiteGraph.NODE_TITLE_HEIGHT * 0.5\n      return [nodeX + width, nodeY - halfTitle]\n    }\n\n    const outputPos = outputs?.[slot]?.pos\n    if (outputPos) return [nodeX + outputPos[0], nodeY + outputPos[1]]\n\n    // default vertical slots\n    const offsetX = LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    const nodeOffsetY = this.constructor.slot_start_y || 0\n    const slotIndex = this.#defaultVerticalOutputs.indexOf(this.outputs[slot])\n    const slotY = (slotIndex + 0.7) * LiteGraph.NODE_SLOT_HEIGHT\n\n    // TODO: Why +1?\n    return [nodeX + width + 1 - offsetX, nodeY + slotY + nodeOffsetY]\n  }\n\n  /** @inheritdoc */\n  snapToGrid(snapTo: number): boolean {\n    return this.pinned ? false : snapPoint(this.pos, snapTo)\n  }\n\n  /** @see {@link snapToGrid} */\n  alignToGrid(): void {\n    this.snapToGrid(LiteGraph.CANVAS_GRID_SIZE)\n  }\n\n  /* Console output */\n  trace(msg: string): void {\n    this.console ||= []\n    this.console.push(msg)\n    // @ts-expect-error deprecated\n    if (this.console.length > LGraphNode.MAX_CONSOLE)\n      this.console.shift()\n  }\n\n  /* Forces to redraw or the main canvas (LGraphNode) or the bg canvas (links) */\n  setDirtyCanvas(dirty_foreground: boolean, dirty_background?: boolean): void {\n    this.graph?.canvasAction(c => c.setDirty(dirty_foreground, dirty_background))\n  }\n\n  loadImage(url: string): HTMLImageElement {\n    interface AsyncImageElement extends HTMLImageElement { ready?: boolean }\n\n    const img: AsyncImageElement = new Image()\n    img.src = LiteGraph.node_images_path + url\n    img.ready = false\n\n    const dirty = () => this.setDirtyCanvas(true)\n    img.addEventListener(\"load\", function (this: AsyncImageElement) {\n      this.ready = true\n      dirty()\n    })\n    return img\n  }\n\n  /**\n   * Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus\n   * @deprecated Use {@link LGraphCanvas.pointer} instead.\n   */\n  captureInput(v: boolean): void {\n    warnDeprecated(\"[DEPRECATED] captureInput will be removed in a future version. Please use LGraphCanvas.pointer (CanvasPointer) instead.\")\n    if (!this.graph || !this.graph.list_of_graphcanvas) return\n\n    const list = this.graph.list_of_graphcanvas\n\n    for (const c of list) {\n      // releasing somebody elses capture?!\n      if (!v && c.node_capturing_input != this) continue\n\n      // change\n      c.node_capturing_input = v ? this : null\n    }\n  }\n\n  get collapsed() {\n    return !!this.flags.collapsed\n  }\n\n  get collapsible() {\n    return !this.pinned && this.constructor.collapsable !== false\n  }\n\n  /**\n   * Toggle node collapse (makes it smaller on the canvas)\n   */\n  collapse(force?: boolean): void {\n    if (!this.collapsible && !force) return\n    if (!this.graph) throw new NullGraphError()\n    this.graph._version++\n    this.flags.collapsed = !this.flags.collapsed\n    this.setDirtyCanvas(true, true)\n  }\n\n  /**\n   * Toggles advanced mode of the node, showing advanced widgets\n   */\n  toggleAdvanced() {\n    if (!this.widgets?.some(w => w.advanced)) return\n    if (!this.graph) throw new NullGraphError()\n    this.graph._version++\n    this.showAdvanced = !this.showAdvanced\n    this.expandToFitContent()\n    this.setDirtyCanvas(true, true)\n  }\n\n  get pinned() {\n    return !!this.flags.pinned\n  }\n\n  /**\n   * Prevents the node being accidentally moved or resized by mouse interaction.\n   * Toggles pinned state if no value is provided.\n   */\n  pin(v?: boolean): void {\n    if (!this.graph) throw new NullGraphError()\n\n    this.graph._version++\n    this.flags.pinned = v ?? !this.flags.pinned\n    this.resizable = !this.pinned\n    // Delete the flag if unpinned, so that we don't get unnecessary\n    // flags.pinned = false in serialized object.\n    if (!this.pinned) delete this.flags.pinned\n  }\n\n  unpin(): void {\n    this.pin(false)\n  }\n\n  localToScreen(x: number, y: number, dragAndScale: DragAndScale): Point {\n    return [\n      (x + this.pos[0]) * dragAndScale.scale + dragAndScale.offset[0],\n      (y + this.pos[1]) * dragAndScale.scale + dragAndScale.offset[1],\n    ]\n  }\n\n  get width() {\n    return this.collapsed\n      ? this._collapsed_width || LiteGraph.NODE_COLLAPSED_WIDTH\n      : this.size[0]\n  }\n\n  /**\n   * Returns the height of the node, including the title bar.\n   */\n  get height() {\n    return LiteGraph.NODE_TITLE_HEIGHT + this.bodyHeight\n  }\n\n  /**\n   * Returns the height of the node, excluding the title bar.\n   */\n  get bodyHeight() {\n    return this.collapsed ? 0 : this.size[1]\n  }\n\n  drawBadges(ctx: CanvasRenderingContext2D, { gap = 2 } = {}): void {\n    const badgeInstances = this.badges.map(badge =>\n      badge instanceof LGraphBadge ? badge : badge())\n    const isLeftAligned = this.badgePosition === BadgePosition.TopLeft\n\n    let currentX = isLeftAligned\n      ? 0\n      : this.width - badgeInstances.reduce((acc, badge) => acc + badge.getWidth(ctx) + gap, 0)\n    const y = -(LiteGraph.NODE_TITLE_HEIGHT + gap)\n\n    for (const badge of badgeInstances) {\n      badge.draw(ctx, currentX, y - badge.height)\n      currentX += badge.getWidth(ctx) + gap\n    }\n  }\n\n  /**\n   * Renders the node's title bar background\n   */\n  drawTitleBarBackground(ctx: CanvasRenderingContext2D, {\n    scale,\n    title_height = LiteGraph.NODE_TITLE_HEIGHT,\n    low_quality = false,\n  }: DrawTitleOptions): void {\n    const fgcolor = this.renderingColor\n    const shape = this.renderingShape\n    const size = this.renderingSize\n\n    if (this.onDrawTitleBar) {\n      this.onDrawTitleBar(ctx, title_height, size, scale, fgcolor)\n      return\n    }\n\n    if (this.title_mode === TitleMode.TRANSPARENT_TITLE) {\n      return\n    }\n\n    if (this.collapsed) {\n      ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR\n    }\n\n    ctx.fillStyle = this.constructor.title_color || fgcolor\n    ctx.beginPath()\n\n    if (shape == RenderShape.BOX || low_quality) {\n      ctx.rect(0, -title_height, size[0], title_height)\n    } else if (shape == RenderShape.ROUND || shape == RenderShape.CARD) {\n      ctx.roundRect(\n        0,\n        -title_height,\n        size[0],\n        title_height,\n        this.collapsed\n          ? [LiteGraph.ROUND_RADIUS]\n          : [LiteGraph.ROUND_RADIUS, LiteGraph.ROUND_RADIUS, 0, 0],\n      )\n    }\n    ctx.fill()\n    ctx.shadowColor = \"transparent\"\n  }\n\n  /**\n   * Renders the node's title box, i.e. the dot in front of the title text that\n   * when clicked toggles the node's collapsed state. The term `title box` comes\n   * from the original LiteGraph implementation.\n   */\n  drawTitleBox(ctx: CanvasRenderingContext2D, {\n    scale,\n    low_quality = false,\n    title_height = LiteGraph.NODE_TITLE_HEIGHT,\n    box_size = 10,\n  }: DrawTitleBoxOptions): void {\n    const size = this.renderingSize\n    const shape = this.renderingShape\n\n    if (this.onDrawTitleBox) {\n      this.onDrawTitleBox(ctx, title_height, size, scale)\n      return\n    }\n\n    if (\n      [RenderShape.ROUND, RenderShape.CIRCLE, RenderShape.CARD].includes(shape)\n    ) {\n      if (low_quality) {\n        ctx.fillStyle = \"black\"\n        ctx.beginPath()\n        ctx.arc(\n          title_height * 0.5,\n          title_height * -0.5,\n          box_size * 0.5 + 1,\n          0,\n          Math.PI * 2,\n        )\n        ctx.fill()\n      }\n\n      ctx.fillStyle = this.renderingBoxColor\n      if (low_quality) {\n        ctx.fillRect(\n          title_height * 0.5 - box_size * 0.5,\n          title_height * -0.5 - box_size * 0.5,\n          box_size,\n          box_size,\n        )\n      } else {\n        ctx.beginPath()\n        ctx.arc(\n          title_height * 0.5,\n          title_height * -0.5,\n          box_size * 0.5,\n          0,\n          Math.PI * 2,\n        )\n        ctx.fill()\n      }\n    } else {\n      if (low_quality) {\n        ctx.fillStyle = \"black\"\n        ctx.fillRect(\n          (title_height - box_size) * 0.5 - 1,\n          (title_height + box_size) * -0.5 - 1,\n          box_size + 2,\n          box_size + 2,\n        )\n      }\n      ctx.fillStyle = this.renderingBoxColor\n      ctx.fillRect(\n        (title_height - box_size) * 0.5,\n        (title_height + box_size) * -0.5,\n        box_size,\n        box_size,\n      )\n    }\n  }\n\n  /**\n   * Renders the node's title text.\n   */\n  drawTitleText(ctx: CanvasRenderingContext2D, {\n    scale,\n    default_title_color,\n    low_quality = false,\n    title_height = LiteGraph.NODE_TITLE_HEIGHT,\n  }: DrawTitleTextOptions): void {\n    const size = this.renderingSize\n    const selected = this.selected\n\n    if (this.onDrawTitleText) {\n      this.onDrawTitleText(\n        ctx,\n        title_height,\n        size,\n        scale,\n        this.titleFontStyle,\n        selected,\n      )\n      return\n    }\n\n    // Don't render title text if low quality\n    if (low_quality) {\n      return\n    }\n\n    ctx.font = this.titleFontStyle\n    const rawTitle = this.getTitle() ?? `â ${this.type}`\n    const title = String(rawTitle) + (this.pinned ? \"ð\" : \"\")\n    if (title) {\n      if (selected) {\n        ctx.fillStyle = LiteGraph.NODE_SELECTED_TITLE_COLOR\n      } else {\n        ctx.fillStyle = this.constructor.title_text_color || default_title_color\n      }\n      if (this.collapsed) {\n        ctx.textAlign = \"left\"\n        ctx.fillText(\n          // avoid urls too long\n          title.substr(0, 20),\n          title_height,\n          LiteGraph.NODE_TITLE_TEXT_Y - title_height,\n        )\n        ctx.textAlign = \"left\"\n      } else {\n        ctx.textAlign = \"left\"\n        ctx.fillText(\n          title,\n          title_height,\n          LiteGraph.NODE_TITLE_TEXT_Y - title_height,\n        )\n      }\n    }\n  }\n\n  /**\n   * Attempts to gracefully bypass this node in all of its connections by reconnecting all links.\n   *\n   * Each input is checked against each output.  This is done on a matching index basis, i.e. input 3 -> output 3.\n   * If there are any input links remaining,\n   * and {@link flags}.{@link INodeFlags.keepAllLinksOnBypass keepAllLinksOnBypass} is `true`,\n   * each input will check for outputs that match, and take the first one that matches\n   * `true`: Try the index matching first, then every input to every output.\n   * `false`: Only matches indexes, e.g. input 3 to output 3.\n   *\n   * If {@link flags}.{@link INodeFlags.keepAllLinksOnBypass keepAllLinksOnBypass} is `undefined`, it will fall back to\n   * the static {@link keepAllLinksOnBypass}.\n   * @returns `true` if any new links were established, otherwise `false`.\n   * @todo Decision: Change API to return array of new links instead?\n   */\n  connectInputToOutput(): boolean | undefined {\n    const { inputs, outputs, graph } = this\n    if (!inputs || !outputs) return\n    if (!graph) throw new NullGraphError()\n\n    const { _links } = graph\n    let madeAnyConnections = false\n\n    // First pass: only match exactly index-to-index\n    for (const [index, input] of inputs.entries()) {\n      if (input.link == null) continue\n\n      const output = outputs[index]\n      if (!output || !LiteGraph.isValidConnection(input.type, output.type)) continue\n\n      const inLink = _links.get(input.link)\n      if (!inLink) continue\n      const inNode = graph.getNodeById(inLink?.origin_id)\n      if (!inNode) continue\n\n      bypassAllLinks(output, inNode, inLink, graph)\n    }\n    // Configured to only use index-to-index matching\n    if (!(this.flags.keepAllLinksOnBypass ?? LGraphNode.keepAllLinksOnBypass))\n      return madeAnyConnections\n\n    // Second pass: match any remaining links\n    for (const input of inputs) {\n      if (input.link == null) continue\n\n      const inLink = _links.get(input.link)\n      if (!inLink) continue\n      const inNode = graph.getNodeById(inLink?.origin_id)\n      if (!inNode) continue\n\n      for (const output of outputs) {\n        if (!LiteGraph.isValidConnection(input.type, output.type)) continue\n\n        bypassAllLinks(output, inNode, inLink, graph)\n        break\n      }\n    }\n    return madeAnyConnections\n\n    function bypassAllLinks(output: INodeOutputSlot, inNode: LGraphNode, inLink: LLink, graph: LGraph) {\n      const outLinks = output.links\n        ?.map(x => _links.get(x))\n        .filter(x => !!x)\n      if (!outLinks?.length) return\n\n      for (const outLink of outLinks) {\n        const outNode = graph.getNodeById(outLink.target_id)\n        if (!outNode) continue\n\n        const result = inNode.connect(\n          inLink.origin_slot,\n          outNode,\n          outLink.target_slot,\n          inLink.parentId,\n        )\n        madeAnyConnections ||= !!result\n      }\n    }\n  }\n\n  /**\n   * Returns `true` if the widget is visible, otherwise `false`.\n   */\n  isWidgetVisible(widget: IBaseWidget): boolean {\n    const isHidden = (\n      this.collapsed ||\n      widget.hidden ||\n      (widget.advanced && !this.showAdvanced)\n    )\n    return !isHidden\n  }\n\n  drawWidgets(ctx: CanvasRenderingContext2D, {\n    lowQuality = false,\n    editorAlpha = 1,\n  }: DrawWidgetsOptions): void {\n    if (!this.widgets) return\n\n    const nodeWidth = this.size[0]\n    const { widgets } = this\n    const H = LiteGraph.NODE_WIDGET_HEIGHT\n    const showText = !lowQuality\n    ctx.save()\n    ctx.globalAlpha = editorAlpha\n\n    for (const widget of widgets) {\n      if (!this.isWidgetVisible(widget)) continue\n\n      const { y } = widget\n      const outlineColour = widget.advanced ? LiteGraph.WIDGET_ADVANCED_OUTLINE_COLOR : LiteGraph.WIDGET_OUTLINE_COLOR\n\n      widget.last_y = y\n      // Disable widget if it is disabled or if the value is passed from socket connection.\n      widget.computedDisabled = widget.disabled || this.getSlotFromWidget(widget)?.link != null\n\n      ctx.strokeStyle = outlineColour\n      ctx.fillStyle = \"#222\"\n      ctx.textAlign = \"left\"\n      if (widget.computedDisabled) ctx.globalAlpha *= 0.5\n      const width = widget.width || nodeWidth\n\n      const widgetInstance = toConcreteWidget(widget, this, false)\n      if (widgetInstance) {\n        widgetInstance.drawWidget(ctx, { width, showText })\n      } else {\n        widget.draw?.(ctx, this, width, y, H, lowQuality)\n      }\n      ctx.globalAlpha = editorAlpha\n    }\n    ctx.restore()\n  }\n\n  /**\n   * When {@link LGraphNode.collapsed} is `true`, this method draws the node's collapsed slots.\n   */\n  drawCollapsedSlots(ctx: CanvasRenderingContext2D): void {\n    // Render the first connected slot only.\n    for (const slot of this.#concreteInputs) {\n      if (slot.link != null) {\n        slot.drawCollapsed(ctx)\n        break\n      }\n    }\n    for (const slot of this.#concreteOutputs) {\n      if (slot.links?.length) {\n        slot.drawCollapsed(ctx)\n        break\n      }\n    }\n  }\n\n  get slots(): (INodeInputSlot | INodeOutputSlot)[] {\n    return [...this.inputs, ...this.outputs]\n  }\n\n  #measureSlot(slot: NodeInputSlot | NodeOutputSlot, slotIndex: number, isInput: boolean): void {\n    const pos = isInput ? this.getInputPos(slotIndex) : this.getOutputPos(slotIndex)\n\n    slot.boundingRect[0] = pos[0] - LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    slot.boundingRect[1] = pos[1] - LiteGraph.NODE_SLOT_HEIGHT * 0.5\n    slot.boundingRect[2] = slot.isWidgetInputSlot ? BaseWidget.margin : LiteGraph.NODE_SLOT_HEIGHT\n    slot.boundingRect[3] = LiteGraph.NODE_SLOT_HEIGHT\n  }\n\n  #measureSlots(): ReadOnlyRect | null {\n    const slots: (NodeInputSlot | NodeOutputSlot)[] = []\n\n    for (const [slotIndex, slot] of this.#concreteInputs.entries()) {\n      // Unrecognized nodes (Nodes with error) has inputs but no widgets. Treat\n      // converted inputs as normal inputs.\n      /** Widget input slots are handled in {@link layoutWidgetInputSlots} */\n      if (this.widgets?.length && isWidgetInputSlot(slot)) continue\n\n      this.#measureSlot(slot, slotIndex, true)\n      slots.push(slot)\n    }\n    for (const [slotIndex, slot] of this.#concreteOutputs.entries()) {\n      this.#measureSlot(slot, slotIndex, false)\n      slots.push(slot)\n    }\n\n    return slots.length ? createBounds(slots, 0) : null\n  }\n\n  #getMouseOverSlot(slot: INodeSlot): INodeSlot | null {\n    const isInput = isINodeInputSlot(slot)\n    const mouseOverId = this.mouseOver?.[isInput ? \"inputId\" : \"outputId\"] ?? -1\n    if (mouseOverId === -1) {\n      return null\n    }\n    return isInput ? this.inputs[mouseOverId] : this.outputs[mouseOverId]\n  }\n\n  #isMouseOverSlot(slot: INodeSlot): boolean {\n    return this.#getMouseOverSlot(slot) === slot\n  }\n\n  #isMouseOverWidget(widget: IBaseWidget | undefined): boolean {\n    if (!widget) return false\n    return this.mouseOver?.overWidget === widget\n  }\n\n  /**\n   * Returns the input slot that is associated with the given widget.\n   */\n  getSlotFromWidget(widget: IBaseWidget | undefined): INodeInputSlot | undefined {\n    if (widget) return this.inputs.find(slot => isWidgetInputSlot(slot) && slot.widget.name === widget.name)\n  }\n\n  /**\n   * Returns the widget that is associated with the given input slot.\n   */\n  getWidgetFromSlot(slot: INodeInputSlot): IBaseWidget | undefined {\n    if (!isWidgetInputSlot(slot)) return\n    return this.widgets?.find(w => w.name === slot.widget.name)\n  }\n\n  /**\n   * Draws the node's input and output slots.\n   */\n  drawSlots(ctx: CanvasRenderingContext2D, {\n    fromSlot,\n    colorContext,\n    editorAlpha,\n    lowQuality,\n  }: DrawSlotsOptions) {\n    for (const slot of [...this.#concreteInputs, ...this.#concreteOutputs]) {\n      const isValidTarget = fromSlot && slot.isValidTarget(fromSlot)\n      const isMouseOverSlot = this.#isMouseOverSlot(slot)\n\n      // change opacity of incompatible slots when dragging a connection\n      const isValid = !fromSlot || isValidTarget\n      const highlight = isValid && isMouseOverSlot\n\n      // Show slot if it's not a widget input slot\n      // or if it's a widget input slot and satisfies one of the following:\n      // - the mouse is over the widget\n      // - the slot is valid during link drop\n      // - the slot is connected\n      if (\n        isMouseOverSlot ||\n        isValidTarget ||\n        !slot.isWidgetInputSlot ||\n        this.#isMouseOverWidget(this.getWidgetFromSlot(slot)) ||\n        slot.isConnected\n      ) {\n        ctx.globalAlpha = isValid ? editorAlpha : 0.4 * editorAlpha\n        slot.draw(ctx, {\n          colorContext,\n          lowQuality,\n          highlight,\n        })\n      }\n    }\n  }\n\n  /**\n   * Arranges the node's widgets vertically.\n   * Sets following properties on each widget:\n   * -  {@link IBaseWidget.computedHeight}\n   * -  {@link IBaseWidget.y}\n   * @param widgetStartY The y-coordinate of the first widget\n   */\n  #arrangeWidgets(widgetStartY: number): void {\n    if (!this.widgets || !this.widgets.length) return\n\n    const bodyHeight = this.bodyHeight\n    const startY = this.widgets_start_y ?? (\n      (this.widgets_up ? 0 : widgetStartY) + 2\n    )\n\n    let freeSpace = bodyHeight - startY\n\n    // Collect fixed height widgets first\n    let fixedWidgetHeight = 0\n    const growableWidgets: {\n      minHeight: number\n      prefHeight?: number\n      w: IBaseWidget\n    }[] = []\n\n    for (const w of this.widgets) {\n      if (w.computeSize) {\n        const height = w.computeSize()[1] + 4\n        w.computedHeight = height\n        fixedWidgetHeight += height\n      } else if (w.computeLayoutSize) {\n        const { minHeight, maxHeight } = w.computeLayoutSize(this)\n        growableWidgets.push({\n          minHeight,\n          prefHeight: maxHeight,\n          w,\n        })\n      } else {\n        const height = LiteGraph.NODE_WIDGET_HEIGHT + 4\n        w.computedHeight = height\n        fixedWidgetHeight += height\n      }\n    }\n\n    // Calculate remaining space for DOM widgets\n    freeSpace -= fixedWidgetHeight\n    this.freeWidgetSpace = freeSpace\n\n    // Prepare space requests for distribution\n    const spaceRequests = growableWidgets.map(d => ({\n      minSize: d.minHeight,\n      maxSize: d.prefHeight,\n    }))\n\n    // Distribute space among DOM widgets\n    const allocations = distributeSpace(Math.max(0, freeSpace), spaceRequests)\n\n    // Apply computed heights\n    for (const [i, d] of growableWidgets.entries()) {\n      d.w.computedHeight = allocations[i]\n    }\n\n    // Position widgets\n    let y = startY\n    for (const w of this.widgets) {\n      w.y = y\n      y += w.computedHeight ?? 0\n    }\n\n    if (!this.graph) throw new NullGraphError()\n\n    // Grow the node if necessary.\n    // Ref: https://github.com/Comfy-Org/ComfyUI_frontend/issues/2652\n    // TODO: Move the layout logic before drawing of the node shape, so we don't\n    // need to trigger extra round of rendering.\n    if (y > bodyHeight) {\n      this.setSize([this.size[0], y])\n      this.graph.setDirtyCanvas(false, true)\n    }\n  }\n\n  /**\n   * Arranges the layout of the node's widget input slots.\n   */\n  #arrangeWidgetInputSlots(): void {\n    if (!this.widgets) return\n\n    const slotByWidgetName = new Map<string, INodeInputSlot & { index: number }>()\n\n    for (const [i, slot] of this.inputs.entries()) {\n      if (!isWidgetInputSlot(slot)) continue\n\n      slotByWidgetName.set(slot.widget.name, { ...slot, index: i })\n    }\n    if (!slotByWidgetName.size) return\n\n    for (const widget of this.widgets) {\n      const slot = slotByWidgetName.get(widget.name)\n      if (!slot) continue\n\n      const actualSlot = this.#concreteInputs[slot.index]\n      const offset = LiteGraph.NODE_SLOT_HEIGHT * 0.5\n      actualSlot.pos = [offset, widget.y + offset]\n      this.#measureSlot(actualSlot, slot.index, true)\n    }\n  }\n\n  /**\n   * @internal Sets the internal concrete slot arrays, ensuring they are instances of\n   * {@link NodeInputSlot} or {@link NodeOutputSlot}.\n   *\n   * A temporary workaround until duck-typed inputs and outputs\n   * have been removed from the ecosystem.\n   */\n  _setConcreteSlots(): void {\n    this.#concreteInputs = this.inputs.map(slot => toClass(NodeInputSlot, slot, this))\n    this.#concreteOutputs = this.outputs.map(slot => toClass(NodeOutputSlot, slot, this))\n  }\n\n  /**\n   * Arranges node elements in preparation for rendering (slots & widgets).\n   */\n  arrange(): void {\n    const slotsBounds = this.#measureSlots()\n    const widgetStartY = slotsBounds ? slotsBounds[1] + slotsBounds[3] - this.pos[1] : 0\n    this.#arrangeWidgets(widgetStartY)\n    this.#arrangeWidgetInputSlots()\n  }\n\n  /**\n   * Draws a progress bar on the node.\n   * @param ctx The canvas context to draw on\n   */\n  drawProgressBar(ctx: CanvasRenderingContext2D): void {\n    if (!this.progress) return\n\n    const originalFillStyle = ctx.fillStyle\n    ctx.fillStyle = \"green\"\n    ctx.fillRect(\n      0,\n      0,\n      this.width * this.progress,\n      6,\n    )\n    ctx.fillStyle = originalFillStyle\n  }\n}\n","import type {\n  ColorOption,\n  IColorable,\n  IContextMenuValue,\n  IPinnable,\n  Point,\n  Positionable,\n  Size,\n} from \"./interfaces\"\nimport type { LGraph } from \"./LGraph\"\nimport type { ISerialisedGroup } from \"./types/serialisation\"\n\nimport { NullGraphError } from \"@/infrastructure/NullGraphError\"\n\nimport { strokeShape } from \"./draw\"\nimport { LGraphCanvas } from \"./LGraphCanvas\"\nimport { LGraphNode } from \"./LGraphNode\"\nimport { LiteGraph } from \"./litegraph\"\nimport {\n  containsCentre,\n  containsRect,\n  createBounds,\n  isInRectangle,\n  isPointInRect,\n  snapPoint,\n} from \"./measure\"\n\nexport interface IGraphGroupFlags extends Record<string, unknown> {\n  pinned?: true\n}\n\nexport class LGraphGroup implements Positionable, IPinnable, IColorable {\n  static minWidth = 140\n  static minHeight = 80\n  static resizeLength = 10\n  static padding = 4\n  static defaultColour = \"#335\"\n\n  id: number\n  color?: string\n  title: string\n  font?: string\n  font_size: number = LiteGraph.DEFAULT_GROUP_FONT || 24\n  _bounding: Float32Array = new Float32Array([\n    10,\n    10,\n    LGraphGroup.minWidth,\n    LGraphGroup.minHeight,\n  ])\n\n  _pos: Point = this._bounding.subarray(0, 2)\n  _size: Size = this._bounding.subarray(2, 4)\n  /** @deprecated See {@link _children} */\n  _nodes: LGraphNode[] = []\n  _children: Set<Positionable> = new Set()\n  graph?: LGraph\n  flags: IGraphGroupFlags = {}\n  selected?: boolean\n\n  constructor(title?: string, id?: number) {\n    // TODO: Object instantiation pattern requires too much boilerplate and null checking.  ID should be passed in via constructor.\n    this.id = id ?? -1\n    this.title = title || \"Group\"\n\n    const { pale_blue } = LGraphCanvas.node_colors\n    this.color = pale_blue ? pale_blue.groupcolor : \"#AAA\"\n  }\n\n  /** @inheritdoc {@link IColorable.setColorOption} */\n  setColorOption(colorOption: ColorOption | null): void {\n    if (colorOption == null) {\n      delete this.color\n    } else {\n      this.color = colorOption.groupcolor\n    }\n  }\n\n  /** @inheritdoc {@link IColorable.getColorOption} */\n  getColorOption(): ColorOption | null {\n    return Object.values(LGraphCanvas.node_colors).find(\n      colorOption => colorOption.groupcolor === this.color,\n    ) ?? null\n  }\n\n  /** Position of the group, as x,y co-ordinates in graph space */\n  get pos() {\n    return this._pos\n  }\n\n  set pos(v) {\n    if (!v || v.length < 2) return\n\n    this._pos[0] = v[0]\n    this._pos[1] = v[1]\n  }\n\n  /** Size of the group, as width,height in graph units */\n  get size() {\n    return this._size\n  }\n\n  set size(v) {\n    if (!v || v.length < 2) return\n\n    this._size[0] = Math.max(LGraphGroup.minWidth, v[0])\n    this._size[1] = Math.max(LGraphGroup.minHeight, v[1])\n  }\n\n  get boundingRect() {\n    return this._bounding\n  }\n\n  get nodes() {\n    return this._nodes\n  }\n\n  get titleHeight() {\n    return this.font_size * 1.4\n  }\n\n  get children(): ReadonlySet<Positionable> {\n    return this._children\n  }\n\n  get pinned() {\n    return !!this.flags.pinned\n  }\n\n  /**\n   * Prevents the group being accidentally moved or resized by mouse interaction.\n   * Toggles pinned state if no value is provided.\n   */\n  pin(value?: boolean): void {\n    const newState = value === undefined ? !this.pinned : value\n\n    if (newState) this.flags.pinned = true\n    else delete this.flags.pinned\n  }\n\n  unpin(): void {\n    this.pin(false)\n  }\n\n  configure(o: ISerialisedGroup): void {\n    this.id = o.id\n    this.title = o.title\n    this._bounding.set(o.bounding)\n    this.color = o.color\n    this.flags = o.flags || this.flags\n    if (o.font_size) this.font_size = o.font_size\n  }\n\n  serialize(): ISerialisedGroup {\n    const b = this._bounding\n    return {\n      id: this.id,\n      title: this.title,\n      bounding: [...b],\n      color: this.color,\n      font_size: this.font_size,\n      flags: this.flags,\n    }\n  }\n\n  /**\n   * Draws the group on the canvas\n   * @param graphCanvas\n   * @param ctx\n   */\n  draw(graphCanvas: LGraphCanvas, ctx: CanvasRenderingContext2D): void {\n    const { padding, resizeLength, defaultColour } = LGraphGroup\n    const font_size = this.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE\n\n    const [x, y] = this._pos\n    const [width, height] = this._size\n    const color = this.color || defaultColour\n\n    // Titlebar\n    ctx.globalAlpha = 0.25 * graphCanvas.editor_alpha\n    ctx.fillStyle = color\n    ctx.strokeStyle = color\n    ctx.beginPath()\n    ctx.rect(x + 0.5, y + 0.5, width, font_size * 1.4)\n    ctx.fill()\n\n    // Group background, border\n    ctx.fillStyle = color\n    ctx.strokeStyle = color\n    ctx.beginPath()\n    ctx.rect(x + 0.5, y + 0.5, width, height)\n    ctx.fill()\n    ctx.globalAlpha = graphCanvas.editor_alpha\n    ctx.stroke()\n\n    // Resize marker\n    ctx.beginPath()\n    ctx.moveTo(x + width, y + height)\n    ctx.lineTo(x + width - resizeLength, y + height)\n    ctx.lineTo(x + width, y + height - resizeLength)\n    ctx.fill()\n\n    // Title\n    ctx.font = `${font_size}px ${LiteGraph.GROUP_FONT}`\n    ctx.textAlign = \"left\"\n    ctx.fillText(this.title + (this.pinned ? \"ð\" : \"\"), x + padding, y + font_size)\n\n    if (LiteGraph.highlight_selected_group && this.selected) {\n      strokeShape(ctx, this._bounding, {\n        title_height: this.titleHeight,\n        padding,\n      })\n    }\n  }\n\n  resize(width: number, height: number): boolean {\n    if (this.pinned) return false\n\n    this._size[0] = Math.max(LGraphGroup.minWidth, width)\n    this._size[1] = Math.max(LGraphGroup.minHeight, height)\n    return true\n  }\n\n  move(deltaX: number, deltaY: number, skipChildren: boolean = false): void {\n    if (this.pinned) return\n\n    this._pos[0] += deltaX\n    this._pos[1] += deltaY\n    if (skipChildren === true) return\n\n    for (const item of this._children) {\n      item.move(deltaX, deltaY)\n    }\n  }\n\n  /** @inheritdoc */\n  snapToGrid(snapTo: number): boolean {\n    return this.pinned ? false : snapPoint(this.pos, snapTo)\n  }\n\n  recomputeInsideNodes(): void {\n    if (!this.graph) throw new NullGraphError()\n    const { nodes, reroutes, groups } = this.graph\n    const children = this._children\n    this._nodes.length = 0\n    children.clear()\n\n    // Move nodes we overlap the centre point of\n    for (const node of nodes) {\n      if (containsCentre(this._bounding, node.boundingRect)) {\n        this._nodes.push(node)\n        children.add(node)\n      }\n    }\n\n    // Move reroutes we overlap the centre point of\n    for (const reroute of reroutes.values()) {\n      if (isPointInRect(reroute.pos, this._bounding))\n        children.add(reroute)\n    }\n\n    // Move groups we wholly contain\n    for (const group of groups) {\n      if (containsRect(this._bounding, group._bounding))\n        children.add(group)\n    }\n\n    groups.sort((a, b) => {\n      if (a === this) {\n        return children.has(b) ? -1 : 0\n      } else if (b === this) {\n        return children.has(a) ? 1 : 0\n      } else {\n        return 0\n      }\n    })\n  }\n\n  /**\n   * Resizes and moves the group to neatly fit all given {@link objects}.\n   * @param objects All objects that should be inside the group\n   * @param padding Value in graph units to add to all sides of the group.  Default: 10\n   */\n  resizeTo(objects: Iterable<Positionable>, padding: number = 10): void {\n    const boundingBox = createBounds(objects, padding)\n    if (boundingBox === null) return\n\n    this.pos[0] = boundingBox[0]\n    this.pos[1] = boundingBox[1] - this.titleHeight\n    this.size[0] = boundingBox[2]\n    this.size[1] = boundingBox[3] + this.titleHeight\n  }\n\n  /**\n   * Add nodes to the group and adjust the group's position and size accordingly\n   * @param nodes The nodes to add to the group\n   * @param padding The padding around the group\n   */\n  addNodes(nodes: LGraphNode[], padding: number = 10): void {\n    if (!this._nodes && nodes.length === 0) return\n    this.resizeTo([...this.children, ...this._nodes, ...nodes], padding)\n  }\n\n  getMenuOptions(): (IContextMenuValue<string> | IContextMenuValue<string | null> | null)[] {\n    return [\n      {\n        content: this.pinned ? \"Unpin\" : \"Pin\",\n        callback: () => {\n          if (this.pinned) this.unpin()\n          else this.pin()\n          this.setDirtyCanvas(false, true)\n        },\n      },\n      null,\n      { content: \"Title\", callback: LGraphCanvas.onShowPropertyEditor },\n      {\n        content: \"Color\",\n        has_submenu: true,\n        callback: LGraphCanvas.onMenuNodeColors,\n      },\n      {\n        content: \"Font size\",\n        property: \"font_size\",\n        type: \"Number\",\n        callback: LGraphCanvas.onShowPropertyEditor,\n      },\n      null,\n      { content: \"Remove\", callback: LGraphCanvas.onMenuNodeRemove },\n    ]\n  }\n\n  isPointInTitlebar(x: number, y: number): boolean {\n    const b = this.boundingRect\n    return isInRectangle(x, y, b[0], b[1], b[2], this.titleHeight)\n  }\n\n  isInResize(x: number, y: number): boolean {\n    const b = this.boundingRect\n    const right = b[0] + b[2]\n    const bottom = b[1] + b[3]\n\n    return (\n      x < right &&\n      y < bottom &&\n      x - right + (y - bottom) > -LGraphGroup.resizeLength\n    )\n  }\n\n  isPointInside = LGraphNode.prototype.isPointInside\n  setDirtyCanvas = LGraphNode.prototype.setDirtyCanvas\n}\n","import type {\n  CanvasColour,\n  INodeInputSlot,\n  INodeOutputSlot,\n  LinkNetwork,\n  LinkSegment,\n  Point,\n  Positionable,\n  ReadonlyLinkNetwork,\n  ReadOnlyRect,\n} from \"./interfaces\"\nimport type { LGraphNode, NodeId } from \"./LGraphNode\"\nimport type { Serialisable, SerialisableReroute } from \"./types/serialisation\"\n\nimport { LGraphBadge } from \"./LGraphBadge\"\nimport { type LinkId, LLink } from \"./LLink\"\nimport { distance, isPointInRect } from \"./measure\"\n\nexport type RerouteId = number\n\n/** The input or output slot that an incomplete reroute link is connected to. */\nexport interface FloatingRerouteSlot {\n  /** Floating connection to an input or output */\n  slotType: \"input\" | \"output\"\n}\n\n/**\n * Represents an additional point on the graph that a link path will travel through.  Used for visual organisation only.\n *\n * Requires no disposal or clean up.\n * Stores only primitive values (IDs) to reference other items in its network,\n * and a `WeakRef` to a {@link LinkNetwork} to resolve them.\n */\nexport class Reroute implements Positionable, LinkSegment, Serialisable<SerialisableReroute> {\n  static radius: number = 10\n  /** Maximum distance from reroutes to their bezier curve control points. */\n  static maxSplineOffset: number = 80\n  static drawIdBadge: boolean = false\n  static slotRadius: number = 5\n  /** Distance from reroute centre to slot centre. */\n  static get slotOffset(): number {\n    const gap = Reroute.slotRadius * 0.33\n    return Reroute.radius + gap + Reroute.slotRadius\n  }\n\n  #malloc = new Float32Array(8)\n\n  /** The network this reroute belongs to.  Contains all valid links and reroutes. */\n  #network: WeakRef<LinkNetwork>\n\n  #parentId?: RerouteId\n  public get parentId(): RerouteId | undefined {\n    return this.#parentId\n  }\n\n  /** Ignores attempts to create an infinite loop. @inheritdoc */\n  public set parentId(value) {\n    if (value === this.id) return\n    if (this.getReroutes() === null) return\n    this.#parentId = value\n  }\n\n  public get parent(): Reroute | undefined {\n    return this.#network.deref()?.getReroute(this.#parentId)\n  }\n\n  /** This property is only defined on the last reroute of a floating reroute chain (closest to input end). */\n  floating?: FloatingRerouteSlot\n\n  #pos = this.#malloc.subarray(0, 2)\n  /** @inheritdoc */\n  get pos(): Point {\n    return this.#pos\n  }\n\n  set pos(value: Point) {\n    if (!(value?.length >= 2))\n      throw new TypeError(\"Reroute.pos is an x,y point, and expects an indexable with at least two values.\")\n    this.#pos[0] = value[0]\n    this.#pos[1] = value[1]\n  }\n\n  /** @inheritdoc */\n  get boundingRect(): ReadOnlyRect {\n    const { radius } = Reroute\n    const [x, y] = this.#pos\n    return [x - radius, y - radius, 2 * radius, 2 * radius]\n  }\n\n  /**\n   * Slightly over-sized rectangle, guaranteed to contain the entire surface area for hover detection.\n   * Eliminates most hover positions using an extremely cheap check.\n   */\n  get #hoverArea(): ReadOnlyRect {\n    const xOffset = 2 * Reroute.slotOffset\n    const yOffset = 2 * Math.max(Reroute.radius, Reroute.slotRadius)\n\n    const [x, y] = this.#pos\n    return [x - xOffset, y - yOffset, 2 * xOffset, 2 * yOffset]\n  }\n\n  /** The total number of links & floating links using this reroute */\n  get totalLinks(): number {\n    return this.linkIds.size + this.floatingLinkIds.size\n  }\n\n  /** @inheritdoc */\n  selected?: boolean\n\n  /** The ID ({@link LLink.id}) of every link using this reroute */\n  linkIds: Set<LinkId>\n\n  /** The ID ({@link LLink.id}) of every floating link using this reroute */\n  floatingLinkIds: Set<LinkId>\n\n  /** Cached cos */\n  cos: number = 0\n  sin: number = 0\n\n  /** Bezier curve control point for the \"target\" (input) side of the link */\n  controlPoint: Point = this.#malloc.subarray(4, 6)\n\n  /** @inheritdoc */\n  path?: Path2D\n  /** @inheritdoc */\n  _centreAngle?: number\n  /** @inheritdoc */\n  _pos: Float32Array = this.#malloc.subarray(6, 8)\n\n  /** @inheritdoc */\n  _dragging?: boolean\n\n  /** Colour of the first link that rendered this reroute */\n  _colour?: CanvasColour\n\n  /** Colour of the first link that rendered this reroute */\n  get colour(): CanvasColour {\n    return this._colour ?? \"#18184d\"\n  }\n\n  /**\n   * Used to ensure reroute angles are only executed once per frame.\n   * @todo Calculate on change instead.\n   */\n  #lastRenderTime: number = -Infinity\n\n  #inputSlot = new RerouteSlot(this, true)\n  #outputSlot = new RerouteSlot(this, false)\n\n  get isSlotHovered(): boolean {\n    return this.isInputHovered || this.isOutputHovered\n  }\n\n  get isInputHovered(): boolean {\n    return this.#inputSlot.hovering\n  }\n\n  get isOutputHovered(): boolean {\n    return this.#outputSlot.hovering\n  }\n\n  get firstLink(): LLink | undefined {\n    const linkId = this.linkIds.values().next().value\n    return linkId === undefined\n      ? undefined\n      : this.#network\n        .deref()\n        ?.links\n        .get(linkId)\n  }\n\n  get firstFloatingLink(): LLink | undefined {\n    const linkId = this.floatingLinkIds.values().next().value\n    return linkId === undefined\n      ? undefined\n      : this.#network\n        .deref()\n        ?.floatingLinks\n        .get(linkId)\n  }\n\n  /** @inheritdoc */\n  get origin_id(): NodeId | undefined {\n    return this.firstLink?.origin_id\n  }\n\n  /** @inheritdoc */\n  get origin_slot(): number | undefined {\n    return this.firstLink?.origin_slot\n  }\n\n  /**\n   * Initialises a new link reroute object.\n   * @param id Unique identifier for this reroute\n   * @param network The network of links this reroute belongs to.  Internally converted to a WeakRef.\n   * @param pos Position in graph coordinates\n   * @param linkIds Link IDs ({@link LLink.id}) of all links that use this reroute\n   */\n  constructor(\n    public readonly id: RerouteId,\n    network: LinkNetwork,\n    pos?: Point,\n    parentId?: RerouteId,\n    linkIds?: Iterable<LinkId>,\n    floatingLinkIds?: Iterable<LinkId>,\n  ) {\n    this.#network = new WeakRef(network)\n    this.parentId = parentId\n    if (pos) this.pos = pos\n    this.linkIds = new Set(linkIds)\n    this.floatingLinkIds = new Set(floatingLinkIds)\n  }\n\n  /**\n   * Applies a new parentId to the reroute, and optinoally a new position and linkId.\n   * Primarily used for deserialisation.\n   * @param parentId The ID of the reroute prior to this reroute, or\n   * `undefined` if it is the first reroute connected to a nodes output\n   * @param pos The position of this reroute\n   * @param linkIds All link IDs that pass through this reroute\n   */\n  update(\n    parentId: RerouteId | undefined,\n    pos?: Point,\n    linkIds?: Iterable<LinkId>,\n    floating?: FloatingRerouteSlot,\n  ): void {\n    this.parentId = parentId\n    if (pos) this.pos = pos\n    if (linkIds) this.linkIds = new Set(linkIds)\n    this.floating = floating\n  }\n\n  /**\n   * Validates the linkIds this reroute has.  Removes broken links.\n   * @param links Collection of valid links\n   * @returns true if any links remain after validation\n   */\n  validateLinks(links: ReadonlyMap<LinkId, LLink>, floatingLinks: ReadonlyMap<LinkId, LLink>): boolean {\n    const { linkIds, floatingLinkIds } = this\n    for (const linkId of linkIds) {\n      if (!links.has(linkId)) linkIds.delete(linkId)\n    }\n    for (const linkId of floatingLinkIds) {\n      if (!floatingLinks.has(linkId)) floatingLinkIds.delete(linkId)\n    }\n    return linkIds.size > 0 || floatingLinkIds.size > 0\n  }\n\n  /**\n   * Retrieves an ordered array of all reroutes from the node output.\n   * @param visited Internal.  A set of reroutes that this function\n   * has already visited whilst recursing up the chain.\n   * @returns An ordered array of all reroutes from the node output to this reroute, inclusive.\n   * `null` if an infinite loop is detected.\n   * `undefined` if the reroute chain or {@link LinkNetwork} are invalid.\n   */\n  getReroutes(visited = new Set<Reroute>()): Reroute[] | null {\n    // No parentId - last in the chain\n    if (this.#parentId === undefined) return [this]\n    // Invalid chain - looped\n    if (visited.has(this)) return null\n    visited.add(this)\n\n    const parent = this.#network.deref()?.reroutes.get(this.#parentId)\n    // Invalid parent (or network) - drop silently to recover\n    if (!parent) {\n      this.#parentId = undefined\n      return [this]\n    }\n\n    const reroutes = parent.getReroutes(visited)\n    reroutes?.push(this)\n    return reroutes\n  }\n\n  /**\n   * Internal.  Called by {@link LLink.findNextReroute}.  Not intended for use by itself.\n   * @param withParentId The rerouteId to look for\n   * @param visited A set of reroutes that have already been visited\n   * @returns The reroute that was found, `undefined` if no reroute was found, or `null` if an infinite loop was detected.\n   */\n  findNextReroute(\n    withParentId: RerouteId,\n    visited = new Set<Reroute>(),\n  ): Reroute | null | undefined {\n    if (this.#parentId === withParentId) return this\n    if (visited.has(this)) return null\n    visited.add(this)\n    if (this.#parentId === undefined) return\n\n    return this.#network\n      .deref()\n      ?.reroutes\n      .get(this.#parentId)\n      ?.findNextReroute(withParentId, visited)\n  }\n\n  /**\n   * Finds the output node and output slot of the first link passing through this reroute.\n   * @returns The output node and output slot of the first link passing through this reroute, or `undefined` if no link is found.\n   */\n  findSourceOutput(): { node: LGraphNode, output: INodeOutputSlot } | undefined {\n    const link = this.firstLink ?? this.firstFloatingLink\n    if (!link) return\n\n    const node = this.#network.deref()?.getNodeById(link.origin_id)\n    if (!node) return\n\n    return {\n      node,\n      output: node.outputs[link.origin_slot],\n    }\n  }\n\n  /**\n   * Finds the inputs and nodes of (floating) links passing through this reroute.\n   * @returns An array of objects containing the node and input slot of each link passing through this reroute.\n   */\n  findTargetInputs(): { node: LGraphNode, input: INodeInputSlot, link: LLink }[] | undefined {\n    const network = this.#network.deref()\n    if (!network) return\n\n    const results: {\n      node: LGraphNode\n      input: INodeInputSlot\n      link: LLink\n    }[] = []\n\n    addAllResults(network, this.linkIds, network.links)\n    addAllResults(network, this.floatingLinkIds, network.floatingLinks)\n\n    return results\n\n    function addAllResults(\n      network: ReadonlyLinkNetwork,\n      linkIds: Iterable<LinkId>,\n      links: ReadonlyMap<LinkId, LLink>,\n    ) {\n      for (const linkId of linkIds) {\n        const link = links.get(linkId)\n        if (!link) continue\n\n        const node = network.getNodeById(link.target_id)\n        const input = node?.inputs[link.target_slot]\n        if (!input) continue\n\n        results.push({ node, input, link })\n      }\n    }\n  }\n\n  /**\n   * Retrieves all floating links passing through this reroute.\n   * @param from Filters the links by the currently connected link side.\n   * @returns An array of floating links\n   */\n  getFloatingLinks(from: \"input\" | \"output\"): LLink[] | undefined {\n    const floatingLinks = this.#network.deref()?.floatingLinks\n    if (!floatingLinks) return\n\n    const idProp = from === \"input\" ? \"origin_id\" : \"target_id\"\n    const out: LLink[] = []\n\n    for (const linkId of this.floatingLinkIds) {\n      const link = floatingLinks.get(linkId)\n      if (link?.[idProp] === -1) out.push(link)\n    }\n    return out\n  }\n\n  /**\n   * Changes the origin node/output of all floating links that pass through this reroute.\n   * @param node The new origin node\n   * @param output The new origin output slot\n   * @param index The slot index of {@link output}\n   */\n  setFloatingLinkOrigin(node: LGraphNode, output: INodeOutputSlot, index: number) {\n    const network = this.#network.deref()\n    const floatingOutLinks = this.getFloatingLinks(\"output\")\n    if (!floatingOutLinks) throw new Error(\"[setFloatingLinkOrigin]: Invalid network.\")\n    if (!floatingOutLinks.length) return\n\n    output._floatingLinks ??= new Set()\n\n    for (const link of floatingOutLinks) {\n      // Update cached floating links\n      output._floatingLinks.add(link)\n\n      network?.getNodeById(link.origin_id)\n        ?.outputs[link.origin_slot]\n        ?._floatingLinks\n        ?.delete(link)\n\n      // Update the floating link\n      link.origin_id = node.id\n      link.origin_slot = index\n    }\n  }\n\n  /** @inheritdoc */\n  move(deltaX: number, deltaY: number) {\n    this.#pos[0] += deltaX\n    this.#pos[1] += deltaY\n  }\n\n  /** @inheritdoc */\n  snapToGrid(snapTo: number): boolean {\n    if (!snapTo) return false\n\n    const { pos } = this\n    pos[0] = snapTo * Math.round(pos[0] / snapTo)\n    pos[1] = snapTo * Math.round(pos[1] / snapTo)\n    return true\n  }\n\n  removeAllFloatingLinks() {\n    for (const linkId of this.floatingLinkIds) {\n      this.removeFloatingLink(linkId)\n    }\n  }\n\n  removeFloatingLink(linkId: LinkId) {\n    const network = this.#network.deref()\n    if (!network) return\n\n    const floatingLink = network.floatingLinks.get(linkId)\n    if (!floatingLink) {\n      console.warn(`[Reroute.removeFloatingLink] Floating link not found: ${linkId}, ignoring and discarding ID.`)\n      this.floatingLinkIds.delete(linkId)\n      return\n    }\n\n    network.removeFloatingLink(floatingLink)\n  }\n\n  /**\n   * Removes a link or floating link from this reroute, by matching link object instance equality.\n   * @param link The link to remove.\n   * @remarks Does not remove the link from the network.\n   */\n  removeLink(link: LLink) {\n    const network = this.#network.deref()\n    if (!network) return\n\n    const floatingLink = network.floatingLinks.get(link.id)\n    if (link === floatingLink) {\n      this.floatingLinkIds.delete(link.id)\n    } else {\n      this.linkIds.delete(link.id)\n    }\n  }\n\n  remove() {\n    const network = this.#network.deref()\n    if (!network) return\n\n    network.removeReroute(this.id)\n  }\n\n  calculateAngle(lastRenderTime: number, network: ReadonlyLinkNetwork, linkStart: Point): void {\n    // Ensure we run once per render\n    if (!(lastRenderTime > this.#lastRenderTime)) return\n    this.#lastRenderTime = lastRenderTime\n\n    const { id, pos: thisPos } = this\n\n    // Add all link angles\n    const angles: number[] = []\n    let sum = 0\n    calculateAngles(this.linkIds, network.links)\n    calculateAngles(this.floatingLinkIds, network.floatingLinks)\n\n    // Invalid - reset\n    if (!angles.length) {\n      this.cos = 0\n      this.sin = 0\n      this.controlPoint[0] = 0\n      this.controlPoint[1] = 0\n      return\n    }\n\n    sum /= angles.length\n\n    const originToReroute = Math.atan2(\n      this.#pos[1] - linkStart[1],\n      this.#pos[0] - linkStart[0],\n    )\n    let diff = (originToReroute - sum) * 0.5\n    if (Math.abs(diff) > Math.PI * 0.5) diff += Math.PI\n    const dist = Math.min(Reroute.maxSplineOffset, distance(linkStart, this.#pos) * 0.25)\n\n    // Store results\n    const originDiff = originToReroute - diff\n    const cos = Math.cos(originDiff)\n    const sin = Math.sin(originDiff)\n\n    this.cos = cos\n    this.sin = sin\n    this.controlPoint[0] = dist * -cos\n    this.controlPoint[1] = dist * -sin\n\n    /**\n     * Calculates the direction of each link and adds it to the array.\n     * @param linkIds The IDs of the links to calculate\n     * @param links The link container from the link network.\n     */\n    function calculateAngles(linkIds: Iterable<LinkId>, links: ReadonlyMap<LinkId, LLink>) {\n      for (const linkId of linkIds) {\n        const link = links.get(linkId)\n        const pos = getNextPos(network, link, id)\n        if (!pos) continue\n\n        const angle = getDirection(thisPos, pos)\n        angles.push(angle)\n        sum += angle\n      }\n    }\n  }\n\n  /**\n   * Renders the reroute on the canvas.\n   * @param ctx Canvas context to draw on\n   * @param backgroundPattern The canvas background pattern; used to make floating reroutes appear washed out.\n   * @remarks Leaves {@link ctx}.fillStyle, strokeStyle, and lineWidth dirty (perf.).\n   */\n  draw(ctx: CanvasRenderingContext2D, backgroundPattern?: CanvasPattern): void {\n    const { globalAlpha } = ctx\n    const { pos } = this\n\n    ctx.beginPath()\n    ctx.arc(pos[0], pos[1], Reroute.radius, 0, 2 * Math.PI)\n\n    if (this.linkIds.size === 0) {\n      ctx.fillStyle = backgroundPattern ?? \"#797979\"\n      ctx.fill()\n      ctx.globalAlpha = globalAlpha * 0.33\n    }\n\n    ctx.fillStyle = this.colour\n    ctx.lineWidth = Reroute.radius * 0.1\n    ctx.strokeStyle = \"rgb(0,0,0,0.5)\"\n    ctx.fill()\n    ctx.stroke()\n\n    ctx.fillStyle = \"#ffffff55\"\n    ctx.strokeStyle = \"rgb(0,0,0,0.3)\"\n    ctx.beginPath()\n    ctx.arc(pos[0], pos[1], Reroute.radius * 0.8, 0, 2 * Math.PI)\n    ctx.fill()\n    ctx.stroke()\n\n    if (this.selected) {\n      ctx.strokeStyle = \"#fff\"\n      ctx.beginPath()\n      ctx.arc(pos[0], pos[1], Reroute.radius * 1.2, 0, 2 * Math.PI)\n      ctx.stroke()\n    }\n\n    if (Reroute.drawIdBadge) {\n      const idBadge = new LGraphBadge({ text: this.id.toString() })\n      const x = pos[0] - idBadge.getWidth(ctx) * 0.5\n      const y = pos[1] - idBadge.height - Reroute.radius - 2\n      idBadge.draw(ctx, x, y)\n    }\n\n    ctx.globalAlpha = globalAlpha\n  }\n\n  /**\n   * Draws the input and output slots on the canvas, if the slots are visible.\n   * @param ctx The canvas context to draw on.\n   */\n  drawSlots(ctx: CanvasRenderingContext2D): void {\n    this.#inputSlot.draw(ctx)\n    this.#outputSlot.draw(ctx)\n  }\n\n  drawHighlight(ctx: CanvasRenderingContext2D, colour: CanvasColour): void {\n    const { pos } = this\n\n    const { strokeStyle, lineWidth } = ctx\n    ctx.strokeStyle = colour\n    ctx.lineWidth = 1\n\n    ctx.beginPath()\n    ctx.arc(pos[0], pos[1], Reroute.radius * 1.5, 0, 2 * Math.PI)\n    ctx.stroke()\n\n    ctx.strokeStyle = strokeStyle\n    ctx.lineWidth = lineWidth\n  }\n\n  /**\n   * Updates visibility of the input and output slots, based on the position of the pointer.\n   * @param pos The position of the pointer.\n   * @returns `true` if any changes require a redraw.\n   */\n  updateVisibility(pos: Point): boolean {\n    const input = this.#inputSlot\n    const output = this.#outputSlot\n    input.dirty = false\n    output.dirty = false\n\n    const { firstFloatingLink } = this\n    const hasLink = !!this.firstLink\n\n    const showInput = hasLink || firstFloatingLink?.isFloatingOutput\n    const showOutput = hasLink || firstFloatingLink?.isFloatingInput\n    const showEither = showInput || showOutput\n\n    // Check if even in the vicinity\n    if (showEither && isPointInRect(pos, this.#hoverArea)) {\n      const outlineOnly = this.#contains(pos)\n\n      if (showInput) input.update(pos, outlineOnly)\n      if (showOutput) output.update(pos, outlineOnly)\n    } else {\n      this.hideSlots()\n    }\n\n    return input.dirty || output.dirty\n  }\n\n  /** Prevents rendering of the input and output slots. */\n  hideSlots() {\n    this.#inputSlot.hide()\n    this.#outputSlot.hide()\n  }\n\n  /**\n   * Precisely determines if {@link pos} is inside this reroute.\n   * @param pos The position to check (canvas space)\n   * @returns `true` if {@link pos} is within the reroute's radius.\n   */\n  containsPoint(pos: Point): boolean {\n    return isPointInRect(pos, this.#hoverArea) && this.#contains(pos)\n  }\n\n  #contains(pos: Point): boolean {\n    return distance(this.pos, pos) <= Reroute.radius\n  }\n\n  /** @inheritdoc */\n  asSerialisable(): SerialisableReroute {\n    const { id, parentId, pos, linkIds } = this\n    return {\n      id,\n      parentId,\n      pos: [pos[0], pos[1]],\n      linkIds: [...linkIds],\n      floating: this.floating ? { slotType: this.floating.slotType } : undefined,\n    }\n  }\n}\n\n/**\n * Represents a slot on a reroute.\n * @private Designed for internal use within this module.\n */\nclass RerouteSlot {\n  /** The reroute that the slot belongs to. */\n  readonly #reroute: Reroute\n\n  readonly #offsetMultiplier: 1 | -1\n  /** Centre point of this slot. */\n  get pos(): Point {\n    const [x, y] = this.#reroute.pos\n    return [x + Reroute.slotOffset * this.#offsetMultiplier, y]\n  }\n\n  /** Whether any changes require a redraw. */\n  dirty: boolean = false\n\n  #hovering = false\n  /** Whether the pointer is hovering over the slot itself. */\n  get hovering() {\n    return this.#hovering\n  }\n\n  set hovering(value) {\n    if (!Object.is(this.#hovering, value)) {\n      this.#hovering = value\n      this.dirty = true\n    }\n  }\n\n  #showOutline = false\n  /** Whether the slot outline / faint background is visible. */\n  get showOutline() {\n    return this.#showOutline\n  }\n\n  set showOutline(value) {\n    if (!Object.is(this.#showOutline, value)) {\n      this.#showOutline = value\n      this.dirty = true\n    }\n  }\n\n  constructor(reroute: Reroute, isInput: boolean) {\n    this.#reroute = reroute\n    this.#offsetMultiplier = isInput ? -1 : 1\n  }\n\n  /**\n   * Updates the slot's visibility based on the position of the pointer.\n   * @param pos The position of the pointer.\n   * @param outlineOnly If `true`, slot will display with the faded outline only ({@link showOutline}).\n   */\n  update(pos: Point, outlineOnly?: boolean) {\n    if (outlineOnly) {\n      this.hovering = false\n      this.showOutline = true\n    } else {\n      const dist = distance(this.pos, pos)\n      this.hovering = dist <= 2 * Reroute.slotRadius\n      this.showOutline = dist <= 5 * Reroute.slotRadius\n    }\n  }\n\n  /** Hides the slot. */\n  hide() {\n    this.hovering = false\n    this.showOutline = false\n  }\n\n  /**\n   * Draws the slot on the canvas.\n   * @param ctx The canvas context to draw on.\n   */\n  draw(ctx: CanvasRenderingContext2D): void {\n    const { fillStyle, strokeStyle, lineWidth } = ctx\n    const { showOutline, hovering, pos: [x, y] } = this\n    if (!showOutline) return\n\n    try {\n      ctx.fillStyle = hovering\n        ? this.#reroute.colour\n        : \"rgba(127,127,127,0.3)\"\n      ctx.strokeStyle = \"rgb(0,0,0,0.5)\"\n      ctx.lineWidth = 1\n\n      ctx.beginPath()\n      ctx.arc(x, y, Reroute.slotRadius, 0, 2 * Math.PI)\n      ctx.fill()\n      ctx.stroke()\n    } finally {\n      ctx.fillStyle = fillStyle\n      ctx.strokeStyle = strokeStyle\n      ctx.lineWidth = lineWidth\n    }\n  }\n}\n\n/**\n * Retrieves the position of the next reroute in the chain, or the destination input slot on this link.\n * @param network The network of links\n * @param link The link representing the current reroute chain\n * @param id The ID of \"this\" reroute\n * @returns The position of the next reroute or the input slot target, otherwise `undefined`.\n */\nfunction getNextPos(network: ReadonlyLinkNetwork, link: LLink | undefined, id: RerouteId) {\n  if (!link) return\n\n  const linkPos = LLink.findNextReroute(network, link, id)?.pos\n  if (linkPos) return linkPos\n\n  // Floating link with no input to find\n  if (link.target_id === -1 || link.target_slot === -1) return\n\n  return network.getNodeById(link.target_id)?.getInputPos(link.target_slot)\n}\n\n/** Returns the direction from one point to another in radians. */\nfunction getDirection(fromPos: Point, toPos: Point) {\n  return Math.atan2(toPos[1] - fromPos[1], toPos[0] - fromPos[0])\n}\n","import type { Direction, IBoundaryNodes } from \"../interfaces\"\nimport type { LGraphNode } from \"../LGraphNode\"\n\n/**\n * Finds the nodes that are farthest in all four directions, representing the boundary of the nodes.\n * @param nodes The nodes to check the edges of\n * @returns An object listing the furthest node (edge) in all four directions.\n * `null` if no nodes were supplied or the first node was falsy.\n */\nexport function getBoundaryNodes(nodes: LGraphNode[]): IBoundaryNodes | null {\n  const valid = nodes?.find(x => x)\n  if (!valid) return null\n\n  let top = valid\n  let right = valid\n  let bottom = valid\n  let left = valid\n\n  for (const node of nodes) {\n    if (!node) continue\n    const [x, y] = node.pos\n    const [width, height] = node.size\n\n    if (y < top.pos[1]) top = node\n    if (x + width > right.pos[0] + right.size[0]) right = node\n    if (y + height > bottom.pos[1] + bottom.size[1]) bottom = node\n    if (x < left.pos[0]) left = node\n  }\n\n  return {\n    top,\n    right,\n    bottom,\n    left,\n  }\n}\n\n/**\n * Distributes nodes evenly along a horizontal or vertical plane.\n * @param nodes The nodes to distribute\n * @param horizontal If true, distributes along the horizontal plane.  Otherwise, the vertical plane.\n */\nexport function distributeNodes(nodes: LGraphNode[], horizontal?: boolean): void {\n  const nodeCount = nodes?.length\n  if (!(nodeCount > 1)) return\n\n  const index = horizontal ? 0 : 1\n\n  let total = 0\n  let highest = -Infinity\n\n  for (const node of nodes) {\n    total += node.size[index]\n\n    const high = node.pos[index] + node.size[index]\n    if (high > highest) highest = high\n  }\n  const sorted = [...nodes].sort((a, b) => a.pos[index] - b.pos[index])\n  const lowest = sorted[0].pos[index]\n\n  const gap = (highest - lowest - total) / (nodeCount - 1)\n  let startAt = lowest\n  for (let i = 0; i < nodeCount; i++) {\n    const node = sorted[i]\n    node.pos[index] = startAt + gap * i\n    startAt += node.size[index]\n  }\n}\n\n/**\n * Aligns all nodes along the edge of a node.\n * @param nodes The nodes to align\n * @param direction The edge to align nodes on\n * @param align_to The node to align all other nodes to.  If undefined, the farthest node will be used.\n */\nexport function alignNodes(\n  nodes: LGraphNode[],\n  direction: Direction,\n  align_to?: LGraphNode,\n): void {\n  if (!nodes) return\n\n  const boundary = align_to === undefined\n    ? getBoundaryNodes(nodes)\n    : { top: align_to, right: align_to, bottom: align_to, left: align_to }\n\n  if (boundary === null) return\n\n  for (const node of nodes) {\n    switch (direction) {\n    case \"right\":\n      node.pos[0] = boundary.right.pos[0] + boundary.right.size[0] - node.size[0]\n      break\n    case \"left\":\n      node.pos[0] = boundary.left.pos[0]\n      break\n    case \"top\":\n      node.pos[1] = boundary.top.pos[1]\n      break\n    case \"bottom\":\n      node.pos[1] = boundary.bottom.pos[1] + boundary.bottom.size[1] - node.size[1]\n      break\n    }\n  }\n}\n","import type { ContextMenu } from \"./ContextMenu\"\nimport type { LGraphCanvasEventMap } from \"./infrastructure/LGraphCanvasEventMap\"\nimport type {\n  CanvasColour,\n  ColorOption,\n  ConnectingLink,\n  ContextMenuDivElement,\n  DefaultConnectionColors,\n  Dictionary,\n  Direction,\n  IBoundaryNodes,\n  IColorable,\n  IContextMenuOptions,\n  IContextMenuValue,\n  INodeInputSlot,\n  INodeOutputSlot,\n  INodeSlot,\n  INodeSlotContextItem,\n  ISlotType,\n  LinkSegment,\n  NullableProperties,\n  Point,\n  Positionable,\n  ReadOnlyPoint,\n  ReadOnlyRect,\n  Rect,\n  Size,\n} from \"./interfaces\"\nimport type { LGraph } from \"./LGraph\"\nimport type {\n  CanvasMouseEvent,\n  CanvasPointerEvent,\n  CanvasPointerExtensions,\n} from \"./types/events\"\nimport type { ClipboardItems } from \"./types/serialisation\"\nimport type { IBaseWidget } from \"./types/widgets\"\n\nimport { LinkConnector } from \"@/canvas/LinkConnector\"\n\nimport { isOverNodeInput, isOverNodeOutput } from \"./canvas/measureSlots\"\nimport { CanvasPointer } from \"./CanvasPointer\"\nimport { type AnimationOptions, DragAndScale } from \"./DragAndScale\"\nimport { strokeShape } from \"./draw\"\nimport { NullGraphError } from \"./infrastructure/NullGraphError\"\nimport { LGraphGroup } from \"./LGraphGroup\"\nimport { LGraphNode, type NodeId, type NodeProperty } from \"./LGraphNode\"\nimport { LiteGraph, type Rectangle } from \"./litegraph\"\nimport { type LinkId, LLink } from \"./LLink\"\nimport {\n  containsRect,\n  createBounds,\n  distance,\n  findPointOnCurve,\n  isInRect,\n  isInRectangle,\n  isPointInRect,\n  overlapBounding,\n  snapPoint,\n} from \"./measure\"\nimport { NodeInputSlot } from \"./node/NodeInputSlot\"\nimport { Reroute, type RerouteId } from \"./Reroute\"\nimport { stringOrEmpty } from \"./strings\"\nimport { Subgraph } from \"./subgraph/Subgraph\"\nimport {\n  CanvasItem,\n  LGraphEventMode,\n  LinkDirection,\n  LinkMarkerShape,\n  LinkRenderType,\n  RenderShape,\n  TitleMode,\n} from \"./types/globalEnums\"\nimport { alignNodes, distributeNodes, getBoundaryNodes } from \"./utils/arrange\"\nimport { findFirstNode, getAllNestedItems } from \"./utils/collections\"\nimport { BaseWidget } from \"./widgets/BaseWidget\"\nimport { toConcreteWidget } from \"./widgets/widgetMap\"\n\ninterface IShowSearchOptions {\n  node_to?: LGraphNode | null\n  node_from?: LGraphNode | null\n  slot_from: number | INodeOutputSlot | INodeInputSlot | null | undefined\n  type_filter_in?: ISlotType\n  type_filter_out?: ISlotType | false\n\n  // TODO check for registered_slot_[in/out]_types not empty // this will be checked for functionality enabled : filter on slot type, in and out\n  do_type_filter?: boolean\n  show_general_if_none_on_typefilter?: boolean\n  show_general_after_typefiltered?: boolean\n  hide_on_mouse_leave?: boolean\n  show_all_if_empty?: boolean\n  show_all_on_open?: boolean\n}\n\ninterface ICreateNodeOptions {\n  /** input */\n  nodeFrom?: LGraphNode | null\n  /** input */\n  slotFrom?: number | INodeOutputSlot | INodeInputSlot | null\n  /** output */\n  nodeTo?: LGraphNode | null\n  /** output */\n  slotTo?: number | INodeOutputSlot | INodeInputSlot | null\n  /** pass the event coords */\n\n  /** Create the connection from a reroute */\n  afterRerouteId?: RerouteId\n\n  // FIXME: Should not be optional\n  /** choose a nodetype to add, AUTO to set at first good */\n  nodeType?: string\n  e?: CanvasMouseEvent\n  allow_searchbox?: boolean\n}\n\ninterface ICreateDefaultNodeOptions extends ICreateNodeOptions {\n  /** Position of new node */\n  position: Point\n  /** adjust x,y */\n  posAdd?: Point\n  /** alpha, adjust the position x,y based on the new node size w,h */\n  posSizeFix?: Point\n}\n\ninterface HasShowSearchCallback {\n  /** See {@link LGraphCanvas.showSearchBox} */\n  showSearchBox: (\n    event: MouseEvent,\n    options?: IShowSearchOptions,\n  ) => HTMLDivElement | void\n}\n\ninterface ICloseable {\n  close(): void\n}\n\ninterface IDialogExtensions extends ICloseable {\n  modified(): void\n  is_modified: boolean\n}\n\ninterface IDialog extends HTMLDivElement, IDialogExtensions {}\ntype PromptDialog = Omit<IDialog, \"modified\">\n\ninterface IDialogOptions {\n  position?: Point\n  event?: MouseEvent\n  checkForInput?: boolean\n  closeOnLeave?: boolean\n  onclose?(): void\n}\n\n/** @inheritdoc {@link LGraphCanvas.state} */\nexport interface LGraphCanvasState {\n  /** {@link Positionable} items are being dragged on the canvas. */\n  draggingItems: boolean\n  /** The canvas itself is being dragged. */\n  draggingCanvas: boolean\n  /** The canvas is read-only, preventing changes to nodes, disconnecting links, moving items, etc. */\n  readOnly: boolean\n\n  /** Bit flags indicating what is currently below the pointer. */\n  hoveringOver: CanvasItem\n  /** If `true`, pointer move events will set the canvas cursor style. */\n  shouldSetCursor: boolean\n\n  /**\n   * Dirty flag indicating that {@link selectedItems} has changed.\n   * Downstream consumers may reset to false once actioned.\n   */\n  selectionChanged: boolean\n}\n\n/**\n * The items created by a clipboard paste operation.\n * Includes maps of original copied IDs to newly created items.\n */\ninterface ClipboardPasteResult {\n  /** All successfully created items */\n  created: Positionable[]\n  /** Map: original node IDs to newly created nodes */\n  nodes: Map<NodeId, LGraphNode>\n  /** Map: original link IDs to new link IDs */\n  links: Map<LinkId, LLink>\n  /** Map: original reroute IDs to newly created reroutes */\n  reroutes: Map<RerouteId, Reroute>\n}\n\n/** Options for {@link LGraphCanvas.pasteFromClipboard}. */\ninterface IPasteFromClipboardOptions {\n  /** If `true`, always attempt to connect inputs of pasted nodes - including to nodes that were not pasted. */\n  connectInputs?: boolean\n  /** The position to paste the items at. */\n  position?: Point\n}\n\ninterface ICreatePanelOptions {\n  closable?: any\n  window?: any\n  onOpen?: () => void\n  onClose?: () => void\n  width?: any\n  height?: any\n}\n\n/**\n * This class is in charge of rendering one graph inside a canvas. And provides all the interaction required.\n * Valid callbacks are: onNodeSelected, onNodeDeselected, onShowNodePanel, onNodeDblClicked\n */\nexport class LGraphCanvas {\n  // Optimised buffers used during rendering\n  static #temp = new Float32Array(4)\n  static #temp_vec2 = new Float32Array(2)\n  static #tmp_area = new Float32Array(4)\n  static #margin_area = new Float32Array(4)\n  static #link_bounding = new Float32Array(4)\n  static #lTempA: Point = new Float32Array(2)\n  static #lTempB: Point = new Float32Array(2)\n  static #lTempC: Point = new Float32Array(2)\n\n  static DEFAULT_BACKGROUND_IMAGE = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGQAAABkCAIAAAD/gAIDAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQBJREFUeNrs1rEKwjAUhlETUkj3vP9rdmr1Ysammk2w5wdxuLgcMHyptfawuZX4pJSWZTnfnu/lnIe/jNNxHHGNn//HNbbv+4dr6V+11uF527arU7+u63qfa/bnmh8sWLBgwYJlqRf8MEptXPBXJXa37BSl3ixYsGDBMliwFLyCV/DeLIMFCxYsWLBMwSt4Be/NggXLYMGCBUvBK3iNruC9WbBgwYJlsGApeAWv4L1ZBgsWLFiwYJmCV/AK3psFC5bBggULloJX8BpdwXuzYMGCBctgwVLwCl7Be7MMFixYsGDBsu8FH1FaSmExVfAxBa/gvVmwYMGCZbBg/W4vAQYA5tRF9QYlv/QAAAAASUVORK5CYII=\"\n\n  static DEFAULT_EVENT_LINK_COLOR = \"#A86\"\n\n  /** Link type to colour dictionary. */\n  static link_type_colors: Dictionary<string> = {\n    \"-1\": LGraphCanvas.DEFAULT_EVENT_LINK_COLOR,\n    \"number\": \"#AAA\",\n    \"node\": \"#DCA\",\n  }\n\n  static gradients: Record<string, CanvasGradient> = {}\n\n  static search_limit = -1\n  static node_colors: Record<string, ColorOption> = {\n    red: { color: \"#322\", bgcolor: \"#533\", groupcolor: \"#A88\" },\n    brown: { color: \"#332922\", bgcolor: \"#593930\", groupcolor: \"#b06634\" },\n    green: { color: \"#232\", bgcolor: \"#353\", groupcolor: \"#8A8\" },\n    blue: { color: \"#223\", bgcolor: \"#335\", groupcolor: \"#88A\" },\n    pale_blue: {\n      color: \"#2a363b\",\n      bgcolor: \"#3f5159\",\n      groupcolor: \"#3f789e\",\n    },\n    cyan: { color: \"#233\", bgcolor: \"#355\", groupcolor: \"#8AA\" },\n    purple: { color: \"#323\", bgcolor: \"#535\", groupcolor: \"#a1309b\" },\n    yellow: { color: \"#432\", bgcolor: \"#653\", groupcolor: \"#b58b2a\" },\n    black: { color: \"#222\", bgcolor: \"#000\", groupcolor: \"#444\" },\n  }\n\n  /**\n   * @internal Exclusively a workaround for design limitation in {@link LGraphNode.computeSize}.\n   */\n  static _measureText?: (text: string, fontStyle?: string) => number\n\n  /**\n   * The state of this canvas, e.g. whether it is being dragged, or read-only.\n   *\n   * Implemented as a POCO that can be proxied without side-effects.\n   */\n  state: LGraphCanvasState = {\n    draggingItems: false,\n    draggingCanvas: false,\n    readOnly: false,\n    hoveringOver: CanvasItem.Nothing,\n    shouldSetCursor: true,\n    selectionChanged: false,\n  }\n\n  declare subgraph?: Subgraph\n\n  #updateCursorStyle() {\n    if (!this.state.shouldSetCursor) return\n\n    let cursor = \"default\"\n    if (this.state.draggingCanvas) {\n      cursor = \"grabbing\"\n    } else if (this.state.readOnly) {\n      cursor = \"grab\"\n    } else if (this.state.hoveringOver & CanvasItem.ResizeSe) {\n      cursor = \"se-resize\"\n    } else if (this.state.hoveringOver & CanvasItem.Node) {\n      cursor = \"crosshair\"\n    } else if (this.state.hoveringOver & CanvasItem.Reroute) {\n      cursor = \"grab\"\n    } else if (this.state.hoveringOver & CanvasItem.RerouteSlot) {\n      cursor = \"crosshair\"\n    }\n\n    this.canvas.style.cursor = cursor\n  }\n\n  // Whether the canvas was previously being dragged prior to pressing space key.\n  // null if space key is not pressed.\n  private _previously_dragging_canvas: boolean | null = null\n\n  // #region Legacy accessors\n  /** @deprecated @inheritdoc {@link LGraphCanvasState.readOnly} */\n  get read_only(): boolean {\n    return this.state.readOnly\n  }\n\n  set read_only(value: boolean) {\n    this.state.readOnly = value\n    this.#updateCursorStyle()\n  }\n\n  get isDragging(): boolean {\n    return this.state.draggingItems\n  }\n\n  set isDragging(value: boolean) {\n    this.state.draggingItems = value\n  }\n\n  get hoveringOver(): CanvasItem {\n    return this.state.hoveringOver\n  }\n\n  set hoveringOver(value: CanvasItem) {\n    this.state.hoveringOver = value\n    this.#updateCursorStyle()\n  }\n\n  /** @deprecated Replace all references with {@link pointer}.{@link CanvasPointer.isDown isDown}. */\n  get pointer_is_down() {\n    return this.pointer.isDown\n  }\n\n  /** @deprecated Replace all references with {@link pointer}.{@link CanvasPointer.isDouble isDouble}. */\n  get pointer_is_double() {\n    return this.pointer.isDouble\n  }\n\n  /** @deprecated @inheritdoc {@link LGraphCanvasState.draggingCanvas} */\n  get dragging_canvas(): boolean {\n    return this.state.draggingCanvas\n  }\n\n  set dragging_canvas(value: boolean) {\n    this.state.draggingCanvas = value\n    this.#updateCursorStyle()\n  }\n\n  /**\n   * @deprecated Use {@link LGraphNode.titleFontStyle} instead.\n   */\n  get title_text_font(): string {\n    return `${LiteGraph.NODE_TEXT_SIZE}px ${LiteGraph.NODE_FONT}`\n  }\n  // #endregion Legacy accessors\n\n  get inner_text_font(): string {\n    return `normal ${LiteGraph.NODE_SUBTEXT_SIZE}px ${LiteGraph.NODE_FONT}`\n  }\n\n  #maximumFrameGap = 0\n  /** Maximum frames per second to render. 0: unlimited. Default: 0 */\n  public get maximumFps() {\n    return this.#maximumFrameGap > Number.EPSILON ? this.#maximumFrameGap / 1000 : 0\n  }\n\n  public set maximumFps(value) {\n    this.#maximumFrameGap = value > Number.EPSILON ? 1000 / value : 0\n  }\n\n  /**\n   * @deprecated Use {@link LiteGraphGlobal.ROUND_RADIUS} instead.\n   */\n  get round_radius() {\n    return LiteGraph.ROUND_RADIUS\n  }\n\n  /**\n   * @deprecated Use {@link LiteGraphGlobal.ROUND_RADIUS} instead.\n   */\n  set round_radius(value: number) {\n    LiteGraph.ROUND_RADIUS = value\n  }\n\n  /**\n   * Render low quality when zoomed out.\n   */\n  get low_quality(): boolean {\n    return this.ds.scale < this.low_quality_zoom_threshold\n  }\n\n  options: {\n    skip_events?: any\n    viewport?: any\n    skip_render?: any\n    autoresize?: any\n  }\n\n  background_image: string\n  readonly ds: DragAndScale\n  readonly pointer: CanvasPointer\n  zoom_modify_alpha: boolean\n  zoom_speed: number\n  node_title_color: string\n  default_link_color: string\n  default_connection_color: {\n    input_off: string\n    input_on: string\n    output_off: string\n    output_on: string\n  }\n\n  default_connection_color_byType: Dictionary<CanvasColour>\n  default_connection_color_byTypeOff: Dictionary<CanvasColour>\n\n  /** Gets link colours. Extremely basic impl. until the legacy object dictionaries are removed. */\n  colourGetter: DefaultConnectionColors = {\n    getConnectedColor: (type: string) =>\n      this.default_connection_color_byType[type] ||\n      this.default_connection_color.output_on,\n    getDisconnectedColor: (type: string) =>\n      this.default_connection_color_byTypeOff[type] ||\n      this.default_connection_color_byType[type] ||\n      this.default_connection_color.output_off,\n  }\n\n  highquality_render: boolean\n  use_gradients: boolean\n  editor_alpha: number\n  pause_rendering: boolean\n  clear_background: boolean\n  clear_background_color: string\n  render_only_selected: boolean\n  show_info: boolean\n  allow_dragcanvas: boolean\n  allow_dragnodes: boolean\n  allow_interaction: boolean\n  multi_select: boolean\n  allow_searchbox: boolean\n  allow_reconnect_links: boolean\n  align_to_grid: boolean\n  drag_mode: boolean\n  dragging_rectangle: Rect | null\n  filter?: string | null\n  set_canvas_dirty_on_mouse_event: boolean\n  always_render_background: boolean\n  render_shadows: boolean\n  render_canvas_border: boolean\n  render_connections_shadows: boolean\n  render_connections_border: boolean\n  render_curved_connections: boolean\n  render_connection_arrows: boolean\n  render_collapsed_slots: boolean\n  render_execution_order: boolean\n  render_link_tooltip: boolean\n\n  /** Shape of the markers shown at the midpoint of links.  Default: Circle */\n  linkMarkerShape: LinkMarkerShape = LinkMarkerShape.Circle\n  links_render_mode: number\n  /** Zoom threshold for low quality rendering. Zoom below this threshold will render low quality. */\n  low_quality_zoom_threshold: number = 0.6\n  /** mouse in canvas coordinates, where 0,0 is the top-left corner of the blue rectangle */\n  readonly mouse: Point\n  /** mouse in graph coordinates, where 0,0 is the top-left corner of the blue rectangle */\n  readonly graph_mouse: Point\n  /** @deprecated LEGACY: REMOVE THIS, USE {@link graph_mouse} INSTEAD */\n  canvas_mouse: Point\n  /** to personalize the search box */\n  onSearchBox?: (helper: Element, str: string, canvas: LGraphCanvas) => any\n  onSearchBoxSelection?: (name: any, event: any, canvas: LGraphCanvas) => void\n  onMouse?: (e: CanvasMouseEvent) => boolean\n  /** to render background objects (behind nodes and connections) in the canvas affected by transform */\n  onDrawBackground?: (ctx: CanvasRenderingContext2D, visible_area: any) => void\n  /** to render foreground objects (above nodes and connections) in the canvas affected by transform */\n  onDrawForeground?: (arg0: CanvasRenderingContext2D, arg1: any) => void\n  connections_width: number\n  /** The current node being drawn by {@link drawNode}.  This should NOT be used to determine the currently selected node.  See {@link selectedItems} */\n  current_node: LGraphNode | null\n  /** used for widgets */\n  node_widget?: [LGraphNode, IBaseWidget] | null\n  /** The link to draw a tooltip for. */\n  over_link_center?: LinkSegment\n  last_mouse_position: Point\n  /** The visible area of this canvas.  Tightly coupled with {@link ds}. */\n  visible_area: Rectangle\n  /** Contains all links and reroutes that were rendered.  Repopulated every render cycle. */\n  renderedPaths: Set<LinkSegment> = new Set()\n  /** @deprecated Replaced by {@link renderedPaths}, but length is set to 0 by some extensions. */\n  visible_links: LLink[] = []\n  /** @deprecated This array is populated and cleared to support legacy extensions. The contents are ignored by Litegraph. */\n  connecting_links: ConnectingLink[] | null\n  linkConnector = new LinkConnector(links => this.connecting_links = links)\n  /** The viewport of this canvas.  Tightly coupled with {@link ds}. */\n  readonly viewport?: Rect\n  autoresize: boolean\n  static active_canvas: LGraphCanvas\n  frame = 0\n  last_draw_time = 0\n  render_time = 0\n  fps = 0\n  /** @deprecated See {@link LGraphCanvas.selectedItems} */\n  selected_nodes: Dictionary<LGraphNode> = {}\n  /** All selected nodes, groups, and reroutes */\n  selectedItems: Set<Positionable> = new Set()\n  /** The group currently being resized. */\n  resizingGroup: LGraphGroup | null = null\n  /** @deprecated See {@link LGraphCanvas.selectedItems} */\n  selected_group: LGraphGroup | null = null\n  /** The nodes that are currently visible on the canvas. */\n  visible_nodes: LGraphNode[] = []\n  /**\n   * The IDs of the nodes that are currently visible on the canvas. More\n   * performant than {@link visible_nodes} for visibility checks.\n   */\n  #visible_node_ids: Set<NodeId> = new Set()\n  node_over?: LGraphNode\n  node_capturing_input?: LGraphNode | null\n  highlighted_links: Dictionary<boolean> = {}\n\n  #visibleReroutes: Set<Reroute> = new Set()\n\n  dirty_canvas: boolean = true\n  dirty_bgcanvas: boolean = true\n  /** A map of nodes that require selective-redraw */\n  dirty_nodes = new Map<NodeId, LGraphNode>()\n  dirty_area?: Rect | null\n  /** @deprecated Unused */\n  node_in_panel?: LGraphNode | null\n  last_mouse: ReadOnlyPoint = [0, 0]\n  last_mouseclick: number = 0\n  graph: LGraph | null\n  canvas: HTMLCanvasElement\n  bgcanvas: HTMLCanvasElement\n  ctx: CanvasRenderingContext2D\n  _events_binded?: boolean\n  _mousedown_callback?(e: PointerEvent): void\n  _mousewheel_callback?(e: WheelEvent): void\n  _mousemove_callback?(e: PointerEvent): void\n  _mouseup_callback?(e: PointerEvent): void\n  _mouseout_callback?(e: PointerEvent): void\n  _mousecancel_callback?(e: PointerEvent): void\n  _key_callback?(e: KeyboardEvent): void\n  bgctx?: CanvasRenderingContext2D | null\n  is_rendering?: boolean\n  /** @deprecated Panels */\n  block_click?: boolean\n  /** @deprecated Panels */\n  last_click_position?: Point | null\n  resizing_node?: LGraphNode | null\n  /** @deprecated See {@link LGraphCanvas.resizingGroup} */\n  selected_group_resizing?: boolean\n  /** @deprecated See {@link pointer}.{@link CanvasPointer.dragStarted dragStarted} */\n  last_mouse_dragging?: boolean\n  onMouseDown?: (arg0: CanvasMouseEvent) => void\n  _highlight_pos?: Point\n  _highlight_input?: INodeInputSlot\n  // TODO: Check if panels are used\n  /** @deprecated Panels */\n  node_panel?: any\n  /** @deprecated Panels */\n  options_panel?: any\n  _bg_img?: HTMLImageElement\n  _pattern?: CanvasPattern\n  _pattern_img?: HTMLImageElement\n  // TODO: This looks like another panel thing\n  prompt_box?: PromptDialog | null\n  search_box?: HTMLDivElement\n  /** @deprecated Panels */\n  SELECTED_NODE?: LGraphNode\n  /** @deprecated Panels */\n  NODEPANEL_IS_OPEN?: boolean\n\n  /** Once per frame check of snap to grid value.  @todo Update on change. */\n  #snapToGrid?: number\n  /** Set on keydown, keyup. @todo */\n  #shiftDown: boolean = false\n\n  /** If true, enable drag zoom. Ctrl+Shift+Drag Up/Down: zoom canvas. */\n  dragZoomEnabled: boolean = false\n  /** The start position of the drag zoom. */\n  #dragZoomStart: { pos: Point, scale: number } | null = null\n\n  getMenuOptions?(): IContextMenuValue<string>[]\n  getExtraMenuOptions?(\n    canvas: LGraphCanvas,\n    options: IContextMenuValue<string>[],\n  ): IContextMenuValue<string>[]\n  static active_node: LGraphNode\n  /** called before modifying the graph */\n  onBeforeChange?(graph: LGraph): void\n  /** called after modifying the graph */\n  onAfterChange?(graph: LGraph): void\n  onClear?: () => void\n  /** called after moving a node @deprecated Does not handle multi-node move, and can return the wrong node. */\n  onNodeMoved?: (node_dragged: LGraphNode | undefined) => void\n  /** @deprecated Called with the deprecated {@link selected_nodes} when the selection changes. Replacement not yet impl. */\n  onSelectionChange?: (selected: Dictionary<Positionable>) => void\n  /** called when rendering a tooltip */\n  onDrawLinkTooltip?: (\n    ctx: CanvasRenderingContext2D,\n    link: LLink | null,\n    canvas?: LGraphCanvas,\n  ) => boolean\n\n  /** to render foreground objects not affected by transform (for GUIs) */\n  onDrawOverlay?: (ctx: CanvasRenderingContext2D) => void\n  onRenderBackground?: (\n    canvas: HTMLCanvasElement,\n    ctx: CanvasRenderingContext2D,\n  ) => boolean\n\n  onNodeDblClicked?: (n: LGraphNode) => void\n  onShowNodePanel?: (n: LGraphNode) => void\n  onNodeSelected?: (node: LGraphNode) => void\n  onNodeDeselected?: (node: LGraphNode) => void\n  onRender?: (canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D) => void\n\n  /**\n   * Creates a new instance of LGraphCanvas.\n   * @param canvas The canvas HTML element (or its id) to use, or null / undefined to leave blank.\n   * @param graph The graph that owns this canvas.\n   * @param options\n   */\n  constructor(\n    canvas: HTMLCanvasElement,\n    graph: LGraph,\n    options?: LGraphCanvas[\"options\"],\n  ) {\n    options ||= {}\n    this.options = options\n\n    // if(graph === undefined)\n    // throw (\"No graph assigned\");\n    this.background_image = LGraphCanvas.DEFAULT_BACKGROUND_IMAGE\n\n    this.ds = new DragAndScale(canvas)\n    this.pointer = new CanvasPointer(canvas)\n\n    // @deprecated Workaround: Keep until connecting_links is removed.\n    this.linkConnector.events.addEventListener(\"reset\", () => {\n      this.connecting_links = null\n    })\n\n    // Dropped a link on the canvas\n    this.linkConnector.events.addEventListener(\"dropped-on-canvas\", (customEvent) => {\n      if (!this.connecting_links) return\n\n      const e = customEvent.detail\n      this.emitEvent({\n        subType: \"empty-release\",\n        originalEvent: e,\n        linkReleaseContext: { links: this.connecting_links },\n      })\n\n      const firstLink = this.linkConnector.renderLinks[0]\n\n      // No longer in use\n      // add menu when releasing link in empty space\n      if (LiteGraph.release_link_on_empty_shows_menu) {\n        const linkReleaseContext = this.linkConnector.state.connectingTo === \"input\"\n          ? {\n            node_from: firstLink.node,\n            slot_from: firstLink.fromSlot,\n            type_filter_in: firstLink.fromSlot.type,\n          }\n          : {\n            node_to: firstLink.node,\n            slot_from: firstLink.fromSlot,\n            type_filter_out: firstLink.fromSlot.type,\n          }\n\n        const afterRerouteId = firstLink.fromReroute?.id\n\n        if (\"shiftKey\" in e && e.shiftKey) {\n          if (this.allow_searchbox) {\n            this.showSearchBox(e as unknown as MouseEvent, linkReleaseContext)\n          }\n        } else if (this.linkConnector.state.connectingTo === \"input\") {\n          this.showConnectionMenu({ nodeFrom: firstLink.node, slotFrom: firstLink.fromSlot, e, afterRerouteId })\n        } else {\n          this.showConnectionMenu({ nodeTo: firstLink.node, slotTo: firstLink.fromSlot, e, afterRerouteId })\n        }\n      }\n    })\n\n    // otherwise it generates ugly patterns when scaling down too much\n    this.zoom_modify_alpha = true\n    // in range (1.01, 2.5). Less than 1 will invert the zoom direction\n    this.zoom_speed = 1.1\n\n    this.node_title_color = LiteGraph.NODE_TITLE_COLOR\n    this.default_link_color = LiteGraph.LINK_COLOR\n    this.default_connection_color = {\n      input_off: \"#778\",\n      input_on: \"#7F7\",\n      output_off: \"#778\",\n      output_on: \"#7F7\",\n    }\n    this.default_connection_color_byType = {\n      /* number: \"#7F7\",\n            string: \"#77F\",\n            boolean: \"#F77\", */\n    }\n    this.default_connection_color_byTypeOff = {\n      /* number: \"#474\",\n            string: \"#447\",\n            boolean: \"#744\", */\n    }\n\n    this.highquality_render = true\n    // set to true to render titlebar with gradients\n    this.use_gradients = false\n    // used for transition\n    this.editor_alpha = 1\n    this.pause_rendering = false\n    this.clear_background = true\n    this.clear_background_color = \"#222\"\n\n    this.render_only_selected = true\n    this.show_info = true\n    this.allow_dragcanvas = true\n    this.allow_dragnodes = true\n    // allow to control widgets, buttons, collapse, etc\n    this.allow_interaction = true\n    // allow selecting multi nodes without pressing extra keys\n    this.multi_select = false\n    this.allow_searchbox = true\n    // allows to change a connection with having to redo it again\n    this.allow_reconnect_links = true\n    // snap to grid\n    this.align_to_grid = false\n\n    this.drag_mode = false\n    this.dragging_rectangle = null\n\n    // allows to filter to only accept some type of nodes in a graph\n    this.filter = null\n\n    // forces to redraw the canvas on mouse events (except move)\n    this.set_canvas_dirty_on_mouse_event = true\n    this.always_render_background = false\n    this.render_shadows = true\n    this.render_canvas_border = true\n    // too much cpu\n    this.render_connections_shadows = false\n    this.render_connections_border = true\n    this.render_curved_connections = false\n    this.render_connection_arrows = false\n    this.render_collapsed_slots = true\n    this.render_execution_order = false\n    this.render_link_tooltip = true\n\n    this.links_render_mode = LinkRenderType.SPLINE_LINK\n\n    this.mouse = [0, 0]\n    this.graph_mouse = [0, 0]\n    this.canvas_mouse = this.graph_mouse\n\n    this.connections_width = 3\n\n    this.current_node = null\n    this.node_widget = null\n    this.last_mouse_position = [0, 0]\n    this.visible_area = this.ds.visible_area\n    // Explicitly null-checked\n    this.connecting_links = null\n\n    // to constraint render area to a portion of the canvas\n    this.viewport = options.viewport || null\n\n    // link canvas and graph\n    this.graph = graph\n    graph?.attachCanvas(this)\n\n    // TypeScript strict workaround: cannot use method to initialize properties.\n    this.canvas = undefined!\n    this.bgcanvas = undefined!\n    this.ctx = undefined!\n\n    this.setCanvas(canvas, options.skip_events)\n    this.clear()\n\n    LGraphCanvas._measureText = (text: string, fontStyle = this.inner_text_font) => {\n      const { ctx } = this\n      const { font } = ctx\n      try {\n        ctx.font = fontStyle\n        return ctx.measureText(text).width\n      } finally {\n        ctx.font = font\n      }\n    }\n\n    if (!options.skip_render) {\n      this.startRendering()\n    }\n\n    this.autoresize = options.autoresize\n  }\n\n  static onGroupAdd(info: unknown, entry: unknown, mouse_event: MouseEvent): void {\n    const canvas = LGraphCanvas.active_canvas\n\n    const group = new LiteGraph.LGraphGroup()\n    group.pos = canvas.convertEventToCanvasOffset(mouse_event)\n    if (!canvas.graph) throw new NullGraphError()\n    canvas.graph.add(group)\n  }\n\n  /**\n   * @deprecated Functionality moved to {@link getBoundaryNodes}.  The new function returns null on failure, instead of an object with all null properties.\n   * Determines the furthest nodes in each direction\n   * @param nodes the nodes to from which boundary nodes will be extracted\n   * @returns\n   */\n  static getBoundaryNodes(\n    nodes: LGraphNode[] | Dictionary<LGraphNode>,\n  ): NullableProperties<IBoundaryNodes> {\n    const _nodes = Array.isArray(nodes) ? nodes : Object.values(nodes)\n    return (\n      getBoundaryNodes(_nodes) ?? {\n        top: null,\n        right: null,\n        bottom: null,\n        left: null,\n      }\n    )\n  }\n\n  /**\n   * @deprecated Functionality moved to {@link alignNodes}.  The new function does not set dirty canvas.\n   * @param nodes a list of nodes\n   * @param direction Direction to align the nodes\n   * @param align_to Node to align to (if null, align to the furthest node in the given direction)\n   */\n  static alignNodes(\n    nodes: Dictionary<LGraphNode>,\n    direction: Direction,\n    align_to?: LGraphNode,\n  ): void {\n    alignNodes(Object.values(nodes), direction, align_to)\n    LGraphCanvas.active_canvas.setDirty(true, true)\n  }\n\n  static onNodeAlign(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    event: MouseEvent,\n    prev_menu: ContextMenu<string>,\n    node: LGraphNode,\n  ): void {\n    new LiteGraph.ContextMenu([\"Top\", \"Bottom\", \"Left\", \"Right\"], {\n      event,\n      callback: inner_clicked,\n      parentMenu: prev_menu,\n    })\n\n    function inner_clicked(value: string) {\n      alignNodes(\n        Object.values(LGraphCanvas.active_canvas.selected_nodes),\n        value.toLowerCase() as Direction,\n        node,\n      )\n      LGraphCanvas.active_canvas.setDirty(true, true)\n    }\n  }\n\n  static onGroupAlign(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    event: MouseEvent,\n    prev_menu: ContextMenu<string>,\n  ): void {\n    new LiteGraph.ContextMenu([\"Top\", \"Bottom\", \"Left\", \"Right\"], {\n      event,\n      callback: inner_clicked,\n      parentMenu: prev_menu,\n    })\n\n    function inner_clicked(value: string) {\n      alignNodes(\n        Object.values(LGraphCanvas.active_canvas.selected_nodes),\n        value.toLowerCase() as Direction,\n      )\n      LGraphCanvas.active_canvas.setDirty(true, true)\n    }\n  }\n\n  static createDistributeMenu(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    event: MouseEvent,\n    prev_menu: ContextMenu<string>,\n  ): void {\n    new LiteGraph.ContextMenu([\"Vertically\", \"Horizontally\"], {\n      event,\n      callback: inner_clicked,\n      parentMenu: prev_menu,\n    })\n\n    function inner_clicked(value: string) {\n      const canvas = LGraphCanvas.active_canvas\n      distributeNodes(Object.values(canvas.selected_nodes), value === \"Horizontally\")\n      canvas.setDirty(true, true)\n    }\n  }\n\n  static onMenuAdd(\n    value: unknown,\n    options: unknown,\n    e: MouseEvent,\n    prev_menu?: ContextMenu<string>,\n    callback?: (node: LGraphNode | null) => void,\n  ): boolean | undefined {\n    const canvas = LGraphCanvas.active_canvas\n    const ref_window = canvas.getCanvasWindow()\n    const { graph } = canvas\n    if (!graph) return\n\n    inner_onMenuAdded(\"\", prev_menu)\n    return false\n\n    type AddNodeMenu = Omit<IContextMenuValue<string>, \"callback\"> & {\n      callback: (\n        value: { value: string },\n        event: Event,\n        mouseEvent: MouseEvent,\n        contextMenu: ContextMenu<string>\n      ) => void\n    }\n\n    function inner_onMenuAdded(base_category: string, prev_menu?: ContextMenu<string>): void {\n      if (!graph) return\n\n      const categories = LiteGraph\n        .getNodeTypesCategories(canvas.filter || graph.filter)\n        .filter(category => category.startsWith(base_category))\n      const entries: AddNodeMenu[] = []\n\n      for (const category of categories) {\n        if (!category) continue\n\n        const base_category_regex = new RegExp(`^(${base_category})`)\n        const category_name = category\n          .replace(base_category_regex, \"\")\n          .split(\"/\", 1)[0]\n        const category_path =\n          base_category === \"\"\n            ? `${category_name}/`\n            : `${base_category}${category_name}/`\n\n        let name = category_name\n        // in case it has a namespace like \"shader::math/rand\" it hides the namespace\n        if (name.includes(\"::\")) name = name.split(\"::\", 2)[1]\n\n        const index = entries.findIndex(entry => entry.value === category_path)\n        if (index === -1) {\n          entries.push({\n            value: category_path,\n            content: name,\n            has_submenu: true,\n            callback: function (value, event, mouseEvent, contextMenu) {\n              inner_onMenuAdded(value.value, contextMenu)\n            },\n          })\n        }\n      }\n\n      const nodes = LiteGraph.getNodeTypesInCategory(\n        base_category.slice(0, -1),\n        canvas.filter || graph.filter,\n      )\n\n      for (const node of nodes) {\n        if (node.skip_list) continue\n\n        const entry: AddNodeMenu = {\n          value: node.type,\n          content: node.title,\n          has_submenu: false,\n          callback: function (value, event, mouseEvent, contextMenu) {\n            if (!canvas.graph) throw new NullGraphError()\n\n            const first_event = contextMenu.getFirstEvent()\n            canvas.graph.beforeChange()\n            const node = LiteGraph.createNode(value.value)\n            if (node) {\n              if (!first_event) throw new TypeError(\"Context menu event was null. This should not occur in normal usage.\")\n              node.pos = canvas.convertEventToCanvasOffset(first_event)\n              canvas.graph.add(node)\n            } else {\n              console.warn(\"Failed to create node of type:\", value.value)\n            }\n\n            callback?.(node)\n            canvas.graph.afterChange()\n          },\n        }\n\n        entries.push(entry)\n      }\n\n      // @ts-expect-error Remove param ref_window - unused\n      new LiteGraph.ContextMenu(entries, { event: e, parentMenu: prev_menu }, ref_window)\n    }\n  }\n\n  static onMenuCollapseAll() {}\n  static onMenuNodeEdit() {}\n\n  /** @param _options Parameter is never used */\n  static showMenuNodeOptionalOutputs(\n    v: unknown,\n    /** Unused - immediately overwritten */\n    _options: INodeOutputSlot[],\n    e: MouseEvent,\n    prev_menu: ContextMenu<INodeSlotContextItem>,\n    node: LGraphNode,\n  ): boolean | undefined {\n    if (!node) return\n\n    const canvas = LGraphCanvas.active_canvas\n\n    let entries: (IContextMenuValue<INodeSlotContextItem> | null)[] = []\n\n    if (LiteGraph.do_add_triggers_slots && node.findOutputSlot(\"onExecuted\") == -1) {\n      entries.push({ content: \"On Executed\", value: [\"onExecuted\", LiteGraph.EVENT, { nameLocked: true }], className: \"event\" })\n    }\n    // add callback for modifing the menu elements onMenuNodeOutputs\n    const retEntries = node.onMenuNodeOutputs?.(entries)\n    if (retEntries) entries = retEntries\n\n    if (!entries.length) return\n\n    new LiteGraph.ContextMenu<INodeSlotContextItem>(\n      entries,\n      {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: prev_menu,\n        node,\n      },\n    )\n\n    function inner_clicked(this: ContextMenuDivElement<INodeSlotContextItem>, v: IContextMenuValue<INodeSlotContextItem>, e: any, prev: any) {\n      if (!node) return\n\n      // TODO: This is a static method, so the below \"that\" appears broken.\n      if (v.callback) v.callback.call(this, node, v, e, prev)\n\n      if (!v.value) return\n\n      const value = v.value[1]\n\n      if (value &&\n        (typeof value === \"object\" || Array.isArray(value))) {\n        // submenu why?\n        const entries = []\n        for (const i in value) {\n          entries.push({ content: i, value: value[i] })\n        }\n        new LiteGraph.ContextMenu(entries, {\n          event: e,\n          callback: inner_clicked,\n          parentMenu: prev_menu,\n          node,\n        })\n        return false\n      }\n\n      const { graph } = node\n      if (!graph) throw new NullGraphError()\n\n      graph.beforeChange()\n      node.addOutput(v.value[0], v.value[1], v.value[2])\n\n      // a callback to the node when adding a slot\n      node.onNodeOutputAdd?.(v.value)\n      canvas.setDirty(true, true)\n      graph.afterChange()\n    }\n\n    return false\n  }\n\n  /** @param value Parameter is never used */\n  static onShowMenuNodeProperties(\n    value: NodeProperty | undefined,\n    options: unknown,\n    e: MouseEvent,\n    prev_menu: ContextMenu<string>,\n    node: LGraphNode,\n  ): boolean | undefined {\n    if (!node || !node.properties) return\n\n    const canvas = LGraphCanvas.active_canvas\n    const ref_window = canvas.getCanvasWindow()\n\n    const entries: IContextMenuValue<string>[] = []\n    for (const i in node.properties) {\n      value = node.properties[i] !== undefined ? node.properties[i] : \" \"\n      if (typeof value == \"object\")\n        value = JSON.stringify(value)\n      const info = node.getPropertyInfo(i)\n      if (info.type == \"enum\" || info.type == \"combo\")\n        value = LGraphCanvas.getPropertyPrintableValue(value, info.values)\n\n      // value could contain invalid html characters, clean that\n      value = LGraphCanvas.decodeHTML(stringOrEmpty(value))\n      entries.push({\n        content:\n         `<span class='property_name'>${info.label || i}</span>` +\n         `<span class='property_value'>${value}</span>`,\n        value: i,\n      })\n    }\n    if (!entries.length) {\n      return\n    }\n\n    new LiteGraph.ContextMenu<string>(\n      entries,\n      {\n        event: e,\n        callback: inner_clicked,\n        parentMenu: prev_menu,\n        allow_html: true,\n        node,\n      },\n      // @ts-expect-error Unused\n      ref_window,\n    )\n\n    function inner_clicked(this: ContextMenuDivElement, v: { value: any }) {\n      if (!node) return\n\n      const rect = this.getBoundingClientRect()\n      canvas.showEditPropertyValue(node, v.value, {\n        position: [rect.left, rect.top],\n      })\n    }\n\n    return false\n  }\n\n  /** @deprecated */\n  static decodeHTML(str: string): string {\n    const e = document.createElement(\"div\")\n    e.textContent = str\n    return e.innerHTML\n  }\n\n  static onMenuResizeNode(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): void {\n    if (!node) return\n\n    const fApplyMultiNode = function (node: LGraphNode) {\n      node.setSize(node.computeSize())\n    }\n\n    const canvas = LGraphCanvas.active_canvas\n    if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node)\n    } else {\n      for (const i in canvas.selected_nodes) {\n        fApplyMultiNode(canvas.selected_nodes[i])\n      }\n    }\n\n    canvas.setDirty(true, true)\n  }\n\n  // TODO refactor :: this is used fot title but not for properties!\n  static onShowPropertyEditor(\n    item: { property: keyof LGraphNode, type: string },\n    options: IContextMenuOptions<string>,\n    e: MouseEvent,\n    menu: ContextMenu<string>,\n    node: LGraphNode,\n  ): void {\n    const property = item.property || \"title\"\n    const value = node[property]\n\n    const title = document.createElement(\"span\")\n    title.className = \"name\"\n    title.textContent = property\n\n    const input = document.createElement(\"input\")\n    Object.assign(input, { type: \"text\", className: \"value\", autofocus: true })\n\n    const button = document.createElement(\"button\")\n    button.textContent = \"OK\"\n\n    // TODO refactor :: use createDialog ?\n    const dialog = Object.assign(document.createElement(\"div\"), {\n      is_modified: false,\n      className: \"graphdialog\",\n      close: () => dialog.remove(),\n    })\n    dialog.append(title, input, button)\n\n    input.value = String(value)\n    input.addEventListener(\"blur\", function () {\n      this.focus()\n    })\n    input.addEventListener(\"keydown\", (e: KeyboardEvent) => {\n      dialog.is_modified = true\n      if (e.key == \"Escape\") {\n        // ESC\n        dialog.close()\n      } else if (e.key == \"Enter\") {\n        // save\n        inner()\n      } else if (!e.target || !(\"localName\" in e.target) || e.target.localName != \"textarea\") {\n        return\n      }\n      e.preventDefault()\n      e.stopPropagation()\n    })\n\n    const canvas = LGraphCanvas.active_canvas\n    const canvasEl = canvas.canvas\n\n    const rect = canvasEl.getBoundingClientRect()\n    const offsetx = rect ? -20 - rect.left : -20\n    const offsety = rect ? -20 - rect.top : -20\n\n    if (e) {\n      dialog.style.left = `${e.clientX + offsetx}px`\n      dialog.style.top = `${e.clientY + offsety}px`\n    } else {\n      dialog.style.left = `${canvasEl.width * 0.5 + offsetx}px`\n      dialog.style.top = `${canvasEl.height * 0.5 + offsety}px`\n    }\n\n    button.addEventListener(\"click\", inner)\n\n    if (canvasEl.parentNode == null) throw new TypeError(\"canvasEl.parentNode was null\")\n    canvasEl.parentNode.append(dialog)\n\n    input.focus()\n\n    let dialogCloseTimer: number\n    dialog.addEventListener(\"mouseleave\", function () {\n      if (LiteGraph.dialog_close_on_mouse_leave) {\n        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave) {\n          dialogCloseTimer = setTimeout(\n            dialog.close,\n            LiteGraph.dialog_close_on_mouse_leave_delay,\n          )\n        }\n      }\n    })\n    dialog.addEventListener(\"mouseenter\", function () {\n      if (LiteGraph.dialog_close_on_mouse_leave) {\n        if (dialogCloseTimer) clearTimeout(dialogCloseTimer)\n      }\n    })\n\n    function inner() {\n      if (input) setValue(input.value)\n    }\n\n    function setValue(value: NodeProperty) {\n      if (item.type == \"Number\") {\n        value = Number(value)\n      } else if (item.type == \"Boolean\") {\n        value = Boolean(value)\n      }\n      // @ts-expect-error Requires refactor.\n      node[property] = value\n      dialog.remove()\n      canvas.setDirty(true, true)\n    }\n  }\n\n  static getPropertyPrintableValue(value: unknown, values: unknown[] | object | undefined): string | undefined {\n    if (!values) return String(value)\n\n    if (Array.isArray(values)) {\n      return String(value)\n    }\n\n    if (typeof values === \"object\") {\n      let desc_value = \"\"\n      for (const k in values) {\n        // @ts-expect-error deprecated #578\n        if (values[k] != value) continue\n\n        desc_value = k\n        break\n      }\n      return `${String(value)} (${desc_value})`\n    }\n  }\n\n  static onMenuNodeCollapse(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): void {\n    if (!node.graph) throw new NullGraphError()\n\n    node.graph.beforeChange()\n\n    const fApplyMultiNode = function (node: LGraphNode) {\n      node.collapse()\n    }\n\n    const graphcanvas = LGraphCanvas.active_canvas\n    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node)\n    } else {\n      for (const i in graphcanvas.selected_nodes) {\n        fApplyMultiNode(graphcanvas.selected_nodes[i])\n      }\n    }\n\n    node.graph.afterChange()\n  }\n\n  static onMenuToggleAdvanced(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): void {\n    if (!node.graph) throw new NullGraphError()\n\n    node.graph.beforeChange()\n    const fApplyMultiNode = function (node: LGraphNode) {\n      node.toggleAdvanced()\n    }\n\n    const graphcanvas = LGraphCanvas.active_canvas\n    if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node)\n    } else {\n      for (const i in graphcanvas.selected_nodes) {\n        fApplyMultiNode(graphcanvas.selected_nodes[i])\n      }\n    }\n    node.graph.afterChange()\n  }\n\n  static onMenuNodeMode(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): boolean {\n    new LiteGraph.ContextMenu(\n      LiteGraph.NODE_MODES,\n      { event: e, callback: inner_clicked, parentMenu: menu, node },\n    )\n\n    function inner_clicked(v: string) {\n      if (!node) return\n\n      const kV = Object.values(LiteGraph.NODE_MODES).indexOf(v)\n      const fApplyMultiNode = function (node: LGraphNode) {\n        if (kV !== -1 && LiteGraph.NODE_MODES[kV]) {\n          node.changeMode(kV)\n        } else {\n          console.warn(`unexpected mode: ${v}`)\n          node.changeMode(LGraphEventMode.ALWAYS)\n        }\n      }\n\n      const graphcanvas = LGraphCanvas.active_canvas\n      if (!graphcanvas.selected_nodes || Object.keys(graphcanvas.selected_nodes).length <= 1) {\n        fApplyMultiNode(node)\n      } else {\n        for (const i in graphcanvas.selected_nodes) {\n          fApplyMultiNode(graphcanvas.selected_nodes[i])\n        }\n      }\n    }\n\n    return false\n  }\n\n  /** @param value Parameter is never used */\n  static onMenuNodeColors(\n    value: IContextMenuValue<string | null>,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu<string | null>,\n    node: LGraphNode,\n  ): boolean {\n    if (!node) throw \"no node for color\"\n\n    const values: IContextMenuValue<string | null, unknown, { value: string | null }>[] = []\n    values.push({\n      value: null,\n      content: \"<span style='display: block; padding-left: 4px;'>No color</span>\",\n    })\n\n    for (const i in LGraphCanvas.node_colors) {\n      const color = LGraphCanvas.node_colors[i]\n      value = {\n        value: i,\n        content: `<span style='display: block; color: #999; padding-left: 4px;` +\n          ` border-left: 8px solid ${color.color}; background-color:${color.bgcolor}'>${i}</span>`,\n      }\n      values.push(value)\n    }\n    new LiteGraph.ContextMenu<string | null>(values, {\n      event: e,\n      callback: inner_clicked,\n      parentMenu: menu,\n      node,\n    })\n\n    function inner_clicked(v: IContextMenuValue<string>) {\n      if (!node) return\n\n      const fApplyColor = function (item: IColorable) {\n        const colorOption = v.value ? LGraphCanvas.node_colors[v.value] : null\n        item.setColorOption(colorOption)\n      }\n\n      const canvas = LGraphCanvas.active_canvas\n      if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {\n        fApplyColor(node)\n      } else {\n        for (const i in canvas.selected_nodes) {\n          fApplyColor(canvas.selected_nodes[i])\n        }\n      }\n      canvas.setDirty(true, true)\n    }\n\n    return false\n  }\n\n  static onMenuNodeShapes(\n    value: IContextMenuValue<typeof LiteGraph.VALID_SHAPES[number]>,\n    options: IContextMenuOptions<typeof LiteGraph.VALID_SHAPES[number]>,\n    e: MouseEvent,\n    menu?: ContextMenu<typeof LiteGraph.VALID_SHAPES[number]>,\n    node?: LGraphNode,\n  ): boolean {\n    if (!node) throw \"no node passed\"\n\n    new LiteGraph.ContextMenu<typeof LiteGraph.VALID_SHAPES[number]>(LiteGraph.VALID_SHAPES, {\n      event: e,\n      callback: inner_clicked,\n      parentMenu: menu,\n      node,\n    })\n\n    function inner_clicked(v: typeof LiteGraph.VALID_SHAPES[number]) {\n      if (!node) return\n      if (!node.graph) throw new NullGraphError()\n\n      node.graph.beforeChange()\n\n      const fApplyMultiNode = function (node: LGraphNode) {\n        node.shape = v\n      }\n\n      const canvas = LGraphCanvas.active_canvas\n      if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {\n        fApplyMultiNode(node)\n      } else {\n        for (const i in canvas.selected_nodes) {\n          fApplyMultiNode(canvas.selected_nodes[i])\n        }\n      }\n\n      node.graph.afterChange()\n      canvas.setDirty(true)\n    }\n\n    return false\n  }\n\n  static onMenuNodeRemove(): void {\n    LGraphCanvas.active_canvas.deleteSelected()\n  }\n\n  static onMenuNodeClone(\n    value: IContextMenuValue,\n    options: IContextMenuOptions,\n    e: MouseEvent,\n    menu: ContextMenu,\n    node: LGraphNode,\n  ): void {\n    const { graph } = node\n    if (!graph) throw new NullGraphError()\n    graph.beforeChange()\n\n    const newSelected = new Set<LGraphNode>()\n\n    const fApplyMultiNode = function (node: LGraphNode, newNodes: Set<LGraphNode>): void {\n      if (node.clonable === false) return\n\n      const newnode = node.clone()\n      if (!newnode) return\n\n      newnode.pos = [node.pos[0] + 5, node.pos[1] + 5]\n      if (!node.graph) throw new NullGraphError()\n\n      node.graph.add(newnode)\n      newNodes.add(newnode)\n    }\n\n    const canvas = LGraphCanvas.active_canvas\n    if (!canvas.selected_nodes || Object.keys(canvas.selected_nodes).length <= 1) {\n      fApplyMultiNode(node, newSelected)\n    } else {\n      for (const i in canvas.selected_nodes) {\n        fApplyMultiNode(canvas.selected_nodes[i], newSelected)\n      }\n    }\n\n    if (newSelected.size) {\n      canvas.selectNodes([...newSelected])\n    }\n\n    graph.afterChange()\n\n    canvas.setDirty(true, true)\n  }\n\n  /**\n   * clears all the data inside\n   *\n   */\n  clear(): void {\n    this.frame = 0\n    this.last_draw_time = 0\n    this.render_time = 0\n    this.fps = 0\n\n    // this.scale = 1;\n    // this.offset = [0,0];\n    this.dragging_rectangle = null\n\n    this.selected_nodes = {}\n    this.selected_group = null\n    this.selectedItems.clear()\n    this.state.selectionChanged = true\n    this.onSelectionChange?.(this.selected_nodes)\n\n    this.visible_nodes = []\n    this.node_over = undefined\n    this.node_capturing_input = null\n    this.connecting_links = null\n    this.highlighted_links = {}\n\n    this.dragging_canvas = false\n\n    this.#dirty()\n    this.dirty_area = null\n\n    this.node_in_panel = null\n    this.node_widget = null\n\n    this.last_mouse = [0, 0]\n    this.last_mouseclick = 0\n    this.pointer.reset()\n    this.visible_area.set([0, 0, 0, 0])\n\n    this.onClear?.()\n  }\n\n  /**\n   * Assigns a new graph to this canvas.\n   */\n  setGraph(newGraph: LGraph | Subgraph): void {\n    const { graph } = this\n    if (newGraph === graph) return\n\n    const options = {\n      bubbles: true,\n      detail: { newGraph, oldGraph: graph },\n    }\n\n    this.clear()\n    newGraph.attachCanvas(this)\n\n    this.canvas.dispatchEvent(new CustomEvent(\"litegraph:set-graph\", options))\n    this.#dirty()\n  }\n\n  /**\n   * @returns the visually active graph (in case there are more in the stack)\n   */\n  getCurrentGraph(): LGraph | null {\n    return this.graph\n  }\n\n  /**\n   * Finds the canvas if required, throwing on failure.\n   * @param canvas Canvas element, or its element ID\n   * @returns The canvas element\n   * @throws If {@link canvas} is an element ID that does not belong to a valid HTML canvas element\n   */\n  #validateCanvas(\n    canvas: string | HTMLCanvasElement,\n  ): HTMLCanvasElement & { data?: LGraphCanvas } {\n    if (typeof canvas === \"string\") {\n      const el = document.getElementById(canvas)\n      if (!(el instanceof HTMLCanvasElement)) throw \"Error validating LiteGraph canvas: Canvas element not found\"\n      return el\n    }\n    return canvas\n  }\n\n  /**\n   * Sets the current HTML canvas element.\n   * Calls bindEvents to add input event listeners, and (re)creates the background canvas.\n   * @param canvas The canvas element to assign, or its HTML element ID.  If null or undefined, the current reference is cleared.\n   * @param skip_events If true, events on the previous canvas will not be removed.  Has no effect on the first invocation.\n   */\n  setCanvas(canvas: string | HTMLCanvasElement, skip_events?: boolean) {\n    const element = this.#validateCanvas(canvas)\n    if (element === this.canvas) return\n    // maybe detach events from old_canvas\n    if (!element && this.canvas && !skip_events) this.unbindEvents()\n\n    this.canvas = element\n    this.ds.element = element\n    this.pointer.element = element\n\n    if (!element) return\n\n    // TODO: classList.add\n    element.className += \" lgraphcanvas\"\n    element.data = this\n\n    // Background canvas: To render objects behind nodes (background, links, groups)\n    this.bgcanvas = document.createElement(\"canvas\")\n    this.bgcanvas.width = this.canvas.width\n    this.bgcanvas.height = this.canvas.height\n\n    const ctx = element.getContext?.(\"2d\")\n    if (ctx == null) {\n      if (element.localName != \"canvas\") {\n        throw `Element supplied for LGraphCanvas must be a <canvas> element, you passed a ${element.localName}`\n      }\n      throw \"This browser doesn't support Canvas\"\n    }\n    this.ctx = ctx\n\n    if (!skip_events) this.bindEvents()\n  }\n\n  /** Captures an event and prevents default - returns false. */\n  _doNothing(e: Event): boolean {\n    // console.log(\"pointerevents: _doNothing \"+e.type);\n    e.preventDefault()\n    return false\n  }\n\n  /** Captures an event and prevents default - returns true. */\n  _doReturnTrue(e: Event): boolean {\n    e.preventDefault()\n    return true\n  }\n\n  /**\n   * binds mouse, keyboard, touch and drag events to the canvas\n   */\n  bindEvents(): void {\n    if (this._events_binded) {\n      console.warn(\"LGraphCanvas: events already binded\")\n      return\n    }\n\n    const { canvas } = this\n    // hack used when moving canvas between windows\n    const { document } = this.getCanvasWindow()\n\n    this._mousedown_callback = this.processMouseDown.bind(this)\n    this._mousewheel_callback = this.processMouseWheel.bind(this)\n    this._mousemove_callback = this.processMouseMove.bind(this)\n    this._mouseup_callback = this.processMouseUp.bind(this)\n    this._mouseout_callback = this.processMouseOut.bind(this)\n    this._mousecancel_callback = this.processMouseCancel.bind(this)\n\n    canvas.addEventListener(\"pointerdown\", this._mousedown_callback, true)\n    canvas.addEventListener(\"wheel\", this._mousewheel_callback, false)\n\n    canvas.addEventListener(\"pointerup\", this._mouseup_callback, true)\n    canvas.addEventListener(\"pointermove\", this._mousemove_callback)\n    canvas.addEventListener(\"pointerout\", this._mouseout_callback)\n    canvas.addEventListener(\"pointercancel\", this._mousecancel_callback, true)\n\n    canvas.addEventListener(\"contextmenu\", this._doNothing)\n\n    // Keyboard\n    this._key_callback = this.processKey.bind(this)\n\n    canvas.addEventListener(\"keydown\", this._key_callback, true)\n    // keyup event must be bound on the document\n    document.addEventListener(\"keyup\", this._key_callback, true)\n\n    canvas.addEventListener(\"dragover\", this._doNothing, false)\n    canvas.addEventListener(\"dragend\", this._doNothing, false)\n    canvas.addEventListener(\"dragenter\", this._doReturnTrue, false)\n\n    this._events_binded = true\n  }\n\n  /**\n   * unbinds mouse events from the canvas\n   */\n  unbindEvents(): void {\n    if (!this._events_binded) {\n      console.warn(\"LGraphCanvas: no events binded\")\n      return\n    }\n\n    // console.log(\"pointerevents: unbindEvents\");\n    const { document } = this.getCanvasWindow()\n    const { canvas } = this\n\n    // Assertions: removing nullish is fine.\n    canvas.removeEventListener(\"pointercancel\", this._mousecancel_callback!)\n    canvas.removeEventListener(\"pointerout\", this._mouseout_callback!)\n    canvas.removeEventListener(\"pointermove\", this._mousemove_callback!)\n    canvas.removeEventListener(\"pointerup\", this._mouseup_callback!)\n    canvas.removeEventListener(\"pointerdown\", this._mousedown_callback!)\n    canvas.removeEventListener(\"wheel\", this._mousewheel_callback!)\n    canvas.removeEventListener(\"keydown\", this._key_callback!)\n    document.removeEventListener(\"keyup\", this._key_callback!)\n    canvas.removeEventListener(\"contextmenu\", this._doNothing)\n    canvas.removeEventListener(\"dragenter\", this._doReturnTrue)\n\n    this._mousedown_callback = undefined\n    this._mousewheel_callback = undefined\n    this._key_callback = undefined\n\n    this._events_binded = false\n  }\n\n  /**\n   * Ensures the canvas will be redrawn on the next frame by setting the dirty flag(s).\n   * Without parameters, this function does nothing.\n   * @todo Impl. `setDirty()` or similar as shorthand to redraw everything.\n   * @param fgcanvas If true, marks the foreground canvas as dirty (nodes and anything drawn on top of them).  Default: false\n   * @param bgcanvas If true, mark the background canvas as dirty (background, groups, links).  Default: false\n   */\n  setDirty(fgcanvas: boolean, bgcanvas?: boolean): void {\n    if (fgcanvas) this.dirty_canvas = true\n    if (bgcanvas) this.dirty_bgcanvas = true\n  }\n\n  /** Marks the entire canvas as dirty. */\n  #dirty(): void {\n    this.dirty_canvas = true\n    this.dirty_bgcanvas = true\n  }\n\n  #linkConnectorDrop(): void {\n    const { graph, linkConnector, pointer } = this\n    if (!graph) throw new NullGraphError()\n\n    pointer.onDragEnd = upEvent => linkConnector.dropLinks(graph, upEvent)\n    pointer.finally = () => {\n      this.linkConnector.reset(true)\n      this.#dirty()\n    }\n  }\n\n  /**\n   * Used to attach the canvas in a popup\n   * @returns returns the window where the canvas is attached (the DOM root node)\n   */\n  getCanvasWindow(): Window {\n    if (!this.canvas) return window\n\n    const doc = this.canvas.ownerDocument\n    // @ts-expect-error Check if required\n    return doc.defaultView || doc.parentWindow\n  }\n\n  /**\n   * starts rendering the content of the canvas when needed\n   *\n   */\n  startRendering(): void {\n    // already rendering\n    if (this.is_rendering) return\n\n    this.is_rendering = true\n    renderFrame.call(this)\n\n    /** Render loop */\n    function renderFrame(this: LGraphCanvas) {\n      if (!this.pause_rendering) {\n        this.draw()\n      }\n\n      const window = this.getCanvasWindow()\n      if (this.is_rendering) {\n        if (this.#maximumFrameGap > 0) {\n          // Manual FPS limit\n          const gap = this.#maximumFrameGap - (LiteGraph.getTime() - this.last_draw_time)\n          setTimeout(renderFrame.bind(this), Math.max(1, gap))\n        } else {\n          // FPS limited by refresh rate\n          window.requestAnimationFrame(renderFrame.bind(this))\n        }\n      }\n    }\n  }\n\n  /**\n   * stops rendering the content of the canvas (to save resources)\n   *\n   */\n  stopRendering(): void {\n    this.is_rendering = false\n    /*\n    if(this.rendering_timer_id)\n    {\n        clearInterval(this.rendering_timer_id);\n        this.rendering_timer_id = null;\n    }\n    */\n  }\n\n  /* LiteGraphCanvas input */\n  // used to block future mouse events (because of im gui)\n  blockClick(): void {\n    this.block_click = true\n    this.last_mouseclick = 0\n  }\n\n  /**\n   * Gets the widget at the current cursor position.\n   * @param node Optional node to check for widgets under cursor\n   * @returns The widget located at the current cursor position, if any is found.\n   * @deprecated Use {@link LGraphNode.getWidgetOnPos} instead.\n   * ```ts\n   * const [x, y] = canvas.graph_mouse\n   * const widget = canvas.node_over?.getWidgetOnPos(x, y, true)\n   * ```\n   */\n  getWidgetAtCursor(node?: LGraphNode): IBaseWidget | undefined {\n    node ??= this.node_over\n    return node?.getWidgetOnPos(this.graph_mouse[0], this.graph_mouse[1], true)\n  }\n\n  /**\n   * Clears highlight and mouse-over information from nodes that should not have it.\n   *\n   * Intended to be called when the pointer moves away from a node.\n   * @param node The node that the mouse is now over\n   * @param e MouseEvent that is triggering this\n   */\n  updateMouseOverNodes(node: LGraphNode | null, e: CanvasMouseEvent): void {\n    if (!this.graph) throw new NullGraphError()\n\n    const nodes = this.graph._nodes\n    for (const otherNode of nodes) {\n      if (otherNode.mouseOver && node != otherNode) {\n        // mouse leave\n        otherNode.mouseOver = undefined\n        this._highlight_input = undefined\n        this._highlight_pos = undefined\n        this.linkConnector.overWidget = undefined\n\n        // Hover transitions\n        // TODO: Implement single lerp ease factor for current progress on hover in/out.\n        // In drawNode, multiply by ease factor and differential value (e.g. bg alpha +0.5).\n        otherNode.lostFocusAt = LiteGraph.getTime()\n\n        this.node_over?.onMouseLeave?.(e)\n        this.node_over = undefined\n        this.dirty_canvas = true\n      }\n    }\n  }\n\n  processMouseDown(e: PointerEvent): void {\n    if (this.dragZoomEnabled && e.ctrlKey && e.shiftKey && !e.altKey && e.buttons) {\n      this.#dragZoomStart = { pos: [e.x, e.y], scale: this.ds.scale }\n      return\n    }\n\n    const { graph, pointer } = this\n    this.adjustMouseEvent(e)\n    if (e.isPrimary) pointer.down(e)\n\n    if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true\n\n    if (!graph) return\n\n    const ref_window = this.getCanvasWindow()\n    LGraphCanvas.active_canvas = this\n\n    const x = e.clientX\n    const y = e.clientY\n    this.ds.viewport = this.viewport\n    const is_inside = !this.viewport || isInRect(x, y, this.viewport)\n\n    if (!is_inside) return\n\n    const node = graph.getNodeOnPos(e.canvasX, e.canvasY, this.visible_nodes) ?? undefined\n\n    this.mouse[0] = x\n    this.mouse[1] = y\n    this.graph_mouse[0] = e.canvasX\n    this.graph_mouse[1] = e.canvasY\n    this.last_click_position = [this.mouse[0], this.mouse[1]]\n\n    pointer.isDouble = pointer.isDown && e.isPrimary\n    pointer.isDown = true\n\n    this.canvas.focus()\n\n    LiteGraph.closeAllContextMenus(ref_window)\n\n    if (this.onMouse?.(e) == true) return\n\n    // left button mouse / single finger\n    if (e.button === 0 && !pointer.isDouble) {\n      this.#processPrimaryButton(e, node)\n    } else if (e.button === 1) {\n      this.#processMiddleButton(e, node)\n    } else if (\n      (e.button === 2 || pointer.isDouble) &&\n      this.allow_interaction &&\n      !this.read_only\n    ) {\n      // Right / aux button\n\n      // Sticky select - won't remove single nodes\n      if (node) {\n        this.processSelect(node, e, true)\n      } else if (this.links_render_mode !== LinkRenderType.HIDDEN_LINK) {\n        // Reroutes\n        const reroute = graph.getRerouteOnPos(e.canvasX, e.canvasY, this.#visibleReroutes)\n        if (reroute) {\n          if (e.altKey) {\n            pointer.onClick = (upEvent) => {\n              if (upEvent.altKey) {\n                // Ensure deselected\n                if (reroute.selected) {\n                  this.deselect(reroute)\n                  this.onSelectionChange?.(this.selected_nodes)\n                }\n                reroute.remove()\n              }\n            }\n          } else {\n            this.processSelect(reroute, e, true)\n          }\n        }\n      }\n\n      // Show context menu for the node or group under the pointer\n      pointer.onClick ??= () => this.processContextMenu(node, e)\n    }\n\n    this.last_mouse = [x, y]\n    this.last_mouseclick = LiteGraph.getTime()\n    this.last_mouse_dragging = true\n\n    graph.change()\n\n    // this is to ensure to defocus(blur) if a text input element is on focus\n    if (\n      !ref_window.document.activeElement ||\n      (ref_window.document.activeElement.nodeName.toLowerCase() != \"input\" &&\n        ref_window.document.activeElement.nodeName.toLowerCase() != \"textarea\")\n    ) {\n      e.preventDefault()\n    }\n    e.stopPropagation()\n\n    this.onMouseDown?.(e)\n  }\n\n  #processPrimaryButton(e: CanvasPointerEvent, node: LGraphNode | undefined) {\n    const { pointer, graph, linkConnector } = this\n    if (!graph) throw new NullGraphError()\n\n    const x = e.canvasX\n    const y = e.canvasY\n\n    // Modifiers\n    const ctrlOrMeta = e.ctrlKey || e.metaKey\n\n    // Multi-select drag rectangle\n    if (ctrlOrMeta && !e.altKey) {\n      const dragRect = new Float32Array(4)\n      dragRect[0] = x\n      dragRect[1] = y\n      dragRect[2] = 1\n      dragRect[3] = 1\n\n      pointer.onClick = (eUp) => {\n        // Click, not drag\n        const clickedItem = node ??\n          graph.getRerouteOnPos(eUp.canvasX, eUp.canvasY, this.#visibleReroutes) ??\n          graph.getGroupTitlebarOnPos(eUp.canvasX, eUp.canvasY)\n        this.processSelect(clickedItem, eUp)\n      }\n      pointer.onDragStart = () => this.dragging_rectangle = dragRect\n      pointer.onDragEnd = upEvent => this.#handleMultiSelect(upEvent, dragRect)\n      pointer.finally = () => this.dragging_rectangle = null\n      return\n    }\n\n    if (this.read_only) {\n      pointer.finally = () => this.dragging_canvas = false\n      this.dragging_canvas = true\n      return\n    }\n\n    // clone node ALT dragging\n    if (LiteGraph.alt_drag_do_clone_nodes && e.altKey && !e.ctrlKey && node && this.allow_interaction) {\n      const node_data = node.clone()?.serialize()\n      if (node_data?.type != null) {\n        const cloned = LiteGraph.createNode(node_data.type)\n        if (cloned) {\n          cloned.configure(node_data)\n          cloned.pos[0] += 5\n          cloned.pos[1] += 5\n\n          if (this.allow_dragnodes) {\n            pointer.onDragStart = (pointer) => {\n              graph.add(cloned, false)\n              this.#startDraggingItems(cloned, pointer)\n            }\n            pointer.onDragEnd = e => this.#processDraggedItems(e)\n          } else {\n          // TODO: Check if before/after change are necessary here.\n            graph.beforeChange()\n            graph.add(cloned, false)\n            graph.afterChange()\n          }\n\n          return\n        }\n      }\n    }\n\n    // Node clicked\n    if (node && (this.allow_interaction || node.flags.allow_interaction)) {\n      this.#processNodeClick(e, ctrlOrMeta, node)\n    } else {\n      // Reroutes\n      if (this.links_render_mode !== LinkRenderType.HIDDEN_LINK) {\n        for (const reroute of this.#visibleReroutes) {\n          const overReroute = reroute.containsPoint([x, y])\n          if (!reroute.isSlotHovered && !overReroute) continue\n\n          if (overReroute) {\n            pointer.onClick = () => this.processSelect(reroute, e)\n            if (!e.shiftKey) {\n              pointer.onDragStart = pointer => this.#startDraggingItems(reroute, pointer, true)\n              pointer.onDragEnd = e => this.#processDraggedItems(e)\n            }\n          }\n\n          if (reroute.isOutputHovered || (overReroute && e.shiftKey)) {\n            linkConnector.dragFromReroute(graph, reroute)\n            this.#linkConnectorDrop()\n          }\n\n          if (reroute.isInputHovered) {\n            linkConnector.dragFromRerouteToOutput(graph, reroute)\n            this.#linkConnectorDrop()\n          }\n\n          reroute.hideSlots()\n          this.dirty_bgcanvas = true\n          return\n        }\n      }\n\n      // Links - paths of links & reroutes\n      // Set the width of the line for isPointInStroke checks\n      const { lineWidth } = this.ctx\n      this.ctx.lineWidth = this.connections_width + 7\n      const dpi = window?.devicePixelRatio || 1\n\n      for (const linkSegment of this.renderedPaths) {\n        const centre = linkSegment._pos\n        if (!centre) continue\n\n        // If we shift click on a link then start a link from that input\n        if (\n          (e.shiftKey || e.altKey) &&\n          linkSegment.path &&\n          this.ctx.isPointInStroke(linkSegment.path, x * dpi, y * dpi)\n        ) {\n          this.ctx.lineWidth = lineWidth\n\n          if (e.shiftKey && !e.altKey) {\n            linkConnector.dragFromLinkSegment(graph, linkSegment)\n            this.#linkConnectorDrop()\n\n            return\n          } else if (e.altKey && !e.shiftKey) {\n            const newReroute = graph.createReroute([x, y], linkSegment)\n            pointer.onDragStart = pointer => this.#startDraggingItems(newReroute, pointer)\n            pointer.onDragEnd = e => this.#processDraggedItems(e)\n            return\n          }\n        } else if (isInRectangle(x, y, centre[0] - 4, centre[1] - 4, 8, 8)) {\n          this.ctx.lineWidth = lineWidth\n\n          pointer.onClick = () => this.showLinkMenu(linkSegment, e)\n          pointer.onDragStart = () => this.dragging_canvas = true\n          pointer.finally = () => this.dragging_canvas = false\n\n          // clear tooltip\n          this.over_link_center = undefined\n          return\n        }\n      }\n\n      // Restore line width\n      this.ctx.lineWidth = lineWidth\n\n      // Groups\n      const group = graph.getGroupOnPos(x, y)\n      this.selected_group = group ?? null\n      if (group) {\n        if (group.isInResize(x, y)) {\n          // Resize group\n          const b = group.boundingRect\n          const offsetX = x - (b[0] + b[2])\n          const offsetY = y - (b[1] + b[3])\n\n          pointer.onDragStart = () => this.resizingGroup = group\n          pointer.onDrag = (eMove) => {\n            if (this.read_only) return\n\n            // Resize only by the exact pointer movement\n            const pos: Point = [\n              eMove.canvasX - group.pos[0] - offsetX,\n              eMove.canvasY - group.pos[1] - offsetY,\n            ]\n            // Unless snapping.\n            if (this.#snapToGrid) snapPoint(pos, this.#snapToGrid)\n\n            const resized = group.resize(pos[0], pos[1])\n            if (resized) this.dirty_bgcanvas = true\n          }\n          pointer.finally = () => this.resizingGroup = null\n        } else {\n          const f = group.font_size || LiteGraph.DEFAULT_GROUP_FONT_SIZE\n          const headerHeight = f * 1.4\n          if (\n            isInRectangle(\n              x,\n              y,\n              group.pos[0],\n              group.pos[1],\n              group.size[0],\n              headerHeight,\n            )\n          ) {\n            // In title bar\n            pointer.onClick = () => this.processSelect(group, e)\n            pointer.onDragStart = (pointer) => {\n              group.recomputeInsideNodes()\n              this.#startDraggingItems(group, pointer, true)\n            }\n            pointer.onDragEnd = e => this.#processDraggedItems(e)\n          }\n        }\n\n        pointer.onDoubleClick = () => {\n          this.emitEvent({\n            subType: \"group-double-click\",\n            originalEvent: e,\n            group,\n          })\n        }\n      } else {\n        pointer.onDoubleClick = () => {\n          // Double click within group should not trigger the searchbox.\n          if (this.allow_searchbox) {\n            this.showSearchBox(e)\n            e.preventDefault()\n          }\n          this.emitEvent({\n            subType: \"empty-double-click\",\n            originalEvent: e,\n          })\n        }\n      }\n    }\n\n    if (\n      !pointer.onDragStart &&\n      !pointer.onClick &&\n      !pointer.onDrag &&\n      this.allow_dragcanvas\n    ) {\n      pointer.onClick = () => this.processSelect(null, e)\n      pointer.finally = () => this.dragging_canvas = false\n      this.dragging_canvas = true\n    }\n  }\n\n  /**\n   * Processes a pointerdown event inside the bounds of a node.  Part of {@link processMouseDown}.\n   * @param e The pointerdown event\n   * @param ctrlOrMeta Ctrl or meta key is pressed\n   * @param node The node to process a click event for\n   */\n  #processNodeClick(\n    e: CanvasPointerEvent,\n    ctrlOrMeta: boolean,\n    node: LGraphNode,\n  ): void {\n    const { pointer, graph, linkConnector } = this\n    if (!graph) throw new NullGraphError()\n\n    const x = e.canvasX\n    const y = e.canvasY\n\n    pointer.onClick = () => this.processSelect(node, e)\n\n    // Immediately bring to front\n    if (!node.flags.pinned) {\n      this.bringToFront(node)\n    }\n\n    // Collapse toggle\n    const inCollapse = node.isPointInCollapse(x, y)\n    if (inCollapse) {\n      pointer.onClick = () => {\n        node.collapse()\n        this.setDirty(true, true)\n      }\n    } else if (!node.flags.collapsed) {\n      // Resize node\n      if (node.resizable !== false && node.inResizeCorner(x, y)) {\n        const b = node.boundingRect\n        const offsetX = x - (b[0] + b[2])\n        const offsetY = y - (b[1] + b[3])\n\n        pointer.onDragStart = () => {\n          graph.beforeChange()\n          this.resizing_node = node\n        }\n\n        pointer.onDrag = (eMove) => {\n          if (this.read_only) return\n\n          // Resize only by the exact pointer movement\n          const pos: Point = [\n            eMove.canvasX - node.pos[0] - offsetX,\n            eMove.canvasY - node.pos[1] - offsetY,\n          ]\n          // Unless snapping.\n          if (this.#snapToGrid) snapPoint(pos, this.#snapToGrid)\n\n          const min = node.computeSize()\n          pos[0] = Math.max(min[0], pos[0])\n          pos[1] = Math.max(min[1], pos[1])\n          node.setSize(pos)\n\n          this.#dirty()\n        }\n\n        pointer.onDragEnd = () => {\n          this.#dirty()\n          graph.afterChange(this.resizing_node)\n        }\n        pointer.finally = () => this.resizing_node = null\n        this.canvas.style.cursor = \"se-resize\"\n        return\n      }\n\n      const { inputs, outputs } = node\n\n      // Outputs\n      if (outputs) {\n        for (const [i, output] of outputs.entries()) {\n          const link_pos = node.getOutputPos(i)\n          if (isInRectangle(x, y, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n            // Drag multiple output links\n            if (e.shiftKey && (output.links?.length || output._floatingLinks?.size)) {\n              linkConnector.moveOutputLink(graph, output)\n              this.#linkConnectorDrop()\n              return\n            }\n\n            // New output link\n            linkConnector.dragNewFromOutput(graph, node, output)\n            this.#linkConnectorDrop()\n\n            if (LiteGraph.shift_click_do_break_link_from) {\n              if (e.shiftKey) {\n                node.disconnectOutput(i)\n              }\n            } else if (LiteGraph.ctrl_alt_click_do_break_link) {\n              if (ctrlOrMeta && e.altKey && !e.shiftKey) {\n                node.disconnectOutput(i)\n              }\n            }\n\n            // TODO: Move callbacks to the start of this closure (onInputClick is already correct).\n            pointer.onDoubleClick = () => node.onOutputDblClick?.(i, e)\n            pointer.onClick = () => node.onOutputClick?.(i, e)\n\n            return\n          }\n        }\n      }\n\n      // Inputs\n      if (inputs) {\n        for (const [i, input] of inputs.entries()) {\n          const link_pos = node.getInputPos(i)\n          const isInSlot = input instanceof NodeInputSlot\n            ? isInRect(x, y, input.boundingRect)\n            : isInRectangle(x, y, link_pos[0] - 15, link_pos[1] - 10, 30, 20)\n\n          if (isInSlot) {\n            pointer.onDoubleClick = () => node.onInputDblClick?.(i, e)\n            pointer.onClick = () => node.onInputClick?.(i, e)\n\n            const shouldBreakLink = LiteGraph.ctrl_alt_click_do_break_link &&\n              ctrlOrMeta &&\n              e.altKey &&\n              !e.shiftKey\n            if (input.link !== null || input._floatingLinks?.size) {\n              // Existing link\n              if (shouldBreakLink || LiteGraph.click_do_break_link_to) {\n                node.disconnectInput(i, true)\n              } else if (e.shiftKey || this.allow_reconnect_links) {\n                linkConnector.moveInputLink(graph, input)\n              }\n            }\n\n            // Dragging a new link from input to output\n            if (!linkConnector.isConnecting) {\n              linkConnector.dragNewFromInput(graph, node, input)\n            }\n\n            this.#linkConnectorDrop()\n            this.dirty_bgcanvas = true\n\n            return\n          }\n        }\n      }\n    }\n\n    // Click was inside the node, but not on input/output, or the resize corner\n    const pos: Point = [x - node.pos[0], y - node.pos[1]]\n\n    // Widget\n    const widget = node.getWidgetOnPos(x, y)\n    if (widget) {\n      this.#processWidgetClick(e, node, widget)\n      this.node_widget = [node, widget]\n    } else {\n      pointer.onDoubleClick = () => {\n        // Double-click\n        // Check if it's a double click on the title bar\n        // Note: pos[1] is the y-coordinate of the node's body\n        // If clicking on node header (title), pos[1] is negative\n        if (pos[1] < 0 && !inCollapse) {\n          node.onNodeTitleDblClick?.(e, pos, this)\n        }\n        node.onDblClick?.(e, pos, this)\n        this.emitEvent({\n          subType: \"node-double-click\",\n          originalEvent: e,\n          node,\n        })\n        this.processNodeDblClicked(node)\n      }\n\n      // Mousedown callback - can block drag\n      if (node.onMouseDown?.(e, pos, this) || !this.allow_dragnodes)\n        return\n\n      // Drag node\n      pointer.onDragStart = pointer => this.#startDraggingItems(node, pointer, true)\n      pointer.onDragEnd = e => this.#processDraggedItems(e)\n    }\n\n    this.dirty_canvas = true\n  }\n\n  #processWidgetClick(e: CanvasPointerEvent, node: LGraphNode, widget: IBaseWidget) {\n    const { pointer } = this\n\n    // Custom widget - CanvasPointer\n    if (typeof widget.onPointerDown === \"function\") {\n      const handled = widget.onPointerDown(pointer, node, this)\n      if (handled) return\n    }\n\n    const oldValue = widget.value\n\n    const pos = this.graph_mouse\n    const x = pos[0] - node.pos[0]\n    const y = pos[1] - node.pos[1]\n\n    const widgetInstance = toConcreteWidget(widget, node, false)\n    if (widgetInstance) {\n      pointer.onClick = () => widgetInstance.onClick({\n        e,\n        node,\n        canvas: this,\n      })\n      pointer.onDrag = eMove => widgetInstance.onDrag?.({\n        e: eMove,\n        node,\n        canvas: this,\n      })\n    } else if (widget.mouse) {\n      const result = widget.mouse(e, [x, y], node)\n      if (result != null) this.dirty_canvas = result\n    }\n\n    // value changed\n    if (oldValue != widget.value) {\n      node.onWidgetChanged?.(widget.name, widget.value, oldValue, widget)\n      if (!node.graph) throw new NullGraphError()\n      node.graph._version++\n    }\n\n    // Clean up state var\n    pointer.finally = () => {\n      // Legacy custom widget callback\n      if (widget.mouse) {\n        const { eUp } = pointer\n        if (!eUp) return\n        const { canvasX, canvasY } = eUp\n        widget.mouse(eUp, [canvasX - node.pos[0], canvasY - node.pos[1]], node)\n      }\n\n      this.node_widget = null\n    }\n  }\n\n  /**\n   * Pointer middle button click processing.  Part of {@link processMouseDown}.\n   * @param e The pointerdown event\n   * @param node The node to process a click event for\n   */\n  #processMiddleButton(e: CanvasPointerEvent, node: LGraphNode | undefined) {\n    const { pointer } = this\n\n    if (\n      LiteGraph.middle_click_slot_add_default_node &&\n      node &&\n      this.allow_interaction &&\n      !this.read_only &&\n      !this.connecting_links &&\n      !node.flags.collapsed\n    ) {\n      // not dragging mouse to connect two slots\n      let mClikSlot: INodeSlot | false = false\n      let mClikSlot_index: number | false = false\n      let mClikSlot_isOut: boolean = false\n      const { inputs, outputs } = node\n\n      // search for outputs\n      if (outputs) {\n        for (const [i, output] of outputs.entries()) {\n          const link_pos = node.getOutputPos(i)\n          if (isInRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n            mClikSlot = output\n            mClikSlot_index = i\n            mClikSlot_isOut = true\n            break\n          }\n        }\n      }\n\n      // search for inputs\n      if (inputs) {\n        for (const [i, input] of inputs.entries()) {\n          const link_pos = node.getInputPos(i)\n          if (isInRectangle(e.canvasX, e.canvasY, link_pos[0] - 15, link_pos[1] - 10, 30, 20)) {\n            mClikSlot = input\n            mClikSlot_index = i\n            mClikSlot_isOut = false\n            break\n          }\n        }\n      }\n      // Middle clicked a slot\n      if (mClikSlot && mClikSlot_index !== false) {\n        const alphaPosY =\n          0.5 -\n          (mClikSlot_index + 1) /\n          (mClikSlot_isOut ? outputs.length : inputs.length)\n        const node_bounding = node.getBounding()\n        // estimate a position: this is a bad semi-bad-working mess .. REFACTOR with\n        // a correct autoplacement that knows about the others slots and nodes\n        const posRef: Point = [\n          !mClikSlot_isOut\n            ? node_bounding[0]\n            : node_bounding[0] + node_bounding[2],\n          e.canvasY - 80,\n        ]\n\n        pointer.onClick = () => this.createDefaultNodeForSlot({\n          nodeFrom: !mClikSlot_isOut ? null : node,\n          slotFrom: !mClikSlot_isOut ? null : mClikSlot_index,\n          nodeTo: !mClikSlot_isOut ? node : null,\n          slotTo: !mClikSlot_isOut ? mClikSlot_index : null,\n          position: posRef,\n          nodeType: \"AUTO\",\n          posAdd: [!mClikSlot_isOut ? -30 : 30, -alphaPosY * 130],\n          posSizeFix: [!mClikSlot_isOut ? -1 : 0, 0],\n        })\n      }\n    }\n\n    // Drag canvas using middle mouse button\n    if (this.allow_dragcanvas) {\n      pointer.onDragStart = () => this.dragging_canvas = true\n      pointer.finally = () => this.dragging_canvas = false\n    }\n  }\n\n  #processDragZoom(e: PointerEvent): void {\n    // stop canvas zoom action\n    if (!e.buttons) {\n      this.#dragZoomStart = null\n      return\n    }\n\n    const start = this.#dragZoomStart\n    if (!start) throw new TypeError(\"Drag-zoom state object was null\")\n    if (!this.graph) throw new NullGraphError()\n\n    // calculate delta\n    const deltaY = e.y - start.pos[1]\n    const startScale = start.scale\n\n    const scale = startScale - deltaY / 100\n\n    this.ds.changeScale(scale, start.pos)\n    this.graph.change()\n  }\n\n  /**\n   * Called when a mouse move event has to be processed\n   */\n  processMouseMove(e: PointerEvent): void {\n    if (this.dragZoomEnabled && e.ctrlKey && e.shiftKey && this.#dragZoomStart) {\n      this.#processDragZoom(e)\n      return\n    }\n\n    if (this.autoresize) this.resize()\n\n    if (this.set_canvas_dirty_on_mouse_event) this.dirty_canvas = true\n\n    const { graph, resizingGroup, linkConnector } = this\n    if (!graph) return\n\n    LGraphCanvas.active_canvas = this\n    this.adjustMouseEvent(e)\n    const mouse: ReadOnlyPoint = [e.clientX, e.clientY]\n    this.mouse[0] = mouse[0]\n    this.mouse[1] = mouse[1]\n    const delta = [\n      mouse[0] - this.last_mouse[0],\n      mouse[1] - this.last_mouse[1],\n    ]\n    this.last_mouse = mouse\n    this.graph_mouse[0] = e.canvasX\n    this.graph_mouse[1] = e.canvasY\n\n    if (e.isPrimary) this.pointer.move(e)\n\n    if (this.block_click) {\n      e.preventDefault()\n      return\n    }\n\n    e.dragging = this.last_mouse_dragging\n\n    if (this.node_widget) {\n      // Legacy widget mouse callbacks for pointermove events\n      const [node, widget] = this.node_widget\n\n      if (widget?.mouse) {\n        const x = e.canvasX - node.pos[0]\n        const y = e.canvasY - node.pos[1]\n        const result = widget.mouse(e, [x, y], node)\n        if (result != null) this.dirty_canvas = result\n      }\n    }\n\n    /** See {@link state}.{@link LGraphCanvasState.hoveringOver hoveringOver} */\n    let underPointer = CanvasItem.Nothing\n    // get node over\n    const node = graph.getNodeOnPos(\n      e.canvasX,\n      e.canvasY,\n      this.visible_nodes,\n    )\n\n    const dragRect = this.dragging_rectangle\n    if (dragRect) {\n      dragRect[2] = e.canvasX - dragRect[0]\n      dragRect[3] = e.canvasY - dragRect[1]\n      this.dirty_canvas = true\n    } else if (resizingGroup) {\n      // Resizing a group\n      underPointer |= CanvasItem.ResizeSe | CanvasItem.Group\n    } else if (this.dragging_canvas) {\n      this.ds.offset[0] += delta[0] / this.ds.scale\n      this.ds.offset[1] += delta[1] / this.ds.scale\n      this.#dirty()\n    } else if (\n      (this.allow_interaction || node?.flags.allow_interaction) &&\n      !this.read_only\n    ) {\n      if (linkConnector.isConnecting) this.dirty_canvas = true\n\n      // remove mouseover flag\n      this.updateMouseOverNodes(node, e)\n\n      // mouse over a node\n      if (node) {\n        underPointer |= CanvasItem.Node\n\n        if (node.redraw_on_mouse) this.dirty_canvas = true\n\n        // For input/output hovering\n        // to store the output of isOverNodeInput\n        const pos: Point = [0, 0]\n        const inputId = isOverNodeInput(node, e.canvasX, e.canvasY, pos)\n        const outputId = isOverNodeOutput(node, e.canvasX, e.canvasY, pos)\n        const overWidget = node.getWidgetOnPos(e.canvasX, e.canvasY, true) ?? undefined\n\n        if (!node.mouseOver) {\n          // mouse enter\n          node.mouseOver = {}\n          this.node_over = node\n          this.dirty_canvas = true\n\n          for (const reroute of this.#visibleReroutes) {\n            reroute.hideSlots()\n            this.dirty_bgcanvas = true\n          }\n          node.onMouseEnter?.(e)\n        }\n\n        // in case the node wants to do something\n        node.onMouseMove?.(e, [e.canvasX - node.pos[0], e.canvasY - node.pos[1]], this)\n\n        // The input the mouse is over has changed\n        const { mouseOver } = node\n        if (\n          mouseOver.inputId !== inputId ||\n          mouseOver.outputId !== outputId ||\n          mouseOver.overWidget !== overWidget\n        ) {\n          mouseOver.inputId = inputId\n          mouseOver.outputId = outputId\n          mouseOver.overWidget = overWidget\n\n          // State reset\n          linkConnector.overWidget = undefined\n\n          // Check if link is over anything it could connect to - record position of valid target for snap / highlight\n          if (linkConnector.isConnecting) {\n            const firstLink = linkConnector.renderLinks.at(0)\n\n            // Default: nothing highlighted\n            let highlightPos: Point | undefined\n            let highlightInput: INodeInputSlot | undefined\n\n            if (!firstLink || !linkConnector.isNodeValidDrop(node)) {\n              // No link, or none of the dragged links may be dropped here\n            } else if (linkConnector.state.connectingTo === \"input\") {\n              if (overWidget) {\n                // Check widgets first - inputId is only valid if over the input socket\n                const slot = node.getSlotFromWidget(overWidget)\n\n                if (slot && linkConnector.isInputValidDrop(node, slot)) {\n                  highlightInput = slot\n                  highlightPos = node.getInputSlotPos(slot)\n                  linkConnector.overWidget = overWidget\n                }\n              }\n\n              // Not over a valid widget - treat drop on invalid widget same as node background\n              if (!linkConnector.overWidget) {\n                if (inputId === -1 && outputId === -1) {\n                // Node background / title under the pointer\n                  const result = node.findInputByType(firstLink.fromSlot.type)\n                  if (result) {\n                    highlightInput = result.slot\n                    highlightPos = node.getInputSlotPos(result.slot)\n                  }\n                } else if (\n                  inputId != -1 &&\n                  node.inputs[inputId] &&\n                  LiteGraph.isValidConnection(firstLink.fromSlot.type, node.inputs[inputId].type)\n                ) {\n                  highlightPos = pos\n                  // XXX CHECK THIS\n                  highlightInput = node.inputs[inputId]\n                }\n\n                if (highlightInput) {\n                  const widget = node.getWidgetFromSlot(highlightInput)\n                  if (widget) linkConnector.overWidget = widget\n                }\n              }\n            } else if (linkConnector.state.connectingTo === \"output\") {\n              // Connecting from an input to an output\n              if (inputId === -1 && outputId === -1) {\n                const result = node.findOutputByType(firstLink.fromSlot.type)\n                if (result) {\n                  highlightPos = node.getOutputPos(result.index)\n                }\n              } else {\n                // check if I have a slot below de mouse\n                if (\n                  outputId != -1 &&\n                  node.outputs[outputId] &&\n                  LiteGraph.isValidConnection(firstLink.fromSlot.type, node.outputs[outputId].type)\n                ) {\n                  highlightPos = pos\n                }\n              }\n            }\n            this._highlight_pos = highlightPos\n            this._highlight_input = highlightInput\n          }\n\n          this.dirty_canvas = true\n        }\n\n        // Resize corner\n        if (node.inResizeCorner(e.canvasX, e.canvasY)) {\n          underPointer |= CanvasItem.ResizeSe\n        }\n      } else {\n        // Reroutes\n        underPointer = this.#updateReroutes(underPointer)\n\n        // Not over a node\n        const segment = this.#getLinkCentreOnPos(e)\n        if (this.over_link_center !== segment) {\n          underPointer |= CanvasItem.Link\n          this.over_link_center = segment\n          this.dirty_bgcanvas = true\n        }\n\n        if (this.canvas) {\n          const group = graph.getGroupOnPos(e.canvasX, e.canvasY)\n          if (\n            group &&\n            !e.ctrlKey &&\n            !this.read_only &&\n            group.isInResize(e.canvasX, e.canvasY)\n          ) {\n            underPointer |= CanvasItem.ResizeSe\n          }\n        }\n      }\n\n      // send event to node if capturing input (used with widgets that allow drag outside of the area of the node)\n      if (this.node_capturing_input && this.node_capturing_input != node) {\n        this.node_capturing_input.onMouseMove?.(\n          e,\n          [\n            e.canvasX - this.node_capturing_input.pos[0],\n            e.canvasY - this.node_capturing_input.pos[1],\n          ],\n          this,\n        )\n      }\n\n      // Items being dragged\n      if (this.isDragging) {\n        const selected = this.selectedItems\n        const allItems = e.ctrlKey ? selected : getAllNestedItems(selected)\n\n        const deltaX = delta[0] / this.ds.scale\n        const deltaY = delta[1] / this.ds.scale\n        for (const item of allItems) {\n          item.move(deltaX, deltaY, true)\n        }\n\n        this.#dirty()\n      }\n\n      if (this.resizing_node) underPointer |= CanvasItem.ResizeSe\n    }\n\n    this.hoveringOver = underPointer\n\n    e.preventDefault()\n    return\n  }\n\n  /**\n   * Updates the hover / snap state of all visible reroutes.\n   * @returns The original value of {@link underPointer}, with any found reroute items added.\n   */\n  #updateReroutes(underPointer: CanvasItem): CanvasItem {\n    const { graph, pointer, linkConnector } = this\n    if (!graph) throw new NullGraphError()\n\n    // Update reroute hover state\n    if (!pointer.isDown) {\n      let anyChanges = false\n      for (const reroute of this.#visibleReroutes) {\n        anyChanges ||= reroute.updateVisibility(this.graph_mouse)\n\n        if (reroute.isSlotHovered) underPointer |= CanvasItem.RerouteSlot\n      }\n      if (anyChanges) this.dirty_bgcanvas = true\n    } else if (linkConnector.isConnecting) {\n      // Highlight the reroute that the mouse is over\n      for (const reroute of this.#visibleReroutes) {\n        if (reroute.containsPoint(this.graph_mouse)) {\n          if (linkConnector.isRerouteValidDrop(reroute)) {\n            linkConnector.overReroute = reroute\n            this._highlight_pos = reroute.pos\n          }\n\n          return underPointer |= CanvasItem.RerouteSlot\n        }\n      }\n    }\n\n    this._highlight_pos &&= undefined\n    linkConnector.overReroute &&= undefined\n    return underPointer\n  }\n\n  /**\n   * Start dragging an item, optionally including all other selected items.\n   *\n   * ** This function sets the {@link CanvasPointer.finally}() callback. **\n   * @param item The item that the drag event started on\n   * @param pointer The pointer event that initiated the drag, e.g. pointerdown\n   * @param sticky If `true`, the item is added to the selection - see {@link processSelect}\n   */\n  #startDraggingItems(item: Positionable, pointer: CanvasPointer, sticky = false): void {\n    this.emitBeforeChange()\n    this.graph?.beforeChange()\n    // Ensure that dragging is properly cleaned up, on success or failure.\n    pointer.finally = () => {\n      this.isDragging = false\n      this.graph?.afterChange()\n      this.emitAfterChange()\n    }\n\n    this.processSelect(item, pointer.eDown, sticky)\n    this.isDragging = true\n  }\n\n  /**\n   * Handles shared clean up and placement after items have been dragged.\n   * @param e The event that completed the drag, e.g. pointerup, pointermove\n   */\n  #processDraggedItems(e: CanvasPointerEvent): void {\n    const { graph } = this\n    if (e.shiftKey || LiteGraph.alwaysSnapToGrid)\n      graph?.snapToGrid(this.selectedItems)\n\n    this.dirty_canvas = true\n    this.dirty_bgcanvas = true\n\n    // TODO: Replace legacy behaviour: callbacks were never extended for multiple items\n    this.onNodeMoved?.(findFirstNode(this.selectedItems))\n  }\n\n  /**\n   * Called when a mouse up event has to be processed\n   */\n  processMouseUp(e: PointerEvent): void {\n    // early exit for extra pointer\n    if (e.isPrimary === false) return\n\n    const { graph, pointer } = this\n    if (!graph) return\n\n    LGraphCanvas.active_canvas = this\n\n    this.adjustMouseEvent(e)\n\n    const now = LiteGraph.getTime()\n    e.click_time = now - this.last_mouseclick\n\n    /** The mouseup event occurred near the mousedown event. */\n    /** Normal-looking click event - mouseUp occurred near mouseDown, without dragging. */\n    const isClick = pointer.up(e)\n    if (isClick === true) {\n      pointer.isDown = false\n      pointer.isDouble = false\n      // Required until all link behaviour is added to Pointer API\n      this.connecting_links = null\n      this.dragging_canvas = false\n\n      graph.change()\n\n      e.stopPropagation()\n      e.preventDefault()\n      return\n    }\n\n    this.last_mouse_dragging = false\n    this.last_click_position = null\n\n    // used to avoid sending twice a click in an immediate button\n    this.block_click &&= false\n\n    if (e.button === 0) {\n      // left button\n      this.selected_group = null\n\n      this.isDragging = false\n\n      const x = e.canvasX\n      const y = e.canvasY\n\n      if (!this.linkConnector.isConnecting) {\n        this.dirty_canvas = true\n\n        // @ts-expect-error Unused param\n        this.node_over?.onMouseUp?.(e, [x - this.node_over.pos[0], y - this.node_over.pos[1]], this)\n        this.node_capturing_input?.onMouseUp?.(e, [\n          x - this.node_capturing_input.pos[0],\n          y - this.node_capturing_input.pos[1],\n        ])\n      }\n    } else if (e.button === 1) {\n      // middle button\n      this.dirty_canvas = true\n      this.dragging_canvas = false\n    } else if (e.button === 2) {\n      // right button\n      this.dirty_canvas = true\n    }\n\n    pointer.isDown = false\n    pointer.isDouble = false\n\n    graph.change()\n\n    e.stopPropagation()\n    e.preventDefault()\n    return\n  }\n\n  /**\n   * Called when the mouse moves off the canvas.  Clears all node hover states.\n   * @param e\n   */\n  processMouseOut(e: MouseEvent): void {\n    // TODO: Check if document.contains(e.relatedTarget) - handle mouseover node textarea etc.\n    this.adjustMouseEvent(e)\n    this.updateMouseOverNodes(null, e)\n  }\n\n  processMouseCancel(): void {\n    console.warn(\"Pointer cancel!\")\n    this.pointer.reset()\n  }\n\n  /**\n   * Called when a mouse wheel event has to be processed\n   */\n  processMouseWheel(e: WheelEvent): void {\n    if (!this.graph || !this.allow_dragcanvas) return\n\n    // TODO: Mouse wheel zoom rewrite\n    // @ts-expect-error\n    const delta = e.wheelDeltaY ?? e.detail * -60\n\n    this.adjustMouseEvent(e)\n\n    const pos: Point = [e.clientX, e.clientY]\n    if (this.viewport && !isPointInRect(pos, this.viewport)) return\n\n    let { scale } = this.ds\n\n    if (\n      LiteGraph.macTrackpadGestures &&\n      (!LiteGraph.macGesturesRequireMac || navigator.userAgent.includes(\"Mac\"))\n    ) {\n      if (e.ctrlKey && !Number.isInteger(e.deltaY)) {\n        scale *= 1 + e.deltaY * (1 - this.zoom_speed) * 0.18\n        this.ds.changeScale(scale, [e.clientX, e.clientY], false)\n      } else {\n        this.ds.offset[0] -= e.deltaX * 1.18 * (1 / scale)\n        this.ds.offset[1] -= e.deltaY * 1.18 * (1 / scale)\n      }\n    } else {\n      if (delta > 0) {\n        scale *= this.zoom_speed\n      } else if (delta < 0) {\n        scale *= 1 / (this.zoom_speed)\n      }\n      this.ds.changeScale(scale, [e.clientX, e.clientY])\n    }\n\n    this.graph.change()\n\n    e.preventDefault()\n    return\n  }\n\n  #noItemsSelected(): void {\n    const event = new CustomEvent(\"litegraph:no-items-selected\", { bubbles: true })\n    this.canvas.dispatchEvent(event)\n  }\n\n  /**\n   * process a key event\n   */\n  processKey(e: KeyboardEvent): void {\n    this.#shiftDown = e.shiftKey\n\n    const { graph } = this\n    if (!graph) return\n\n    let block_default = false\n    // @ts-expect-error\n    if (e.target.localName == \"input\") return\n\n    if (e.type == \"keydown\") {\n      // TODO: Switch\n      if (e.key === \" \") {\n        // space\n        this.read_only = true\n        if (this._previously_dragging_canvas === null) {\n          this._previously_dragging_canvas = this.dragging_canvas\n        }\n        this.dragging_canvas = this.pointer.isDown\n        block_default = true\n      } else if (e.key === \"Escape\") {\n        // esc\n        if (this.linkConnector.isConnecting) {\n          this.linkConnector.reset()\n          this.#dirty()\n          e.preventDefault()\n          return\n        }\n        this.node_panel?.close()\n        this.options_panel?.close()\n        block_default = true\n      } else if (e.keyCode === 65 && e.ctrlKey) {\n        // select all Control A\n        this.selectItems()\n        block_default = true\n      } else if (e.keyCode === 67 && (e.metaKey || e.ctrlKey) && !e.shiftKey) {\n        // copy\n        if (this.selected_nodes) {\n          this.copyToClipboard()\n          block_default = true\n        }\n      } else if (e.keyCode === 86 && (e.metaKey || e.ctrlKey)) {\n        // paste\n        this.pasteFromClipboard({ connectInputs: e.shiftKey })\n      } else if (e.key === \"Delete\" || e.key === \"Backspace\") {\n        // delete or backspace\n        // @ts-expect-error\n        if (e.target.localName != \"input\" && e.target.localName != \"textarea\") {\n          if (this.selectedItems.size === 0) {\n            this.#noItemsSelected()\n            return\n          }\n\n          this.deleteSelected()\n          block_default = true\n        }\n      }\n\n      // TODO\n      for (const node of Object.values(this.selected_nodes)) {\n        node.onKeyDown?.(e)\n      }\n    } else if (e.type == \"keyup\") {\n      if (e.key === \" \") {\n        // space\n        this.read_only = false\n        this.dragging_canvas = (this._previously_dragging_canvas ?? false) && this.pointer.isDown\n        this._previously_dragging_canvas = null\n      }\n\n      for (const node of Object.values(this.selected_nodes)) {\n        node.onKeyUp?.(e)\n      }\n    }\n\n    // TODO: Do we need to remeasure and recalculate everything on every key down/up?\n    graph.change()\n\n    if (block_default) {\n      e.preventDefault()\n      e.stopImmediatePropagation()\n    }\n  }\n\n  /**\n   * Copies canvas items to an internal, app-specific clipboard backed by local storage.\n   * When called without parameters, it copies {@link selectedItems}.\n   * @param items The items to copy.  If nullish, all selected items are copied.\n   */\n  copyToClipboard(items?: Iterable<Positionable>): void {\n    const serialisable: Required<ClipboardItems> = {\n      nodes: [],\n      groups: [],\n      reroutes: [],\n      links: [],\n    }\n\n    // Create serialisable objects\n    for (const item of items ?? this.selectedItems) {\n      if (item instanceof LGraphNode) {\n        // Nodes\n        if (item.clonable === false) continue\n\n        const cloned = item.clone()?.serialize()\n        if (!cloned) continue\n\n        cloned.id = item.id\n        serialisable.nodes.push(cloned)\n\n        // Links\n        if (item.inputs) {\n          for (const { link: linkId } of item.inputs) {\n            if (linkId == null) continue\n\n            const link = this.graph?._links.get(linkId)?.asSerialisable()\n            if (link) serialisable.links.push(link)\n          }\n        }\n      } else if (item instanceof LGraphGroup) {\n        // Groups\n        serialisable.groups.push(item.serialize())\n      } else if (item instanceof Reroute) {\n        // Reroutes\n        serialisable.reroutes.push(item.asSerialisable())\n      }\n    }\n\n    localStorage.setItem(\n      \"litegrapheditor_clipboard\",\n      JSON.stringify(serialisable),\n    )\n  }\n\n  emitEvent(detail: LGraphCanvasEventMap[\"litegraph:canvas\"]): void {\n    this.canvas.dispatchEvent(\n      new CustomEvent(\"litegraph:canvas\", {\n        bubbles: true,\n        detail,\n      }),\n    )\n  }\n\n  /** @todo Refactor to where it belongs - e.g. Deleting / creating nodes is not actually canvas event. */\n  emitBeforeChange(): void {\n    this.emitEvent({\n      subType: \"before-change\",\n    })\n  }\n\n  /** @todo See {@link emitBeforeChange} */\n  emitAfterChange(): void {\n    this.emitEvent({\n      subType: \"after-change\",\n    })\n  }\n\n  /**\n   * Pastes the items from the canvas \"clipbaord\" - a local storage variable.\n   */\n  _pasteFromClipboard(options: IPasteFromClipboardOptions = {}): ClipboardPasteResult | undefined {\n    const {\n      connectInputs = false,\n      position = this.graph_mouse,\n    } = options\n\n    // if ctrl + shift + v is off, return when isConnectUnselected is true (shift is pressed) to maintain old behavior\n    if (!LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs && connectInputs) return\n\n    const data = localStorage.getItem(\"litegrapheditor_clipboard\")\n    if (!data) return\n\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n    graph.beforeChange()\n\n    // Parse & initialise\n    const parsed: ClipboardItems = JSON.parse(data)\n    parsed.nodes ??= []\n    parsed.groups ??= []\n    parsed.reroutes ??= []\n    parsed.links ??= []\n\n    // Find top-left-most boundary\n    let offsetX = Infinity\n    let offsetY = Infinity\n    for (const item of [...parsed.nodes, ...parsed.reroutes]) {\n      if (item.pos == null) throw new TypeError(\"Invalid node encounterd on paste.  `pos` was null.\")\n\n      if (item.pos[0] < offsetX) offsetX = item.pos[0]\n      if (item.pos[1] < offsetY) offsetY = item.pos[1]\n    }\n\n    // TODO: Remove when implementing `asSerialisable`\n    if (parsed.groups) {\n      for (const group of parsed.groups) {\n        if (group.bounding[0] < offsetX) offsetX = group.bounding[0]\n        if (group.bounding[1] < offsetY) offsetY = group.bounding[1]\n      }\n    }\n\n    const results: ClipboardPasteResult = {\n      created: [],\n      nodes: new Map<NodeId, LGraphNode>(),\n      links: new Map<LinkId, LLink>(),\n      reroutes: new Map<RerouteId, Reroute>(),\n    }\n    const { created, nodes, links, reroutes } = results\n\n    // const failedNodes: ISerialisedNode[] = []\n\n    // Groups\n    for (const info of parsed.groups) {\n      info.id = -1\n\n      const group = new LGraphGroup()\n      group.configure(info)\n      graph.add(group)\n      created.push(group)\n    }\n\n    // Nodes\n    for (const info of parsed.nodes) {\n      const node = info.type == null ? null : LiteGraph.createNode(info.type)\n      if (!node) {\n        // failedNodes.push(info)\n        continue\n      }\n\n      nodes.set(info.id, node)\n      info.id = -1\n\n      node.configure(info)\n      graph.add(node)\n\n      created.push(node)\n    }\n\n    // Reroutes\n    for (const info of parsed.reroutes) {\n      const { id, ...rerouteInfo } = info\n\n      const reroute = graph.setReroute(rerouteInfo)\n      created.push(reroute)\n      reroutes.set(id, reroute)\n    }\n\n    // Remap reroute parentIds for pasted reroutes\n    for (const reroute of reroutes.values()) {\n      if (reroute.parentId == null) continue\n\n      const mapped = reroutes.get(reroute.parentId)\n      if (mapped) reroute.parentId = mapped.id\n    }\n\n    // Links\n    for (const info of parsed.links) {\n      // Find the copied node / reroute ID\n      let outNode: LGraphNode | null | undefined = nodes.get(info.origin_id)\n      let afterRerouteId: number | undefined\n      if (info.parentId != null) afterRerouteId = reroutes.get(info.parentId)?.id\n\n      // If it wasn't copied, use the original graph value\n      if (connectInputs && LiteGraph.ctrl_shift_v_paste_connect_unselected_outputs) {\n        outNode ??= graph.getNodeById(info.origin_id)\n        afterRerouteId ??= info.parentId\n      }\n\n      const inNode = nodes.get(info.target_id)\n      if (inNode) {\n        const link = outNode?.connect(\n          info.origin_slot,\n          inNode,\n          info.target_slot,\n          afterRerouteId,\n        )\n        if (link) links.set(info.id, link)\n      }\n    }\n\n    // Remap linkIds\n    for (const reroute of reroutes.values()) {\n      const ids = [...reroute.linkIds].map(x => links.get(x)?.id ?? x)\n      reroute.update(reroute.parentId, undefined, ids, reroute.floating)\n\n      // Remove any invalid items\n      if (!reroute.validateLinks(graph.links, graph.floatingLinks)) {\n        graph.removeReroute(reroute.id)\n      }\n    }\n\n    // Adjust positions\n    for (const item of created) {\n      item.pos[0] += position[0] - offsetX\n      item.pos[1] += position[1] - offsetY\n    }\n\n    // TODO: Report failures, i.e. `failedNodes`\n\n    this.selectItems(created)\n\n    graph.afterChange()\n\n    return results\n  }\n\n  pasteFromClipboard(options: IPasteFromClipboardOptions = {}): void {\n    this.emitBeforeChange()\n    try {\n      this._pasteFromClipboard(options)\n    } finally {\n      this.emitAfterChange()\n    }\n  }\n\n  processNodeDblClicked(n: LGraphNode): void {\n    this.onShowNodePanel?.(n)\n    this.onNodeDblClicked?.(n)\n\n    this.setDirty(true)\n  }\n\n  #handleMultiSelect(e: CanvasPointerEvent, dragRect: Float32Array) {\n    // Process drag\n    // Convert Point pair (pos, offset) to Rect\n    const { graph, selectedItems } = this\n    if (!graph) throw new NullGraphError()\n\n    const w = Math.abs(dragRect[2])\n    const h = Math.abs(dragRect[3])\n    if (dragRect[2] < 0) dragRect[0] -= w\n    if (dragRect[3] < 0) dragRect[1] -= h\n    dragRect[2] = w\n    dragRect[3] = h\n\n    // Select nodes - any part of the node is in the select area\n    const isSelected = new Set<Positionable>()\n    const notSelected: Positionable[] = []\n\n    for (const nodeX of graph._nodes) {\n      if (overlapBounding(dragRect, nodeX.boundingRect)) {\n        addPositionable(nodeX)\n      }\n    }\n\n    // Select groups - the group is wholly inside the select area\n    for (const group of graph.groups) {\n      if (!containsRect(dragRect, group._bounding)) continue\n\n      group.recomputeInsideNodes()\n      addPositionable(group)\n    }\n\n    // Select reroutes - the centre point is inside the select area\n    for (const reroute of graph.reroutes.values()) {\n      if (!isPointInRect(reroute.pos, dragRect)) continue\n\n      selectedItems.add(reroute)\n      reroute.selected = true\n      addPositionable(reroute)\n    }\n\n    if (e.shiftKey) {\n      // Add to selection\n      for (const item of notSelected) this.select(item)\n    } else if (e.altKey) {\n      // Remove from selection\n      for (const item of isSelected) this.deselect(item)\n    } else {\n      // Replace selection\n      for (const item of selectedItems.values()) {\n        if (!isSelected.has(item)) this.deselect(item)\n      }\n      for (const item of notSelected) this.select(item)\n    }\n    this.onSelectionChange?.(this.selected_nodes)\n\n    function addPositionable(item: Positionable): void {\n      if (!item.selected || !selectedItems.has(item)) notSelected.push(item)\n      else isSelected.add(item)\n    }\n  }\n\n  /**\n   * Determines whether to select or deselect an item that has received a pointer event.  Will deselect other nodes if\n   * @param item Canvas item to select/deselect\n   * @param e The MouseEvent to handle\n   * @param sticky Prevents deselecting individual nodes (as used by aux/right-click)\n   * @remarks\n   * Accessibility: anyone using {@link mutli_select} always deselects when clicking empty space.\n   */\n  processSelect<TPositionable extends Positionable = LGraphNode>(\n    item: TPositionable | null | undefined,\n    e: CanvasMouseEvent | undefined,\n    sticky: boolean = false,\n  ): void {\n    const addModifier = e?.shiftKey\n    const subtractModifier = e != null && (e.metaKey || e.ctrlKey)\n    const eitherModifier = addModifier || subtractModifier\n    const modifySelection = eitherModifier || this.multi_select\n\n    if (!item) {\n      if (!eitherModifier || this.multi_select) this.deselectAll()\n    } else if (!item.selected || !this.selectedItems.has(item)) {\n      if (!modifySelection) this.deselectAll(item)\n      this.select(item)\n    } else if (modifySelection && !sticky) {\n      this.deselect(item)\n    } else if (!sticky) {\n      this.deselectAll(item)\n    } else {\n      return\n    }\n    this.onSelectionChange?.(this.selected_nodes)\n    this.setDirty(true)\n  }\n\n  /**\n   * Selects a {@link Positionable} item.\n   * @param item The canvas item to add to the selection.\n   */\n  select<TPositionable extends Positionable = LGraphNode>(item: TPositionable): void {\n    if (item.selected && this.selectedItems.has(item)) return\n\n    item.selected = true\n    this.selectedItems.add(item)\n    this.state.selectionChanged = true\n    if (!(item instanceof LGraphNode)) return\n\n    // Node-specific handling\n    item.onSelected?.()\n    this.selected_nodes[item.id] = item\n\n    this.onNodeSelected?.(item)\n\n    // Highlight links\n    if (item.inputs) {\n      for (const input of item.inputs) {\n        if (input.link == null) continue\n        this.highlighted_links[input.link] = true\n      }\n    }\n    if (item.outputs) {\n      for (const id of item.outputs.flatMap(x => x.links)) {\n        if (id == null) continue\n        this.highlighted_links[id] = true\n      }\n    }\n  }\n\n  /**\n   * Deselects a {@link Positionable} item.\n   * @param item The canvas item to remove from the selection.\n   */\n  deselect<TPositionable extends Positionable = LGraphNode>(item: TPositionable): void {\n    if (!item.selected && !this.selectedItems.has(item)) return\n\n    item.selected = false\n    this.selectedItems.delete(item)\n    this.state.selectionChanged = true\n    if (!(item instanceof LGraphNode)) return\n\n    // Node-specific handling\n    item.onDeselected?.()\n    delete this.selected_nodes[item.id]\n\n    this.onNodeDeselected?.(item)\n\n    // Should be moved to top of function, and throw if null\n    const { graph } = this\n    if (!graph) return\n\n    // Clear link highlight\n    if (item.inputs) {\n      for (const input of item.inputs) {\n        if (input.link == null) continue\n\n        const node = LLink.getOriginNode(graph, input.link)\n        if (node && this.selectedItems.has(node)) continue\n\n        delete this.highlighted_links[input.link]\n      }\n    }\n    if (item.outputs) {\n      for (const id of item.outputs.flatMap(x => x.links)) {\n        if (id == null) continue\n\n        const node = LLink.getTargetNode(graph, id)\n        if (node && this.selectedItems.has(node)) continue\n\n        delete this.highlighted_links[id]\n      }\n    }\n  }\n\n  /** @deprecated See {@link LGraphCanvas.processSelect} */\n  processNodeSelected(item: LGraphNode, e: CanvasMouseEvent): void {\n    this.processSelect(\n      item,\n      e,\n      e && (e.shiftKey || e.metaKey || e.ctrlKey || this.multi_select),\n    )\n  }\n\n  /** @deprecated See {@link LGraphCanvas.select} */\n  selectNode(node: LGraphNode, add_to_current_selection?: boolean): void {\n    if (node == null) {\n      this.deselectAll()\n    } else {\n      this.selectNodes([node], add_to_current_selection)\n    }\n  }\n\n  get empty(): boolean {\n    if (!this.graph) throw new NullGraphError()\n    return this.graph.empty\n  }\n\n  get positionableItems() {\n    if (!this.graph) throw new NullGraphError()\n    return this.graph.positionableItems()\n  }\n\n  /**\n   * Selects several items.\n   * @param items Items to select - if falsy, all items on the canvas will be selected\n   * @param add_to_current_selection If set, the items will be added to the current selection instead of replacing it\n   */\n  selectItems(items?: Positionable[], add_to_current_selection?: boolean): void {\n    const itemsToSelect = items ?? this.positionableItems\n    if (!add_to_current_selection) this.deselectAll()\n    for (const item of itemsToSelect) this.select(item)\n    this.onSelectionChange?.(this.selected_nodes)\n    this.setDirty(true)\n  }\n\n  /**\n   * selects several nodes (or adds them to the current selection)\n   * @deprecated See {@link LGraphCanvas.selectItems}\n   */\n  selectNodes(nodes?: LGraphNode[], add_to_current_selection?: boolean): void {\n    this.selectItems(nodes, add_to_current_selection)\n  }\n\n  /** @deprecated See {@link LGraphCanvas.deselect} */\n  deselectNode(node: LGraphNode): void {\n    this.deselect(node)\n  }\n\n  /**\n   * Deselects all items on the canvas.\n   * @param keepSelected If set, this item will not be removed from the selection.\n   */\n  deselectAll(keepSelected?: Positionable): void {\n    if (!this.graph) return\n\n    const selected = this.selectedItems\n    if (!selected.size) return\n\n    let wasSelected: Positionable | undefined\n    for (const sel of selected) {\n      if (sel === keepSelected) {\n        wasSelected = sel\n        continue\n      }\n      sel.onDeselected?.()\n      sel.selected = false\n    }\n    selected.clear()\n    if (wasSelected) selected.add(wasSelected)\n\n    this.setDirty(true)\n\n    // Legacy code\n    const oldNode = keepSelected?.id == null ? null : this.selected_nodes[keepSelected.id]\n    this.selected_nodes = {}\n    this.current_node = null\n    this.highlighted_links = {}\n\n    if (keepSelected instanceof LGraphNode) {\n      // Handle old object lookup\n      if (oldNode) this.selected_nodes[oldNode.id] = oldNode\n\n      // Highlight links\n      if (keepSelected.inputs) {\n        for (const input of keepSelected.inputs) {\n          if (input.link == null) continue\n          this.highlighted_links[input.link] = true\n        }\n      }\n      if (keepSelected.outputs) {\n        for (const id of keepSelected.outputs.flatMap(x => x.links)) {\n          if (id == null) continue\n          this.highlighted_links[id] = true\n        }\n      }\n    }\n\n    this.state.selectionChanged = true\n    this.onSelectionChange?.(this.selected_nodes)\n  }\n\n  /** @deprecated See {@link LGraphCanvas.deselectAll} */\n  deselectAllNodes(): void {\n    this.deselectAll()\n  }\n\n  /**\n   * Deletes all selected items from the graph.\n   * @todo Refactor deletion task to LGraph.  Selection is a canvas property, delete is a graph action.\n   */\n  deleteSelected(): void {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    this.emitBeforeChange()\n    graph.beforeChange()\n\n    for (const item of this.selectedItems) {\n      if (item instanceof LGraphNode) {\n        const node = item\n        if (node.block_delete) continue\n        node.connectInputToOutput()\n        graph.remove(node)\n        this.onNodeDeselected?.(node)\n      } else if (item instanceof LGraphGroup) {\n        graph.remove(item)\n      } else if (item instanceof Reroute) {\n        graph.removeReroute(item.id)\n      }\n    }\n\n    this.selected_nodes = {}\n    this.selectedItems.clear()\n    this.current_node = null\n    this.highlighted_links = {}\n\n    this.state.selectionChanged = true\n    this.onSelectionChange?.(this.selected_nodes)\n    this.setDirty(true)\n    graph.afterChange()\n    this.emitAfterChange()\n  }\n\n  /**\n   * deletes all nodes in the current selection from the graph\n   * @deprecated See {@link LGraphCanvas.deleteSelected}\n   */\n  deleteSelectedNodes(): void {\n    this.deleteSelected()\n  }\n\n  /**\n   * centers the camera on a given node\n   */\n  centerOnNode(node: LGraphNode): void {\n    const dpi = window?.devicePixelRatio || 1\n    this.ds.offset[0] =\n      -node.pos[0] -\n      node.size[0] * 0.5 +\n      (this.canvas.width * 0.5) / (this.ds.scale * dpi)\n    this.ds.offset[1] =\n      -node.pos[1] -\n      node.size[1] * 0.5 +\n      (this.canvas.height * 0.5) / (this.ds.scale * dpi)\n    this.setDirty(true, true)\n  }\n\n  /**\n   * adds some useful properties to a mouse event, like the position in graph coordinates\n   */\n  adjustMouseEvent<T extends MouseEvent>(\n    e: T & Partial<CanvasPointerExtensions>,\n  ): asserts e is T & CanvasMouseEvent {\n    let clientX_rel = e.clientX\n    let clientY_rel = e.clientY\n\n    if (this.canvas) {\n      const b = this.canvas.getBoundingClientRect()\n      clientX_rel -= b.left\n      clientY_rel -= b.top\n    }\n\n    e.safeOffsetX = clientX_rel\n    e.safeOffsetY = clientY_rel\n\n    // TODO: Find a less brittle way to do this\n\n    // Only set deltaX and deltaY if not already set.\n    // If deltaX and deltaY are already present, they are read-only.\n    // Setting them would result browser error => zoom in/out feature broken.\n    if (e.deltaX === undefined)\n      e.deltaX = clientX_rel - this.last_mouse_position[0]\n    if (e.deltaY === undefined)\n      e.deltaY = clientY_rel - this.last_mouse_position[1]\n\n    this.last_mouse_position[0] = clientX_rel\n    this.last_mouse_position[1] = clientY_rel\n\n    e.canvasX = clientX_rel / this.ds.scale - this.ds.offset[0]\n    e.canvasY = clientY_rel / this.ds.scale - this.ds.offset[1]\n  }\n\n  /**\n   * changes the zoom level of the graph (default is 1), you can pass also a place used to pivot the zoom\n   */\n  setZoom(value: number, zooming_center: Point) {\n    this.ds.changeScale(value, zooming_center)\n    this.#dirty()\n  }\n\n  /**\n   * converts a coordinate from graph coordinates to canvas2D coordinates\n   */\n  convertOffsetToCanvas(pos: Point, out: Point): Point {\n    // @ts-expect-error Unused param\n    return this.ds.convertOffsetToCanvas(pos, out)\n  }\n\n  /**\n   * converts a coordinate from Canvas2D coordinates to graph space\n   */\n  convertCanvasToOffset(pos: Point, out?: Point): Point {\n    return this.ds.convertCanvasToOffset(pos, out)\n  }\n\n  // converts event coordinates from canvas2D to graph coordinates\n  convertEventToCanvasOffset(e: MouseEvent): Point {\n    const rect = this.canvas.getBoundingClientRect()\n    // TODO: -> this.ds.convertCanvasToOffset\n    return this.convertCanvasToOffset([\n      e.clientX - rect.left,\n      e.clientY - rect.top,\n    ])\n  }\n\n  /**\n   * brings a node to front (above all other nodes)\n   */\n  bringToFront(node: LGraphNode): void {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const i = graph._nodes.indexOf(node)\n    if (i == -1) return\n\n    graph._nodes.splice(i, 1)\n    graph._nodes.push(node)\n  }\n\n  /**\n   * sends a node to the back (below all other nodes)\n   */\n  sendToBack(node: LGraphNode): void {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const i = graph._nodes.indexOf(node)\n    if (i == -1) return\n\n    graph._nodes.splice(i, 1)\n    graph._nodes.unshift(node)\n  }\n\n  /**\n   * Determines which nodes are visible and populates {@link out} with the results.\n   * @param nodes The list of nodes to check - if falsy, all nodes in the graph will be checked\n   * @param out Array to write visible nodes into - if falsy, a new array is created instead\n   * @returns Array passed ({@link out}), or a new array containing all visible nodes\n   */\n  computeVisibleNodes(nodes?: LGraphNode[], out?: LGraphNode[]): LGraphNode[] {\n    const visible_nodes = out || []\n    visible_nodes.length = 0\n    if (!this.graph) throw new NullGraphError()\n\n    const _nodes = nodes || this.graph._nodes\n    for (const node of _nodes) {\n      node.updateArea(this.ctx)\n      // Not in visible area\n      if (!overlapBounding(this.visible_area, node.renderArea)) continue\n\n      visible_nodes.push(node)\n    }\n    return visible_nodes\n  }\n\n  /**\n   * Checks if a node is visible on the canvas.\n   * @param node The node to check\n   * @returns `true` if the node is visible, otherwise `false`\n   */\n  isNodeVisible(node: LGraphNode): boolean {\n    return this.#visible_node_ids.has(node.id)\n  }\n\n  /**\n   * renders the whole canvas content, by rendering in two separated canvas, one containing the background grid and the connections, and one containing the nodes)\n   */\n  draw(force_canvas?: boolean, force_bgcanvas?: boolean): void {\n    if (!this.canvas || this.canvas.width == 0 || this.canvas.height == 0) return\n\n    // fps counting\n    const now = LiteGraph.getTime()\n    this.render_time = (now - this.last_draw_time) * 0.001\n    this.last_draw_time = now\n\n    if (this.graph) this.ds.computeVisibleArea(this.viewport)\n\n    // Compute node size before drawing links.\n    if (this.dirty_canvas || force_canvas) {\n      this.computeVisibleNodes(undefined, this.visible_nodes)\n      // Update visible node IDs\n      this.#visible_node_ids = new Set(this.visible_nodes.map(node => node.id))\n    }\n\n    if (\n      this.dirty_bgcanvas ||\n      force_bgcanvas ||\n      this.always_render_background ||\n      (this.graph?._last_trigger_time &&\n        now - this.graph._last_trigger_time < 1000)\n    ) {\n      this.drawBackCanvas()\n    }\n\n    if (this.dirty_canvas || force_canvas) this.drawFrontCanvas()\n\n    this.fps = this.render_time ? 1.0 / this.render_time : 0\n    this.frame++\n  }\n\n  /**\n   * draws the front canvas (the one containing all the nodes)\n   */\n  drawFrontCanvas(): void {\n    this.dirty_canvas = false\n\n    const { ctx, canvas, linkConnector } = this\n\n    // @ts-expect-error\n    if (ctx.start2D && !this.viewport) {\n      // @ts-expect-error\n      ctx.start2D()\n      ctx.restore()\n      ctx.setTransform(1, 0, 0, 1, 0, 0)\n    }\n\n    // clip dirty area if there is one, otherwise work in full canvas\n    const area = this.viewport || this.dirty_area\n    if (area) {\n      ctx.save()\n      ctx.beginPath()\n      ctx.rect(area[0], area[1], area[2], area[3])\n      ctx.clip()\n    }\n\n    // TODO: Set snapping value when changed instead of once per frame\n    this.#snapToGrid = this.#shiftDown || LiteGraph.alwaysSnapToGrid\n      ? this.graph?.getSnapToGridSize()\n      : undefined\n\n    // clear\n    // canvas.width = canvas.width;\n    if (this.clear_background) {\n      if (area) ctx.clearRect(area[0], area[1], area[2], area[3])\n      else ctx.clearRect(0, 0, canvas.width, canvas.height)\n    }\n\n    // draw bg canvas\n    if (this.bgcanvas == this.canvas) {\n      this.drawBackCanvas()\n    } else {\n      const scale = window.devicePixelRatio\n      ctx.drawImage(\n        this.bgcanvas,\n        0,\n        0,\n        this.bgcanvas.width / scale,\n        this.bgcanvas.height / scale,\n      )\n    }\n\n    // rendering\n    this.onRender?.(canvas, ctx)\n\n    // info widget\n    if (this.show_info) {\n      this.renderInfo(ctx, area ? area[0] : 0, area ? area[1] : 0)\n    }\n\n    if (this.graph) {\n      // apply transformations\n      ctx.save()\n      this.ds.toCanvasContext(ctx)\n\n      // draw nodes\n      const { visible_nodes } = this\n      const drawSnapGuides = this.#snapToGrid && this.isDragging\n\n      for (const node of visible_nodes) {\n        ctx.save()\n\n        // Draw snap shadow\n        if (drawSnapGuides && this.selectedItems.has(node))\n          this.drawSnapGuide(ctx, node)\n\n        // Localise co-ordinates to node position\n        ctx.translate(node.pos[0], node.pos[1])\n\n        // Draw\n        this.drawNode(node, ctx)\n\n        ctx.restore()\n      }\n\n      // on top (debug)\n      if (this.render_execution_order) {\n        this.drawExecutionOrder(ctx)\n      }\n\n      // connections ontop?\n      if (this.graph.config.links_ontop) {\n        this.drawConnections(ctx)\n      }\n\n      if (linkConnector.isConnecting) {\n        // current connection (the one being dragged by the mouse)\n        const { renderLinks } = linkConnector\n        const highlightPos = this.#getHighlightPosition()\n        ctx.lineWidth = this.connections_width\n\n        for (const renderLink of renderLinks) {\n          const { fromSlot, fromPos: pos, fromDirection, dragDirection } = renderLink\n          const connShape = fromSlot.shape\n          const connType = fromSlot.type\n\n          const colour = connType === LiteGraph.EVENT\n            ? LiteGraph.EVENT_LINK_COLOR\n            : LiteGraph.CONNECTING_LINK_COLOR\n\n          // the connection being dragged by the mouse\n          this.renderLink(\n            ctx,\n            pos,\n            highlightPos,\n            null,\n            false,\n            null,\n            colour,\n            fromDirection,\n            dragDirection,\n          )\n\n          ctx.beginPath()\n          if (connType === LiteGraph.EVENT || connShape === RenderShape.BOX) {\n            ctx.rect(pos[0] - 6 + 0.5, pos[1] - 5 + 0.5, 14, 10)\n            ctx.rect(\n              highlightPos[0] - 6 + 0.5,\n              highlightPos[1] - 5 + 0.5,\n              14,\n              10,\n            )\n          } else if (connShape === RenderShape.ARROW) {\n            ctx.moveTo(pos[0] + 8, pos[1] + 0.5)\n            ctx.lineTo(pos[0] - 4, pos[1] + 6 + 0.5)\n            ctx.lineTo(pos[0] - 4, pos[1] - 6 + 0.5)\n            ctx.closePath()\n          } else {\n            ctx.arc(pos[0], pos[1], 4, 0, Math.PI * 2)\n            ctx.arc(highlightPos[0], highlightPos[1], 4, 0, Math.PI * 2)\n          }\n          ctx.fill()\n        }\n\n        // Gradient half-border over target node\n        this.#renderSnapHighlight(ctx, highlightPos)\n      }\n\n      // Area-selection rectangle\n      if (this.dragging_rectangle) {\n        const { eDown, eMove } = this.pointer\n        ctx.strokeStyle = \"#FFF\"\n\n        if (eDown && eMove) {\n          // Do not scale the selection box\n          const transform = ctx.getTransform()\n          const ratio = Math.max(1, window.devicePixelRatio)\n          ctx.setTransform(ratio, 0, 0, ratio, 0, 0)\n\n          const x = eDown.safeOffsetX\n          const y = eDown.safeOffsetY\n          ctx.strokeRect(x, y, eMove.safeOffsetX - x, eMove.safeOffsetY - y)\n\n          ctx.setTransform(transform)\n        } else {\n          // Fallback to legacy behaviour\n          const [x, y, w, h] = this.dragging_rectangle\n          ctx.strokeRect(x, y, w, h)\n        }\n      }\n\n      // on top of link center\n      if (!this.isDragging && this.over_link_center && this.render_link_tooltip) {\n        this.drawLinkTooltip(ctx, this.over_link_center)\n      } else {\n        this.onDrawLinkTooltip?.(ctx, null)\n      }\n\n      // custom info\n      this.onDrawForeground?.(ctx, this.visible_area)\n\n      ctx.restore()\n    }\n\n    this.onDrawOverlay?.(ctx)\n\n    if (area) ctx.restore()\n  }\n\n  /** @returns If the pointer is over a link centre marker, the link segment it belongs to.  Otherwise, `undefined`.  */\n  #getLinkCentreOnPos(e: CanvasMouseEvent): LinkSegment | undefined {\n    for (const linkSegment of this.renderedPaths) {\n      const centre = linkSegment._pos\n      if (!centre) continue\n\n      if (isInRectangle(e.canvasX, e.canvasY, centre[0] - 4, centre[1] - 4, 8, 8)) {\n        return linkSegment\n      }\n    }\n  }\n\n  /** Get the target snap / highlight point in graph space */\n  #getHighlightPosition(): ReadOnlyPoint {\n    return LiteGraph.snaps_for_comfy\n      ? this.linkConnector.state.snapLinksPos ?? this._highlight_pos ?? this.graph_mouse\n      : this.graph_mouse\n  }\n\n  /**\n   * Renders indicators showing where a link will connect if released.\n   * Partial border over target node and a highlight over the slot itself.\n   * @param ctx Canvas 2D context\n   */\n  #renderSnapHighlight(\n    ctx: CanvasRenderingContext2D,\n    highlightPos: ReadOnlyPoint,\n  ): void {\n    const linkConnectorSnap = !!this.linkConnector.state.snapLinksPos\n    if (!this._highlight_pos && !linkConnectorSnap) return\n\n    ctx.fillStyle = \"#ffcc00\"\n    ctx.beginPath()\n    const shape = this._highlight_input?.shape\n\n    if (shape === RenderShape.ARROW) {\n      ctx.moveTo(highlightPos[0] + 8, highlightPos[1] + 0.5)\n      ctx.lineTo(highlightPos[0] - 4, highlightPos[1] + 6 + 0.5)\n      ctx.lineTo(highlightPos[0] - 4, highlightPos[1] - 6 + 0.5)\n      ctx.closePath()\n    } else {\n      ctx.arc(highlightPos[0], highlightPos[1], 6, 0, Math.PI * 2)\n    }\n    ctx.fill()\n\n    const { linkConnector } = this\n    const { overReroute, overWidget } = linkConnector\n    if (!LiteGraph.snap_highlights_node || !linkConnector.isConnecting || linkConnectorSnap) return\n\n    // Reroute highlight\n    overReroute?.drawHighlight(ctx, \"#ffcc00aa\")\n\n    // Ensure we're mousing over a node and connecting a link\n    const node = this.node_over\n    if (!node) return\n\n    const { strokeStyle, lineWidth } = ctx\n\n    const area = node.boundingRect\n    const gap = 3\n    const radius = LiteGraph.ROUND_RADIUS + gap\n\n    const x = area[0] - gap\n    const y = area[1] - gap\n    const width = area[2] + gap * 2\n    const height = area[3] + gap * 2\n\n    ctx.beginPath()\n    ctx.roundRect(x, y, width, height, radius)\n\n    // TODO: Currently works on LTR slots only.  Add support for other directions.\n    const start = linkConnector.state.connectingTo === \"output\" ? 0 : 1\n    const inverter = start ? -1 : 1\n\n    // Radial highlight centred on highlight pos\n    const hx = highlightPos[0]\n    const hy = highlightPos[1]\n    const gRadius = width < height\n      ? width\n      : width * Math.max(height / width, 0.5)\n\n    const gradient = ctx.createRadialGradient(hx, hy, 0, hx, hy, gRadius)\n    gradient.addColorStop(1, \"#00000000\")\n    gradient.addColorStop(0, \"#ffcc00aa\")\n\n    // Linear gradient over half the node.\n    const linearGradient = ctx.createLinearGradient(x, y, x + width, y)\n    linearGradient.addColorStop(0.5, \"#00000000\")\n    linearGradient.addColorStop(start + 0.67 * inverter, \"#ddeeff33\")\n    linearGradient.addColorStop(start + inverter, \"#ffcc0055\")\n\n    /**\n     * Workaround for a canvas render issue.\n     * In Chromium 129 (2024-10-15), rounded corners can be rendered with the wrong part of a gradient colour.\n     * Occurs only at certain thicknesses / arc sizes.\n     */\n    ctx.setLineDash([radius, radius * 0.001])\n\n    ctx.lineWidth = 1\n    ctx.strokeStyle = linearGradient\n    ctx.stroke()\n\n    if (overWidget) {\n      const { computedHeight } = overWidget\n\n      ctx.beginPath()\n      const { pos: [nodeX, nodeY] } = node\n      const height = LiteGraph.NODE_WIDGET_HEIGHT\n      if (\n        overWidget.type.startsWith(\"custom\") &&\n        computedHeight != null &&\n        computedHeight > height * 2\n      ) {\n        // Most likely DOM widget text box\n        ctx.rect(\n          nodeX + 9,\n          nodeY + overWidget.y + 9,\n          (overWidget.width ?? area[2]) - 18,\n          computedHeight - 18,\n        )\n      } else {\n        // Regular widget, probably\n        ctx.roundRect(\n          nodeX + BaseWidget.margin,\n          nodeY + overWidget.y,\n          overWidget.width ?? area[2],\n          height,\n          height * 0.5,\n        )\n      }\n      ctx.stroke()\n    }\n\n    ctx.strokeStyle = gradient\n    ctx.stroke()\n\n    ctx.setLineDash([])\n    ctx.lineWidth = lineWidth\n    ctx.strokeStyle = strokeStyle\n  }\n\n  /**\n   * draws some useful stats in the corner of the canvas\n   */\n  renderInfo(ctx: CanvasRenderingContext2D, x: number, y: number): void {\n    x = x || 10\n    y = y || this.canvas.offsetHeight - 80\n\n    ctx.save()\n    ctx.translate(x, y)\n\n    ctx.font = `10px ${LiteGraph.DEFAULT_FONT}`\n    ctx.fillStyle = \"#888\"\n    ctx.textAlign = \"left\"\n    if (this.graph) {\n      ctx.fillText(`T: ${this.graph.globaltime.toFixed(2)}s`, 5, 13 * 1)\n      ctx.fillText(`I: ${this.graph.iteration}`, 5, 13 * 2)\n      ctx.fillText(`N: ${this.graph._nodes.length} [${this.visible_nodes.length}]`, 5, 13 * 3)\n      ctx.fillText(`V: ${this.graph._version}`, 5, 13 * 4)\n      ctx.fillText(`FPS:${this.fps.toFixed(2)}`, 5, 13 * 5)\n    } else {\n      ctx.fillText(\"No graph selected\", 5, 13 * 1)\n    }\n    ctx.restore()\n  }\n\n  /**\n   * draws the back canvas (the one containing the background and the connections)\n   */\n  drawBackCanvas(): void {\n    const canvas = this.bgcanvas\n    if (\n      canvas.width != this.canvas.width ||\n      canvas.height != this.canvas.height\n    ) {\n      canvas.width = this.canvas.width\n      canvas.height = this.canvas.height\n    }\n\n    if (!this.bgctx) {\n      this.bgctx = this.bgcanvas.getContext(\"2d\")\n    }\n    const ctx = this.bgctx\n    if (!ctx) throw new TypeError(\"Background canvas context was null.\")\n\n    const viewport = this.viewport || [0, 0, ctx.canvas.width, ctx.canvas.height]\n\n    // clear\n    if (this.clear_background) {\n      ctx.clearRect(viewport[0], viewport[1], viewport[2], viewport[3])\n    }\n\n    const bg_already_painted = this.onRenderBackground\n      ? this.onRenderBackground(canvas, ctx)\n      : false\n\n    // reset in case of error\n    if (!this.viewport) {\n      const scale = window.devicePixelRatio\n      ctx.restore()\n      ctx.setTransform(scale, 0, 0, scale, 0, 0)\n    }\n\n    if (this.graph) {\n      // apply transformations\n      ctx.save()\n      this.ds.toCanvasContext(ctx)\n\n      // render BG\n      if (\n        this.ds.scale < 1.5 &&\n        !bg_already_painted &&\n        this.clear_background_color\n      ) {\n        ctx.fillStyle = this.clear_background_color\n        ctx.fillRect(\n          this.visible_area[0],\n          this.visible_area[1],\n          this.visible_area[2],\n          this.visible_area[3],\n        )\n      }\n\n      if (this.background_image && this.ds.scale > 0.5 && !bg_already_painted) {\n        if (this.zoom_modify_alpha) {\n          ctx.globalAlpha = (1.0 - 0.5 / this.ds.scale) * this.editor_alpha\n        } else {\n          ctx.globalAlpha = this.editor_alpha\n        }\n        ctx.imageSmoothingEnabled = false\n        if (!this._bg_img || this._bg_img.name != this.background_image) {\n          this._bg_img = new Image()\n          this._bg_img.name = this.background_image\n          this._bg_img.src = this.background_image\n          const that = this\n          this._bg_img.addEventListener(\"load\", function () {\n            that.draw(true, true)\n          })\n        }\n\n        let pattern = this._pattern\n        if (pattern == null && this._bg_img.width > 0) {\n          pattern = ctx.createPattern(this._bg_img, \"repeat\") ?? undefined\n          this._pattern_img = this._bg_img\n          this._pattern = pattern\n        }\n\n        // NOTE: This ridiculous kludge provides a significant performance increase when rendering many large (> canvas width) paths in HTML canvas.\n        // I could find no documentation or explanation.  Requires that the BG image is set.\n        if (pattern) {\n          ctx.fillStyle = pattern\n          ctx.fillRect(\n            this.visible_area[0],\n            this.visible_area[1],\n            this.visible_area[2],\n            this.visible_area[3],\n          )\n          ctx.fillStyle = \"transparent\"\n        }\n\n        ctx.globalAlpha = 1.0\n        ctx.imageSmoothingEnabled = true\n      }\n\n      // groups\n      if (this.graph._groups.length) {\n        this.drawGroups(canvas, ctx)\n      }\n\n      this.onDrawBackground?.(ctx, this.visible_area)\n\n      // DEBUG: show clipping area\n      // ctx.fillStyle = \"red\";\n      // ctx.fillRect( this.visible_area[0] + 10, this.visible_area[1] + 10, this.visible_area[2] - 20, this.visible_area[3] - 20);\n      // bg\n      if (this.render_canvas_border) {\n        ctx.strokeStyle = \"#235\"\n        ctx.strokeRect(0, 0, canvas.width, canvas.height)\n      }\n\n      if (this.render_connections_shadows) {\n        ctx.shadowColor = \"#000\"\n        ctx.shadowOffsetX = 0\n        ctx.shadowOffsetY = 0\n        ctx.shadowBlur = 6\n      } else {\n        ctx.shadowColor = \"rgba(0,0,0,0)\"\n      }\n\n      // draw connections\n      this.drawConnections(ctx)\n\n      ctx.shadowColor = \"rgba(0,0,0,0)\"\n\n      // restore state\n      ctx.restore()\n    }\n\n    this.dirty_bgcanvas = false\n    // Forces repaint of the front canvas.\n    this.dirty_canvas = true\n  }\n\n  /**\n   * draws the given node inside the canvas\n   */\n  drawNode(node: LGraphNode, ctx: CanvasRenderingContext2D): void {\n    this.current_node = node\n\n    const color = node.renderingColor\n    const bgcolor = node.renderingBgColor\n\n    const { low_quality, editor_alpha } = this\n    ctx.globalAlpha = editor_alpha\n\n    if (this.render_shadows && !low_quality) {\n      ctx.shadowColor = LiteGraph.DEFAULT_SHADOW_COLOR\n      ctx.shadowOffsetX = 2 * this.ds.scale\n      ctx.shadowOffsetY = 2 * this.ds.scale\n      ctx.shadowBlur = 3 * this.ds.scale\n    } else {\n      ctx.shadowColor = \"transparent\"\n    }\n\n    // custom draw collapsed method (draw after shadows because they are affected)\n    if (node.flags.collapsed && node.onDrawCollapsed?.(ctx, this) == true)\n      return\n\n    // clip if required (mask)\n    const shape = node._shape || RenderShape.BOX\n    const size = LGraphCanvas.#temp_vec2\n    size.set(node.renderingSize)\n\n    if (node.collapsed) {\n      ctx.font = this.inner_text_font\n    }\n\n    if (node.clip_area) {\n      // Start clipping\n      ctx.save()\n      ctx.beginPath()\n      if (shape == RenderShape.BOX) {\n        ctx.rect(0, 0, size[0], size[1])\n      } else if (shape == RenderShape.ROUND) {\n        ctx.roundRect(0, 0, size[0], size[1], [10])\n      } else if (shape == RenderShape.CIRCLE) {\n        ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5, 0, Math.PI * 2)\n      }\n      ctx.clip()\n    }\n\n    // draw shape\n    this.drawNodeShape(\n      node,\n      ctx,\n      size,\n      color,\n      bgcolor,\n      !!node.selected,\n    )\n\n    if (!low_quality) {\n      node.drawBadges(ctx)\n    }\n\n    ctx.shadowColor = \"transparent\"\n\n    // TODO: Legacy behaviour: onDrawForeground received ctx in this state\n    ctx.strokeStyle = LiteGraph.NODE_BOX_OUTLINE_COLOR\n\n    // Draw Foreground\n    node.onDrawForeground?.(ctx, this, this.canvas)\n\n    // connection slots\n    ctx.font = this.inner_text_font\n\n    // render inputs and outputs\n    node._setConcreteSlots()\n    if (!node.collapsed) {\n      node.arrange()\n      node.drawSlots(ctx, {\n        fromSlot: this.linkConnector.renderLinks[0]?.fromSlot,\n        colorContext: this.colourGetter,\n        editorAlpha: this.editor_alpha,\n        lowQuality: this.low_quality,\n      })\n\n      ctx.textAlign = \"left\"\n      ctx.globalAlpha = 1\n\n      this.drawNodeWidgets(node, null, ctx)\n    } else if (this.render_collapsed_slots) {\n      node.drawCollapsedSlots(ctx)\n    }\n\n    if (node.clip_area) {\n      ctx.restore()\n    }\n\n    ctx.globalAlpha = 1.0\n  }\n\n  /**\n   * Draws the link mouseover effect and tooltip.\n   * @param ctx Canvas 2D context to draw on\n   * @param link The link to render the mouseover effect for\n   * @remarks\n   * Called against {@link LGraphCanvas.over_link_center}.\n   * @todo Split tooltip from hover, so it can be drawn / eased separately\n   */\n  drawLinkTooltip(ctx: CanvasRenderingContext2D, link: LinkSegment): void {\n    const pos = link._pos\n    ctx.fillStyle = \"black\"\n    ctx.beginPath()\n    if (this.linkMarkerShape === LinkMarkerShape.Arrow) {\n      const transform = ctx.getTransform()\n      ctx.translate(pos[0], pos[1])\n      // Assertion: Number.isFinite guarantees this is a number.\n      if (Number.isFinite(link._centreAngle)) ctx.rotate(link._centreAngle as number)\n      ctx.moveTo(-2, -3)\n      ctx.lineTo(+4, 0)\n      ctx.lineTo(-2, +3)\n      ctx.setTransform(transform)\n    } else if (\n      this.linkMarkerShape == null ||\n      this.linkMarkerShape === LinkMarkerShape.Circle\n    ) {\n      ctx.arc(pos[0], pos[1], 3, 0, Math.PI * 2)\n    }\n    ctx.fill()\n\n    // @ts-expect-error TODO: Better value typing\n    const { data } = link\n    if (data == null) return\n\n    // @ts-expect-error TODO: Better value typing\n    if (this.onDrawLinkTooltip?.(ctx, link, this) == true) return\n\n    let text: string | null = null\n\n    if (typeof data === \"number\")\n      text = data.toFixed(2)\n    else if (typeof data === \"string\")\n      text = `\"${data}\"`\n    else if (typeof data === \"boolean\")\n      text = String(data)\n    else if (data.toToolTip)\n      text = data.toToolTip()\n    else\n      text = `[${data.constructor.name}]`\n\n    if (text == null) return\n\n    // Hard-coded tooltip limit\n    text = text.substring(0, 30)\n\n    ctx.font = \"14px Courier New\"\n    const info = ctx.measureText(text)\n    const w = info.width + 20\n    const h = 24\n    ctx.shadowColor = \"black\"\n    ctx.shadowOffsetX = 2\n    ctx.shadowOffsetY = 2\n    ctx.shadowBlur = 3\n    ctx.fillStyle = \"#454\"\n    ctx.beginPath()\n    ctx.roundRect(pos[0] - w * 0.5, pos[1] - 15 - h, w, h, [3])\n    ctx.moveTo(pos[0] - 10, pos[1] - 15)\n    ctx.lineTo(pos[0] + 10, pos[1] - 15)\n    ctx.lineTo(pos[0], pos[1] - 5)\n    ctx.fill()\n    ctx.shadowColor = \"transparent\"\n    ctx.textAlign = \"center\"\n    ctx.fillStyle = \"#CEC\"\n    ctx.fillText(text, pos[0], pos[1] - 15 - h * 0.3)\n  }\n\n  /**\n   * Draws the shape of the given node on the canvas\n   * @param node The node to draw\n   * @param ctx 2D canvas rendering context used to draw\n   * @param size Size of the background to draw, in graph units.  Differs from node size if collapsed, etc.\n   * @param fgcolor Foreground colour - used for text\n   * @param bgcolor Background colour of the node\n   * @param _selected Whether to render the node as selected.  Likely to be removed in future, as current usage is simply the selected property of the node.\n   */\n  drawNodeShape(\n    node: LGraphNode,\n    ctx: CanvasRenderingContext2D,\n    size: Size,\n    fgcolor: CanvasColour,\n    bgcolor: CanvasColour,\n    _selected: boolean,\n  ): void {\n    // Rendering options\n    ctx.strokeStyle = fgcolor\n    ctx.fillStyle = bgcolor\n\n    const title_height = LiteGraph.NODE_TITLE_HEIGHT\n    const { low_quality } = this\n\n    const { collapsed } = node.flags\n    const shape = node.renderingShape\n    const { title_mode } = node\n\n    const render_title = title_mode == TitleMode.TRANSPARENT_TITLE || title_mode == TitleMode.NO_TITLE\n      ? false\n      : true\n\n    // Normalised node dimensions\n    const area = LGraphCanvas.#tmp_area\n    area.set(node.boundingRect)\n    area[0] -= node.pos[0]\n    area[1] -= node.pos[1]\n\n    const old_alpha = ctx.globalAlpha\n\n    // Draw node background (shape)\n    ctx.beginPath()\n    if (shape == RenderShape.BOX || low_quality) {\n      ctx.rect(area[0], area[1], area[2], area[3])\n    } else if (shape == RenderShape.ROUND || shape == RenderShape.CARD) {\n      ctx.roundRect(\n        area[0],\n        area[1],\n        area[2],\n        area[3],\n        shape == RenderShape.CARD\n          ? [LiteGraph.ROUND_RADIUS, LiteGraph.ROUND_RADIUS, 0, 0]\n          : [LiteGraph.ROUND_RADIUS],\n      )\n    } else if (shape == RenderShape.CIRCLE) {\n      ctx.arc(size[0] * 0.5, size[1] * 0.5, size[0] * 0.5, 0, Math.PI * 2)\n    }\n    ctx.fill()\n\n    // Separator - title bar <-> body\n    if (!collapsed && render_title) {\n      ctx.shadowColor = \"transparent\"\n      ctx.fillStyle = \"rgba(0,0,0,0.2)\"\n      ctx.fillRect(0, -1, area[2], 2)\n    }\n    ctx.shadowColor = \"transparent\"\n\n    node.onDrawBackground?.(ctx)\n\n    // Title bar background (remember, it is rendered ABOVE the node)\n    if (render_title || title_mode == TitleMode.TRANSPARENT_TITLE) {\n      node.drawTitleBarBackground(ctx, {\n        scale: this.ds.scale,\n        low_quality,\n      })\n\n      // title box\n      node.drawTitleBox(ctx, {\n        scale: this.ds.scale,\n        low_quality,\n        box_size: 10,\n      })\n\n      ctx.globalAlpha = old_alpha\n\n      // title text\n      node.drawTitleText(ctx, {\n        scale: this.ds.scale,\n        default_title_color: this.node_title_color,\n        low_quality,\n      })\n\n      // custom title render\n      node.onDrawTitle?.(ctx)\n    }\n\n    // Draw stroke styles\n    for (const getStyle of Object.values(node.strokeStyles)) {\n      const strokeStyle = getStyle.call(node)\n      if (strokeStyle) {\n        strokeShape(ctx, area, {\n          shape,\n          title_height,\n          title_mode,\n          collapsed,\n          ...strokeStyle,\n        })\n      }\n    }\n\n    node.drawProgressBar(ctx)\n\n    // these counter helps in conditioning drawing based on if the node has been executed or an action occurred\n    if (node.execute_triggered != null && node.execute_triggered > 0) node.execute_triggered--\n    if (node.action_triggered != null && node.action_triggered > 0) node.action_triggered--\n  }\n\n  /**\n   * Draws a snap guide for a {@link Positionable} item.\n   *\n   * Initial design was a simple white rectangle representing the location the\n   * item would land if dropped.\n   * @param ctx The 2D canvas context to draw on\n   * @param item The item to draw a snap guide for\n   * @param shape The shape of the snap guide to draw\n   * @todo Update to align snapping with boundingRect\n   * @todo Shapes\n   */\n  drawSnapGuide(\n    ctx: CanvasRenderingContext2D,\n    item: Positionable,\n    shape = RenderShape.ROUND,\n  ) {\n    const snapGuide = LGraphCanvas.#temp\n    snapGuide.set(item.boundingRect)\n\n    // Not all items have pos equal to top-left of bounds\n    const { pos } = item\n    const offsetX = pos[0] - snapGuide[0]\n    const offsetY = pos[1] - snapGuide[1]\n\n    // Normalise boundingRect to pos to snap\n    snapGuide[0] += offsetX\n    snapGuide[1] += offsetY\n    if (this.#snapToGrid) snapPoint(snapGuide, this.#snapToGrid)\n    snapGuide[0] -= offsetX\n    snapGuide[1] -= offsetY\n\n    const { globalAlpha } = ctx\n    ctx.globalAlpha = 1\n    ctx.beginPath()\n    const [x, y, w, h] = snapGuide\n    if (shape === RenderShape.CIRCLE) {\n      const midX = x + (w * 0.5)\n      const midY = y + (h * 0.5)\n      const radius = Math.min(w * 0.5, h * 0.5)\n      ctx.arc(midX, midY, radius, 0, Math.PI * 2)\n    } else {\n      ctx.rect(x, y, w, h)\n    }\n\n    ctx.lineWidth = 0.5\n    ctx.strokeStyle = \"#FFFFFF66\"\n    ctx.fillStyle = \"#FFFFFF22\"\n    ctx.fill()\n    ctx.stroke()\n    ctx.globalAlpha = globalAlpha\n  }\n\n  drawConnections(ctx: CanvasRenderingContext2D): void {\n    this.renderedPaths.clear()\n    if (this.links_render_mode === LinkRenderType.HIDDEN_LINK) return\n\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const visibleReroutes: Reroute[] = []\n\n    const now = LiteGraph.getTime()\n    const { visible_area } = this\n    LGraphCanvas.#margin_area[0] = visible_area[0] - 20\n    LGraphCanvas.#margin_area[1] = visible_area[1] - 20\n    LGraphCanvas.#margin_area[2] = visible_area[2] + 40\n    LGraphCanvas.#margin_area[3] = visible_area[3] + 40\n\n    // draw connections\n    ctx.lineWidth = this.connections_width\n\n    ctx.fillStyle = \"#AAA\"\n    ctx.strokeStyle = \"#AAA\"\n    ctx.globalAlpha = this.editor_alpha\n    // for every node\n    const nodes = graph._nodes\n    for (const node of nodes) {\n      // for every input (we render just inputs because it is easier as every slot can only have one input)\n      const { inputs } = node\n      if (!inputs?.length) continue\n\n      for (const [i, input] of inputs.entries()) {\n        if (!input || input.link == null) continue\n\n        const link_id = input.link\n        const link = graph._links.get(link_id)\n        if (!link) continue\n\n        const endPos = node.getInputPos(i)\n\n        // find link info\n        const start_node = graph.getNodeById(link.origin_id)\n        if (start_node == null) continue\n\n        const outputId = link.origin_slot\n        const startPos: Point = outputId === -1\n          ? [start_node.pos[0] + 10, start_node.pos[1] + 10]\n          : start_node.getOutputPos(outputId)\n\n        const output = start_node.outputs[outputId]\n        if (!output) continue\n\n        this.#renderAllLinkSegments(ctx, link, startPos, endPos, visibleReroutes, now, output.dir, input.dir)\n      }\n    }\n\n    if (graph.floatingLinks.size > 0) {\n      this.#renderFloatingLinks(ctx, graph, visibleReroutes, now)\n    }\n\n    const rerouteSet = this.#visibleReroutes\n    rerouteSet.clear()\n\n    // Render reroutes, ordered by number of non-floating links\n    visibleReroutes.sort((a, b) => a.linkIds.size - b.linkIds.size)\n    for (const reroute of visibleReroutes) {\n      rerouteSet.add(reroute)\n\n      if (\n        this.#snapToGrid &&\n        this.isDragging &&\n        this.selectedItems.has(reroute)\n      ) {\n        this.drawSnapGuide(ctx, reroute, RenderShape.CIRCLE)\n      }\n      reroute.draw(ctx, this._pattern)\n\n      // Never draw slots when the pointer is down\n      if (!this.pointer.isDown) reroute.drawSlots(ctx)\n    }\n    ctx.globalAlpha = 1\n  }\n\n  #renderFloatingLinks(ctx: CanvasRenderingContext2D, graph: LGraph, visibleReroutes: Reroute[], now: number) {\n    // Render floating links with 3/4 current alpha\n    const { globalAlpha } = ctx\n    ctx.globalAlpha = globalAlpha * 0.33\n\n    // Floating reroutes\n    for (const link of graph.floatingLinks.values()) {\n      const reroutes = LLink.getReroutes(graph, link)\n      const firstReroute = reroutes[0]\n      const reroute = reroutes.at(-1)\n      if (!firstReroute || !reroute?.floating) continue\n\n      // Input not connected\n      if (reroute.floating.slotType === \"input\") {\n        const node = graph.getNodeById(link.target_id)\n        if (!node) continue\n\n        const startPos = firstReroute.pos\n        const endPos = node.getInputPos(link.target_slot)\n        const endDirection = node.inputs[link.target_slot]?.dir\n\n        firstReroute._dragging = true\n        this.#renderAllLinkSegments(ctx, link, startPos, endPos, visibleReroutes, now, LinkDirection.CENTER, endDirection, true)\n      } else {\n        const node = graph.getNodeById(link.origin_id)\n        if (!node) continue\n\n        const startPos = node.getOutputPos(link.origin_slot)\n        const endPos = reroute.pos\n        const startDirection = node.outputs[link.origin_slot]?.dir\n\n        link._dragging = true\n        this.#renderAllLinkSegments(ctx, link, startPos, endPos, visibleReroutes, now, startDirection, LinkDirection.CENTER, true)\n      }\n    }\n    ctx.globalAlpha = globalAlpha\n  }\n\n  #renderAllLinkSegments(\n    ctx: CanvasRenderingContext2D,\n    link: LLink,\n    startPos: Point,\n    endPos: Point,\n    visibleReroutes: Reroute[],\n    now: number,\n    startDirection?: LinkDirection,\n    endDirection?: LinkDirection,\n    disabled: boolean = false,\n  ) {\n    const { graph, renderedPaths } = this\n    if (!graph) return\n\n    // Get all points this link passes through\n    const reroutes = LLink.getReroutes(graph, link)\n    const points: [Point, ...Point[], Point] = [\n      startPos,\n      ...reroutes.map(x => x.pos),\n      endPos,\n    ]\n\n    // Bounding box of all points (bezier overshoot on long links will be cut)\n    const pointsX = points.map(x => x[0])\n    const pointsY = points.map(x => x[1])\n    LGraphCanvas.#link_bounding[0] = Math.min(...pointsX)\n    LGraphCanvas.#link_bounding[1] = Math.min(...pointsY)\n    LGraphCanvas.#link_bounding[2] = Math.max(...pointsX) - LGraphCanvas.#link_bounding[0]\n    LGraphCanvas.#link_bounding[3] = Math.max(...pointsY) - LGraphCanvas.#link_bounding[1]\n\n    // skip links outside of the visible area of the canvas\n    if (!overlapBounding(LGraphCanvas.#link_bounding, LGraphCanvas.#margin_area))\n      return\n\n    const start_dir = startDirection || LinkDirection.RIGHT\n    const end_dir = endDirection || LinkDirection.LEFT\n\n    // Has reroutes\n    if (reroutes.length) {\n      let startControl: Point | undefined\n\n      const l = reroutes.length\n      for (let j = 0; j < l; j++) {\n        const reroute = reroutes[j]\n\n        // Only render once\n        if (!renderedPaths.has(reroute)) {\n          renderedPaths.add(reroute)\n          visibleReroutes.push(reroute)\n          reroute._colour = link.color ||\n            LGraphCanvas.link_type_colors[link.type] ||\n            this.default_link_color\n\n          const prevReroute = graph.getReroute(reroute.parentId)\n          const rerouteStartPos = prevReroute?.pos ?? startPos\n          reroute.calculateAngle(this.last_draw_time, graph, rerouteStartPos)\n\n          // Skip the first segment if it is being dragged\n          if (!reroute._dragging) {\n            this.renderLink(\n              ctx,\n              rerouteStartPos,\n              reroute.pos,\n              link,\n              false,\n              0,\n              null,\n              startControl === undefined ? start_dir : LinkDirection.CENTER,\n              LinkDirection.CENTER,\n              {\n                startControl,\n                endControl: reroute.controlPoint,\n                reroute,\n                disabled,\n              },\n            )\n          }\n        }\n\n        if (!startControl && reroutes.at(-1)?.floating?.slotType === \"input\") {\n          // Floating link connected to an input\n          startControl = [0, 0]\n        } else {\n          // Calculate start control for the next iter control point\n          const nextPos = reroutes[j + 1]?.pos ?? endPos\n          const dist = Math.min(Reroute.maxSplineOffset, distance(reroute.pos, nextPos) * 0.25)\n          startControl = [dist * reroute.cos, dist * reroute.sin]\n        }\n      }\n\n      // Skip the last segment if it is being dragged\n      if (link._dragging) return\n\n      // Use runtime fallback; TypeScript cannot evaluate this correctly.\n      const segmentStartPos = points.at(-2) ?? startPos\n\n      // Render final link segment\n      this.renderLink(\n        ctx,\n        segmentStartPos,\n        endPos,\n        link,\n        false,\n        0,\n        null,\n        LinkDirection.CENTER,\n        end_dir,\n        { startControl, disabled },\n      )\n      // Skip normal render when link is being dragged\n    } else if (!link._dragging) {\n      this.renderLink(\n        ctx,\n        startPos,\n        endPos,\n        link,\n        false,\n        0,\n        null,\n        start_dir,\n        end_dir,\n      )\n    }\n    renderedPaths.add(link)\n\n    // event triggered rendered on top\n    if (link?._last_time && now - link._last_time < 1000) {\n      const f = 2.0 - (now - link._last_time) * 0.002\n      const tmp = ctx.globalAlpha\n      ctx.globalAlpha = tmp * f\n      this.renderLink(\n        ctx,\n        startPos,\n        endPos,\n        link,\n        true,\n        f,\n        \"white\",\n        start_dir,\n        end_dir,\n      )\n      ctx.globalAlpha = tmp\n    }\n  }\n\n  /**\n   * draws a link between two points\n   * @param ctx Canvas 2D rendering context\n   * @param a start pos\n   * @param b end pos\n   * @param link the link object with all the link info\n   * @param skip_border ignore the shadow of the link\n   * @param flow show flow animation (for events)\n   * @param color the color for the link\n   * @param start_dir the direction enum\n   * @param end_dir the direction enum\n   */\n  renderLink(\n    ctx: CanvasRenderingContext2D,\n    a: ReadOnlyPoint,\n    b: ReadOnlyPoint,\n    link: LLink | null,\n    skip_border: boolean,\n    flow: number | null,\n    color: CanvasColour | null,\n    start_dir: LinkDirection,\n    end_dir: LinkDirection,\n    {\n      startControl,\n      endControl,\n      reroute,\n      num_sublines = 1,\n      disabled = false,\n    }: {\n      /** When defined, render data will be saved to this reroute instead of the {@link link}. */\n      reroute?: Reroute\n      /** Offset of the bezier curve control point from {@link a point a} (output side) */\n      startControl?: ReadOnlyPoint\n      /** Offset of the bezier curve control point from {@link b point b} (input side) */\n      endControl?: ReadOnlyPoint\n      /** Number of sublines (useful to represent vec3 or rgb) @todo If implemented, refactor calculations out of the loop */\n      num_sublines?: number\n      /** Whether this is a floating link segment */\n      disabled?: boolean\n    } = {},\n  ): void {\n    const linkColour =\n      link != null && this.highlighted_links[link.id]\n        ? \"#FFF\"\n        : color ||\n          link?.color ||\n          (link?.type != null && LGraphCanvas.link_type_colors[link.type]) ||\n          this.default_link_color\n    const startDir = start_dir || LinkDirection.RIGHT\n    const endDir = end_dir || LinkDirection.LEFT\n\n    const dist = this.links_render_mode == LinkRenderType.SPLINE_LINK && (!endControl || !startControl)\n      ? distance(a, b)\n      : 0\n\n    // TODO: Subline code below was inserted in the wrong place - should be before this statement\n    if (this.render_connections_border && !this.low_quality) {\n      ctx.lineWidth = this.connections_width + 4\n    }\n    ctx.lineJoin = \"round\"\n    num_sublines ||= 1\n    if (num_sublines > 1) ctx.lineWidth = 0.5\n\n    // begin line shape\n    const path = new Path2D()\n\n    /** The link or reroute we're currently rendering */\n    const linkSegment = reroute ?? link\n    if (linkSegment) linkSegment.path = path\n\n    const innerA = LGraphCanvas.#lTempA\n    const innerB = LGraphCanvas.#lTempB\n\n    /** Reference to {@link reroute._pos} if present, or {@link link._pos} if present.  Caches the centre point of the link. */\n    const pos: Point = linkSegment?._pos ?? [0, 0]\n\n    for (let i = 0; i < num_sublines; i++) {\n      const offsety = (i - (num_sublines - 1) * 0.5) * 5\n      innerA[0] = a[0]\n      innerA[1] = a[1]\n      innerB[0] = b[0]\n      innerB[1] = b[1]\n\n      if (this.links_render_mode == LinkRenderType.SPLINE_LINK) {\n        if (endControl) {\n          innerB[0] = b[0] + endControl[0]\n          innerB[1] = b[1] + endControl[1]\n        } else {\n          this.#addSplineOffset(innerB, endDir, dist)\n        }\n        if (startControl) {\n          innerA[0] = a[0] + startControl[0]\n          innerA[1] = a[1] + startControl[1]\n        } else {\n          this.#addSplineOffset(innerA, startDir, dist)\n        }\n        path.moveTo(a[0], a[1] + offsety)\n        path.bezierCurveTo(\n          innerA[0],\n          innerA[1] + offsety,\n          innerB[0],\n          innerB[1] + offsety,\n          b[0],\n          b[1] + offsety,\n        )\n\n        // Calculate centre point\n        findPointOnCurve(pos, a, b, innerA, innerB, 0.5)\n\n        if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {\n          const justPastCentre = LGraphCanvas.#lTempC\n          findPointOnCurve(justPastCentre, a, b, innerA, innerB, 0.51)\n\n          linkSegment._centreAngle = Math.atan2(\n            justPastCentre[1] - pos[1],\n            justPastCentre[0] - pos[0],\n          )\n        }\n      } else {\n        const l = this.links_render_mode == LinkRenderType.LINEAR_LINK ? 15 : 10\n        switch (startDir) {\n        case LinkDirection.LEFT:\n          innerA[0] += -l\n          break\n        case LinkDirection.RIGHT:\n          innerA[0] += l\n          break\n        case LinkDirection.UP:\n          innerA[1] += -l\n          break\n        case LinkDirection.DOWN:\n          innerA[1] += l\n          break\n        }\n        switch (endDir) {\n        case LinkDirection.LEFT:\n          innerB[0] += -l\n          break\n        case LinkDirection.RIGHT:\n          innerB[0] += l\n          break\n        case LinkDirection.UP:\n          innerB[1] += -l\n          break\n        case LinkDirection.DOWN:\n          innerB[1] += l\n          break\n        }\n        if (this.links_render_mode == LinkRenderType.LINEAR_LINK) {\n          path.moveTo(a[0], a[1] + offsety)\n          path.lineTo(innerA[0], innerA[1] + offsety)\n          path.lineTo(innerB[0], innerB[1] + offsety)\n          path.lineTo(b[0], b[1] + offsety)\n\n          // Calculate centre point\n          pos[0] = (innerA[0] + innerB[0]) * 0.5\n          pos[1] = (innerA[1] + innerB[1]) * 0.5\n\n          if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {\n            linkSegment._centreAngle = Math.atan2(\n              innerB[1] - innerA[1],\n              innerB[0] - innerA[0],\n            )\n          }\n        } else if (this.links_render_mode == LinkRenderType.STRAIGHT_LINK) {\n          const midX = (innerA[0] + innerB[0]) * 0.5\n\n          path.moveTo(a[0], a[1])\n          path.lineTo(innerA[0], innerA[1])\n          path.lineTo(midX, innerA[1])\n          path.lineTo(midX, innerB[1])\n          path.lineTo(innerB[0], innerB[1])\n          path.lineTo(b[0], b[1])\n\n          // Calculate centre point\n          pos[0] = midX\n          pos[1] = (innerA[1] + innerB[1]) * 0.5\n\n          if (linkSegment && this.linkMarkerShape === LinkMarkerShape.Arrow) {\n            const diff = innerB[1] - innerA[1]\n            if (Math.abs(diff) < 4) linkSegment._centreAngle = 0\n            else if (diff > 0) linkSegment._centreAngle = Math.PI * 0.5\n            else linkSegment._centreAngle = -(Math.PI * 0.5)\n          }\n        } else {\n          return\n        }\n      }\n    }\n\n    // rendering the outline of the connection can be a little bit slow\n    if (this.render_connections_border && !this.low_quality && !skip_border) {\n      ctx.strokeStyle = \"rgba(0,0,0,0.5)\"\n      ctx.stroke(path)\n    }\n\n    ctx.lineWidth = this.connections_width\n    ctx.fillStyle = ctx.strokeStyle = linkColour\n    ctx.stroke(path)\n\n    // render arrow in the middle\n    if (\n      this.ds.scale >= 0.6 &&\n      this.highquality_render &&\n      linkSegment\n    ) {\n      // render arrow\n      if (this.render_connection_arrows) {\n        // compute two points in the connection\n        const posA = this.computeConnectionPoint(a, b, 0.25, startDir, endDir)\n        const posB = this.computeConnectionPoint(a, b, 0.26, startDir, endDir)\n        const posC = this.computeConnectionPoint(a, b, 0.75, startDir, endDir)\n        const posD = this.computeConnectionPoint(a, b, 0.76, startDir, endDir)\n\n        // compute the angle between them so the arrow points in the right direction\n        let angleA = 0\n        let angleB = 0\n        if (this.render_curved_connections) {\n          angleA = -Math.atan2(posB[0] - posA[0], posB[1] - posA[1])\n          angleB = -Math.atan2(posD[0] - posC[0], posD[1] - posC[1])\n        } else {\n          angleB = angleA = b[1] > a[1] ? 0 : Math.PI\n        }\n\n        // render arrow\n        const transform = ctx.getTransform()\n        ctx.translate(posA[0], posA[1])\n        ctx.rotate(angleA)\n        ctx.beginPath()\n        ctx.moveTo(-5, -3)\n        ctx.lineTo(0, +7)\n        ctx.lineTo(+5, -3)\n        ctx.fill()\n        ctx.setTransform(transform)\n\n        ctx.translate(posC[0], posC[1])\n        ctx.rotate(angleB)\n        ctx.beginPath()\n        ctx.moveTo(-5, -3)\n        ctx.lineTo(0, +7)\n        ctx.lineTo(+5, -3)\n        ctx.fill()\n        ctx.setTransform(transform)\n      }\n\n      // Draw link centre marker\n      ctx.beginPath()\n      if (this.linkMarkerShape === LinkMarkerShape.Arrow) {\n        const transform = ctx.getTransform()\n        ctx.translate(pos[0], pos[1])\n        if (linkSegment._centreAngle) ctx.rotate(linkSegment._centreAngle)\n        // The math is off, but it currently looks better in chromium\n        ctx.moveTo(-3.2, -5)\n        ctx.lineTo(+7, 0)\n        ctx.lineTo(-3.2, +5)\n        ctx.setTransform(transform)\n      } else if (\n        this.linkMarkerShape == null ||\n        this.linkMarkerShape === LinkMarkerShape.Circle\n      ) {\n        ctx.arc(pos[0], pos[1], 5, 0, Math.PI * 2)\n      }\n      if (disabled) {\n        const { fillStyle, globalAlpha } = ctx\n        ctx.fillStyle = this._pattern ?? \"#797979\"\n        ctx.globalAlpha = 0.75\n        ctx.fill()\n        ctx.globalAlpha = globalAlpha\n        ctx.fillStyle = fillStyle\n      }\n      ctx.fill()\n    }\n\n    // render flowing points\n    if (flow) {\n      ctx.fillStyle = linkColour\n      for (let i = 0; i < 5; ++i) {\n        const f = (LiteGraph.getTime() * 0.001 + i * 0.2) % 1\n        const flowPos = this.computeConnectionPoint(a, b, f, startDir, endDir)\n        ctx.beginPath()\n        ctx.arc(flowPos[0], flowPos[1], 5, 0, 2 * Math.PI)\n        ctx.fill()\n      }\n    }\n  }\n\n  /**\n   * Finds a point along a spline represented by a to b, with spline endpoint directions dictacted by start_dir and end_dir.\n   * @param a Start point\n   * @param b End point\n   * @param t Time: distance between points (e.g 0.25 is 25% along the line)\n   * @param start_dir Spline start direction\n   * @param end_dir Spline end direction\n   * @returns The point at {@link t} distance along the spline a-b.\n   */\n  computeConnectionPoint(\n    a: ReadOnlyPoint,\n    b: ReadOnlyPoint,\n    t: number,\n    start_dir: LinkDirection,\n    end_dir: LinkDirection,\n  ): Point {\n    start_dir ||= LinkDirection.RIGHT\n    end_dir ||= LinkDirection.LEFT\n\n    const dist = distance(a, b)\n    const pa: Point = [a[0], a[1]]\n    const pb: Point = [b[0], b[1]]\n\n    this.#addSplineOffset(pa, start_dir, dist)\n    this.#addSplineOffset(pb, end_dir, dist)\n\n    const c1 = (1 - t) * (1 - t) * (1 - t)\n    const c2 = 3 * ((1 - t) * (1 - t)) * t\n    const c3 = 3 * (1 - t) * (t * t)\n    const c4 = t * t * t\n\n    const x = c1 * a[0] + c2 * pa[0] + c3 * pb[0] + c4 * b[0]\n    const y = c1 * a[1] + c2 * pa[1] + c3 * pb[1] + c4 * b[1]\n    return [x, y]\n  }\n\n  /**\n   * Modifies an existing point, adding a single-axis offset.\n   * @param point The point to add the offset to\n   * @param direction The direction to add the offset in\n   * @param dist Distance to offset\n   * @param factor Distance is mulitplied by this value.  Default: 0.25\n   */\n  #addSplineOffset(\n    point: Point,\n    direction: LinkDirection,\n    dist: number,\n    factor = 0.25,\n  ): void {\n    switch (direction) {\n    case LinkDirection.LEFT:\n      point[0] += dist * -factor\n      break\n    case LinkDirection.RIGHT:\n      point[0] += dist * factor\n      break\n    case LinkDirection.UP:\n      point[1] += dist * -factor\n      break\n    case LinkDirection.DOWN:\n      point[1] += dist * factor\n      break\n    }\n  }\n\n  drawExecutionOrder(ctx: CanvasRenderingContext2D): void {\n    ctx.shadowColor = \"transparent\"\n    ctx.globalAlpha = 0.25\n\n    ctx.textAlign = \"center\"\n    ctx.strokeStyle = \"white\"\n    ctx.globalAlpha = 0.75\n\n    const { visible_nodes } = this\n    for (const node of visible_nodes) {\n      ctx.fillStyle = \"black\"\n      ctx.fillRect(\n        node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT,\n        node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT,\n        LiteGraph.NODE_TITLE_HEIGHT,\n        LiteGraph.NODE_TITLE_HEIGHT,\n      )\n      if (node.order == 0) {\n        ctx.strokeRect(\n          node.pos[0] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,\n          node.pos[1] - LiteGraph.NODE_TITLE_HEIGHT + 0.5,\n          LiteGraph.NODE_TITLE_HEIGHT,\n          LiteGraph.NODE_TITLE_HEIGHT,\n        )\n      }\n      ctx.fillStyle = \"#FFF\"\n      ctx.fillText(\n        stringOrEmpty(node.order),\n        node.pos[0] + LiteGraph.NODE_TITLE_HEIGHT * -0.5,\n        node.pos[1] - 6,\n      )\n    }\n    ctx.globalAlpha = 1\n  }\n\n  /**\n   * draws the widgets stored inside a node\n   * @deprecated Use {@link LGraphNode.drawWidgets} instead.\n   * @remarks Currently there are extensions hijacking this function, so we cannot remove it.\n   */\n  drawNodeWidgets(\n    node: LGraphNode,\n    _posY: null,\n    ctx: CanvasRenderingContext2D,\n  ): void {\n    node.drawWidgets(ctx, {\n      lowQuality: this.low_quality,\n      editorAlpha: this.editor_alpha,\n    })\n  }\n\n  /**\n   * draws every group area in the background\n   */\n  drawGroups(canvas: HTMLCanvasElement, ctx: CanvasRenderingContext2D): void {\n    if (!this.graph) return\n\n    const groups = this.graph._groups\n\n    ctx.save()\n    ctx.globalAlpha = 0.5 * this.editor_alpha\n    const drawSnapGuides = this.#snapToGrid && this.isDragging\n\n    for (const group of groups) {\n      // out of the visible area\n      if (!overlapBounding(this.visible_area, group._bounding)) {\n        continue\n      }\n\n      // Draw snap shadow\n      if (drawSnapGuides && this.selectedItems.has(group))\n        this.drawSnapGuide(ctx, group)\n\n      group.draw(this, ctx)\n    }\n\n    ctx.restore()\n  }\n\n  /**\n   * resizes the canvas to a given size, if no size is passed, then it tries to fill the parentNode\n   * @todo Remove or rewrite\n   */\n  resize(width?: number, height?: number): void {\n    if (!width && !height) {\n      const parent = this.canvas.parentElement\n      if (!parent) throw new TypeError(\"Attempted to resize canvas, but parent element was null.\")\n      width = parent.offsetWidth\n      height = parent.offsetHeight\n    }\n\n    if (this.canvas.width == width && this.canvas.height == height) return\n\n    this.canvas.width = width ?? 0\n    this.canvas.height = height ?? 0\n    this.bgcanvas.width = this.canvas.width\n    this.bgcanvas.height = this.canvas.height\n    this.setDirty(true, true)\n  }\n\n  onNodeSelectionChange(): void {}\n\n  /**\n   * Determines the furthest nodes in each direction for the currently selected nodes\n   */\n  boundaryNodesForSelection(): NullableProperties<IBoundaryNodes> {\n    return LGraphCanvas.getBoundaryNodes(this.selected_nodes)\n  }\n\n  showLinkMenu(segment: LinkSegment, e: CanvasMouseEvent): boolean {\n    const { graph } = this\n    if (!graph) throw new NullGraphError()\n\n    const title = \"data\" in segment && segment.data != null\n      ? segment.data.constructor.name\n      : undefined\n\n    const { origin_id, origin_slot } = segment\n    if (origin_id == null || origin_slot == null) {\n      new LiteGraph.ContextMenu<string>([\"Link has no origin\"], {\n        event: e,\n        title,\n      })\n      return false\n    }\n\n    const node_left = graph.getNodeById(origin_id)\n    const fromType = node_left?.outputs?.[origin_slot]?.type\n\n    const options = [\"Add Node\", \"Add Reroute\", null, \"Delete\", null]\n\n    const menu = new LiteGraph.ContextMenu<string>(options, {\n      event: e,\n      title,\n      callback: inner_clicked.bind(this),\n    })\n\n    return false\n\n    function inner_clicked(this: LGraphCanvas, v: string, options: unknown, e: MouseEvent) {\n      if (!graph) throw new NullGraphError()\n\n      switch (v) {\n      case \"Add Node\":\n        LGraphCanvas.onMenuAdd(null, null, e, menu, (node) => {\n          if (!node?.inputs?.length || !node?.outputs?.length || origin_slot == null) return\n\n          // leave the connection type checking inside connectByType\n          const options = { afterRerouteId: segment.parentId }\n          if (node_left?.connectByType(origin_slot, node, fromType ?? \"*\", options)) {\n            node.pos[0] -= node.size[0] * 0.5\n          }\n        })\n        break\n\n      case \"Add Reroute\": {\n        try {\n          this.emitBeforeChange()\n          this.adjustMouseEvent(e)\n          graph.createReroute(segment._pos, segment)\n          this.setDirty(false, true)\n        } catch (error) {\n          console.error(error)\n        } finally {\n          this.emitAfterChange()\n        }\n        break\n      }\n\n      case \"Delete\":\n        graph.removeLink(segment.id)\n        break\n      default:\n      }\n    }\n  }\n\n  createDefaultNodeForSlot(optPass: ICreateDefaultNodeOptions): boolean {\n    type DefaultOptions = ICreateDefaultNodeOptions & {\n      posAdd: Point\n      posSizeFix: Point\n    }\n\n    const opts = Object.assign<DefaultOptions, ICreateDefaultNodeOptions>({\n      nodeFrom: null,\n      slotFrom: null,\n      nodeTo: null,\n      slotTo: null,\n      position: [0, 0],\n      nodeType: undefined,\n      posAdd: [0, 0],\n      posSizeFix: [0, 0],\n    }, optPass)\n    const { afterRerouteId } = opts\n\n    const isFrom = opts.nodeFrom && opts.slotFrom !== null\n    const isTo = !isFrom && opts.nodeTo && opts.slotTo !== null\n\n    if (!isFrom && !isTo) {\n      console.warn(`No data passed to createDefaultNodeForSlot`, opts.nodeFrom, opts.slotFrom, opts.nodeTo, opts.slotTo)\n      return false\n    }\n    if (!opts.nodeType) {\n      console.warn(\"No type to createDefaultNodeForSlot\")\n      return false\n    }\n\n    const nodeX = isFrom ? opts.nodeFrom : opts.nodeTo\n    if (!nodeX) throw new TypeError(\"nodeX was null when creating default node for slot.\")\n\n    let slotX = isFrom ? opts.slotFrom : opts.slotTo\n\n    let iSlotConn: number | false = false\n    switch (typeof slotX) {\n    case \"string\":\n      iSlotConn = isFrom ? nodeX.findOutputSlot(slotX, false) : nodeX.findInputSlot(slotX, false)\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX]\n      break\n    case \"object\":\n      if (slotX === null) {\n        console.warn(\"Cant get slot information\", slotX)\n        return false\n      }\n\n      // ok slotX\n      iSlotConn = isFrom ? nodeX.findOutputSlot(slotX.name) : nodeX.findInputSlot(slotX.name)\n      break\n    case \"number\":\n      iSlotConn = slotX\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX]\n      break\n    case \"undefined\":\n    default:\n      console.warn(\"Cant get slot information\", slotX)\n      return false\n    }\n\n    // check for defaults nodes for this slottype\n    const fromSlotType = slotX.type == LiteGraph.EVENT ? \"_event_\" : slotX.type\n    const slotTypesDefault = isFrom\n      ? LiteGraph.slot_types_default_out\n      : LiteGraph.slot_types_default_in\n    if (slotTypesDefault?.[fromSlotType]) {\n      // TODO: Remove \"any\" kludge\n      let nodeNewType: any = false\n      if (typeof slotTypesDefault[fromSlotType] == \"object\") {\n        for (const typeX in slotTypesDefault[fromSlotType]) {\n          if (\n            opts.nodeType == slotTypesDefault[fromSlotType][typeX] ||\n            opts.nodeType == \"AUTO\"\n          ) {\n            nodeNewType = slotTypesDefault[fromSlotType][typeX]\n            break\n          }\n        }\n      } else if (\n        opts.nodeType == slotTypesDefault[fromSlotType] ||\n        opts.nodeType == \"AUTO\"\n      ) {\n        nodeNewType = slotTypesDefault[fromSlotType]\n      }\n      if (nodeNewType) {\n        // TODO: Remove \"any\" kludge\n        let nodeNewOpts: any = false\n        if (typeof nodeNewType == \"object\" && nodeNewType.node) {\n          nodeNewOpts = nodeNewType\n          nodeNewType = nodeNewType.node\n        }\n\n        // that.graph.beforeChange();\n        const newNode = LiteGraph.createNode(nodeNewType)\n        if (newNode) {\n          // if is object pass options\n          if (nodeNewOpts) {\n            if (nodeNewOpts.properties) {\n              for (const i in nodeNewOpts.properties) {\n                newNode.addProperty(i, nodeNewOpts.properties[i])\n              }\n            }\n            if (nodeNewOpts.inputs) {\n              newNode.inputs = []\n              for (const i in nodeNewOpts.inputs) {\n                newNode.addOutput(\n                  nodeNewOpts.inputs[i][0],\n                  nodeNewOpts.inputs[i][1],\n                )\n              }\n            }\n            if (nodeNewOpts.outputs) {\n              newNode.outputs = []\n              for (const i in nodeNewOpts.outputs) {\n                newNode.addOutput(\n                  nodeNewOpts.outputs[i][0],\n                  nodeNewOpts.outputs[i][1],\n                )\n              }\n            }\n            if (nodeNewOpts.title) {\n              newNode.title = nodeNewOpts.title\n            }\n            if (nodeNewOpts.json) {\n              newNode.configure(nodeNewOpts.json)\n            }\n          }\n\n          // add the node\n          if (!this.graph) throw new NullGraphError()\n\n          this.graph.add(newNode)\n          newNode.pos = [\n            opts.position[0] + opts.posAdd[0] + (opts.posSizeFix[0] ? opts.posSizeFix[0] * newNode.size[0] : 0),\n            opts.position[1] + opts.posAdd[1] + (opts.posSizeFix[1] ? opts.posSizeFix[1] * newNode.size[1] : 0),\n          ]\n\n          // Interim API - allow the link connection to be canceled.\n          // TODO: https://github.com/Comfy-Org/litegraph.js/issues/946\n          const detail = { node: newNode, opts }\n          const mayConnectLinks = this.canvas.dispatchEvent(new CustomEvent(\"connect-new-default-node\", { detail, cancelable: true }))\n          if (!mayConnectLinks) return true\n\n          // connect the two!\n          if (isFrom) {\n            if (!opts.nodeFrom) throw new TypeError(\"createDefaultNodeForSlot - nodeFrom was null\")\n            opts.nodeFrom.connectByType(iSlotConn, newNode, fromSlotType, { afterRerouteId })\n          } else {\n            if (!opts.nodeTo) throw new TypeError(\"createDefaultNodeForSlot - nodeTo was null\")\n            opts.nodeTo.connectByTypeOutput(iSlotConn, newNode, fromSlotType, { afterRerouteId })\n          }\n\n          // if connecting in between\n          if (isFrom && isTo) {\n            // TODO\n          }\n\n          return true\n        }\n        console.log(`failed creating ${nodeNewType}`)\n      }\n    }\n    return false\n  }\n\n  showConnectionMenu(optPass: Partial<ICreateNodeOptions & { e: MouseEvent }>): ContextMenu<string> | undefined {\n    const opts = Object.assign<ICreateNodeOptions & HasShowSearchCallback, ICreateNodeOptions>({\n      nodeFrom: null,\n      slotFrom: null,\n      nodeTo: null,\n      slotTo: null,\n      e: undefined,\n      allow_searchbox: this.allow_searchbox,\n      showSearchBox: this.showSearchBox,\n    }, optPass || {})\n    const dirty = () => this.#dirty()\n    const that = this\n    const { graph } = this\n    const { afterRerouteId } = opts\n\n    const isFrom = opts.nodeFrom && opts.slotFrom\n    const isTo = !isFrom && opts.nodeTo && opts.slotTo\n\n    if (!isFrom && !isTo) {\n      console.warn(\"No data passed to showConnectionMenu\")\n      return\n    }\n\n    const nodeX = isFrom ? opts.nodeFrom : opts.nodeTo\n    if (!nodeX) throw new TypeError(\"nodeX was null when creating default node for slot.\")\n    let slotX = isFrom ? opts.slotFrom : opts.slotTo\n\n    let iSlotConn: number\n    switch (typeof slotX) {\n    case \"string\":\n      iSlotConn = isFrom\n        ? nodeX.findOutputSlot(slotX, false)\n        : nodeX.findInputSlot(slotX, false)\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX]\n      break\n    case \"object\":\n      if (slotX === null) {\n        console.warn(\"Cant get slot information\", slotX)\n        return\n      }\n\n      // ok slotX\n      iSlotConn = isFrom\n        ? nodeX.findOutputSlot(slotX.name)\n        : nodeX.findInputSlot(slotX.name)\n      break\n    case \"number\":\n      iSlotConn = slotX\n      slotX = isFrom ? nodeX.outputs[slotX] : nodeX.inputs[slotX]\n      break\n    default:\n      console.warn(\"Cant get slot information\", slotX)\n      return\n    }\n\n    const options = [\"Add Node\", \"Add Reroute\", null]\n\n    if (opts.allow_searchbox) {\n      options.push(\"Search\", null)\n    }\n\n    // get defaults nodes for this slottype\n    const fromSlotType = slotX.type == LiteGraph.EVENT ? \"_event_\" : slotX.type\n    const slotTypesDefault = isFrom\n      ? LiteGraph.slot_types_default_out\n      : LiteGraph.slot_types_default_in\n    if (slotTypesDefault?.[fromSlotType]) {\n      if (typeof slotTypesDefault[fromSlotType] == \"object\") {\n        for (const typeX in slotTypesDefault[fromSlotType]) {\n          options.push(slotTypesDefault[fromSlotType][typeX])\n        }\n      } else {\n        options.push(slotTypesDefault[fromSlotType])\n      }\n    }\n\n    // build menu\n    const menu = new LiteGraph.ContextMenu<string>(options, {\n      event: opts.e,\n      extra: slotX,\n      title:\n        (slotX && slotX.name != \"\"\n          ? slotX.name + (fromSlotType ? \" | \" : \"\")\n          : \"\") + (slotX && fromSlotType ? fromSlotType : \"\"),\n      callback: inner_clicked,\n    })\n\n    return menu\n\n    // callback\n    function inner_clicked(v: string | undefined, options: IContextMenuOptions<string, INodeInputSlot | INodeOutputSlot>, e: MouseEvent) {\n      switch (v) {\n      case \"Add Node\":\n        LGraphCanvas.onMenuAdd(null, null, e, menu, function (node) {\n          if (!node) return\n\n          if (isFrom) {\n            opts.nodeFrom?.connectByType(iSlotConn, node, fromSlotType, { afterRerouteId })\n          } else {\n            opts.nodeTo?.connectByTypeOutput(iSlotConn, node, fromSlotType, { afterRerouteId })\n          }\n        })\n        break\n      case \"Add Reroute\":{\n        const node = isFrom ? opts.nodeFrom : opts.nodeTo\n        const slot = options.extra\n\n        if (!graph) throw new NullGraphError()\n        if (!node) throw new TypeError(\"Cannot add reroute: node was null\")\n        if (!slot) throw new TypeError(\"Cannot add reroute: slot was null\")\n        if (!opts.e) throw new TypeError(\"Cannot add reroute: CanvasPointerEvent was null\")\n\n        const reroute = node.connectFloatingReroute([opts.e.canvasX, opts.e.canvasY], slot, afterRerouteId)\n        if (!reroute) throw new Error(\"Failed to create reroute\")\n\n        dirty()\n        break\n      }\n      case \"Search\":\n        if (isFrom) {\n          opts.showSearchBox(e, { node_from: opts.nodeFrom, slot_from: slotX, type_filter_in: fromSlotType })\n        } else {\n          opts.showSearchBox(e, { node_to: opts.nodeTo, slot_from: slotX, type_filter_out: fromSlotType })\n        }\n        break\n      default: {\n        const customProps = {\n          position: [opts.e?.canvasX ?? 0, opts.e?.canvasY ?? 0],\n          nodeType: v,\n          afterRerouteId,\n        } satisfies Partial<ICreateDefaultNodeOptions>\n\n        const options = Object.assign(opts, customProps)\n        that.createDefaultNodeForSlot(options)\n        break\n      }\n      }\n    }\n  }\n\n  // refactor: there are different dialogs, some uses createDialog some dont\n  prompt(\n    title: string,\n    value: any,\n    callback: (arg0: any) => void,\n    event: CanvasMouseEvent,\n    multiline?: boolean,\n  ): HTMLDivElement {\n    const that = this\n    title = title || \"\"\n\n    const customProperties = {\n      is_modified: false,\n      className: \"graphdialog rounded\",\n      innerHTML: multiline\n        ? \"<span class='name'></span> <textarea autofocus class='value'></textarea><button class='rounded'>OK</button>\"\n        : \"<span class='name'></span> <input autofocus type='text' class='value'/><button class='rounded'>OK</button>\",\n      close() {\n        that.prompt_box = null\n        if (dialog.parentNode) {\n          dialog.remove()\n        }\n      },\n    } satisfies Partial<IDialog>\n\n    const div = document.createElement(\"div\")\n    const dialog: PromptDialog = Object.assign(div, customProperties)\n\n    const graphcanvas = LGraphCanvas.active_canvas\n    const { canvas } = graphcanvas\n    if (!canvas.parentNode) throw new TypeError(\"canvas element parentNode was null when opening a prompt.\")\n    canvas.parentNode.append(dialog)\n\n    if (this.ds.scale > 1) dialog.style.transform = `scale(${this.ds.scale})`\n\n    let dialogCloseTimer: number\n    let prevent_timeout = 0\n    LiteGraph.pointerListenerAdd(dialog, \"leave\", function () {\n      if (prevent_timeout) return\n      if (LiteGraph.dialog_close_on_mouse_leave) {\n        if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave) {\n          dialogCloseTimer = setTimeout(\n            dialog.close,\n            LiteGraph.dialog_close_on_mouse_leave_delay,\n          )\n        }\n      }\n    })\n    LiteGraph.pointerListenerAdd(dialog, \"enter\", function () {\n      if (LiteGraph.dialog_close_on_mouse_leave && dialogCloseTimer)\n        clearTimeout(dialogCloseTimer)\n    })\n    const selInDia = dialog.querySelectorAll(\"select\")\n    if (selInDia) {\n      // if filtering, check focus changed to comboboxes and prevent closing\n      for (const selIn of selInDia) {\n        selIn.addEventListener(\"click\", function () {\n          prevent_timeout++\n        })\n        selIn.addEventListener(\"blur\", function () {\n          prevent_timeout = 0\n        })\n        selIn.addEventListener(\"change\", function () {\n          prevent_timeout = -1\n        })\n      }\n    }\n    this.prompt_box?.close()\n    this.prompt_box = dialog\n\n    const name_element: HTMLSpanElement | null = dialog.querySelector(\".name\")\n    if (!name_element) throw new TypeError(\"name_element was null\")\n\n    name_element.textContent = title\n    const value_element: HTMLInputElement | null = dialog.querySelector(\".value\")\n    if (!value_element) throw new TypeError(\"value_element was null\")\n\n    value_element.value = value\n    value_element.select()\n\n    const input = value_element\n    input.addEventListener(\"keydown\", function (e: KeyboardEvent) {\n      dialog.is_modified = true\n      if (e.key == \"Escape\") {\n        // ESC\n        dialog.close()\n      } else if (\n        e.key == \"Enter\" &&\n        (e.target as Element).localName != \"textarea\"\n      ) {\n        if (callback) {\n          callback(this.value)\n        }\n        dialog.close()\n      } else {\n        return\n      }\n      e.preventDefault()\n      e.stopPropagation()\n    })\n\n    const button = dialog.querySelector(\"button\")\n    if (!button) throw new TypeError(\"button was null when opening prompt\")\n\n    button.addEventListener(\"click\", function () {\n      callback?.(input.value)\n      that.setDirty(true)\n      dialog.close()\n    })\n\n    const rect = canvas.getBoundingClientRect()\n    let offsetx = -20\n    let offsety = -20\n    if (rect) {\n      offsetx -= rect.left\n      offsety -= rect.top\n    }\n\n    if (event) {\n      dialog.style.left = `${event.clientX + offsetx}px`\n      dialog.style.top = `${event.clientY + offsety}px`\n    } else {\n      dialog.style.left = `${canvas.width * 0.5 + offsetx}px`\n      dialog.style.top = `${canvas.height * 0.5 + offsety}px`\n    }\n\n    setTimeout(function () {\n      input.focus()\n      const clickTime = Date.now()\n      function handleOutsideClick(e: Event) {\n        if (e.target === canvas && Date.now() - clickTime > 256) {\n          dialog.close()\n          canvas.parentElement?.removeEventListener(\"click\", handleOutsideClick)\n          canvas.parentElement?.removeEventListener(\"touchend\", handleOutsideClick)\n        }\n      }\n      canvas.parentElement?.addEventListener(\"click\", handleOutsideClick)\n      canvas.parentElement?.addEventListener(\"touchend\", handleOutsideClick)\n    }, 10)\n\n    return dialog\n  }\n\n  showSearchBox(\n    event: MouseEvent,\n    searchOptions?: IShowSearchOptions,\n  ): HTMLDivElement {\n    // proposed defaults\n    const options: IShowSearchOptions = {\n      slot_from: null,\n      node_from: null,\n      node_to: null,\n      // TODO check for registered_slot_[in/out]_types not empty\n      // this will be checked for functionality enabled : filter on slot type, in and out\n      do_type_filter: LiteGraph.search_filter_enabled,\n\n      // these are default: pass to set initially set values\n      // @ts-expect-error\n      type_filter_in: false,\n\n      type_filter_out: false,\n      show_general_if_none_on_typefilter: true,\n      show_general_after_typefiltered: true,\n      hide_on_mouse_leave: LiteGraph.search_hide_on_mouse_leave,\n      show_all_if_empty: true,\n      show_all_on_open: LiteGraph.search_show_all_on_open,\n    }\n    Object.assign(options, searchOptions)\n\n    // console.log(options);\n    const that = this\n    const graphcanvas = LGraphCanvas.active_canvas\n    const { canvas } = graphcanvas\n    const root_document = canvas.ownerDocument || document\n\n    const div = document.createElement(\"div\")\n    const dialog = Object.assign(div, {\n      close(this: typeof div) {\n        that.search_box = undefined\n        this.blur()\n        canvas.focus()\n        root_document.body.style.overflow = \"\"\n\n        // important, if canvas loses focus keys wont be captured\n        setTimeout(() => canvas.focus(), 20)\n        dialog.remove()\n      },\n    } satisfies Partial<HTMLDivElement> & ICloseable)\n    dialog.className = \"litegraph litesearchbox graphdialog rounded\"\n    dialog.innerHTML = \"<span class='name'>Search</span> <input autofocus type='text' class='value rounded'/>\"\n    if (options.do_type_filter) {\n      dialog.innerHTML += \"<select class='slot_in_type_filter'><option value=''></option></select>\"\n      dialog.innerHTML += \"<select class='slot_out_type_filter'><option value=''></option></select>\"\n    }\n    const helper = document.createElement(\"div\")\n    helper.className = \"helper\"\n    dialog.append(helper)\n\n    if (root_document.fullscreenElement) {\n      root_document.fullscreenElement.append(dialog)\n    } else {\n      root_document.body.append(dialog)\n      root_document.body.style.overflow = \"hidden\"\n    }\n\n    // dialog element has been appended\n    let selIn\n    let selOut\n    if (options.do_type_filter) {\n      selIn = dialog.querySelector(\".slot_in_type_filter\")\n      selOut = dialog.querySelector(\".slot_out_type_filter\")\n    }\n\n    if (this.ds.scale > 1) {\n      dialog.style.transform = `scale(${this.ds.scale})`\n    }\n\n    // hide on mouse leave\n    if (options.hide_on_mouse_leave) {\n      // FIXME: Remove \"any\" kludge\n      let prevent_timeout: any = false\n      let timeout_close: number | null = null\n      LiteGraph.pointerListenerAdd(dialog, \"enter\", function () {\n        if (timeout_close) {\n          clearTimeout(timeout_close)\n          timeout_close = null\n        }\n      })\n      dialog.addEventListener(\"pointerleave\", function () {\n        if (prevent_timeout) return\n\n        const hideDelay = options.hide_on_mouse_leave\n        const delay = typeof hideDelay === \"number\" ? hideDelay : 500\n        timeout_close = setTimeout(dialog.close, delay)\n      })\n      // if filtering, check focus changed to comboboxes and prevent closing\n      if (options.do_type_filter) {\n        if (!selIn) throw new TypeError(\"selIn was null when showing search box\")\n        if (!selOut) throw new TypeError(\"selOut was null when showing search box\")\n\n        selIn.addEventListener(\"click\", function () {\n          prevent_timeout++\n        })\n        selIn.addEventListener(\"blur\", function () {\n          prevent_timeout = 0\n        })\n        selIn.addEventListener(\"change\", function () {\n          prevent_timeout = -1\n        })\n        selOut.addEventListener(\"click\", function () {\n          prevent_timeout++\n        })\n        selOut.addEventListener(\"blur\", function () {\n          prevent_timeout = 0\n        })\n        selOut.addEventListener(\"change\", function () {\n          prevent_timeout = -1\n        })\n      }\n    }\n\n    // @ts-expect-error Panel?\n    that.search_box?.close()\n    that.search_box = dialog\n\n    let first: string | null = null\n    let timeout: number | null = null\n    let selected: ChildNode | null = null\n\n    const maybeInput = dialog.querySelector(\"input\")\n    if (!maybeInput) throw new TypeError(\"Could not create search input box.\")\n\n    const input = maybeInput\n\n    if (input) {\n      input.addEventListener(\"blur\", function () {\n        this.focus()\n      })\n      input.addEventListener(\"keydown\", function (e) {\n        if (e.key == \"ArrowUp\") {\n          // UP\n          changeSelection(false)\n        } else if (e.key == \"ArrowDown\") {\n          // DOWN\n          changeSelection(true)\n        } else if (e.key == \"Escape\") {\n          // ESC\n          dialog.close()\n        } else if (e.key == \"Enter\") {\n          if (selected instanceof HTMLElement) {\n            select(unescape(String(selected.dataset[\"type\"])))\n          } else if (first) {\n            select(first)\n          } else {\n            dialog.close()\n          }\n        } else {\n          if (timeout) {\n            clearInterval(timeout)\n          }\n          timeout = setTimeout(refreshHelper, 10)\n          return\n        }\n        e.preventDefault()\n        e.stopPropagation()\n        e.stopImmediatePropagation()\n        return true\n      })\n    }\n\n    // if should filter on type, load and fill selected and choose elements if passed\n    if (options.do_type_filter) {\n      if (selIn) {\n        const aSlots = LiteGraph.slot_types_in\n        const nSlots = aSlots.length\n\n        if (\n          options.type_filter_in == LiteGraph.EVENT ||\n          options.type_filter_in == LiteGraph.ACTION\n        ) {\n          options.type_filter_in = \"_event_\"\n        }\n        for (let iK = 0; iK < nSlots; iK++) {\n          const opt = document.createElement(\"option\")\n          opt.value = aSlots[iK]\n          opt.innerHTML = aSlots[iK]\n          selIn.append(opt)\n          if (\n            // @ts-expect-error\n            options.type_filter_in !== false &&\n            String(options.type_filter_in).toLowerCase() ==\n            String(aSlots[iK]).toLowerCase()\n          ) {\n            opt.selected = true\n          }\n        }\n        selIn.addEventListener(\"change\", function () {\n          refreshHelper()\n        })\n      }\n      if (selOut) {\n        const aSlots = LiteGraph.slot_types_out\n\n        if (\n          options.type_filter_out == LiteGraph.EVENT ||\n          options.type_filter_out == LiteGraph.ACTION\n        ) {\n          options.type_filter_out = \"_event_\"\n        }\n        for (const aSlot of aSlots) {\n          const opt = document.createElement(\"option\")\n          opt.value = aSlot\n          opt.innerHTML = aSlot\n          selOut.append(opt)\n          if (\n            options.type_filter_out !== false &&\n            String(options.type_filter_out).toLowerCase() ==\n            String(aSlot).toLowerCase()\n          ) {\n            opt.selected = true\n          }\n        }\n        selOut.addEventListener(\"change\", function () {\n          refreshHelper()\n        })\n      }\n    }\n\n    // compute best position\n    const rect = canvas.getBoundingClientRect()\n\n    const left = (event ? event.clientX : rect.left + rect.width * 0.5) - 80\n    const top = (event ? event.clientY : rect.top + rect.height * 0.5) - 20\n    dialog.style.left = `${left}px`\n    dialog.style.top = `${top}px`\n\n    // To avoid out of screen problems\n    if (event.layerY > rect.height - 200) {\n      helper.style.maxHeight = `${rect.height - event.layerY - 20}px`\n    }\n    requestAnimationFrame(function () {\n      input.focus()\n    })\n    if (options.show_all_on_open) refreshHelper()\n\n    function select(name: string) {\n      if (name) {\n        if (that.onSearchBoxSelection) {\n          that.onSearchBoxSelection(name, event, graphcanvas)\n        } else {\n          if (!graphcanvas.graph) throw new NullGraphError()\n\n          graphcanvas.graph.beforeChange()\n          const node = LiteGraph.createNode(name)\n          if (node) {\n            node.pos = graphcanvas.convertEventToCanvasOffset(event)\n            graphcanvas.graph.add(node, false)\n          }\n\n          // join node after inserting\n          if (options.node_from) {\n            // FIXME: any\n            let iS: any = false\n            switch (typeof options.slot_from) {\n            case \"string\":\n              iS = options.node_from.findOutputSlot(options.slot_from)\n              break\n            case \"object\":\n              if (options.slot_from == null) throw new TypeError(\"options.slot_from was null when showing search box\")\n\n              iS = options.slot_from.name\n                ? options.node_from.findOutputSlot(options.slot_from.name)\n                : -1\n              // @ts-expect-error change interface check\n              if (iS == -1 && options.slot_from.slot_index !== undefined) iS = options.slot_from.slot_index\n              break\n            case \"number\":\n              iS = options.slot_from\n              break\n            default:\n              // try with first if no name set\n              iS = 0\n            }\n            if (options.node_from.outputs[iS] !== undefined) {\n              if (iS !== false && iS > -1) {\n                if (node == null) throw new TypeError(\"options.slot_from was null when showing search box\")\n\n                options.node_from.connectByType(iS, node, options.node_from.outputs[iS].type)\n              }\n            } else {\n              // console.warn(\"cant find slot \" + options.slot_from);\n            }\n          }\n          if (options.node_to) {\n            // FIXME: any\n            let iS: any = false\n            switch (typeof options.slot_from) {\n            case \"string\":\n              iS = options.node_to.findInputSlot(options.slot_from)\n              break\n            case \"object\":\n              if (options.slot_from == null) throw new TypeError(\"options.slot_from was null when showing search box\")\n\n              iS = options.slot_from.name\n                ? options.node_to.findInputSlot(options.slot_from.name)\n                : -1\n              // @ts-expect-error change interface check\n              if (iS == -1 && options.slot_from.slot_index !== undefined) iS = options.slot_from.slot_index\n              break\n            case \"number\":\n              iS = options.slot_from\n              break\n            default:\n              // try with first if no name set\n              iS = 0\n            }\n            if (options.node_to.inputs[iS] !== undefined) {\n              if (iS !== false && iS > -1) {\n                if (node == null) throw new TypeError(\"options.slot_from was null when showing search box\")\n                // try connection\n                options.node_to.connectByTypeOutput(iS, node, options.node_to.inputs[iS].type)\n              }\n            } else {\n              // console.warn(\"cant find slot_nodeTO \" + options.slot_from);\n            }\n          }\n\n          graphcanvas.graph.afterChange()\n        }\n      }\n\n      dialog.close()\n    }\n\n    function changeSelection(forward: boolean) {\n      const prev = selected\n      if (!selected) {\n        selected = forward\n          ? helper.childNodes[0]\n          : helper.childNodes[helper.childNodes.length]\n      } else if (selected instanceof Element) {\n        selected.classList.remove(\"selected\")\n        selected = forward\n          ? selected.nextSibling\n          : selected.previousSibling\n        selected ||= prev\n      }\n\n      if (selected instanceof Element) {\n        selected.classList.add(\"selected\")\n        selected.scrollIntoView({ block: \"end\", behavior: \"smooth\" })\n      }\n    }\n\n    function refreshHelper() {\n      timeout = null\n      let str = input.value\n      first = null\n      helper.innerHTML = \"\"\n      if (!str && !options.show_all_if_empty) return\n\n      if (that.onSearchBox) {\n        const list = that.onSearchBox(helper, str, graphcanvas)\n        if (list) {\n          for (const item of list) {\n            addResult(item)\n          }\n        }\n      } else {\n        let c = 0\n        str = str.toLowerCase()\n        if (!graphcanvas.graph) throw new NullGraphError()\n\n        const filter = graphcanvas.filter || graphcanvas.graph.filter\n\n        // FIXME: any\n        // filter by type preprocess\n        let sIn: any = false\n        let sOut: any = false\n        if (options.do_type_filter && that.search_box) {\n          sIn = that.search_box.querySelector(\".slot_in_type_filter\")\n          sOut = that.search_box.querySelector(\".slot_out_type_filter\")\n        }\n\n        const keys = Object.keys(LiteGraph.registered_node_types)\n        const filtered = keys.filter(x => inner_test_filter(x))\n\n        for (const item of filtered) {\n          addResult(item)\n          if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)\n            break\n        }\n\n        // add general type if filtering\n        if (\n          options.show_general_after_typefiltered &&\n          (sIn.value || sOut.value)\n        ) {\n          // FIXME: Undeclared variable again\n          // @ts-expect-error\n          filtered_extra = []\n          for (const i in LiteGraph.registered_node_types) {\n            if (\n              inner_test_filter(i, {\n                inTypeOverride: sIn && sIn.value ? \"*\" : false,\n                outTypeOverride: sOut && sOut.value ? \"*\" : false,\n              })\n            ) {\n              // @ts-expect-error\n              filtered_extra.push(i)\n            }\n          }\n          // @ts-expect-error\n          for (const extraItem of filtered_extra) {\n            addResult(extraItem, \"generic_type\")\n            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)\n              break\n          }\n        }\n\n        // check il filtering gave no results\n        if (\n          (sIn.value || sOut.value) &&\n          helper.childNodes.length == 0 &&\n          options.show_general_if_none_on_typefilter\n        ) {\n          // @ts-expect-error\n          filtered_extra = []\n          for (const i in LiteGraph.registered_node_types) {\n            if (inner_test_filter(i, { skipFilter: true }))\n              // @ts-expect-error\n              filtered_extra.push(i)\n          }\n          // @ts-expect-error\n          for (const extraItem of filtered_extra) {\n            addResult(extraItem, \"not_in_filter\")\n            if (LGraphCanvas.search_limit !== -1 && c++ > LGraphCanvas.search_limit)\n              break\n          }\n        }\n\n        function inner_test_filter(\n          type: string,\n          optsIn?: {\n            inTypeOverride?: string | boolean\n            outTypeOverride?: string | boolean\n            skipFilter?: boolean\n          },\n        ): boolean {\n          optsIn = optsIn || {}\n          const optsDef = {\n            skipFilter: false,\n            inTypeOverride: false,\n            outTypeOverride: false,\n          }\n          const opts = Object.assign(optsDef, optsIn)\n          const ctor = LiteGraph.registered_node_types[type]\n          if (filter && ctor.filter != filter) return false\n          if (\n            (!options.show_all_if_empty || str) &&\n            !type.toLowerCase().includes(str) &&\n            (!ctor.title || !ctor.title.toLowerCase().includes(str))\n          ) {\n            return false\n          }\n\n          // filter by slot IN, OUT types\n          if (options.do_type_filter && !opts.skipFilter) {\n            const sType = type\n\n            let sV = opts.inTypeOverride !== false\n              ? opts.inTypeOverride\n              : sIn.value\n            // type is stored\n            if (sIn && sV && LiteGraph.registered_slot_in_types[sV]?.nodes) {\n              const doesInc = LiteGraph.registered_slot_in_types[sV].nodes.includes(sType)\n              if (doesInc === false) return false\n            }\n\n            sV = sOut.value\n            if (opts.outTypeOverride !== false) sV = opts.outTypeOverride\n            // type is stored\n            if (sOut && sV && LiteGraph.registered_slot_out_types[sV]?.nodes) {\n              const doesInc = LiteGraph.registered_slot_out_types[sV].nodes.includes(sType)\n              if (doesInc === false) return false\n            }\n          }\n          return true\n        }\n      }\n\n      function addResult(type: string, className?: string): void {\n        const help = document.createElement(\"div\")\n        first ||= type\n\n        const nodeType = LiteGraph.registered_node_types[type]\n        if (nodeType?.title) {\n          help.textContent = nodeType?.title\n          const typeEl = document.createElement(\"span\")\n          typeEl.className = \"litegraph lite-search-item-type\"\n          typeEl.textContent = type\n          help.append(typeEl)\n        } else {\n          help.textContent = type\n        }\n\n        help.dataset[\"type\"] = escape(type)\n        help.className = \"litegraph lite-search-item\"\n        if (className) {\n          help.className += ` ${className}`\n        }\n        help.addEventListener(\"click\", function () {\n          select(unescape(String(this.dataset[\"type\"])))\n        })\n        helper.append(help)\n      }\n    }\n\n    return dialog\n  }\n\n  showEditPropertyValue(\n    node: LGraphNode,\n    property: string,\n    options: IDialogOptions,\n  ): IDialog | undefined {\n    if (!node || node.properties[property] === undefined) return\n\n    options = options || {}\n\n    const info = node.getPropertyInfo(property)\n    const { type } = info\n\n    let input_html = \"\"\n\n    if (\n      type == \"string\" ||\n      type == \"number\" ||\n      type == \"array\" ||\n      type == \"object\"\n    ) {\n      input_html = \"<input autofocus type='text' class='value'/>\"\n    } else if ((type == \"enum\" || type == \"combo\") && info.values) {\n      input_html = \"<select autofocus type='text' class='value'>\"\n      for (const i in info.values) {\n        const v = Array.isArray(info.values) ? info.values[i] : i\n\n        const selected = v == node.properties[property] ? \"selected\" : \"\"\n        input_html += `<option value='${v}' ${selected}>${info.values[i]}</option>`\n      }\n      input_html += \"</select>\"\n    } else if (type == \"boolean\" || type == \"toggle\") {\n      const checked = node.properties[property] ? \"checked\" : \"\"\n      input_html = `<input autofocus type='checkbox' class='value' ${checked}/>`\n    } else {\n      console.warn(`unknown type: ${type}`)\n      return\n    }\n\n    const dialog = this.createDialog(\n      `<span class='name'>${info.label || property}</span>${input_html}<button>OK</button>`,\n      options,\n    )\n\n    let input: HTMLInputElement | HTMLSelectElement | null\n    if ((type == \"enum\" || type == \"combo\") && info.values) {\n      input = dialog.querySelector(\"select\")\n      input?.addEventListener(\"change\", function (e) {\n        dialog.modified()\n        setValue((e.target as HTMLSelectElement)?.value)\n      })\n    } else if (type == \"boolean\" || type == \"toggle\") {\n      input = dialog.querySelector(\"input\")\n      input?.addEventListener(\"click\", function () {\n        dialog.modified()\n        // @ts-expect-error\n        setValue(!!input.checked)\n      })\n    } else {\n      input = dialog.querySelector(\"input\")\n      if (input) {\n        input.addEventListener(\"blur\", function () {\n          this.focus()\n        })\n\n        let v = node.properties[property] !== undefined\n          ? node.properties[property]\n          : \"\"\n        if (type !== \"string\") {\n          v = JSON.stringify(v)\n        }\n\n        // @ts-expect-error\n        input.value = v\n        input.addEventListener(\"keydown\", function (e) {\n          if (e.key == \"Escape\") {\n            // ESC\n            dialog.close()\n          } else if (e.key == \"Enter\") {\n            // ENTER\n            // save\n            inner()\n          } else {\n            dialog.modified()\n            return\n          }\n          e.preventDefault()\n          e.stopPropagation()\n        })\n      }\n    }\n    input?.focus()\n\n    const button = dialog.querySelector(\"button\")\n    if (!button) throw new TypeError(\"Show edit property value button was null.\")\n    button.addEventListener(\"click\", inner)\n\n    function inner() {\n      setValue(input?.value)\n    }\n    const dirty = () => this.#dirty()\n\n    function setValue(value: string | number | undefined) {\n      if (\n        info?.values &&\n        typeof info.values === \"object\" &&\n        info.values[value] != undefined\n      ) {\n        value = info.values[value]\n      }\n\n      if (typeof node.properties[property] == \"number\") {\n        value = Number(value)\n      }\n      if (type == \"array\" || type == \"object\") {\n        // @ts-expect-error JSON.parse doesn't care.\n        value = JSON.parse(value)\n      }\n      node.properties[property] = value\n      if (node.graph) {\n        node.graph._version++\n      }\n      node.onPropertyChanged?.(property, value)\n      options.onclose?.()\n      dialog.close()\n      dirty()\n    }\n\n    return dialog\n  }\n\n  // TODO refactor, theer are different dialog, some uses createDialog, some dont\n  createDialog(html: string, options: IDialogOptions): IDialog {\n    const def_options = {\n      checkForInput: false,\n      closeOnLeave: true,\n      closeOnLeave_checkModified: true,\n    }\n    options = Object.assign(def_options, options || {})\n\n    const customProperties = {\n      className: \"graphdialog\",\n      innerHTML: html,\n      is_modified: false,\n      modified() {\n        this.is_modified = true\n      },\n      close(this: IDialog) {\n        this.remove()\n      },\n    } satisfies Partial<IDialog>\n\n    const div = document.createElement(\"div\")\n    const dialog: IDialog = Object.assign(div, customProperties)\n\n    const rect = this.canvas.getBoundingClientRect()\n    let offsetx = -20\n    let offsety = -20\n    if (rect) {\n      offsetx -= rect.left\n      offsety -= rect.top\n    }\n\n    if (options.position) {\n      offsetx += options.position[0]\n      offsety += options.position[1]\n    } else if (options.event) {\n      offsetx += options.event.clientX\n      offsety += options.event.clientY\n    } else {\n      // centered\n      offsetx += this.canvas.width * 0.5\n      offsety += this.canvas.height * 0.5\n    }\n\n    dialog.style.left = `${offsetx}px`\n    dialog.style.top = `${offsety}px`\n\n    if (!this.canvas.parentNode) throw new TypeError(\"Canvas parent element was null.\")\n    this.canvas.parentNode.append(dialog)\n\n    // acheck for input and use default behaviour: save on enter, close on esc\n    if (options.checkForInput) {\n      const aI = dialog.querySelectorAll(\"input\")\n      if (aI) {\n        for (const iX of aI) {\n          iX.addEventListener(\"keydown\", function (e) {\n            dialog.modified()\n            if (e.key == \"Escape\") {\n              dialog.close()\n            } else if (e.key != \"Enter\") {\n              return\n            }\n            e.preventDefault()\n            e.stopPropagation()\n          })\n          iX.focus()\n        }\n      }\n    }\n\n    let dialogCloseTimer: number\n    let prevent_timeout = 0\n    dialog.addEventListener(\"mouseleave\", function () {\n      if (prevent_timeout) return\n\n      if (!dialog.is_modified && LiteGraph.dialog_close_on_mouse_leave) {\n        dialogCloseTimer = setTimeout(\n          dialog.close,\n          LiteGraph.dialog_close_on_mouse_leave_delay,\n        )\n      }\n    })\n    dialog.addEventListener(\"mouseenter\", function () {\n      if (options.closeOnLeave || LiteGraph.dialog_close_on_mouse_leave) {\n        if (dialogCloseTimer) clearTimeout(dialogCloseTimer)\n      }\n    })\n    const selInDia = dialog.querySelectorAll(\"select\")\n    // if filtering, check focus changed to comboboxes and prevent closing\n    if (selInDia) {\n      for (const selIn of selInDia) {\n        selIn.addEventListener(\"click\", function () {\n          prevent_timeout++\n        })\n        selIn.addEventListener(\"blur\", function () {\n          prevent_timeout = 0\n        })\n        selIn.addEventListener(\"change\", function () {\n          prevent_timeout = -1\n        })\n      }\n    }\n\n    return dialog\n  }\n\n  createPanel(title: string, options: ICreatePanelOptions) {\n    options = options || {}\n\n    const ref_window = options.window || window\n    // TODO: any kludge\n    const root: any = document.createElement(\"div\")\n    root.className = \"litegraph dialog\"\n    root.innerHTML = \"<div class='dialog-header'><span class='dialog-title'></span></div><div class='dialog-content'></div><div style='display:none;' class='dialog-alt-content'></div><div class='dialog-footer'></div>\"\n    root.header = root.querySelector(\".dialog-header\")\n\n    if (options.width)\n      root.style.width = options.width + (typeof options.width === \"number\" ? \"px\" : \"\")\n    if (options.height)\n      root.style.height = options.height + (typeof options.height === \"number\" ? \"px\" : \"\")\n    if (options.closable) {\n      const close = document.createElement(\"span\")\n      close.innerHTML = \"&#10005;\"\n      close.classList.add(\"close\")\n      close.addEventListener(\"click\", function () {\n        root.close()\n      })\n      root.header.append(close)\n    }\n    root.title_element = root.querySelector(\".dialog-title\")\n    root.title_element.textContent = title\n    root.content = root.querySelector(\".dialog-content\")\n    root.alt_content = root.querySelector(\".dialog-alt-content\")\n    root.footer = root.querySelector(\".dialog-footer\")\n\n    root.close = function () {\n      if (typeof root.onClose == \"function\") root.onClose()\n      root.remove()\n      this.remove()\n    }\n\n    // function to swap panel content\n    root.toggleAltContent = function (force: unknown) {\n      let vTo: string\n      let vAlt: string\n      if (force !== undefined) {\n        vTo = force ? \"block\" : \"none\"\n        vAlt = force ? \"none\" : \"block\"\n      } else {\n        vTo = root.alt_content.style.display != \"block\" ? \"block\" : \"none\"\n        vAlt = root.alt_content.style.display != \"block\" ? \"none\" : \"block\"\n      }\n      root.alt_content.style.display = vTo\n      root.content.style.display = vAlt\n    }\n\n    root.toggleFooterVisibility = function (force: unknown) {\n      let vTo: string\n      if (force !== undefined) {\n        vTo = force ? \"block\" : \"none\"\n      } else {\n        vTo = root.footer.style.display != \"block\" ? \"block\" : \"none\"\n      }\n      root.footer.style.display = vTo\n    }\n\n    root.clear = function () {\n      this.content.innerHTML = \"\"\n    }\n\n    root.addHTML = function (code: string, classname: string, on_footer: any) {\n      const elem = document.createElement(\"div\")\n      if (classname) elem.className = classname\n      elem.innerHTML = code\n      if (on_footer) root.footer.append(elem)\n      else root.content.append(elem)\n      return elem\n    }\n\n    root.addButton = function (name: any, callback: any, options: any) {\n      // TODO: any kludge\n      const elem: any = document.createElement(\"button\")\n      elem.textContent = name\n      elem.options = options\n      elem.classList.add(\"btn\")\n      elem.addEventListener(\"click\", callback)\n      root.footer.append(elem)\n      return elem\n    }\n\n    root.addSeparator = function () {\n      const elem = document.createElement(\"div\")\n      elem.className = \"separator\"\n      root.content.append(elem)\n    }\n\n    root.addWidget = function (type: string, name: any, value: unknown, options: { label?: any, type?: any, values?: any, callback?: any }, callback: (arg0: any, arg1: any, arg2: any) => void) {\n      options = options || {}\n      let str_value = String(value)\n      type = type.toLowerCase()\n      if (type == \"number\" && typeof value === \"number\") str_value = value.toFixed(3)\n\n      // FIXME: any kludge\n      const elem: HTMLDivElement & { options?: unknown, value?: unknown } = document.createElement(\"div\")\n      elem.className = \"property\"\n      elem.innerHTML = \"<span class='property_name'></span><span class='property_value'></span>\"\n      const nameSpan = elem.querySelector(\".property_name\")\n      if (!nameSpan) throw new TypeError(\"Property name element was null.\")\n\n      nameSpan.textContent = options.label || name\n      // TODO: any kludge\n      const value_element: HTMLSpanElement | null = elem.querySelector(\".property_value\")\n      if (!value_element) throw new TypeError(\"Property name element was null.\")\n      value_element.textContent = str_value\n      elem.dataset[\"property\"] = name\n      elem.dataset[\"type\"] = options.type || type\n      elem.options = options\n      elem.value = value\n\n      if (type == \"code\") {\n        elem.addEventListener(\"click\", function () {\n          root.inner_showCodePad(this.dataset[\"property\"])\n        })\n      } else if (type == \"boolean\") {\n        elem.classList.add(\"boolean\")\n        if (value) elem.classList.add(\"bool-on\")\n        elem.addEventListener(\"click\", () => {\n          const propname = elem.dataset[\"property\"]\n          elem.value = !elem.value\n          elem.classList.toggle(\"bool-on\")\n          if (!value_element) throw new TypeError(\"Property name element was null.\")\n\n          value_element.textContent = elem.value\n            ? \"true\"\n            : \"false\"\n          innerChange(propname, elem.value)\n        })\n      } else if (type == \"string\" || type == \"number\") {\n        if (!value_element) throw new TypeError(\"Property name element was null.\")\n        value_element.setAttribute(\"contenteditable\", \"true\")\n        value_element.addEventListener(\"keydown\", function (e) {\n          // allow for multiline\n          if (e.code == \"Enter\" && (type != \"string\" || !e.shiftKey)) {\n            e.preventDefault()\n            this.blur()\n          }\n        })\n        value_element.addEventListener(\"blur\", function () {\n          let v: string | number | null = this.textContent\n          const propname = this.parentElement?.dataset[\"property\"]\n          const proptype = this.parentElement?.dataset[\"type\"]\n          if (proptype == \"number\") v = Number(v)\n          innerChange(propname, v)\n        })\n      } else if (type == \"enum\" || type == \"combo\") {\n        const str_value = LGraphCanvas.getPropertyPrintableValue(value, options.values)\n        if (!value_element) throw new TypeError(\"Property name element was null.\")\n        value_element.textContent = str_value ?? \"\"\n\n        value_element.addEventListener(\"click\", function (event) {\n          const values = options.values || []\n          const propname = this.parentElement?.dataset[\"property\"]\n          const inner_clicked = (v: string | null) => {\n            // node.setProperty(propname,v);\n            // graphcanvas.dirty_canvas = true;\n            this.textContent = v\n            innerChange(propname, v)\n            return false\n          }\n          new LiteGraph.ContextMenu(\n            values,\n            {\n              event,\n              className: \"dark\",\n              callback: inner_clicked,\n            },\n            // @ts-expect-error\n            ref_window,\n          )\n        })\n      }\n\n      root.content.append(elem)\n\n      function innerChange(name: string | undefined, value: unknown) {\n        options.callback?.(name, value, options)\n        callback?.(name, value, options)\n      }\n\n      return elem\n    }\n\n    if (typeof root.onOpen == \"function\") root.onOpen()\n\n    return root\n  }\n\n  closePanels(): void {\n    type MightHaveClose = HTMLDivElement & Partial<ICloseable>\n    document.querySelector<MightHaveClose>(\"#node-panel\")?.close?.()\n    document.querySelector<MightHaveClose>(\"#option-panel\")?.close?.()\n  }\n\n  showShowNodePanel(node: LGraphNode): void {\n    this.SELECTED_NODE = node\n    this.closePanels()\n    const ref_window = this.getCanvasWindow()\n    const panel = this.createPanel(node.title || \"\", {\n      closable: true,\n      window: ref_window,\n      onOpen: () => {\n        this.NODEPANEL_IS_OPEN = true\n      },\n      onClose: () => {\n        this.NODEPANEL_IS_OPEN = false\n        this.node_panel = null\n      },\n    })\n    this.node_panel = panel\n    panel.id = \"node-panel\"\n    panel.node = node\n    panel.classList.add(\"settings\")\n\n    const inner_refresh = () => {\n      // clear\n      panel.content.innerHTML = \"\"\n      // @ts-expect-error ctor props\n      panel.addHTML(`<span class='node_type'>${node.type}</span><span class='node_desc'>${node.constructor.desc || \"\"}</span><span class='separator'></span>`)\n\n      panel.addHTML(\"<h3>Properties</h3>\")\n\n      const fUpdate = (name: string, value: string | number | boolean | object | undefined) => {\n        if (!this.graph) throw new NullGraphError()\n        this.graph.beforeChange(node)\n        switch (name) {\n        case \"Title\":\n          if (typeof value !== \"string\") throw new TypeError(\"Attempting to set title to non-string value.\")\n\n          node.title = value\n          break\n        case \"Mode\": {\n          if (typeof value !== \"string\") throw new TypeError(\"Attempting to set mode to non-string value.\")\n\n          const kV = Object.values(LiteGraph.NODE_MODES).indexOf(value)\n          if (kV !== -1 && LiteGraph.NODE_MODES[kV]) {\n            node.changeMode(kV)\n          } else {\n            console.warn(`unexpected mode: ${value}`)\n          }\n          break\n        }\n        case \"Color\":\n          if (typeof value !== \"string\") throw new TypeError(\"Attempting to set colour to non-string value.\")\n\n          if (LGraphCanvas.node_colors[value]) {\n            node.color = LGraphCanvas.node_colors[value].color\n            node.bgcolor = LGraphCanvas.node_colors[value].bgcolor\n          } else {\n            console.warn(`unexpected color: ${value}`)\n          }\n          break\n        default:\n          node.setProperty(name, value)\n          break\n        }\n        this.graph.afterChange()\n        this.dirty_canvas = true\n      }\n\n      panel.addWidget(\"string\", \"Title\", node.title, {}, fUpdate)\n\n      const mode = node.mode == null ? undefined : LiteGraph.NODE_MODES[node.mode]\n      panel.addWidget(\"combo\", \"Mode\", mode, { values: LiteGraph.NODE_MODES }, fUpdate)\n\n      const nodeCol = node.color !== undefined\n        ? Object.keys(LGraphCanvas.node_colors).filter(function (nK) { return LGraphCanvas.node_colors[nK].color == node.color })\n        : \"\"\n\n      panel.addWidget(\"combo\", \"Color\", nodeCol, { values: Object.keys(LGraphCanvas.node_colors) }, fUpdate)\n\n      for (const pName in node.properties) {\n        const value = node.properties[pName]\n        const info = node.getPropertyInfo(pName)\n\n        // in case the user wants control over the side panel widget\n        if (node.onAddPropertyToPanel?.(pName, panel)) continue\n\n        panel.addWidget(info.widget || info.type, pName, value, info, fUpdate)\n      }\n\n      panel.addSeparator()\n\n      node.onShowCustomPanelInfo?.(panel)\n\n      // clear\n      panel.footer.innerHTML = \"\"\n      panel.addButton(\"Delete\", function () {\n        if (node.block_delete) return\n        if (!node.graph) throw new NullGraphError()\n\n        node.graph.remove(node)\n        panel.close()\n      }).classList.add(\"delete\")\n    }\n\n    panel.inner_showCodePad = function (propname: string) {\n      panel.classList.remove(\"settings\")\n      panel.classList.add(\"centered\")\n\n      panel.alt_content.innerHTML = \"<textarea class='code'></textarea>\"\n      const textarea: HTMLTextAreaElement = panel.alt_content.querySelector(\"textarea\")\n      const fDoneWith = function () {\n        panel.toggleAltContent(false)\n        panel.toggleFooterVisibility(true)\n        textarea.remove()\n        panel.classList.add(\"settings\")\n        panel.classList.remove(\"centered\")\n        inner_refresh()\n      }\n      textarea.value = String(node.properties[propname])\n      textarea.addEventListener(\"keydown\", function (e: KeyboardEvent) {\n        if (e.code == \"Enter\" && e.ctrlKey) {\n          node.setProperty(propname, textarea.value)\n          fDoneWith()\n        }\n      })\n      panel.toggleAltContent(true)\n      panel.toggleFooterVisibility(false)\n      textarea.style.height = \"calc(100% - 40px)\"\n\n      const assign = panel.addButton(\"Assign\", function () {\n        node.setProperty(propname, textarea.value)\n        fDoneWith()\n      })\n      panel.alt_content.append(assign)\n      const button = panel.addButton(\"Close\", fDoneWith)\n      button.style.float = \"right\"\n      panel.alt_content.append(button)\n    }\n\n    inner_refresh()\n\n    if (!this.canvas.parentNode) throw new TypeError(\"showNodePanel - this.canvas.parentNode was null\")\n    this.canvas.parentNode.append(panel)\n  }\n\n  checkPanels(): void {\n    if (!this.canvas) return\n\n    if (!this.canvas.parentNode) throw new TypeError(\"checkPanels - this.canvas.parentNode was null\")\n    const panels = this.canvas.parentNode.querySelectorAll(\".litegraph.dialog\")\n    for (const panel of panels) {\n      // @ts-expect-error Panel\n      if (!panel.node) continue\n      // @ts-expect-error Panel\n      if (!panel.node.graph || panel.graph != this.graph) panel.close()\n    }\n  }\n\n  getCanvasMenuOptions(): IContextMenuValue<string>[] {\n    let options: IContextMenuValue<string>[]\n    if (this.getMenuOptions) {\n      options = this.getMenuOptions()\n    } else {\n      options = [\n        {\n          content: \"Add Node\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuAdd,\n        },\n        { content: \"Add Group\", callback: LGraphCanvas.onGroupAdd },\n        // { content: \"Arrange\", callback: that.graph.arrange },\n        // {content:\"Collapse All\", callback: LGraphCanvas.onMenuCollapseAll }\n      ]\n      if (Object.keys(this.selected_nodes).length > 1) {\n        options.push({\n          content: \"Align\",\n          has_submenu: true,\n          callback: LGraphCanvas.onGroupAlign,\n        })\n      }\n    }\n\n    const extra = this.getExtraMenuOptions?.(this, options)\n    return Array.isArray(extra)\n      ? options.concat(extra)\n      : options\n  }\n\n  // called by processContextMenu to extract the menu list\n  getNodeMenuOptions(node: LGraphNode) {\n    let options: (IContextMenuValue<string> | IContextMenuValue<string | null> | IContextMenuValue<INodeSlotContextItem> | IContextMenuValue<unknown, LGraphNode> | IContextMenuValue<typeof LiteGraph.VALID_SHAPES[number]> | null)[]\n\n    if (node.getMenuOptions) {\n      options = node.getMenuOptions(this)\n    } else {\n      options = [\n        {\n          content: \"Inputs\",\n          has_submenu: true,\n          disabled: true,\n        },\n        {\n          content: \"Outputs\",\n          has_submenu: true,\n          disabled: true,\n          callback: LGraphCanvas.showMenuNodeOptionalOutputs,\n        },\n        null,\n        {\n          content: \"Properties\",\n          has_submenu: true,\n          callback: LGraphCanvas.onShowMenuNodeProperties,\n        },\n        {\n          content: \"Properties Panel\",\n          callback: function (item: any, options: any, e: any, menu: any, node: LGraphNode) { LGraphCanvas.active_canvas.showShowNodePanel(node) },\n        },\n        null,\n        {\n          content: \"Title\",\n          callback: LGraphCanvas.onShowPropertyEditor,\n        },\n        {\n          content: \"Mode\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeMode,\n        },\n      ]\n      if (node.resizable !== false) {\n        options.push({\n          content: \"Resize\",\n          callback: LGraphCanvas.onMenuResizeNode,\n        })\n      }\n      if (node.collapsible) {\n        options.push({\n          content: node.collapsed ? \"Expand\" : \"Collapse\",\n          callback: LGraphCanvas.onMenuNodeCollapse,\n        })\n      }\n      if (node.widgets?.some(w => w.advanced)) {\n        options.push({\n          content: node.showAdvanced ? \"Hide Advanced\" : \"Show Advanced\",\n          callback: LGraphCanvas.onMenuToggleAdvanced,\n        })\n      }\n      options.push(\n        {\n          content: node.pinned ? \"Unpin\" : \"Pin\",\n          callback: () => {\n            for (const i in this.selected_nodes) {\n              const node = this.selected_nodes[i]\n              node.pin()\n            }\n            this.setDirty(true, true)\n          },\n        },\n        {\n          content: \"Colors\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeColors,\n        },\n        {\n          content: \"Shapes\",\n          has_submenu: true,\n          callback: LGraphCanvas.onMenuNodeShapes,\n        },\n        null,\n      )\n    }\n\n    const extra = node.getExtraMenuOptions?.(this, options)\n    if (Array.isArray(extra) && extra.length > 0) {\n      extra.push(null)\n      options = extra.concat(options)\n    }\n\n    if (node.clonable !== false) {\n      options.push({\n        content: \"Clone\",\n        callback: LGraphCanvas.onMenuNodeClone,\n      })\n    }\n\n    if (Object.keys(this.selected_nodes).length > 1) {\n      options.push({\n        content: \"Align Selected To\",\n        has_submenu: true,\n        callback: LGraphCanvas.onNodeAlign,\n      }, {\n        content: \"Distribute Nodes\",\n        has_submenu: true,\n        callback: LGraphCanvas.createDistributeMenu,\n      })\n    }\n\n    options.push(null, {\n      content: \"Remove\",\n      disabled: !(node.removable !== false && !node.block_delete),\n      callback: LGraphCanvas.onMenuNodeRemove,\n    })\n\n    node.graph?.onGetNodeMenuOptions?.(options, node)\n\n    return options\n  }\n\n  /** @deprecated */\n  getGroupMenuOptions(group: LGraphGroup) {\n    console.warn(\"LGraphCanvas.getGroupMenuOptions is deprecated, use LGraphGroup.getMenuOptions instead\")\n    return group.getMenuOptions()\n  }\n\n  processContextMenu(node: LGraphNode | undefined, event: CanvasMouseEvent): void {\n    const canvas = LGraphCanvas.active_canvas\n    const ref_window = canvas.getCanvasWindow()\n\n    // TODO: Remove type kludge\n    let menu_info: (IContextMenuValue | string | null)[]\n    const options: IContextMenuOptions = {\n      event,\n      callback: inner_option_clicked,\n      extra: node,\n    }\n\n    if (node) {\n      options.title = node.type ?? undefined\n      LGraphCanvas.active_node = node\n\n      // check if mouse is in input\n      const slot = node.getSlotInPosition(event.canvasX, event.canvasY)\n      if (slot) {\n        // on slot\n        menu_info = []\n        if (node.getSlotMenuOptions) {\n          menu_info = node.getSlotMenuOptions(slot)\n        } else {\n          if (slot.output?.links?.length || slot.input?.link != null) {\n            menu_info.push({ content: \"Disconnect Links\", slot })\n          }\n\n          const _slot = slot.input || slot.output\n          if (!_slot) throw new TypeError(\"Both in put and output slots were null when processing context menu.\")\n\n          if (_slot.removable) {\n            menu_info.push(\n              _slot.locked\n                ? \"Cannot remove\"\n                : { content: \"Remove Slot\", slot },\n            )\n          }\n          if (!_slot.nameLocked && !((\"link\" in _slot) && _slot.widget)) {\n            menu_info.push({ content: \"Rename Slot\", slot })\n          }\n\n          if (node.getExtraSlotMenuOptions) {\n            menu_info.push(...node.getExtraSlotMenuOptions(slot))\n          }\n        }\n        // @ts-expect-error Slot type can be number and has number checks\n        options.title = (slot.input ? slot.input.type : slot.output.type) || \"*\"\n        if (slot.input && slot.input.type == LiteGraph.ACTION)\n          options.title = \"Action\"\n\n        if (slot.output && slot.output.type == LiteGraph.EVENT)\n          options.title = \"Event\"\n      } else {\n        // on node\n        menu_info = this.getNodeMenuOptions(node)\n      }\n    } else {\n      menu_info = this.getCanvasMenuOptions()\n      if (!this.graph) throw new NullGraphError()\n\n      // Check for reroutes\n      if (this.links_render_mode !== LinkRenderType.HIDDEN_LINK) {\n        const reroute = this.graph.getRerouteOnPos(event.canvasX, event.canvasY, this.#visibleReroutes)\n        if (reroute) {\n          menu_info.unshift({\n            content: \"Delete Reroute\",\n            callback: () => {\n              if (!this.graph) throw new NullGraphError()\n\n              this.graph.removeReroute(reroute.id)\n            },\n          }, null)\n        }\n      }\n\n      const group = this.graph.getGroupOnPos(\n        event.canvasX,\n        event.canvasY,\n      )\n      if (group) {\n        // on group\n        menu_info.push(null, {\n          content: \"Edit Group\",\n          has_submenu: true,\n          submenu: {\n            title: \"Group\",\n            extra: group,\n            options: group.getMenuOptions(),\n          },\n        })\n      }\n    }\n\n    // show menu\n    if (!menu_info) return\n\n    // @ts-expect-error Remove param ref_window - unused\n    new LiteGraph.ContextMenu(menu_info, options, ref_window)\n\n    const createDialog = (options: IDialogOptions) => this.createDialog(\n      \"<span class='name'>Name</span><input autofocus type='text'/><button>OK</button>\",\n      options,\n    )\n    const setDirty = () => this.setDirty(true)\n\n    function inner_option_clicked(v: IContextMenuValue<unknown>, options: IDialogOptions) {\n      if (!v) return\n\n      if (v.content == \"Remove Slot\") {\n        if (!node?.graph) throw new NullGraphError()\n\n        const info = v.slot\n        if (!info) throw new TypeError(\"Found-slot info was null when processing context menu.\")\n\n        node.graph.beforeChange()\n        if (info.input) {\n          node.removeInput(info.slot)\n        } else if (info.output) {\n          node.removeOutput(info.slot)\n        }\n        node.graph.afterChange()\n        return\n      } else if (v.content == \"Disconnect Links\") {\n        if (!node?.graph) throw new NullGraphError()\n\n        const info = v.slot\n        if (!info) throw new TypeError(\"Found-slot info was null when processing context menu.\")\n\n        node.graph.beforeChange()\n        if (info.output) {\n          node.disconnectOutput(info.slot)\n        } else if (info.input) {\n          node.disconnectInput(info.slot, true)\n        }\n        node.graph.afterChange()\n        return\n      } else if (v.content == \"Rename Slot\") {\n        if (!node) throw new TypeError(\"`node` was null when processing the context menu.\")\n\n        const info = v.slot\n        if (!info) throw new TypeError(\"Found-slot info was null when processing context menu.\")\n\n        const slot_info = info.input\n          ? node.getInputInfo(info.slot)\n          : node.getOutputInfo(info.slot)\n        const dialog = createDialog(options)\n\n        const input = dialog.querySelector(\"input\")\n        if (input && slot_info) {\n          input.value = slot_info.label || \"\"\n        }\n        const inner = function () {\n          if (!node.graph) throw new NullGraphError()\n\n          node.graph.beforeChange()\n          if (input?.value) {\n            if (slot_info) {\n              slot_info.label = input.value\n            }\n            setDirty()\n          }\n          dialog.close()\n          node.graph.afterChange()\n        }\n        dialog.querySelector(\"button\")?.addEventListener(\"click\", inner)\n        if (!input) throw new TypeError(\"Input element was null when processing context menu.\")\n\n        input.addEventListener(\"keydown\", function (e) {\n          dialog.is_modified = true\n          if (e.key == \"Escape\") {\n            // ESC\n            dialog.close()\n          } else if (e.key == \"Enter\") {\n            // save\n            inner()\n          } else if ((e.target as Element).localName != \"textarea\") {\n            return\n          }\n          e.preventDefault()\n          e.stopPropagation()\n        })\n        input.focus()\n      }\n    }\n  }\n\n  /**\n   * Starts an animation to fit the view around the specified selection of nodes.\n   * @param bounds The bounds to animate the view to, defined by a rectangle.\n   */\n  animateToBounds(bounds: ReadOnlyRect, options: AnimationOptions = {}) {\n    const setDirty = () => this.setDirty(true, true)\n    this.ds.animateToBounds(bounds, setDirty, options)\n  }\n\n  /**\n   * Fits the view to the selected nodes with animation.\n   * If nothing is selected, the view is fitted around all items in the graph.\n   */\n  fitViewToSelectionAnimated(options: AnimationOptions = {}) {\n    const items = this.selectedItems.size\n      ? Array.from(this.selectedItems)\n      : this.positionableItems\n    const bounds = createBounds(items)\n    if (!bounds) throw new TypeError(\"Attempted to fit to view but could not calculate bounds.\")\n\n    const setDirty = () => this.setDirty(true, true)\n    this.ds.animateToBounds(bounds, setDirty, options)\n  }\n}\n","/**\n * Temporary workaround until downstream consumers migrate to Map.\n * A brittle wrapper with many flaws, but should be fine for simple maps using int indexes.\n */\nexport class MapProxyHandler<V> implements ProxyHandler<Map<number | string, V>> {\n  getOwnPropertyDescriptor(\n    target: Map<number | string, V>,\n    p: string | symbol,\n  ): PropertyDescriptor | undefined {\n    const value = this.get(target, p)\n    if (value) {\n      return {\n        configurable: true,\n        enumerable: true,\n        value,\n      }\n    }\n  }\n\n  has(target: Map<number | string, V>, p: string | symbol): boolean {\n    if (typeof p === \"symbol\") return false\n\n    const int = parseInt(p, 10)\n    return target.has(!isNaN(int) ? int : p)\n  }\n\n  ownKeys(target: Map<number | string, V>): ArrayLike<string | symbol> {\n    return [...target.keys()].map(String)\n  }\n\n  get(target: Map<number | string, V>, p: string | symbol): any {\n    // Workaround does not support link IDs of \"values\", \"entries\", \"constructor\", etc.\n    if (p in target) return Reflect.get(target, p, target)\n    if (typeof p === \"symbol\") return\n\n    const int = parseInt(p, 10)\n    return target.get(!isNaN(int) ? int : p)\n  }\n\n  set(target: Map<number | string, V>, p: string | symbol, newValue: any): boolean {\n    if (typeof p === \"symbol\") return false\n\n    const int = parseInt(p, 10)\n    target.set(!isNaN(int) ? int : p, newValue)\n    return true\n  }\n\n  deleteProperty(target: Map<number | string, V>, p: string | symbol): boolean {\n    return target.delete(p as number | string)\n  }\n\n  static bindAllMethods(map: Map<any, any>): void {\n    map.clear = map.clear.bind(map)\n    map.delete = map.delete.bind(map)\n    map.forEach = map.forEach.bind(map)\n    map.get = map.get.bind(map)\n    map.has = map.has.bind(map)\n    map.set = map.set.bind(map)\n    map.entries = map.entries.bind(map)\n    map.keys = map.keys.bind(map)\n    map.values = map.values.bind(map)\n\n    map[Symbol.iterator] = map[Symbol.iterator].bind(map)\n  }\n}\n","import type { DragAndScaleState } from \"./DragAndScale\"\nimport type {\n  Dictionary,\n  IContextMenuValue,\n  LinkNetwork,\n  LinkSegment,\n  MethodNames,\n  OptionalProps,\n  Point,\n  Positionable,\n} from \"./interfaces\"\nimport type {\n  ISerialisedGraph,\n  Serialisable,\n  SerialisableGraph,\n  SerialisableReroute,\n} from \"./types/serialisation\"\nimport type { UUID } from \"@/utils/uuid\"\n\nimport { createUuidv4, zeroUuid } from \"@/utils/uuid\"\n\nimport { LGraphCanvas } from \"./LGraphCanvas\"\nimport { LGraphGroup } from \"./LGraphGroup\"\nimport { LGraphNode, type NodeId } from \"./LGraphNode\"\nimport { LiteGraph } from \"./litegraph\"\nimport { type LinkId, LLink } from \"./LLink\"\nimport { MapProxyHandler } from \"./MapProxyHandler\"\nimport { Reroute, type RerouteId } from \"./Reroute\"\nimport { stringOrEmpty } from \"./strings\"\nimport { LGraphEventMode } from \"./types/globalEnums\"\nimport { getAllNestedItems } from \"./utils/collections\"\n\nexport interface LGraphState {\n  lastGroupId: number\n  lastNodeId: number\n  lastLinkId: number\n  lastRerouteId: number\n}\n\ntype ParamsArray<T extends Record<any, any>, K extends MethodNames<T>> =\n Parameters<T[K]>[1] extends undefined\n   ? Parameters<T[K]> | Parameters<T[K]>[0]\n   : Parameters<T[K]>\n\n/** Configuration used by {@link LGraph} `config`. */\nexport interface LGraphConfig {\n  /** @deprecated Legacy config - unused */\n  align_to_grid?: any\n  links_ontop?: any\n}\n\nexport interface LGraphExtra extends Dictionary<unknown> {\n  reroutes?: SerialisableReroute[]\n  linkExtensions?: { id: number, parentId: number | undefined }[]\n  ds?: DragAndScaleState\n}\n\nexport interface BaseLGraph {\n  readonly rootGraph: LGraph\n}\n\n/**\n * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.\n * supported callbacks:\n * + onNodeAdded: when a new node is added to the graph\n * + onNodeRemoved: when a node inside this graph is removed\n */\nexport class LGraph implements LinkNetwork, BaseLGraph, Serialisable<SerialisableGraph> {\n  static serialisedSchemaVersion = 1 as const\n\n  static STATUS_STOPPED = 1\n  static STATUS_RUNNING = 2\n\n  id: UUID = zeroUuid\n  revision: number = 0\n\n  _version: number = -1\n  /** The backing store for links.  Keys are wrapped in String() */\n  _links: Map<LinkId, LLink> = new Map()\n  /**\n   * Indexed property access is deprecated.\n   * Backwards compatibility with a Proxy has been added, but will eventually be removed.\n   *\n   * Use {@link Map} methods:\n   * ```\n   * const linkId = 123\n   * const link = graph.links.get(linkId)\n   * // Deprecated: const link = graph.links[linkId]\n   * ```\n   */\n  links: Map<LinkId, LLink> & Record<LinkId, LLink>\n  list_of_graphcanvas: LGraphCanvas[] | null\n  status: number = LGraph.STATUS_STOPPED\n\n  state: LGraphState = {\n    lastGroupId: 0,\n    lastNodeId: 0,\n    lastLinkId: 0,\n    lastRerouteId: 0,\n  }\n\n  _nodes: LGraphNode[] = []\n  _nodes_by_id: Record<NodeId, LGraphNode> = {}\n  _nodes_in_order: LGraphNode[] = []\n  _nodes_executable: LGraphNode[] | null = null\n  _groups: LGraphGroup[] = []\n  iteration: number = 0\n  globaltime: number = 0\n  /** @deprecated Unused */\n  runningtime: number = 0\n  fixedtime: number = 0\n  fixedtime_lapse: number = 0.01\n  elapsed_time: number = 0.01\n  last_update_time: number = 0\n  starttime: number = 0\n  catch_errors: boolean = true\n  execution_timer_id?: number | null\n  errors_in_execution?: boolean\n  /** @deprecated Unused */\n  execution_time!: number\n  _last_trigger_time?: number\n  filter?: string\n  /** Must contain serialisable values, e.g. primitive types */\n  config: LGraphConfig = {}\n  vars: Dictionary<unknown> = {}\n  nodes_executing: boolean[] = []\n  nodes_actioning: (string | boolean)[] = []\n  nodes_executedAction: string[] = []\n  extra: LGraphExtra = {}\n\n  /** @deprecated Deserialising a workflow sets this unused property. */\n  version?: number\n\n  /** @returns Whether the graph has no items */\n  get empty(): boolean {\n    return this._nodes.length + this._groups.length + this.reroutes.size === 0\n  }\n\n  /** @returns All items on the canvas that can be selected */\n  *positionableItems(): Generator<LGraphNode | LGraphGroup | Reroute> {\n    for (const node of this._nodes) yield node\n    for (const group of this._groups) yield group\n    for (const reroute of this.reroutes.values()) yield reroute\n    return\n  }\n\n  /** Internal only.  Not required for serialisation; calculated on deserialise. */\n  #lastFloatingLinkId: number = 0\n\n  #floatingLinks: Map<LinkId, LLink> = new Map()\n  get floatingLinks(): ReadonlyMap<LinkId, LLink> {\n    return this.#floatingLinks\n  }\n\n  #reroutes = new Map<RerouteId, Reroute>()\n  /** All reroutes in this graph. */\n  public get reroutes(): Map<RerouteId, Reroute> {\n    return this.#reroutes\n  }\n\n  get rootGraph(): LGraph {\n    return this\n  }\n\n  get isRootGraph(): boolean {\n    return this.rootGraph === this\n  }\n\n  /** @deprecated See {@link state}.{@link LGraphState.lastNodeId lastNodeId} */\n  get last_node_id() {\n    return this.state.lastNodeId\n  }\n\n  set last_node_id(value) {\n    this.state.lastNodeId = value\n  }\n\n  /** @deprecated See {@link state}.{@link LGraphState.lastLinkId lastLinkId} */\n  get last_link_id() {\n    return this.state.lastLinkId\n  }\n\n  set last_link_id(value) {\n    this.state.lastLinkId = value\n  }\n\n  onAfterStep?(): void\n  onBeforeStep?(): void\n  onPlayEvent?(): void\n  onStopEvent?(): void\n  onAfterExecute?(): void\n  onExecuteStep?(): void\n  onNodeAdded?(node: LGraphNode): void\n  onNodeRemoved?(node: LGraphNode): void\n  onTrigger?(action: string, param: unknown): void\n  onBeforeChange?(graph: LGraph, info?: LGraphNode): void\n  onAfterChange?(graph: LGraph, info?: LGraphNode | null): void\n  onConnectionChange?(node: LGraphNode): void\n  on_change?(graph: LGraph): void\n  onSerialize?(data: ISerialisedGraph | SerialisableGraph): void\n  onConfigure?(data: ISerialisedGraph | SerialisableGraph): void\n  onGetNodeMenuOptions?(options: (IContextMenuValue<unknown> | null)[], node: LGraphNode): void\n\n  private _input_nodes?: LGraphNode[]\n\n  /**\n   * See {@link LGraph}\n   * @param o data from previous serialization [optional]\n   */\n  constructor(o?: ISerialisedGraph | SerialisableGraph) {\n    if (LiteGraph.debug) console.log(\"Graph created\")\n\n    /** @see MapProxyHandler */\n    const links = this._links\n    MapProxyHandler.bindAllMethods(links)\n    const handler = new MapProxyHandler<LLink>()\n    this.links = new Proxy(links, handler) as Map<LinkId, LLink> & Record<LinkId, LLink>\n\n    this.list_of_graphcanvas = null\n    this.clear()\n\n    if (o) this.configure(o)\n  }\n\n  /**\n   * Removes all nodes from this graph\n   */\n  clear(): void {\n    this.stop()\n    this.status = LGraph.STATUS_STOPPED\n\n    this.id = zeroUuid\n    this.revision = 0\n\n    this.state = {\n      lastGroupId: 0,\n      lastNodeId: 0,\n      lastLinkId: 0,\n      lastRerouteId: 0,\n    }\n\n    // used to detect changes\n    this._version = -1\n\n    // safe clear\n    if (this._nodes) {\n      for (const _node of this._nodes) {\n        _node.onRemoved?.()\n      }\n    }\n\n    // nodes\n    this._nodes = []\n    this._nodes_by_id = {}\n    // nodes sorted in execution order\n    this._nodes_in_order = []\n    // nodes that contain onExecute sorted in execution order\n    this._nodes_executable = null\n\n    this._links.clear()\n    this.reroutes.clear()\n    this.#floatingLinks.clear()\n\n    this.#lastFloatingLinkId = 0\n\n    // other scene stuff\n    this._groups = []\n\n    // iterations\n    this.iteration = 0\n\n    // custom data\n    this.config = {}\n    this.vars = {}\n    // to store custom data\n    this.extra = {}\n\n    // timing\n    this.globaltime = 0\n    this.runningtime = 0\n    this.fixedtime = 0\n    this.fixedtime_lapse = 0.01\n    this.elapsed_time = 0.01\n    this.last_update_time = 0\n    this.starttime = 0\n\n    this.catch_errors = true\n\n    this.nodes_executing = []\n    this.nodes_actioning = []\n    this.nodes_executedAction = []\n\n    // notify canvas to redraw\n    this.change()\n\n    this.canvasAction(c => c.clear())\n  }\n\n  get nodes() {\n    return this._nodes\n  }\n\n  get groups() {\n    return this._groups\n  }\n\n  /**\n   * Attach Canvas to this graph\n   */\n  attachCanvas(canvas: LGraphCanvas): void {\n    if (!(canvas instanceof LGraphCanvas)) {\n      throw new TypeError(\"attachCanvas expects an LGraphCanvas instance\")\n    }\n\n    this.list_of_graphcanvas ??= []\n    if (!this.list_of_graphcanvas.includes(canvas)) {\n      this.list_of_graphcanvas.push(canvas)\n    }\n\n    if (canvas.graph === this) return\n\n    canvas.graph?.detachCanvas(canvas)\n    canvas.graph = this\n  }\n\n  /**\n   * Detach Canvas from this graph\n   */\n  detachCanvas(canvas: LGraphCanvas): void {\n    canvas.graph = null\n    const canvases = this.list_of_graphcanvas\n    if (canvases) {\n      const pos = canvases.indexOf(canvas)\n      if (pos !== -1) canvases.splice(pos, 1)\n    }\n  }\n\n  /**\n   * @deprecated Will be removed in 0.9\n   * Starts running this graph every interval milliseconds.\n   * @param interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate\n   */\n  start(interval?: number): void {\n    if (this.status == LGraph.STATUS_RUNNING) return\n    this.status = LGraph.STATUS_RUNNING\n\n    this.onPlayEvent?.()\n    this.sendEventToAllNodes(\"onStart\")\n\n    // launch\n    this.starttime = LiteGraph.getTime()\n    this.last_update_time = this.starttime\n    interval ||= 0\n\n    // execute once per frame\n    if (\n      interval == 0 &&\n      typeof window != \"undefined\" &&\n      window.requestAnimationFrame\n    ) {\n      const on_frame = () => {\n        if (this.execution_timer_id != -1) return\n\n        window.requestAnimationFrame(on_frame)\n        this.onBeforeStep?.()\n        this.runStep(1, !this.catch_errors)\n        this.onAfterStep?.()\n      }\n      this.execution_timer_id = -1\n      on_frame()\n    } else {\n      // execute every 'interval' ms\n      this.execution_timer_id = setInterval(() => {\n        // execute\n        this.onBeforeStep?.()\n        this.runStep(1, !this.catch_errors)\n        this.onAfterStep?.()\n      }, interval)\n    }\n  }\n\n  /**\n   * @deprecated Will be removed in 0.9\n   * Stops the execution loop of the graph\n   */\n  stop(): void {\n    if (this.status == LGraph.STATUS_STOPPED) return\n\n    this.status = LGraph.STATUS_STOPPED\n\n    this.onStopEvent?.()\n\n    if (this.execution_timer_id != null) {\n      if (this.execution_timer_id != -1) {\n        clearInterval(this.execution_timer_id)\n      }\n      this.execution_timer_id = null\n    }\n\n    this.sendEventToAllNodes(\"onStop\")\n  }\n\n  /**\n   * Run N steps (cycles) of the graph\n   * @param num number of steps to run, default is 1\n   * @param do_not_catch_errors [optional] if you want to try/catch errors\n   * @param limit max number of nodes to execute (used to execute from start to a node)\n   */\n  runStep(num: number, do_not_catch_errors: boolean, limit?: number): void {\n    num = num || 1\n\n    const start = LiteGraph.getTime()\n    this.globaltime = 0.001 * (start - this.starttime)\n\n    const nodes = this._nodes_executable || this._nodes\n    if (!nodes) return\n\n    limit = limit || nodes.length\n\n    if (do_not_catch_errors) {\n      // iterations\n      for (let i = 0; i < num; i++) {\n        for (let j = 0; j < limit; ++j) {\n          const node = nodes[j]\n          // FIXME: Looks like copy/paste broken logic - checks for \"on\", executes \"do\"\n          if (node.mode == LGraphEventMode.ALWAYS && node.onExecute) {\n            // wrap node.onExecute();\n            node.doExecute?.()\n          }\n        }\n\n        this.fixedtime += this.fixedtime_lapse\n        this.onExecuteStep?.()\n      }\n\n      this.onAfterExecute?.()\n    } else {\n      try {\n        // iterations\n        for (let i = 0; i < num; i++) {\n          for (let j = 0; j < limit; ++j) {\n            const node = nodes[j]\n            if (node.mode == LGraphEventMode.ALWAYS) {\n              node.onExecute?.()\n            }\n          }\n\n          this.fixedtime += this.fixedtime_lapse\n          this.onExecuteStep?.()\n        }\n\n        this.onAfterExecute?.()\n        this.errors_in_execution = false\n      } catch (error) {\n        this.errors_in_execution = true\n        if (LiteGraph.throw_errors) throw error\n\n        if (LiteGraph.debug) console.log(\"Error during execution:\", error)\n        this.stop()\n      }\n    }\n\n    const now = LiteGraph.getTime()\n    let elapsed = now - start\n    if (elapsed == 0) elapsed = 1\n\n    this.execution_time = 0.001 * elapsed\n    this.globaltime += 0.001 * elapsed\n    this.iteration += 1\n    this.elapsed_time = (now - this.last_update_time) * 0.001\n    this.last_update_time = now\n    this.nodes_executing = []\n    this.nodes_actioning = []\n    this.nodes_executedAction = []\n  }\n\n  /**\n   * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than\n   * nodes with only inputs.\n   */\n  updateExecutionOrder(): void {\n    this._nodes_in_order = this.computeExecutionOrder(false)\n    this._nodes_executable = []\n    for (const node of this._nodes_in_order) {\n      if (node.onExecute) {\n        this._nodes_executable.push(node)\n      }\n    }\n  }\n\n  // This is more internal, it computes the executable nodes in order and returns it\n  computeExecutionOrder(\n    only_onExecute: boolean,\n    set_level?: boolean,\n  ): LGraphNode[] {\n    const L: LGraphNode[] = []\n    const S: LGraphNode[] = []\n    const M: Dictionary<LGraphNode> = {}\n    // to avoid repeating links\n    const visited_links: Record<NodeId, boolean> = {}\n    const remaining_links: Record<NodeId, number> = {}\n\n    // search for the nodes without inputs (starting nodes)\n    for (const node of this._nodes) {\n      if (only_onExecute && !node.onExecute) {\n        continue\n      }\n\n      // add to pending nodes\n      M[node.id] = node\n\n      // num of input connections\n      let num = 0\n      if (node.inputs) {\n        for (const input of node.inputs) {\n          if (input?.link != null) {\n            num += 1\n          }\n        }\n      }\n\n      if (num == 0) {\n        // is a starting node\n        S.push(node)\n        if (set_level) node._level = 1\n      } else {\n        // num of input links\n        if (set_level) node._level = 0\n        remaining_links[node.id] = num\n      }\n    }\n\n    while (true) {\n      // get an starting node\n      const node = S.shift()\n      if (node === undefined) break\n\n      // add to ordered list\n      L.push(node)\n      // remove from the pending nodes\n      delete M[node.id]\n\n      if (!node.outputs) continue\n\n      // for every output\n      for (const output of node.outputs) {\n        // not connected\n        // TODO: Confirm functionality, clean condition\n        if (output?.links == null || output.links.length == 0)\n          continue\n\n        // for every connection\n        for (const link_id of output.links) {\n          const link = this._links.get(link_id)\n          if (!link) continue\n\n          // already visited link (ignore it)\n          if (visited_links[link.id]) continue\n\n          const target_node = this.getNodeById(link.target_id)\n          if (target_node == null) {\n            visited_links[link.id] = true\n            continue\n          }\n\n          if (set_level) {\n            node._level ??= 0\n            if (!target_node._level || target_node._level <= node._level) {\n              target_node._level = node._level + 1\n            }\n          }\n\n          // mark as visited\n          visited_links[link.id] = true\n          // reduce the number of links remaining\n          remaining_links[target_node.id] -= 1\n\n          // if no more links, then add to starters array\n          if (remaining_links[target_node.id] == 0) S.push(target_node)\n        }\n      }\n    }\n\n    // the remaining ones (loops)\n    for (const i in M) {\n      L.push(M[i])\n    }\n\n    if (L.length != this._nodes.length && LiteGraph.debug)\n      console.warn(\"something went wrong, nodes missing\")\n\n    /** Ensure type is set */\n    type OrderedLGraphNode = LGraphNode & { order: number }\n\n    /** Sets the order property of each provided node to its index in {@link nodes}. */\n    function setOrder(nodes: LGraphNode[]): asserts nodes is OrderedLGraphNode[] {\n      const l = nodes.length\n      for (let i = 0; i < l; ++i) {\n        nodes[i].order = i\n      }\n    }\n\n    // save order number in the node\n    setOrder(L)\n\n    // sort now by priority\n    L.sort(function (A, B) {\n      // @ts-expect-error ctor props\n      const Ap = A.constructor.priority || A.priority || 0\n      // @ts-expect-error ctor props\n      const Bp = B.constructor.priority || B.priority || 0\n      // if same priority, sort by order\n\n      return Ap == Bp\n        ? A.order - B.order\n        : Ap - Bp\n    })\n\n    // save order number in the node, again...\n    setOrder(L)\n\n    return L\n  }\n\n  /**\n   * Positions every node in a more readable manner\n   */\n  arrange(margin?: number, layout?: string): void {\n    margin = margin || 100\n\n    const nodes = this.computeExecutionOrder(false, true)\n    const columns: LGraphNode[][] = []\n    for (const node of nodes) {\n      const col = node._level || 1\n      columns[col] ||= []\n      columns[col].push(node)\n    }\n\n    let x = margin\n\n    for (const column of columns) {\n      if (!column) continue\n\n      let max_size = 100\n      let y = margin + LiteGraph.NODE_TITLE_HEIGHT\n      for (const node of column) {\n        node.pos[0] = layout == LiteGraph.VERTICAL_LAYOUT ? y : x\n        node.pos[1] = layout == LiteGraph.VERTICAL_LAYOUT ? x : y\n        const max_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 1 : 0\n        if (node.size[max_size_index] > max_size) {\n          max_size = node.size[max_size_index]\n        }\n        const node_size_index = layout == LiteGraph.VERTICAL_LAYOUT ? 0 : 1\n        y += node.size[node_size_index] + margin + LiteGraph.NODE_TITLE_HEIGHT\n      }\n      x += max_size + margin\n    }\n\n    this.setDirtyCanvas(true, true)\n  }\n\n  /**\n   * Returns the amount of time the graph has been running in milliseconds\n   * @returns number of milliseconds the graph has been running\n   */\n  getTime(): number {\n    return this.globaltime\n  }\n\n  /**\n   * Returns the amount of time accumulated using the fixedtime_lapse var.\n   * This is used in context where the time increments should be constant\n   * @returns number of milliseconds the graph has been running\n   */\n  getFixedTime(): number {\n    return this.fixedtime\n  }\n\n  /**\n   * Returns the amount of time it took to compute the latest iteration.\n   * Take into account that this number could be not correct\n   * if the nodes are using graphical actions\n   * @returns number of milliseconds it took the last cycle\n   */\n  getElapsedTime(): number {\n    return this.elapsed_time\n  }\n\n  /**\n   * @deprecated Will be removed in 0.9\n   * Sends an event to all the nodes, useful to trigger stuff\n   * @param eventname the name of the event (function to be called)\n   * @param params parameters in array format\n   */\n  sendEventToAllNodes(\n    eventname: string,\n    params?: object | object[],\n    mode?: LGraphEventMode,\n  ): void {\n    mode = mode || LGraphEventMode.ALWAYS\n\n    const nodes = this._nodes_in_order || this._nodes\n    if (!nodes) return\n\n    for (const node of nodes) {\n      // @ts-expect-error deprecated\n      if (!node[eventname] || node.mode != mode) continue\n      if (params === undefined) {\n        // @ts-expect-error deprecated\n        node[eventname]()\n      } else if (params && params.constructor === Array) {\n        // @ts-expect-error deprecated\n        node[eventname].apply(node, params)\n      } else {\n        // @ts-expect-error deprecated\n        node[eventname](params)\n      }\n    }\n  }\n\n  /**\n   * Runs an action on every canvas registered to this graph.\n   * @param action Action to run for every canvas\n   */\n  canvasAction(action: (canvas: LGraphCanvas) => void): void {\n    const canvases = this.list_of_graphcanvas\n    if (!canvases) return\n    for (const canvas of canvases) action(canvas)\n  }\n\n  /** @deprecated See {@link LGraph.canvasAction} */\n  sendActionToCanvas<T extends MethodNames<LGraphCanvas>>(\n    action: T,\n    params?: ParamsArray<LGraphCanvas, T>,\n  ): void {\n    const { list_of_graphcanvas } = this\n    if (!list_of_graphcanvas) return\n\n    for (const c of list_of_graphcanvas) {\n      c[action]?.apply(c, params)\n    }\n  }\n\n  /**\n   * Adds a new node instance to this graph\n   * @param node the instance of the node\n   */\n  add(\n    node: LGraphNode | LGraphGroup,\n    skip_compute_order?: boolean,\n  ): LGraphNode | null | undefined {\n    if (!node) return\n    const { state } = this\n\n    // Ensure created items are snapped\n    if (LiteGraph.alwaysSnapToGrid) {\n      const snapTo = this.getSnapToGridSize()\n      if (snapTo) node.snapToGrid(snapTo)\n    }\n\n    // LEGACY: This was changed from constructor === LGraphGroup\n    // groups\n    if (node instanceof LGraphGroup) {\n      // Assign group ID\n      if (node.id == null || node.id === -1) node.id = ++state.lastGroupId\n      if (node.id > state.lastGroupId) state.lastGroupId = node.id\n\n      this._groups.push(node)\n      this.setDirtyCanvas(true)\n      this.change()\n      node.graph = this\n      this._version++\n      return\n    }\n\n    // nodes\n    if (node.id != -1 && this._nodes_by_id[node.id] != null) {\n      console.warn(\n        \"LiteGraph: there is already a node with this ID, changing it\",\n      )\n      node.id = LiteGraph.use_uuids\n        ? LiteGraph.uuidv4()\n        : ++state.lastNodeId\n    }\n\n    if (this._nodes.length >= LiteGraph.MAX_NUMBER_OF_NODES) {\n      throw \"LiteGraph: max number of nodes in a graph reached\"\n    }\n\n    // give him an id\n    if (LiteGraph.use_uuids) {\n      if (node.id == null || node.id == -1)\n        node.id = LiteGraph.uuidv4()\n    } else {\n      if (node.id == null || node.id == -1) {\n        node.id = ++state.lastNodeId\n      } else if (typeof node.id === \"number\" && state.lastNodeId < node.id) {\n        state.lastNodeId = node.id\n      }\n    }\n\n    node.graph = this\n    this._version++\n\n    this._nodes.push(node)\n    this._nodes_by_id[node.id] = node\n\n    node.onAdded?.(this)\n\n    if (this.config.align_to_grid) node.alignToGrid()\n\n    if (!skip_compute_order) this.updateExecutionOrder()\n\n    this.onNodeAdded?.(node)\n\n    this.setDirtyCanvas(true)\n    this.change()\n\n    // to chain actions\n    return node\n  }\n\n  /**\n   * Removes a node from the graph\n   * @param node the instance of the node\n   */\n  remove(node: LGraphNode | LGraphGroup): void {\n    // LEGACY: This was changed from constructor === LiteGraph.LGraphGroup\n    if (node instanceof LGraphGroup) {\n      this.canvasAction(c => c.deselect(node))\n\n      const index = this._groups.indexOf(node)\n      if (index != -1) {\n        this._groups.splice(index, 1)\n      }\n      node.graph = undefined\n      this._version++\n      this.setDirtyCanvas(true, true)\n      this.change()\n      return\n    }\n\n    // not found\n    if (this._nodes_by_id[node.id] == null) {\n      console.warn(\"LiteGraph: node not found\", node)\n      return\n    }\n    // cannot be removed\n    if (node.ignore_remove) {\n      console.warn(\"LiteGraph: node cannot be removed\", node)\n      return\n    }\n\n    // sure? - almost sure is wrong\n    this.beforeChange()\n\n    const { inputs, outputs } = node\n\n    // disconnect inputs\n    if (inputs) {\n      for (const [i, slot] of inputs.entries()) {\n        if (slot.link != null) node.disconnectInput(i, true)\n      }\n    }\n\n    // disconnect outputs\n    if (outputs) {\n      for (const [i, slot] of outputs.entries()) {\n        if (slot.links?.length) node.disconnectOutput(i)\n      }\n    }\n\n    // Floating links\n    for (const link of this.floatingLinks.values()) {\n      if (link.origin_id === node.id || link.target_id === node.id) {\n        this.removeFloatingLink(link)\n      }\n    }\n\n    // callback\n    node.onRemoved?.()\n\n    node.graph = null\n    this._version++\n\n    // remove from canvas render\n    const { list_of_graphcanvas } = this\n    if (list_of_graphcanvas) {\n      for (const canvas of list_of_graphcanvas) {\n        if (canvas.selected_nodes[node.id])\n          delete canvas.selected_nodes[node.id]\n\n        canvas.deselect(node)\n      }\n    }\n\n    // remove from containers\n    const pos = this._nodes.indexOf(node)\n    if (pos != -1) this._nodes.splice(pos, 1)\n\n    delete this._nodes_by_id[node.id]\n\n    this.onNodeRemoved?.(node)\n\n    // close panels\n    this.canvasAction(c => c.checkPanels())\n\n    this.setDirtyCanvas(true, true)\n    // sure? - almost sure is wrong\n    this.afterChange()\n    this.change()\n\n    this.updateExecutionOrder()\n  }\n\n  /**\n   * Returns a node by its id.\n   */\n  getNodeById(id: NodeId | null | undefined): LGraphNode | null {\n    return id != null\n      ? this._nodes_by_id[id]\n      : null\n  }\n\n  /**\n   * Returns a list of nodes that matches a class\n   * @param classObject the class itself (not an string)\n   * @returns a list with all the nodes of this type\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n  findNodesByClass(classObject: Function, result?: LGraphNode[]): LGraphNode[] {\n    result = result || []\n    result.length = 0\n    const { _nodes } = this\n    for (const node of _nodes) {\n      if (node.constructor === classObject)\n        result.push(node)\n    }\n    return result\n  }\n\n  /**\n   * Returns a list of nodes that matches a type\n   * @param type the name of the node type\n   * @returns a list with all the nodes of this type\n   */\n  findNodesByType(type: string, result: LGraphNode[]): LGraphNode[] {\n    const matchType = type.toLowerCase()\n    result = result || []\n    result.length = 0\n    const { _nodes } = this\n    for (const node of _nodes) {\n      if (node.type?.toLowerCase() == matchType)\n        result.push(node)\n    }\n    return result\n  }\n\n  /**\n   * Returns the first node that matches a name in its title\n   * @param title the name of the node to search\n   * @returns the node or null\n   */\n  findNodeByTitle(title: string): LGraphNode | null {\n    const { _nodes } = this\n    for (const node of _nodes) {\n      if (node.title == title)\n        return node\n    }\n    return null\n  }\n\n  /**\n   * Returns a list of nodes that matches a name\n   * @param title the name of the node to search\n   * @returns a list with all the nodes with this name\n   */\n  findNodesByTitle(title: string): LGraphNode[] {\n    const result: LGraphNode[] = []\n    const { _nodes } = this\n    for (const node of _nodes) {\n      if (node.title == title)\n        result.push(node)\n    }\n    return result\n  }\n\n  /**\n   * Returns the top-most node in this position of the canvas\n   * @param x the x coordinate in canvas space\n   * @param y the y coordinate in canvas space\n   * @param nodeList a list with all the nodes to search from, by default is all the nodes in the graph\n   * @returns the node at this position or null\n   */\n  getNodeOnPos(\n    x: number,\n    y: number,\n    nodeList?: LGraphNode[],\n  ): LGraphNode | null {\n    const nodes = nodeList || this._nodes\n    let i = nodes.length\n    while (--i >= 0) {\n      const node = nodes[i]\n      if (node.isPointInside(x, y)) return node\n    }\n    return null\n  }\n\n  /**\n   * Returns the top-most group in that position\n   * @param x The x coordinate in canvas space\n   * @param y The y coordinate in canvas space\n   * @returns The group or null\n   */\n  getGroupOnPos(x: number, y: number): LGraphGroup | undefined {\n    return this._groups.toReversed().find(g => g.isPointInside(x, y))\n  }\n\n  /**\n   * Returns the top-most group with a titlebar in the provided position.\n   * @param x The x coordinate in canvas space\n   * @param y The y coordinate in canvas space\n   * @returns The group or null\n   */\n  getGroupTitlebarOnPos(x: number, y: number): LGraphGroup | undefined {\n    return this._groups.toReversed().find(g => g.isPointInTitlebar(x, y))\n  }\n\n  /**\n   * Finds a reroute a the given graph point\n   * @param x X co-ordinate in graph space\n   * @param y Y co-ordinate in graph space\n   * @returns The first reroute under the given co-ordinates, or undefined\n   */\n  getRerouteOnPos(x: number, y: number, reroutes?: Iterable<Reroute>): Reroute | undefined {\n    for (const reroute of reroutes ?? this.reroutes.values()) {\n      if (reroute.containsPoint([x, y])) return reroute\n    }\n  }\n\n  /**\n   * Snaps the provided items to a grid.\n   *\n   * Item positions are reounded to the nearest multiple of {@link LiteGraph.CANVAS_GRID_SIZE}.\n   *\n   * When {@link LiteGraph.alwaysSnapToGrid} is enabled\n   * and the grid size is falsy, a default of 1 is used.\n   * @param items The items to be snapped to the grid\n   * @todo Currently only snaps nodes.\n   */\n  snapToGrid(items: Set<Positionable>): void {\n    const snapTo = this.getSnapToGridSize()\n    if (!snapTo) return\n\n    for (const item of getAllNestedItems(items)) {\n      if (!item.pinned) item.snapToGrid(snapTo)\n    }\n  }\n\n  /**\n   * Finds the size of the grid that items should be snapped to when moved.\n   * @returns The size of the grid that items should be snapped to\n   */\n  getSnapToGridSize(): number {\n    // Default to 1 when always snapping\n    return LiteGraph.alwaysSnapToGrid\n      ? LiteGraph.CANVAS_GRID_SIZE || 1\n      : LiteGraph.CANVAS_GRID_SIZE\n  }\n\n  /**\n   * @deprecated Will be removed in 0.9\n   * Checks that the node type matches the node type registered,\n   * used when replacing a nodetype by a newer version during execution\n   * this replaces the ones using the old version with the new version\n   */\n  checkNodeTypes() {\n    const { _nodes } = this\n    for (const [i, node] of _nodes.entries()) {\n      const ctor = LiteGraph.registered_node_types[node.type]\n      if (node.constructor == ctor) continue\n\n      console.log(\"node being replaced by newer version:\", node.type)\n      const newnode = LiteGraph.createNode(node.type)\n      if (!newnode) continue\n      _nodes[i] = newnode\n      newnode.configure(node.serialize())\n      newnode.graph = this\n      this._nodes_by_id[newnode.id] = newnode\n\n      if (node.inputs) newnode.inputs = [...node.inputs]\n      if (node.outputs) newnode.outputs = [...node.outputs]\n    }\n    this.updateExecutionOrder()\n  }\n\n  // ********** GLOBALS *****************\n  trigger(action: string, param: unknown) {\n    this.onTrigger?.(action, param)\n  }\n\n  /** @todo Clean up - never implemented. */\n  triggerInput(name: string, value: any): void {\n    const nodes = this.findNodesByTitle(name)\n    for (const node of nodes) {\n      // @ts-expect-error\n      node.onTrigger(value)\n    }\n  }\n\n  /** @todo Clean up - never implemented. */\n  setCallback(name: string, func: any): void {\n    const nodes = this.findNodesByTitle(name)\n    for (const node of nodes) {\n      // @ts-expect-error\n      node.setTrigger(func)\n    }\n  }\n\n  // used for undo, called before any change is made to the graph\n  beforeChange(info?: LGraphNode): void {\n    this.onBeforeChange?.(this, info)\n    this.canvasAction(c => c.onBeforeChange?.(this))\n  }\n\n  // used to resend actions, called after any change is made to the graph\n  afterChange(info?: LGraphNode | null): void {\n    this.onAfterChange?.(this, info)\n    this.canvasAction(c => c.onAfterChange?.(this))\n  }\n\n  connectionChange(node: LGraphNode): void {\n    this.updateExecutionOrder()\n    this.onConnectionChange?.(node)\n    this._version++\n    // TODO: Interface never implemented - any consumers?\n    // @ts-expect-error\n    this.canvasAction(c => c.onConnectionChange?.())\n  }\n\n  /**\n   * clears the triggered slot animation in all links (stop visual animation)\n   */\n  clearTriggeredSlots(): void {\n    for (const link_info of this._links.values()) {\n      if (!link_info) continue\n\n      if (link_info._last_time) link_info._last_time = 0\n    }\n  }\n\n  /* Called when something visually changed (not the graph!) */\n  change(): void {\n    if (LiteGraph.debug) {\n      console.log(\"Graph changed\")\n    }\n    this.canvasAction(c => c.setDirty(true, true))\n    this.on_change?.(this)\n  }\n\n  setDirtyCanvas(fg: boolean, bg?: boolean): void {\n    this.canvasAction(c => c.setDirty(fg, bg))\n  }\n\n  addFloatingLink(link: LLink): LLink {\n    if (link.id === -1) {\n      link.id = ++this.#lastFloatingLinkId\n    }\n    this.#floatingLinks.set(link.id, link)\n\n    const slot = link.target_id !== -1\n      ? this.getNodeById(link.target_id)?.inputs?.[link.target_slot]\n      : this.getNodeById(link.origin_id)?.outputs?.[link.origin_slot]\n    if (slot) {\n      slot._floatingLinks ??= new Set()\n      slot._floatingLinks.add(link)\n    } else {\n      console.warn(`Adding invalid floating link: target/slot: [${link.target_id}/${link.target_slot}] origin/slot: [${link.origin_id}/${link.origin_slot}]`)\n    }\n\n    const reroutes = LLink.getReroutes(this, link)\n    for (const reroute of reroutes) {\n      reroute.floatingLinkIds.add(link.id)\n    }\n    return link\n  }\n\n  removeFloatingLink(link: LLink): void {\n    this.#floatingLinks.delete(link.id)\n\n    const slot = link.target_id !== -1\n      ? this.getNodeById(link.target_id)?.inputs?.[link.target_slot]\n      : this.getNodeById(link.origin_id)?.outputs?.[link.origin_slot]\n    if (slot) {\n      slot._floatingLinks?.delete(link)\n    }\n\n    const reroutes = LLink.getReroutes(this, link)\n    for (const reroute of reroutes) {\n      reroute.floatingLinkIds.delete(link.id)\n      if (reroute.floatingLinkIds.size === 0) {\n        delete reroute.floating\n      }\n\n      if (reroute.totalLinks === 0) this.removeReroute(reroute.id)\n    }\n  }\n\n  /**\n   * Finds the link with the provided ID.\n   * @param id ID of link to find\n   * @returns The link with the provided {@link id}, otherwise `undefined`. Always returns `undefined` if `id` is nullish.\n   */\n  getLink(id: null | undefined): undefined\n  getLink(id: LinkId | null | undefined): LLink | undefined\n  getLink(id: LinkId | null | undefined): LLink | undefined {\n    return id == null ? undefined : this._links.get(id)\n  }\n\n  /**\n   * Finds the reroute with the provided ID.\n   * @param id ID of reroute to find\n   * @returns The reroute with the provided {@link id}, otherwise `undefined`. Always returns `undefined` if `id` is nullish.\n   */\n  getReroute(id: null | undefined): undefined\n  getReroute(id: RerouteId | null | undefined): Reroute | undefined\n  getReroute(id: RerouteId | null | undefined): Reroute | undefined {\n    return id == null ? undefined : this.reroutes.get(id)\n  }\n\n  /**\n   * Configures a reroute on the graph where ID is already known (probably deserialisation).\n   * Creates the object if it does not exist.\n   * @param serialisedReroute See {@link SerialisableReroute}\n   */\n  setReroute({ id, parentId, pos, linkIds, floating }: OptionalProps<SerialisableReroute, \"id\">): Reroute {\n    id ??= ++this.state.lastRerouteId\n    if (id > this.state.lastRerouteId) this.state.lastRerouteId = id\n\n    const reroute = this.reroutes.get(id) ?? new Reroute(id, this)\n    reroute.update(parentId, pos, linkIds, floating)\n    this.reroutes.set(id, reroute)\n    return reroute\n  }\n\n  /**\n   * Creates a new reroute and adds it to the graph.\n   * @param pos Position in graph space\n   * @param before The existing link segment (reroute, link) that will be after this reroute,\n   * going from the node output to input.\n   * @returns The newly created reroute - typically ignored.\n   */\n  createReroute(pos: Point, before: LinkSegment): Reroute {\n    const rerouteId = ++this.state.lastRerouteId\n    const linkIds = before instanceof Reroute\n      ? before.linkIds\n      : [before.id]\n    const floatingLinkIds = before instanceof Reroute\n      ? before.floatingLinkIds\n      : [before.id]\n    const reroute = new Reroute(rerouteId, this, pos, before.parentId, linkIds, floatingLinkIds)\n    this.reroutes.set(rerouteId, reroute)\n    for (const linkId of linkIds) {\n      const link = this._links.get(linkId)\n      if (!link) continue\n      if (link.parentId === before.parentId) link.parentId = rerouteId\n\n      const reroutes = LLink.getReroutes(this, link)\n      for (const x of reroutes.filter(x => x.parentId === before.parentId)) {\n        x.parentId = rerouteId\n      }\n    }\n\n    for (const linkId of floatingLinkIds) {\n      const link = this.floatingLinks.get(linkId)\n      if (!link) continue\n      if (link.parentId === before.parentId) link.parentId = rerouteId\n\n      const reroutes = LLink.getReroutes(this, link)\n      for (const x of reroutes.filter(x => x.parentId === before.parentId)) {\n        x.parentId = rerouteId\n      }\n    }\n\n    return reroute\n  }\n\n  /**\n   * Removes a reroute from the graph\n   * @param id ID of reroute to remove\n   */\n  removeReroute(id: RerouteId): void {\n    const { reroutes } = this\n    const reroute = reroutes.get(id)\n    if (!reroute) return\n\n    this.canvasAction(c => c.deselect(reroute))\n\n    // Extract reroute from the reroute chain\n    const { parentId, linkIds, floatingLinkIds } = reroute\n    for (const reroute of reroutes.values()) {\n      if (reroute.parentId === id) reroute.parentId = parentId\n    }\n\n    for (const linkId of linkIds) {\n      const link = this._links.get(linkId)\n      if (link && link.parentId === id) link.parentId = parentId\n    }\n\n    for (const linkId of floatingLinkIds) {\n      const link = this.floatingLinks.get(linkId)\n      if (!link) {\n        console.warn(`Removed reroute had floating link ID that did not exist [${linkId}]`)\n        continue\n      }\n\n      // A floating link is a unique branch; if there is no parent reroute, or\n      // the parent reroute has any other links, remove this floating link.\n      const floatingReroutes = LLink.getReroutes(this, link)\n      const lastReroute = floatingReroutes.at(-1)\n      const secondLastReroute = floatingReroutes.at(-2)\n\n      if (reroute !== lastReroute) {\n        continue\n      } else if (secondLastReroute?.totalLinks !== 1) {\n        this.removeFloatingLink(link)\n      } else if (link.parentId === id) {\n        link.parentId = parentId\n        secondLastReroute.floating = reroute.floating\n      }\n    }\n\n    reroutes.delete(id)\n    // This does not belong here; it should be handled by the caller, or run by a remove-many API.\n    // https://github.com/Comfy-Org/litegraph.js/issues/898\n    this.setDirtyCanvas(false, true)\n  }\n\n  /**\n   * Destroys a link\n   */\n  removeLink(link_id: LinkId): void {\n    const link = this._links.get(link_id)\n    if (!link) return\n\n    const node = this.getNodeById(link.target_id)\n    node?.disconnectInput(link.target_slot, false)\n\n    link.disconnect(this)\n  }\n\n  /**\n   * Creates a Object containing all the info about this graph, it can be serialized\n   * @deprecated Use {@link asSerialisable}, which returns the newer schema version.\n   * @returns value of the node\n   */\n  serialize(option?: { sortNodes: boolean }): ISerialisedGraph {\n    const { config, state, groups, nodes, reroutes, extra, floatingLinks } = this.asSerialisable(option)\n    const linkArray = [...this._links.values()]\n    const links = linkArray.map(x => x.serialize())\n\n    if (reroutes?.length) {\n      // Link parent IDs cannot go in 0.4 schema arrays\n      extra.linkExtensions = linkArray\n        .filter(x => x.parentId !== undefined)\n        .map(x => ({ id: x.id, parentId: x.parentId }))\n    }\n\n    extra.reroutes = reroutes?.length ? reroutes : undefined\n    return {\n      id: this.id,\n      revision: this.revision,\n      last_node_id: state.lastNodeId,\n      last_link_id: state.lastLinkId,\n      nodes,\n      links,\n      floatingLinks,\n      groups,\n      config,\n      extra,\n      version: LiteGraph.VERSION,\n    }\n  }\n\n  /** @returns The drag and scale state of the first attached canvas, otherwise `undefined`. */\n  #getDragAndScale(): DragAndScaleState | undefined {\n    const ds = this.list_of_graphcanvas?.at(0)?.ds\n    if (ds) return { scale: ds.scale, offset: ds.offset }\n  }\n\n  /**\n   * Prepares a shallow copy of this object for immediate serialisation or structuredCloning.\n   * The return value should be discarded immediately.\n   * @param options Serialise options = currently `sortNodes: boolean`, whether to sort nodes by ID.\n   * @returns A shallow copy of parts of this graph, with shallow copies of its serialisable objects.\n   * Mutating the properties of the return object may result in changes to your graph.\n   * It is intended for use with {@link structuredClone} or {@link JSON.stringify}.\n   */\n  asSerialisable(options?: { sortNodes: boolean }): SerialisableGraph & Required<Pick<SerialisableGraph, \"nodes\" | \"groups\" | \"extra\">> {\n    const { id, revision, config, state } = this\n\n    const nodeList = !LiteGraph.use_uuids && options?.sortNodes\n      // @ts-expect-error If LiteGraph.use_uuids is false, ids are numbers.\n      ? [...this._nodes].sort((a, b) => a.id - b.id)\n      : this._nodes\n\n    const nodes = nodeList.map(node => node.serialize())\n    const groups = this._groups.map(x => x.serialize())\n\n    const links = this._links.size ? [...this._links.values()].map(x => x.asSerialisable()) : undefined\n    const floatingLinks = this.floatingLinks.size ? [...this.floatingLinks.values()].map(x => x.asSerialisable()) : undefined\n    const reroutes = this.reroutes.size ? [...this.reroutes.values()].map(x => x.asSerialisable()) : undefined\n\n    // Save scale and offset\n    const extra = { ...this.extra }\n    if (LiteGraph.saveViewportWithGraph) extra.ds = this.#getDragAndScale()\n    if (!extra.ds) delete extra.ds\n\n    const data: ReturnType<typeof this.asSerialisable> = {\n      id,\n      revision,\n      version: LGraph.serialisedSchemaVersion,\n      config,\n      state,\n      groups,\n      nodes,\n      links,\n      floatingLinks,\n      reroutes,\n      extra,\n    }\n\n    this.onSerialize?.(data)\n    return data\n  }\n\n  /**\n   * Configure a graph from a JSON string\n   * @param data The deserialised object to configure this graph from\n   * @param keep_old If `true`, the graph will not be cleared prior to\n   * adding the configuration.\n   */\n  configure(\n    data: ISerialisedGraph | SerialisableGraph,\n    keep_old?: boolean,\n  ): boolean | undefined {\n    // TODO: Finish typing configure()\n    if (!data) return\n    if (!keep_old) this.clear()\n\n    // Create a new graph ID if none is provided\n    if (data.id) this.id = data.id\n    else if (this.id === zeroUuid) this.id = createUuidv4()\n\n    let reroutes: SerialisableReroute[] | undefined\n\n    // TODO: Determine whether this should this fall back to 0.4.\n    if (data.version === 0.4) {\n      const { extra } = data\n      // Deprecated - old schema version, links are arrays\n      if (Array.isArray(data.links)) {\n        for (const linkData of data.links) {\n          const link = LLink.createFromArray(linkData)\n          this._links.set(link.id, link)\n        }\n      }\n      // #region `extra` embeds for v0.4\n\n      // LLink parentIds\n      if (Array.isArray(extra?.linkExtensions)) {\n        for (const linkEx of extra.linkExtensions) {\n          const link = this._links.get(linkEx.id)\n          if (link) link.parentId = linkEx.parentId\n        }\n      }\n\n      // Reroutes\n      reroutes = extra?.reroutes\n\n      // #endregion `extra` embeds for v0.4\n    } else {\n      // New schema - one version so far, no check required.\n\n      // State\n      if (data.state) {\n        const { lastGroupId, lastLinkId, lastNodeId, lastRerouteId } = data.state\n        const { state } = this\n        if (lastGroupId != null) state.lastGroupId = lastGroupId\n        if (lastLinkId != null) state.lastLinkId = lastLinkId\n        if (lastNodeId != null) state.lastNodeId = lastNodeId\n        if (lastRerouteId != null) state.lastRerouteId = lastRerouteId\n      }\n\n      // Links\n      if (Array.isArray(data.links)) {\n        for (const linkData of data.links) {\n          const link = LLink.create(linkData)\n          this._links.set(link.id, link)\n        }\n      }\n\n      reroutes = data.reroutes\n    }\n\n    // Reroutes\n    if (Array.isArray(reroutes)) {\n      for (const rerouteData of reroutes) {\n        this.setReroute(rerouteData)\n      }\n    }\n\n    const nodesData = data.nodes\n\n    // copy all stored fields\n    for (const i in data) {\n      // links must be accepted\n      if ([\"nodes\", \"groups\", \"links\", \"state\", \"reroutes\", \"floatingLinks\", \"id\"].includes(i)) {\n        continue\n      }\n      // @ts-expect-error #574 Legacy property assignment\n      this[i] = data[i]\n    }\n\n    let error = false\n\n    // create nodes\n    this._nodes = []\n    if (nodesData) {\n      for (const n_info of nodesData) {\n        // stored info\n        let node = LiteGraph.createNode(String(n_info.type), n_info.title)\n        if (!node) {\n          if (LiteGraph.debug) console.log(\"Node not found or has errors:\", n_info.type)\n\n          // in case of error we create a replacement node to avoid losing info\n          node = new LGraphNode(\"\")\n          node.last_serialization = n_info\n          node.has_errors = true\n          error = true\n          // continue;\n        }\n\n        // id it or it will create a new id\n        node.id = n_info.id\n        // add before configure, otherwise configure cannot create links\n        this.add(node, true)\n      }\n\n      // configure nodes afterwards so they can reach each other\n      for (const n_info of nodesData) {\n        const node = this.getNodeById(n_info.id)\n        node?.configure(n_info)\n      }\n    }\n\n    // Floating links\n    if (Array.isArray(data.floatingLinks)) {\n      for (const linkData of data.floatingLinks) {\n        const floatingLink = LLink.create(linkData)\n        this.addFloatingLink(floatingLink)\n\n        if (floatingLink.id > this.#lastFloatingLinkId) this.#lastFloatingLinkId = floatingLink.id\n      }\n    }\n\n    // Drop broken reroutes\n    for (const reroute of this.reroutes.values()) {\n      // Drop broken links, and ignore reroutes with no valid links\n      if (!reroute.validateLinks(this._links, this.floatingLinks)) {\n        this.reroutes.delete(reroute.id)\n      }\n    }\n\n    // groups\n    this._groups.length = 0\n    const groupData = data.groups\n    if (groupData) {\n      for (const data of groupData) {\n        // TODO: Search/remove these global object refs\n        const group = new LiteGraph.LGraphGroup()\n        group.configure(data)\n        this.add(group)\n      }\n    }\n\n    this.updateExecutionOrder()\n\n    this.extra = data.extra || {}\n    // Ensure auto-generated serialisation data is removed from extra\n    delete this.extra.linkExtensions\n\n    this.onConfigure?.(data)\n    this._version++\n    this.setDirtyCanvas(true, true)\n    return error\n  }\n\n  load(url: string | Blob | URL | File, callback: () => void) {\n    const that = this\n\n    // from file\n    if (url instanceof Blob || url instanceof File) {\n      const reader = new FileReader()\n      reader.addEventListener(\"load\", function (event) {\n        const result = stringOrEmpty(event.target?.result)\n        const data = JSON.parse(result)\n        that.configure(data)\n        callback?.()\n      })\n\n      reader.readAsText(url)\n      return\n    }\n\n    // is a string, then an URL\n    const req = new XMLHttpRequest()\n    req.open(\"GET\", url, true)\n    req.send(null)\n    req.addEventListener(\"load\", function () {\n      if (req.status !== 200) {\n        console.error(\"Error loading graph:\", req.status, req.response)\n        return\n      }\n      const data = JSON.parse(req.response)\n      that.configure(data)\n      callback?.()\n    })\n    req.addEventListener(\"error\", (err) => {\n      console.error(\"Error loading graph:\", err)\n    })\n  }\n}\n","import type { SubgraphIONodeBase } from \"./SubgraphIONodeBase\"\nimport type { Point, ReadOnlyRect, Rect } from \"@/interfaces\"\nimport type { LinkId } from \"@/LLink\"\nimport type { Serialisable, SubgraphIO } from \"@/types/serialisation\"\n\nimport { LiteGraph } from \"@/litegraph\"\nimport { SlotBase } from \"@/node/SlotBase\"\nimport { createUuidv4, type UUID } from \"@/utils/uuid\"\n\n/** Shared base class for the slots used on Subgraph . */\nexport abstract class SubgraphSlot extends SlotBase implements SubgraphIO, Serialisable<SubgraphIO> {\n  static get defaultHeight() {\n    return LiteGraph.NODE_SLOT_HEIGHT\n  }\n\n  readonly #pos: Point = new Float32Array(2)\n\n  readonly id: UUID\n  readonly parent: SubgraphIONodeBase\n  override type: string\n\n  readonly linkIds: LinkId[] = []\n\n  override readonly boundingRect: Rect = [0, 0, 0, SubgraphSlot.defaultHeight]\n\n  override get pos() {\n    return this.#pos\n  }\n\n  override set pos(value) {\n    if (!value || value.length < 2) return\n\n    this.#pos[0] = value[0]\n    this.#pos[1] = value[1]\n  }\n\n  /** Whether this slot is connected to another slot. */\n  override get isConnected() {\n    return this.linkIds.length > 0\n  }\n\n  /** The display name of this slot. */\n  get displayName() {\n    return this.label ?? this.localized_name ?? this.name\n  }\n\n  abstract get labelPos(): Point\n\n  constructor(slot: SubgraphIO, parent: SubgraphIONodeBase) {\n    super(slot.name, slot.type, slot.boundingRect)\n\n    Object.assign(this, slot)\n    this.id = slot.id ?? createUuidv4()\n    this.type = slot.type\n    this.parent = parent\n  }\n\n  abstract arrange(rect: ReadOnlyRect): void\n\n  asSerialisable(): SubgraphIO {\n    const { id, name, type, linkIds, localized_name, label, dir, shape, color_off, color_on, pos, boundingRect } = this\n    return { id, name, type, linkIds, localized_name, label, dir, shape, color_off, color_on, pos, boundingRect }\n  }\n}\n","import type { Point, ReadOnlyRect } from \"@/interfaces\"\n\nimport { SubgraphSlot } from \"./SubgraphSlotBase\"\n\nexport class SubgraphInput extends SubgraphSlot {\n  get labelPos(): Point {\n    const [x, y, , height] = this.boundingRect\n    return [x, y + height * 0.5]\n  }\n\n  /** For inputs, x is the right edge of the input node. */\n  override arrange(rect: ReadOnlyRect): void {\n    const [right, top, width, height] = rect\n    const { boundingRect: b, pos } = this\n\n    b[0] = right - width\n    b[1] = top\n    b[2] = width\n    b[3] = height\n\n    pos[0] = right - height * 0.5\n    pos[1] = top + height * 0.5\n  }\n}\n","import type { Subgraph } from \"./Subgraph\"\nimport type { SubgraphInput } from \"./SubgraphInput\"\nimport type { SubgraphOutput } from \"./SubgraphOutput\"\nimport type { Point, Positionable, ReadOnlyRect, Rect } from \"@/interfaces\"\nimport type { NodeId } from \"@/LGraphNode\"\nimport type { ExportedSubgraphIONode, Serialisable } from \"@/types/serialisation\"\n\nimport { isPointInRect, snapPoint } from \"@/measure\"\n\nexport abstract class SubgraphIONodeBase implements Positionable, Serialisable<ExportedSubgraphIONode> {\n  static margin = 10\n  static defaultWidth = 100\n  static roundedRadius = 10\n\n  readonly #boundingRect: Float32Array = new Float32Array(4)\n  readonly #pos: Point = this.#boundingRect.subarray(0, 2)\n  readonly #size: Point = this.#boundingRect.subarray(2, 4)\n\n  abstract readonly id: NodeId\n\n  get boundingRect(): Rect {\n    return this.#boundingRect\n  }\n\n  selected: boolean = false\n  pinned: boolean = false\n\n  get pos() {\n    return this.#pos\n  }\n\n  set pos(value) {\n    if (!value || value.length < 2) return\n\n    this.#pos[0] = value[0]\n    this.#pos[1] = value[1]\n  }\n\n  get size() {\n    return this.#size\n  }\n\n  set size(value) {\n    if (!value || value.length < 2) return\n\n    this.#size[0] = value[0]\n    this.#size[1] = value[1]\n  }\n\n  abstract readonly slots: SubgraphInput[] | SubgraphOutput[]\n\n  constructor(\n    /** The subgraph that this node belongs to. */\n    readonly subgraph: Subgraph,\n  ) {}\n\n  move(deltaX: number, deltaY: number): void {\n    this.pos[0] += deltaX\n    this.pos[1] += deltaY\n  }\n\n  /** @inheritdoc */\n  snapToGrid(snapTo: number): boolean {\n    return this.pinned ? false : snapPoint(this.pos, snapTo)\n  }\n\n  containsPoint(point: Point): boolean {\n    return isPointInRect(point, this.boundingRect)\n  }\n\n  asSerialisable(): ExportedSubgraphIONode {\n    return {\n      id: this.id,\n      bounding: serialiseRect(this.boundingRect),\n      pinned: this.pinned ? true : undefined,\n    }\n  }\n}\n\nfunction serialiseRect(rect: ReadOnlyRect): [number, number, number, number] {\n  return [rect[0], rect[1], rect[2], rect[3]]\n}\n","import type { Positionable } from \"@/interfaces\"\nimport type { NodeId } from \"@/LGraphNode\"\n\nimport { SubgraphIONodeBase } from \"./SubgraphIONodeBase\"\n\nexport class SubgraphInputNode extends SubgraphIONodeBase implements Positionable {\n  readonly id: NodeId = -10\n\n  get slots() {\n    return this.subgraph.inputs\n  }\n}\n","import type { Point, ReadOnlyRect } from \"@/interfaces\"\n\nimport { SubgraphSlot } from \"./SubgraphSlotBase\"\n\nexport class SubgraphOutput extends SubgraphSlot {\n  get labelPos(): Point {\n    const [x, y, , height] = this.boundingRect\n    return [x + height, y + height * 0.5]\n  }\n\n  override arrange(rect: ReadOnlyRect): void {\n    const [left, top, width, height] = rect\n    const { boundingRect: b, pos } = this\n\n    b[0] = left\n    b[1] = top\n    b[2] = width\n    b[3] = height\n\n    pos[0] = left + height * 0.5\n    pos[1] = top + height * 0.5\n  }\n}\n","import type { Positionable } from \"@/interfaces\"\nimport type { NodeId } from \"@/LGraphNode\"\n\nimport { SubgraphIONodeBase } from \"./SubgraphIONodeBase\"\n\nexport class SubgraphOutputNode extends SubgraphIONodeBase implements Positionable {\n  readonly id: NodeId = -20\n\n  get slots() {\n    return this.subgraph.outputs\n  }\n}\n","import type { ExportedSubgraph, ExposedWidget, Serialisable, SerialisableGraph } from \"@/types/serialisation\"\n\nimport { type BaseLGraph, LGraph } from \"@/LGraph\"\n\nimport { SubgraphInput } from \"./SubgraphInput\"\nimport { SubgraphInputNode } from \"./SubgraphInputNode\"\nimport { SubgraphOutput } from \"./SubgraphOutput\"\nimport { SubgraphOutputNode } from \"./SubgraphOutputNode\"\n\n/** Internal; simplifies type definitions. */\nexport type GraphOrSubgraph = LGraph | Subgraph\n\n/** A subgraph definition. */\nexport class Subgraph extends LGraph implements BaseLGraph, Serialisable<ExportedSubgraph> {\n  /** The display name of the subgraph. */\n  name: string\n\n  readonly inputNode = new SubgraphInputNode(this)\n  readonly outputNode = new SubgraphOutputNode(this)\n\n  /** Ordered list of inputs to the subgraph itself. Similar to a reroute, with the input side in the graph, and the output side in the subgraph. */\n  readonly inputs: SubgraphInput[]\n  /** Ordered list of outputs from the subgraph itself. Similar to a reroute, with the input side in the subgraph, and the output side in the graph. */\n  readonly outputs: SubgraphOutput[]\n  /** A list of node widgets displayed in the parent graph, on the subgraph object. */\n  readonly widgets: ExposedWidget[]\n\n  override get rootGraph(): LGraph {\n    return this.parents[0]\n  }\n\n  /** @inheritdoc */\n  get pathToRootGraph(): readonly [LGraph, ...Subgraph[]] {\n    return [...this.parents, this]\n  }\n\n  constructor(\n    readonly parents: readonly [LGraph, ...Subgraph[]],\n    data: ExportedSubgraph,\n  ) {\n    if (!parents.length) throw new Error(\"Subgraph must have at least one parent\")\n\n    const cloned = structuredClone(data)\n    const { name, inputs, outputs, widgets } = cloned\n    super()\n\n    this.name = name\n    this.inputs = inputs?.map(x => new SubgraphInput(x, this.inputNode)) ?? []\n    this.outputs = outputs?.map(x => new SubgraphOutput(x, this.outputNode)) ?? []\n    this.widgets = widgets ?? []\n\n    this.configure(cloned)\n  }\n\n  override asSerialisable(): ExportedSubgraph & Required<Pick<SerialisableGraph, \"nodes\" | \"groups\" | \"extra\">> {\n    return {\n      id: this.id,\n      version: LGraph.serialisedSchemaVersion,\n      state: this.state,\n      revision: this.revision,\n      config: this.config,\n      name: this.name,\n      inputNode: this.inputNode.asSerialisable(),\n      outputNode: this.outputNode.asSerialisable(),\n      inputs: this.inputs.map(x => x.asSerialisable()),\n      outputs: this.outputs.map(x => x.asSerialisable()),\n      widgets: [...this.widgets],\n      nodes: this.nodes.map(node => node.serialize()),\n      groups: this.groups.map(group => group.serialize()),\n      links: [...this.links.values()].map(x => x.asSerialisable()),\n      extra: this.extra,\n    }\n  }\n}\n","import type { LGraphCanvas } from \"@/LGraphCanvas\"\n\n/**\n * A class that can be added to the render cycle to show pointer / keyboard status symbols.\n *\n * Used to create videos of feature changes.\n *\n * Example usage with ComfyUI_frontend, via console / devtools:\n *\n * ```ts\n * const inputIndicators = new InputIndicators(canvas)\n * // Dispose:\n * inputIndicators.dispose()\n * ```\n */\nexport class InputIndicators implements Disposable {\n  // #region config\n  radius = 8\n  startAngle = 0\n  endAngle = Math.PI * 2\n\n  inactiveColour = \"#ffffff10\"\n  colour1 = \"#ff5f00\"\n  colour2 = \"#00ff7c\"\n  colour3 = \"#dea7ff\"\n  fontString = \"bold 12px Arial\"\n  // #endregion\n\n  // #region state\n  enabled: boolean = true\n\n  shiftDown: boolean = false\n  undoDown: boolean = false\n  redoDown: boolean = false\n  ctrlDown: boolean = false\n  altDown: boolean = false\n  mouse0Down: boolean = false\n  mouse1Down: boolean = false\n  mouse2Down: boolean = false\n\n  x: number = 0\n  y: number = 0\n  // #endregion\n\n  controller?: AbortController\n\n  constructor(public canvas: LGraphCanvas) {\n    this.controller = new AbortController()\n    const { signal } = this.controller\n\n    const element = canvas.canvas\n    const options = { capture: true, signal } satisfies AddEventListenerOptions\n\n    element.addEventListener(\"pointerdown\", this.#onPointerDownOrMove, options)\n    element.addEventListener(\"pointermove\", this.#onPointerDownOrMove, options)\n    element.addEventListener(\"pointerup\", this.#onPointerUp, options)\n    element.addEventListener(\"keydown\", this.#onKeyDownOrUp, options)\n    document.addEventListener(\"keyup\", this.#onKeyDownOrUp, options)\n\n    const origDrawFrontCanvas = canvas.drawFrontCanvas.bind(canvas)\n    signal.addEventListener(\"abort\", () => {\n      canvas.drawFrontCanvas = origDrawFrontCanvas\n    })\n\n    canvas.drawFrontCanvas = () => {\n      origDrawFrontCanvas()\n      this.draw()\n    }\n  }\n\n  #onPointerDownOrMove = this.onPointerDownOrMove.bind(this)\n  onPointerDownOrMove(e: MouseEvent): void {\n    this.mouse0Down = (e.buttons & 1) === 1\n    this.mouse1Down = (e.buttons & 4) === 4\n    this.mouse2Down = (e.buttons & 2) === 2\n\n    this.x = e.clientX\n    this.y = e.clientY\n\n    this.canvas.setDirty(true)\n  }\n\n  #onPointerUp = this.onPointerUp.bind(this)\n  onPointerUp(): void {\n    this.mouse0Down = false\n    this.mouse1Down = false\n    this.mouse2Down = false\n  }\n\n  #onKeyDownOrUp = this.onKeyDownOrUp.bind(this)\n  onKeyDownOrUp(e: KeyboardEvent): void {\n    this.ctrlDown = e.ctrlKey\n    this.altDown = e.altKey\n    this.shiftDown = e.shiftKey\n    this.undoDown = e.ctrlKey && e.code === \"KeyZ\" && e.type === \"keydown\"\n    this.redoDown = e.ctrlKey && e.code === \"KeyY\" && e.type === \"keydown\"\n  }\n\n  draw() {\n    const {\n      canvas: { ctx },\n      radius,\n      startAngle,\n      endAngle,\n      x,\n      y,\n      inactiveColour,\n      colour1,\n      colour2,\n      colour3,\n      fontString,\n    } = this\n\n    const { fillStyle, font } = ctx\n\n    const mouseDotX = x\n    const mouseDotY = y - 80\n\n    const textX = mouseDotX\n    const textY = mouseDotY - 15\n    ctx.font = fontString\n\n    textMarker(textX + 0, textY, \"Shift\", this.shiftDown ? colour1 : inactiveColour)\n    textMarker(textX + 45, textY + 20, \"Alt\", this.altDown ? colour2 : inactiveColour)\n    textMarker(textX + 30, textY, \"Control\", this.ctrlDown ? colour3 : inactiveColour)\n    textMarker(textX - 30, textY, \"â©ï¸\", this.undoDown ? \"#000\" : \"transparent\")\n    textMarker(textX + 45, textY, \"âªï¸\", this.redoDown ? \"#000\" : \"transparent\")\n\n    ctx.beginPath()\n    drawDot(mouseDotX, mouseDotY)\n    drawDot(mouseDotX + 15, mouseDotY)\n    drawDot(mouseDotX + 30, mouseDotY)\n    ctx.fillStyle = inactiveColour\n    ctx.fill()\n\n    const leftButtonColour = this.mouse0Down ? colour1 : inactiveColour\n    const middleButtonColour = this.mouse1Down ? colour2 : inactiveColour\n    const rightButtonColour = this.mouse2Down ? colour3 : inactiveColour\n    if (this.mouse0Down) mouseMarker(mouseDotX, mouseDotY, leftButtonColour)\n    if (this.mouse1Down) mouseMarker(mouseDotX + 15, mouseDotY, middleButtonColour)\n    if (this.mouse2Down) mouseMarker(mouseDotX + 30, mouseDotY, rightButtonColour)\n\n    ctx.fillStyle = fillStyle\n    ctx.font = font\n\n    function textMarker(x: number, y: number, text: string, colour: string) {\n      ctx.fillStyle = colour\n      ctx.fillText(text, x, y)\n    }\n\n    function mouseMarker(x: number, y: number, colour: string) {\n      ctx.beginPath()\n      ctx.fillStyle = colour\n      drawDot(x, y)\n      ctx.fill()\n    }\n\n    function drawDot(x: number, y: number) {\n      ctx.arc(x, y, radius, startAngle, endAngle)\n    }\n  }\n\n  dispose() {\n    this.controller?.abort()\n    this.controller = undefined\n  }\n\n  [Symbol.dispose](): void {\n    this.dispose()\n  }\n}\n","import type { ContextMenuDivElement, IContextMenuOptions, IContextMenuValue } from \"./interfaces\"\n\nimport { LiteGraph } from \"./litegraph\"\n\n// TODO: Replace this pattern with something more modern.\nexport interface ContextMenu<TValue = unknown> {\n  constructor: new (...args: ConstructorParameters<typeof ContextMenu<TValue>>) => ContextMenu<TValue>\n}\n\n/**\n * ContextMenu from LiteGUI\n */\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nexport class ContextMenu<TValue = unknown> {\n  options: IContextMenuOptions<TValue>\n  parentMenu?: ContextMenu<TValue>\n  root: ContextMenuDivElement<TValue>\n  current_submenu?: ContextMenu<TValue>\n  lock?: boolean\n\n  controller: AbortController = new AbortController()\n\n  /**\n   * @todo Interface for values requires functionality change - currently accepts\n   * an array of strings, functions, objects, nulls, or undefined.\n   * @param values (allows object { title: \"Nice text\", callback: function ... })\n   * @param options [optional] Some options:\\\n   * - title: title to show on top of the menu\n   * - callback: function to call when an option is clicked, it receives the item information\n   * - ignore_item_callbacks: ignores the callback inside the item, it just calls the options.callback\n   * - event: you can pass a MouseEvent, this way the ContextMenu appears in that position\n   */\n  constructor(values: readonly (string | IContextMenuValue<TValue> | null)[], options: IContextMenuOptions<TValue>) {\n    options ||= {}\n    this.options = options\n\n    // to link a menu with its parent\n    const parent = options.parentMenu\n    if (parent) {\n      if (!(parent instanceof ContextMenu)) {\n        console.error(\"parentMenu must be of class ContextMenu, ignoring it\")\n        options.parentMenu = undefined\n      } else {\n        this.parentMenu = parent\n        this.parentMenu.lock = true\n        this.parentMenu.current_submenu = this\n      }\n      if (parent.options?.className === \"dark\") {\n        options.className = \"dark\"\n      }\n    }\n\n    // use strings because comparing classes between windows doesnt work\n    const eventClass = options.event\n      ? options.event.constructor.name\n      : null\n    if (\n      eventClass !== \"MouseEvent\" &&\n      eventClass !== \"CustomEvent\" &&\n      eventClass !== \"PointerEvent\"\n    ) {\n      console.error(`Event passed to ContextMenu is not of type MouseEvent or CustomEvent. Ignoring it. (${eventClass})`)\n      options.event = undefined\n    }\n\n    const root: ContextMenuDivElement<TValue> = document.createElement(\"div\")\n    let classes = \"litegraph litecontextmenu litemenubar-panel\"\n    if (options.className) classes += ` ${options.className}`\n    root.className = classes\n    root.style.minWidth = \"100\"\n    root.style.minHeight = \"100\"\n\n    // Close the context menu when a click occurs outside this context menu or its submenus\n    const { signal } = this.controller\n    const eventOptions = { capture: true, signal }\n\n    if (!this.parentMenu) {\n      document.addEventListener(\"pointerdown\", (e) => {\n        if (e.target instanceof Node && !this.containsNode(e.target)) {\n          this.close()\n        }\n      }, eventOptions)\n    }\n\n    // this prevents the default context browser menu to open in case this menu was created when pressing right button\n    root.addEventListener(\"pointerup\", e => e.preventDefault(), eventOptions)\n\n    // Right button\n    root.addEventListener(\n      \"contextmenu\",\n      (e) => {\n        if (e.button === 2) e.preventDefault()\n      },\n      eventOptions,\n    )\n\n    root.addEventListener(\n      \"pointerdown\",\n      (e) => {\n        if (e.button == 2) {\n          this.close()\n          e.preventDefault()\n        }\n      },\n      eventOptions,\n    )\n\n    this.root = root\n\n    // title\n    if (options.title) {\n      const element = document.createElement(\"div\")\n      element.className = \"litemenu-title\"\n      element.innerHTML = options.title\n      root.append(element)\n    }\n\n    // entries\n    for (let i = 0; i < values.length; i++) {\n      const value = values[i]\n      let name = Array.isArray(values) ? value : String(i)\n\n      if (typeof name !== \"string\") {\n        name = name != null\n          ? (name.content === undefined ? String(name) : name.content)\n          : name\n      }\n\n      this.addItem(name, value, options)\n    }\n\n    // insert before checking position\n    const ownerDocument = (options.event?.target as Node | null | undefined)?.ownerDocument\n    const root_document = ownerDocument || document\n\n    if (root_document.fullscreenElement)\n      root_document.fullscreenElement.append(root)\n    else\n      root_document.body.append(root)\n\n    // compute best position\n    let left = options.left || 0\n    let top = options.top || 0\n    if (options.event) {\n      left = options.event.clientX - 10\n      top = options.event.clientY - 10\n      if (options.title) top -= 20\n\n      if (parent) {\n        const rect = parent.root.getBoundingClientRect()\n        left = rect.left + rect.width\n      }\n\n      const body_rect = document.body.getBoundingClientRect()\n      const root_rect = root.getBoundingClientRect()\n      if (body_rect.height == 0)\n        console.error(\"document.body height is 0. That is dangerous, set html,body { height: 100%; }\")\n\n      if (body_rect.width && left > body_rect.width - root_rect.width - 10)\n        left = body_rect.width - root_rect.width - 10\n      if (body_rect.height && top > body_rect.height - root_rect.height - 10)\n        top = body_rect.height - root_rect.height - 10\n    }\n\n    root.style.left = `${left}px`\n    root.style.top = `${top}px`\n\n    if (LiteGraph.context_menu_scaling && options.scale) {\n      root.style.transform = `scale(${Math.round(options.scale * 4) * 0.25})`\n    }\n  }\n\n  /**\n   * Checks if {@link node} is inside this context menu or any of its submenus\n   * @param node The {@link Node} to check\n   * @param visited A set of visited menus to avoid circular references\n   * @returns `true` if {@link node} is inside this context menu or any of its submenus\n   */\n  containsNode(node: Node, visited: Set<this> = new Set()): boolean {\n    if (visited.has(this)) return false\n    visited.add(this)\n\n    return this.current_submenu?.containsNode(node, visited) || this.root.contains(node)\n  }\n\n  addItem(\n    name: string | null,\n    value: string | IContextMenuValue<TValue> | null,\n    options: IContextMenuOptions<TValue>,\n  ): HTMLElement {\n    options ||= {}\n\n    const element: ContextMenuDivElement<TValue> = document.createElement(\"div\")\n    element.className = \"litemenu-entry submenu\"\n\n    let disabled = false\n\n    if (value === null) {\n      element.classList.add(\"separator\")\n    } else {\n      const innerHtml = name === null ? \"\" : String(name)\n      if (typeof value === \"string\") {\n        element.innerHTML = innerHtml\n      } else {\n        element.innerHTML = value?.title ?? innerHtml\n\n        if (value.disabled) {\n          disabled = true\n          element.classList.add(\"disabled\")\n          element.setAttribute(\"aria-disabled\", \"true\")\n        }\n        if (value.submenu || value.has_submenu) {\n          element.classList.add(\"has_submenu\")\n          element.setAttribute(\"aria-haspopup\", \"true\")\n          element.setAttribute(\"aria-expanded\", \"false\")\n        }\n        if (value.className) element.className += ` ${value.className}`\n      }\n      element.value = value\n      element.setAttribute(\"role\", \"menuitem\")\n\n      if (typeof value === \"function\") {\n        element.dataset[\"value\"] = String(name)\n        element.onclick_callback = value\n      } else {\n        element.dataset[\"value\"] = String(value)\n      }\n    }\n\n    this.root.append(element)\n    if (!disabled) element.addEventListener(\"click\", inner_onclick)\n    if (!disabled && options.autoopen)\n      element.addEventListener(\"pointerenter\", inner_over)\n\n    const setAriaExpanded = () => {\n      const entries = this.root.querySelectorAll(\"div.litemenu-entry.has_submenu\")\n      if (entries) {\n        for (const entry of entries) {\n          entry.setAttribute(\"aria-expanded\", \"false\")\n        }\n      }\n      element.setAttribute(\"aria-expanded\", \"true\")\n    }\n\n    function inner_over(this: ContextMenuDivElement<TValue>, e: MouseEvent) {\n      const value = this.value\n      if (!value || !(value as IContextMenuValue).has_submenu) return\n\n      // if it is a submenu, autoopen like the item was clicked\n      inner_onclick.call(this, e)\n      setAriaExpanded()\n    }\n\n    // menu option clicked\n    const that = this\n    function inner_onclick(this: ContextMenuDivElement<TValue>, e: MouseEvent) {\n      const value = this.value\n      let close_parent = true\n\n      that.current_submenu?.close(e)\n      if (\n        (value as IContextMenuValue)?.has_submenu ||\n        (value as IContextMenuValue)?.submenu\n      ) {\n        setAriaExpanded()\n      }\n\n      // global callback\n      if (options.callback) {\n        const r = options.callback.call(\n          this,\n          value,\n          options,\n          e,\n          that,\n          options.node,\n        )\n        if (r === true) close_parent = false\n      }\n\n      // special cases\n      if (typeof value === \"object\") {\n        if (\n          value.callback &&\n          !options.ignore_item_callbacks &&\n          value.disabled !== true\n        ) {\n          // item callback\n          const r = value.callback.call(\n            this,\n            value,\n            options,\n            e,\n            that,\n            options.extra,\n          )\n          if (r === true) close_parent = false\n        }\n        if (value.submenu) {\n          if (!value.submenu.options) throw \"ContextMenu submenu needs options\"\n\n          new that.constructor(value.submenu.options, {\n            callback: value.submenu.callback,\n            event: e,\n            parentMenu: that,\n            ignore_item_callbacks: value.submenu.ignore_item_callbacks,\n            title: value.submenu.title,\n            extra: value.submenu.extra,\n            autoopen: options.autoopen,\n          })\n          close_parent = false\n        }\n      }\n\n      if (close_parent && !that.lock) that.close()\n    }\n\n    return element\n  }\n\n  close(e?: MouseEvent, ignore_parent_menu?: boolean): void {\n    this.controller.abort()\n    this.root.remove()\n    if (this.parentMenu && !ignore_parent_menu) {\n      this.parentMenu.lock = false\n      this.parentMenu.current_submenu = undefined\n      if (e === undefined) {\n        this.parentMenu.close()\n      } else if (e && !ContextMenu.isCursorOverElement(e, this.parentMenu.root)) {\n        ContextMenu.trigger(\n          this.parentMenu.root,\n          `${LiteGraph.pointerevents_method}leave`,\n          e,\n        )\n      }\n    }\n    this.current_submenu?.close(e, true)\n  }\n\n  /** @deprecated Likely unused, however code search was inconclusive (too many results to check by hand). */\n  // this code is used to trigger events easily (used in the context menu mouseleave\n  static trigger(\n    element: HTMLDivElement,\n    event_name: string,\n    params: MouseEvent,\n  ): CustomEvent {\n    const evt = document.createEvent(\"CustomEvent\")\n    evt.initCustomEvent(event_name, true, true, params)\n    if (element.dispatchEvent) element.dispatchEvent(evt)\n    // else nothing seems binded here so nothing to do\n    return evt\n  }\n\n  // returns the top most menu\n  getTopMenu(): ContextMenu<TValue> {\n    return this.options.parentMenu\n      ? this.options.parentMenu.getTopMenu()\n      : this\n  }\n\n  getFirstEvent(): MouseEvent | undefined {\n    return this.options.parentMenu\n      ? this.options.parentMenu.getFirstEvent()\n      : this.options.event\n  }\n\n  /** @deprecated Unused. */\n  static isCursorOverElement(\n    event: MouseEvent,\n    element: HTMLDivElement,\n  ): boolean {\n    const left = event.clientX\n    const top = event.clientY\n    const rect = element.getBoundingClientRect()\n    if (!rect) return false\n\n    if (\n      top > rect.top &&\n      top < rect.top + rect.height &&\n      left > rect.left &&\n      left < rect.left + rect.width\n    ) {\n      return true\n    }\n    return false\n  }\n}\n","import type { Point, Rect } from \"./interfaces\"\n\nimport { clamp, LGraphCanvas } from \"./litegraph\"\nimport { distance } from \"./measure\"\n\n// used by some widgets to render a curve editor\n\nexport class CurveEditor {\n  points: Point[]\n  selected: number\n  nearest: number\n  size: Rect | null\n  must_update: boolean\n  margin: number\n  _nearest?: number\n\n  constructor(points: Point[]) {\n    this.points = points\n    this.selected = -1\n    this.nearest = -1\n    // stores last size used\n    this.size = null\n    this.must_update = true\n    this.margin = 5\n  }\n\n  static sampleCurve(f: number, points: Point[]): number | undefined {\n    if (!points) return\n\n    for (let i = 0; i < points.length - 1; ++i) {\n      const p = points[i]\n      const pn = points[i + 1]\n      if (pn[0] < f) continue\n\n      const r = pn[0] - p[0]\n      if (Math.abs(r) < 0.000_01) return p[1]\n\n      const local_f = (f - p[0]) / r\n      return p[1] * (1.0 - local_f) + pn[1] * local_f\n    }\n    return 0\n  }\n\n  draw(\n    ctx: CanvasRenderingContext2D,\n    size: Rect,\n    graphcanvas?: LGraphCanvas,\n    background_color?: string,\n    line_color?: string,\n    inactive = false,\n  ): void {\n    const points = this.points\n    if (!points) return\n\n    this.size = size\n    const w = size[0] - this.margin * 2\n    const h = size[1] - this.margin * 2\n\n    line_color = line_color || \"#666\"\n\n    ctx.save()\n    ctx.translate(this.margin, this.margin)\n\n    if (background_color) {\n      ctx.fillStyle = \"#111\"\n      ctx.fillRect(0, 0, w, h)\n      ctx.fillStyle = \"#222\"\n      ctx.fillRect(w * 0.5, 0, 1, h)\n      ctx.strokeStyle = \"#333\"\n      ctx.strokeRect(0, 0, w, h)\n    }\n    ctx.strokeStyle = line_color\n    if (inactive) ctx.globalAlpha = 0.5\n    ctx.beginPath()\n    for (const p of points) {\n      ctx.lineTo(p[0] * w, (1.0 - p[1]) * h)\n    }\n    ctx.stroke()\n    ctx.globalAlpha = 1\n    if (!inactive) {\n      for (const [i, p] of points.entries()) {\n        ctx.fillStyle = this.selected == i\n          ? \"#FFF\"\n          : (this.nearest == i ? \"#DDD\" : \"#AAA\")\n        ctx.beginPath()\n        ctx.arc(p[0] * w, (1.0 - p[1]) * h, 2, 0, Math.PI * 2)\n        ctx.fill()\n      }\n    }\n    ctx.restore()\n  }\n\n  // localpos is mouse in curve editor space\n  onMouseDown(localpos: Point, graphcanvas: LGraphCanvas): boolean | undefined {\n    const points = this.points\n    if (!points) return\n    if (localpos[1] < 0) return\n\n    // this.captureInput(true);\n    if (this.size == null) throw new Error(\"CurveEditor.size was null or undefined.\")\n    const w = this.size[0] - this.margin * 2\n    const h = this.size[1] - this.margin * 2\n    const x = localpos[0] - this.margin\n    const y = localpos[1] - this.margin\n    const pos: Point = [x, y]\n    const max_dist = 30 / graphcanvas.ds.scale\n    // search closer one\n    this.selected = this.getCloserPoint(pos, max_dist)\n    // create one\n    if (this.selected == -1) {\n      const point: Point = [x / w, 1 - y / h]\n      points.push(point)\n      points.sort(function (a, b) {\n        return a[0] - b[0]\n      })\n      this.selected = points.indexOf(point)\n      this.must_update = true\n    }\n    if (this.selected != -1) return true\n  }\n\n  onMouseMove(localpos: Point, graphcanvas: LGraphCanvas): void {\n    const points = this.points\n    if (!points) return\n\n    const s = this.selected\n    if (s < 0) return\n\n    if (this.size == null) throw new Error(\"CurveEditor.size was null or undefined.\")\n    const x = (localpos[0] - this.margin) / (this.size[0] - this.margin * 2)\n    const y = (localpos[1] - this.margin) / (this.size[1] - this.margin * 2)\n    const curvepos: Point = [\n      localpos[0] - this.margin,\n      localpos[1] - this.margin,\n    ]\n    const max_dist = 30 / graphcanvas.ds.scale\n    this._nearest = this.getCloserPoint(curvepos, max_dist)\n    const point = points[s]\n    if (point) {\n      const is_edge_point = s == 0 || s == points.length - 1\n      if (\n        !is_edge_point &&\n        (localpos[0] < -10 ||\n          localpos[0] > this.size[0] + 10 ||\n          localpos[1] < -10 ||\n          localpos[1] > this.size[1] + 10)\n      ) {\n        points.splice(s, 1)\n        this.selected = -1\n        return\n      }\n      // not edges\n      if (!is_edge_point) point[0] = clamp(x, 0, 1)\n      else point[0] = s == 0 ? 0 : 1\n      point[1] = 1.0 - clamp(y, 0, 1)\n      points.sort(function (a, b) {\n        return a[0] - b[0]\n      })\n      this.selected = points.indexOf(point)\n      this.must_update = true\n    }\n  }\n\n  // Former params: localpos, graphcanvas\n  onMouseUp(): boolean {\n    this.selected = -1\n    return false\n  }\n\n  getCloserPoint(pos: Point, max_dist: number): number {\n    const points = this.points\n    if (!points) return -1\n\n    max_dist = max_dist || 30\n    if (this.size == null) throw new Error(\"CurveEditor.size was null or undefined.\")\n    const w = this.size[0] - this.margin * 2\n    const h = this.size[1] - this.margin * 2\n    const num = points.length\n    const p2: Point = [0, 0]\n    let min_dist = 1_000_000\n    let closest = -1\n\n    for (let i = 0; i < num; ++i) {\n      const p = points[i]\n      p2[0] = p[0] * w\n      p2[1] = (1.0 - p[1]) * h\n      const dist = distance(pos, p2)\n      if (dist > min_dist || dist > max_dist) continue\n\n      closest = i\n      min_dist = dist\n    }\n    return closest\n  }\n}\n","import type { Dictionary, ISlotType, Rect, WhenNullish } from \"./interfaces\"\n\nimport { InputIndicators } from \"./canvas/InputIndicators\"\nimport { ContextMenu } from \"./ContextMenu\"\nimport { CurveEditor } from \"./CurveEditor\"\nimport { DragAndScale } from \"./DragAndScale\"\nimport { LabelPosition, SlotDirection, SlotShape, SlotType } from \"./draw\"\nimport { LGraph } from \"./LGraph\"\nimport { LGraphCanvas } from \"./LGraphCanvas\"\nimport { LGraphGroup } from \"./LGraphGroup\"\nimport { LGraphNode } from \"./LGraphNode\"\nimport { LLink } from \"./LLink\"\nimport { distance, isInsideRectangle, overlapBounding } from \"./measure\"\nimport { Reroute } from \"./Reroute\"\nimport {\n  LGraphEventMode,\n  LinkDirection,\n  LinkRenderType,\n  NodeSlotType,\n  RenderShape,\n  TitleMode,\n} from \"./types/globalEnums\"\nimport { createUuidv4 } from \"./utils/uuid\"\n\n/**\n * The Global Scope. It contains all the registered node classes.\n */\nexport class LiteGraphGlobal {\n  // Enums\n  SlotShape = SlotShape\n  SlotDirection = SlotDirection\n  SlotType = SlotType\n  LabelPosition = LabelPosition\n\n  /** Used in serialised graphs at one point. */\n  VERSION = 0.4 as const\n\n  CANVAS_GRID_SIZE = 10\n\n  NODE_TITLE_HEIGHT = 30\n  NODE_TITLE_TEXT_Y = 20\n  NODE_SLOT_HEIGHT = 20\n  NODE_WIDGET_HEIGHT = 20\n  NODE_WIDTH = 140\n  NODE_MIN_WIDTH = 50\n  NODE_COLLAPSED_RADIUS = 10\n  NODE_COLLAPSED_WIDTH = 80\n  NODE_TITLE_COLOR = \"#999\"\n  NODE_SELECTED_TITLE_COLOR = \"#FFF\"\n  NODE_TEXT_SIZE = 14\n  NODE_TEXT_COLOR = \"#AAA\"\n  NODE_TEXT_HIGHLIGHT_COLOR = \"#EEE\"\n  NODE_SUBTEXT_SIZE = 12\n  NODE_DEFAULT_COLOR = \"#333\"\n  NODE_DEFAULT_BGCOLOR = \"#353535\"\n  NODE_DEFAULT_BOXCOLOR = \"#666\"\n  NODE_DEFAULT_SHAPE = RenderShape.ROUND\n  NODE_BOX_OUTLINE_COLOR = \"#FFF\"\n  NODE_ERROR_COLOUR = \"#E00\"\n  NODE_FONT = \"Arial\"\n\n  DEFAULT_FONT = \"Arial\"\n  DEFAULT_SHADOW_COLOR = \"rgba(0,0,0,0.5)\"\n\n  DEFAULT_GROUP_FONT = 24\n  DEFAULT_GROUP_FONT_SIZE?: any\n  GROUP_FONT = \"Arial\"\n\n  WIDGET_BGCOLOR = \"#222\"\n  WIDGET_OUTLINE_COLOR = \"#666\"\n  WIDGET_ADVANCED_OUTLINE_COLOR = \"rgba(56, 139, 253, 0.8)\"\n  WIDGET_TEXT_COLOR = \"#DDD\"\n  WIDGET_SECONDARY_TEXT_COLOR = \"#999\"\n  WIDGET_DISABLED_TEXT_COLOR = \"#666\"\n\n  LINK_COLOR = \"#9A9\"\n  EVENT_LINK_COLOR = \"#A86\"\n  CONNECTING_LINK_COLOR = \"#AFA\"\n\n  /** avoid infinite loops */\n  MAX_NUMBER_OF_NODES = 10_000\n  /** default node position */\n  DEFAULT_POSITION = [100, 100]\n  /** ,\"circle\" */\n  VALID_SHAPES = [\"default\", \"box\", \"round\", \"card\"] satisfies (\"default\" | Lowercase<keyof typeof RenderShape>)[]\n  ROUND_RADIUS = 8\n\n  // shapes are used for nodes but also for slots\n  BOX_SHAPE = RenderShape.BOX\n  ROUND_SHAPE = RenderShape.ROUND\n  CIRCLE_SHAPE = RenderShape.CIRCLE\n  CARD_SHAPE = RenderShape.CARD\n  ARROW_SHAPE = RenderShape.ARROW\n  /** intended for slot arrays */\n  GRID_SHAPE = RenderShape.GRID\n\n  // enums\n  INPUT = NodeSlotType.INPUT\n  OUTPUT = NodeSlotType.OUTPUT\n\n  // TODO: -1 can lead to ambiguity in JS; these should be updated to a more explicit constant or Symbol.\n  /** for outputs */\n  EVENT = -1 as const\n  /** for inputs */\n  ACTION = -1 as const\n\n  /** helper, will add \"On Request\" and more in the future */\n  NODE_MODES = [\"Always\", \"On Event\", \"Never\", \"On Trigger\"]\n  /** use with node_box_coloured_by_mode */\n  NODE_MODES_COLORS = [\"#666\", \"#422\", \"#333\", \"#224\", \"#626\"]\n  ALWAYS = LGraphEventMode.ALWAYS\n  ON_EVENT = LGraphEventMode.ON_EVENT\n  NEVER = LGraphEventMode.NEVER\n  ON_TRIGGER = LGraphEventMode.ON_TRIGGER\n\n  UP = LinkDirection.UP\n  DOWN = LinkDirection.DOWN\n  LEFT = LinkDirection.LEFT\n  RIGHT = LinkDirection.RIGHT\n  CENTER = LinkDirection.CENTER\n\n  /** helper */\n  LINK_RENDER_MODES = [\"Straight\", \"Linear\", \"Spline\"]\n  HIDDEN_LINK = LinkRenderType.HIDDEN_LINK\n  STRAIGHT_LINK = LinkRenderType.STRAIGHT_LINK\n  LINEAR_LINK = LinkRenderType.LINEAR_LINK\n  SPLINE_LINK = LinkRenderType.SPLINE_LINK\n\n  NORMAL_TITLE = TitleMode.NORMAL_TITLE\n  NO_TITLE = TitleMode.NO_TITLE\n  TRANSPARENT_TITLE = TitleMode.TRANSPARENT_TITLE\n  AUTOHIDE_TITLE = TitleMode.AUTOHIDE_TITLE\n\n  /** arrange nodes vertically */\n  VERTICAL_LAYOUT = \"vertical\"\n\n  /** used to redirect calls */\n  proxy = null\n  node_images_path = \"\"\n\n  debug = false\n  catch_exceptions = true\n  throw_errors = true\n  /** if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits */\n  allow_scripts = false\n  /** nodetypes by string */\n  registered_node_types: Record<string, typeof LGraphNode> = {}\n  /** @deprecated used for dropping files in the canvas.  It appears the code that enables this was removed, but the object remains and is references by built-in drag drop. */\n  node_types_by_file_extension: Record<string, { type: string }> = {}\n  /** node types by classname */\n  Nodes: Record<string, typeof LGraphNode> = {}\n  /** used to store vars between graphs */\n  Globals = {}\n\n  /** @deprecated Unused and will be deleted. */\n  searchbox_extras: Dictionary<unknown> = {}\n\n  /** [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback */\n  node_box_coloured_when_on = false\n  /** [true!] nodebox based on node mode, visual feedback */\n  node_box_coloured_by_mode = false\n\n  /** [false on mobile] better true if not touch device, TODO add an helper/listener to close if false */\n  dialog_close_on_mouse_leave = false\n  dialog_close_on_mouse_leave_delay = 500\n\n  /** [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys */\n  shift_click_do_break_link_from = false\n  /** [false!]prefer false, way too easy to break links */\n  click_do_break_link_to = false\n  /** [true!] who accidentally ctrl-alt-clicks on an in/output? nobody! that's who! */\n  ctrl_alt_click_do_break_link = true\n  /** [true!] snaps links when dragging connections over valid targets */\n  snaps_for_comfy = true\n  /** [true!] renders a partial border to highlight when a dragged link is snapped to a node */\n  snap_highlights_node = true\n\n  /**\n   * If `true`, items always snap to the grid - modifier keys are ignored.\n   * When {@link snapToGrid} is falsy, a value of `1` is used.\n   * Default: `false`\n   */\n  alwaysSnapToGrid?: boolean\n\n  /**\n   * When set to a positive number, when nodes are moved their positions will\n   * be rounded to the nearest multiple of this value.  Half up.\n   * Default: `undefined`\n   * @todo Not implemented - see {@link LiteGraph.CANVAS_GRID_SIZE}\n   */\n  snapToGrid?: number\n\n  /** [false on mobile] better true if not touch device, TODO add an helper/listener to close if false */\n  search_hide_on_mouse_leave = true\n  /**\n   * [true!] enable filtering slots type in the search widget\n   * !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]\n   */\n  search_filter_enabled = false\n  /** [true!] opens the results list when opening the search widget */\n  search_show_all_on_open = true\n\n  /**\n   * [if want false, use true, run, get vars values to be statically set, than disable]\n   * nodes types and nodeclass association with node types need to be calculated,\n   * if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]\n   */\n  auto_load_slot_types = false\n\n  // set these values if not using auto_load_slot_types\n  /** slot types for nodeclass */\n  registered_slot_in_types: Record<string, { nodes: string[] }> = {}\n  /** slot types for nodeclass */\n  registered_slot_out_types: Record<string, { nodes: string[] }> = {}\n  /** slot types IN */\n  slot_types_in: string[] = []\n  /** slot types OUT */\n  slot_types_out: string[] = []\n  /**\n   * specify for each IN slot type a(/many) default node(s), use single string, array, or object\n   * (with node, title, parameters, ..) like for search\n   */\n  slot_types_default_in: Record<string, string[]> = {}\n  /**\n   * specify for each OUT slot type a(/many) default node(s), use single string, array, or object\n   * (with node, title, parameters, ..) like for search\n   */\n  slot_types_default_out: Record<string, string[]> = {}\n\n  /** [true!] very handy, ALT click to clone and drag the new node */\n  alt_drag_do_clone_nodes = false\n\n  /**\n   * [true!] will create and connect event slots when using action/events connections,\n   * !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this\n   */\n  do_add_triggers_slots = false\n\n  /** [false!] being events, it is strongly reccomended to use them sequentially, one by one */\n  allow_multi_output_for_events = true\n\n  /** [true!] allows to create and connect a ndoe clicking with the third button (wheel) */\n  middle_click_slot_add_default_node = false\n\n  /** [true!] dragging a link to empty space will open a menu, add from list, search or defaults */\n  release_link_on_empty_shows_menu = false\n\n  /** \"mouse\"|\"pointer\" use mouse for retrocompatibility issues? (none found @ now) */\n  pointerevents_method = \"pointer\"\n\n  /**\n   * [true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected\n   * with the inputs of the newly pasted nodes\n   */\n  ctrl_shift_v_paste_connect_unselected_outputs = true\n\n  // if true, all newly created nodes/links will use string UUIDs for their id fields instead of integers.\n  // use this if you must have node IDs that are unique across all graphs and subgraphs.\n  use_uuids = false\n\n  // Whether to highlight the bounding box of selected groups\n  highlight_selected_group = true\n\n  /** Whether to scale context with the graph when zooming in.  Zooming out never makes context menus smaller. */\n  context_menu_scaling = false\n\n  /**\n   * Debugging flag. Repeats deprecation warnings every time they are reported.\n   * May impact performance.\n   */\n  alwaysRepeatWarnings: boolean = false\n\n  /**\n   * Array of callbacks to execute when Litegraph first reports a deprecated API being used.\n   * @see alwaysRepeatWarnings By default, will not repeat identical messages.\n   */\n  onDeprecationWarning: ((message: string, source?: object) => void)[] = [console.warn]\n\n  /**\n   * If `true`, mouse wheel events will be interpreted as trackpad gestures.\n   * Tested on MacBook M4 Pro.\n   * @default false\n   * @see macGesturesRequireMac\n   */\n  macTrackpadGestures: boolean = false\n\n  /**\n   * If both this setting and {@link macTrackpadGestures} are `true`, trackpad gestures will\n   * only be enabled when the browser user agent includes \"Mac\".\n   * @default true\n   * @see macTrackpadGestures\n   */\n  macGesturesRequireMac: boolean = true\n\n  /**\n   * If `true`, widget labels and values will both be truncated (proportionally to size),\n   * until they fit within the widget.\n   *\n   * Otherwise, the label will be truncated completely before the value is truncated.\n   * @default false\n   */\n  truncateWidgetTextEvenly: boolean = false\n\n  /**\n   * If `true`, widget values will be completely truncated when shrinking a widget,\n   * before truncating widget labels.  {@link truncateWidgetTextEvenly} must be `false`.\n   * @default false\n   */\n  truncateWidgetValuesFirst: boolean = false\n\n  /**\n   * If `true`, the current viewport scale & offset of the first attached canvas will be included with the graph when exporting.\n   * @default true\n   */\n  saveViewportWithGraph: boolean = true\n\n  // TODO: Remove legacy accessors\n  LGraph = LGraph\n  LLink = LLink\n  LGraphNode = LGraphNode\n  LGraphGroup = LGraphGroup\n  DragAndScale = DragAndScale\n  LGraphCanvas = LGraphCanvas\n  ContextMenu = ContextMenu\n  CurveEditor = CurveEditor\n  Reroute = Reroute\n  InputIndicators = InputIndicators\n\n  onNodeTypeRegistered?(type: string, base_class: typeof LGraphNode): void\n  onNodeTypeReplaced?(type: string, base_class: typeof LGraphNode, prev: unknown): void\n\n  /**\n   * Register a node class so it can be listed when the user wants to create a new one\n   * @param type name of the node and path\n   * @param base_class class containing the structure of a node\n   */\n  registerNodeType(type: string, base_class: typeof LGraphNode): void {\n    if (!base_class.prototype)\n      throw \"Cannot register a simple object, it must be a class with a prototype\"\n    base_class.type = type\n\n    if (this.debug) console.log(\"Node registered:\", type)\n\n    const classname = base_class.name\n\n    const pos = type.lastIndexOf(\"/\")\n    base_class.category = type.substring(0, pos)\n\n    base_class.title ||= classname\n\n    // extend class\n    for (const i in LGraphNode.prototype) {\n      // @ts-expect-error #576 This functionality is deprecated and should be removed.\n      base_class.prototype[i] ||= LGraphNode.prototype[i]\n    }\n\n    const prev = this.registered_node_types[type]\n    if (prev && this.debug) {\n      console.log(\"replacing node type:\", type)\n    }\n\n    this.registered_node_types[type] = base_class\n    if (base_class.constructor.name) this.Nodes[classname] = base_class\n\n    this.onNodeTypeRegistered?.(type, base_class)\n    if (prev) this.onNodeTypeReplaced?.(type, base_class, prev)\n\n    // warnings\n    if (base_class.prototype.onPropertyChange)\n      console.warn(`LiteGraph node class ${type} has onPropertyChange method, it must be called onPropertyChanged with d at the end`)\n\n    // TODO one would want to know input and ouput :: this would allow through registerNodeAndSlotType to get all the slots types\n    if (this.auto_load_slot_types) new base_class(base_class.title || \"tmpnode\")\n  }\n\n  /**\n   * removes a node type from the system\n   * @param type name of the node or the node constructor itself\n   */\n  unregisterNodeType(type: string | typeof LGraphNode): void {\n    const base_class = typeof type === \"string\"\n      ? this.registered_node_types[type]\n      : type\n    if (!base_class) throw `node type not found: ${String(type)}`\n\n    delete this.registered_node_types[String(base_class.type)]\n\n    const name = base_class.constructor.name\n    if (name) delete this.Nodes[name]\n  }\n\n  /**\n   * Save a slot type and his node\n   * @param type name of the node or the node constructor itself\n   * @param slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..\n   */\n  registerNodeAndSlotType(\n    type: LGraphNode,\n    slot_type: ISlotType,\n    out?: boolean,\n  ): void {\n    out ||= false\n    // @ts-expect-error Confirm this function no longer supports string types - base_class should always be an instance not a constructor.\n    const base_class = typeof type === \"string\" && this.registered_node_types[type] !== \"anonymous\"\n      ? this.registered_node_types[type]\n      : type\n\n    // @ts-expect-error Confirm this function no longer supports string types - base_class should always be an instance not a constructor.\n    const class_type = base_class.constructor.type\n\n    let allTypes = []\n    if (typeof slot_type === \"string\") {\n      allTypes = slot_type.split(\",\")\n    } else if (slot_type == this.EVENT || slot_type == this.ACTION) {\n      allTypes = [\"_event_\"]\n    } else {\n      allTypes = [\"*\"]\n    }\n\n    for (let slotType of allTypes) {\n      if (slotType === \"\") slotType = \"*\"\n\n      const register = out\n        ? this.registered_slot_out_types\n        : this.registered_slot_in_types\n      register[slotType] ??= { nodes: [] }\n\n      const { nodes } = register[slotType]\n      if (!nodes.includes(class_type)) nodes.push(class_type)\n\n      // check if is a new type\n      const types = out\n        ? this.slot_types_out\n        : this.slot_types_in\n      const type = slotType.toLowerCase()\n\n      if (!types.includes(type)) {\n        types.push(type)\n        types.sort()\n      }\n    }\n  }\n\n  /**\n   * Removes all previously registered node's types\n   */\n  clearRegisteredTypes(): void {\n    this.registered_node_types = {}\n    this.node_types_by_file_extension = {}\n    this.Nodes = {}\n    this.searchbox_extras = {}\n  }\n\n  /**\n   * Create a node of a given type with a name. The node is not attached to any graph yet.\n   * @param type full name of the node class. p.e. \"math/sin\"\n   * @param title a name to distinguish from other nodes\n   * @param options to set options\n   */\n  createNode(\n    type: string,\n    title?: string,\n    options?: Dictionary<unknown>,\n  ): LGraphNode | null {\n    const base_class = this.registered_node_types[type]\n    if (!base_class) {\n      if (this.debug) console.log(`GraphNode type \"${type}\" not registered.`)\n      return null\n    }\n\n    title = title || base_class.title || type\n\n    let node = null\n\n    if (this.catch_exceptions) {\n      try {\n        node = new base_class(title)\n      } catch (error) {\n        console.error(error)\n        return null\n      }\n    } else {\n      node = new base_class(title)\n    }\n\n    node.type = type\n\n    if (!node.title && title) node.title = title\n    node.properties ||= {}\n    node.properties_info ||= []\n    node.flags ||= {}\n    // call onresize?\n    node.size ||= node.computeSize()\n    node.pos ||= [this.DEFAULT_POSITION[0], this.DEFAULT_POSITION[1]]\n    node.mode ||= LGraphEventMode.ALWAYS\n\n    // extra options\n    if (options) {\n      for (const i in options) {\n        // @ts-expect-error #577 Requires interface\n        node[i] = options[i]\n      }\n    }\n\n    // callback\n    node.onNodeCreated?.()\n    return node\n  }\n\n  /**\n   * Returns a registered node type with a given name\n   * @param type full name of the node class. p.e. \"math/sin\"\n   * @returns the node class\n   */\n  getNodeType(type: string): typeof LGraphNode {\n    return this.registered_node_types[type]\n  }\n\n  /**\n   * Returns a list of node types matching one category\n   * @param category category name\n   * @returns array with all the node classes\n   */\n  getNodeTypesInCategory(category: string, filter?: string) {\n    const r = []\n    for (const i in this.registered_node_types) {\n      const type = this.registered_node_types[i]\n      if (type.filter != filter) continue\n\n      if (category == \"\") {\n        if (type.category == null) r.push(type)\n      } else if (type.category == category) {\n        r.push(type)\n      }\n    }\n\n    return r\n  }\n\n  /**\n   * Returns a list with all the node type categories\n   * @param filter only nodes with ctor.filter equal can be shown\n   * @returns array with all the names of the categories\n   */\n  getNodeTypesCategories(filter?: string): string[] {\n    const categories: Dictionary<number> = { \"\": 1 }\n    for (const i in this.registered_node_types) {\n      const type = this.registered_node_types[i]\n      if (type.category && !type.skip_list) {\n        if (type.filter != filter) continue\n\n        categories[type.category] = 1\n      }\n    }\n    const result = []\n    for (const i in categories) {\n      result.push(i)\n    }\n    return result\n  }\n\n  // debug purposes: reloads all the js scripts that matches a wildcard\n  reloadNodes(folder_wildcard: string): void {\n    const tmp = document.getElementsByTagName(\"script\")\n    // weird, this array changes by its own, so we use a copy\n    const script_files = []\n    for (const element of tmp) {\n      script_files.push(element)\n    }\n\n    const docHeadObj = document.getElementsByTagName(\"head\")[0]\n    folder_wildcard = document.location.href + folder_wildcard\n\n    for (const script_file of script_files) {\n      const src = script_file.src\n      if (!src || src.substr(0, folder_wildcard.length) != folder_wildcard)\n        continue\n\n      try {\n        if (this.debug) console.log(\"Reloading:\", src)\n        const dynamicScript = document.createElement(\"script\")\n        dynamicScript.type = \"text/javascript\"\n        dynamicScript.src = src\n        docHeadObj.append(dynamicScript)\n        script_file.remove()\n      } catch (error) {\n        if (this.throw_errors) throw error\n        if (this.debug) console.log(\"Error while reloading\", src)\n      }\n    }\n\n    if (this.debug) console.log(\"Nodes reloaded\")\n  }\n\n  // separated just to improve if it doesn't work\n  /** @deprecated Prefer {@link structuredClone} */\n  cloneObject<T extends object | undefined | null>(obj: T, target?: T): WhenNullish<T, null> {\n    if (obj == null) return null as WhenNullish<T, null>\n\n    const r = JSON.parse(JSON.stringify(obj))\n    if (!target) return r\n\n    for (const i in r) {\n      // @ts-expect-error deprecated\n      target[i] = r[i]\n    }\n    return target\n  }\n\n  /** @see {@link createUuidv4} @inheritdoc */\n  uuidv4 = createUuidv4\n\n  /**\n   * Returns if the types of two slots are compatible (taking into account wildcards, etc)\n   * @param type_a output\n   * @param type_b input\n   * @returns true if they can be connected\n   */\n  isValidConnection(type_a: ISlotType, type_b: ISlotType): boolean {\n    if (type_a == \"\" || type_a === \"*\") type_a = 0\n    if (type_b == \"\" || type_b === \"*\") type_b = 0\n    // If generic in/output, matching types (valid for triggers), or event/action types\n    if (\n      !type_a ||\n      !type_b ||\n      type_a == type_b ||\n      (type_a == this.EVENT && type_b == this.ACTION)\n    ) {\n      return true\n    }\n\n    // Enforce string type to handle toLowerCase call (-1 number not ok)\n    type_a = String(type_a)\n    type_b = String(type_b)\n    type_a = type_a.toLowerCase()\n    type_b = type_b.toLowerCase()\n\n    // For nodes supporting multiple connection types\n    if (!type_a.includes(\",\") && !type_b.includes(\",\"))\n      return type_a == type_b\n\n    // Check all permutations to see if one is valid\n    const supported_types_a = type_a.split(\",\")\n    const supported_types_b = type_b.split(\",\")\n    for (const a of supported_types_a) {\n      for (const b of supported_types_b) {\n        if (this.isValidConnection(a, b))\n          return true\n      }\n    }\n\n    return false\n  }\n\n  // used to create nodes from wrapping functions\n  getParameterNames(func: (...args: any) => any): string[] {\n    return String(func)\n      .replaceAll(/\\/\\/.*$/gm, \"\") // strip single-line comments\n      .replaceAll(/\\s+/g, \"\") // strip white space\n      .replaceAll(/\\/\\*[^*/]*\\*\\//g, \"\") // strip multi-line comments  /**/\n      .split(\"){\", 1)[0]\n      .replace(/^[^(]*\\(/, \"\") // extract the parameters\n      .replaceAll(/=[^,]+/g, \"\") // strip any ES6 defaults\n      .split(\",\")\n      .filter(Boolean) // split & filter [\"\"]\n  }\n\n  /* helper for interaction: pointer, touch, mouse Listeners\n    used by LGraphCanvas DragAndScale ContextMenu */\n  pointerListenerAdd(oDOM: Node, sEvIn: string, fCall: (e: Event) => boolean | void, capture = false): void {\n    if (!oDOM || !oDOM.addEventListener || !sEvIn || typeof fCall !== \"function\") return\n\n    let sMethod = this.pointerevents_method\n    let sEvent = sEvIn\n\n    // UNDER CONSTRUCTION\n    // convert pointerevents to touch event when not available\n    if (sMethod == \"pointer\" && !window.PointerEvent) {\n      console.warn(\"sMethod=='pointer' && !window.PointerEvent\")\n      console.log(`Converting pointer[${sEvent}] : down move up cancel enter TO touchstart touchmove touchend, etc ..`)\n      switch (sEvent) {\n      case \"down\": {\n        sMethod = \"touch\"\n        sEvent = \"start\"\n        break\n      }\n      case \"move\": {\n        sMethod = \"touch\"\n        // sEvent = \"move\";\n        break\n      }\n      case \"up\": {\n        sMethod = \"touch\"\n        sEvent = \"end\"\n        break\n      }\n      case \"cancel\": {\n        sMethod = \"touch\"\n        // sEvent = \"cancel\";\n        break\n      }\n      case \"enter\": {\n        console.log(\"debug: Should I send a move event?\") // ???\n        break\n      }\n      // case \"over\": case \"out\": not used at now\n      default: {\n        console.warn(`PointerEvent not available in this browser ? The event ${sEvent} would not be called`)\n      }\n      }\n    }\n\n    switch (sEvent) {\n    // @ts-expect-error\n    // both pointer and move events\n    case \"down\": case \"up\": case \"move\": case \"over\": case \"out\": case \"enter\":\n    {\n      oDOM.addEventListener(sMethod + sEvent, fCall, capture)\n    }\n    // @ts-expect-error\n    // only pointerevents\n    case \"leave\": case \"cancel\": case \"gotpointercapture\": case \"lostpointercapture\":\n    {\n      if (sMethod != \"mouse\") {\n        return oDOM.addEventListener(sMethod + sEvent, fCall, capture)\n      }\n    }\n    // not \"pointer\" || \"mouse\"\n    default:\n      return oDOM.addEventListener(sEvent, fCall, capture)\n    }\n  }\n\n  pointerListenerRemove(oDOM: Node, sEvent: string, fCall: (e: Event) => boolean | void, capture = false): void {\n    if (!oDOM || !oDOM.removeEventListener || !sEvent || typeof fCall !== \"function\") return\n\n    switch (sEvent) {\n    // @ts-expect-error\n    // both pointer and move events\n    case \"down\": case \"up\": case \"move\": case \"over\": case \"out\": case \"enter\":\n    {\n      if (this.pointerevents_method == \"pointer\" || this.pointerevents_method == \"mouse\") {\n        oDOM.removeEventListener(this.pointerevents_method + sEvent, fCall, capture)\n      }\n    }\n    // @ts-expect-error\n    // only pointerevents\n    case \"leave\": case \"cancel\": case \"gotpointercapture\": case \"lostpointercapture\":\n    {\n      if (this.pointerevents_method == \"pointer\") {\n        return oDOM.removeEventListener(this.pointerevents_method + sEvent, fCall, capture)\n      }\n    }\n    // not \"pointer\" || \"mouse\"\n    default:\n      return oDOM.removeEventListener(sEvent, fCall, capture)\n    }\n  }\n\n  getTime(): number {\n    return performance.now()\n  }\n\n  distance = distance\n\n  colorToString(c: [number, number, number, number]): string {\n    return (\n      `rgba(${\n        Math.round(c[0] * 255).toFixed()\n      },${\n        Math.round(c[1] * 255).toFixed()\n      },${\n        Math.round(c[2] * 255).toFixed()\n      },${\n        c.length == 4 ? c[3].toFixed(2) : \"1.0\"\n      })`\n    )\n  }\n\n  isInsideRectangle = isInsideRectangle\n\n  // [minx,miny,maxx,maxy]\n  growBounding(bounding: Rect, x: number, y: number): void {\n    if (x < bounding[0]) {\n      bounding[0] = x\n    } else if (x > bounding[2]) {\n      bounding[2] = x\n    }\n\n    if (y < bounding[1]) {\n      bounding[1] = y\n    } else if (y > bounding[3]) {\n      bounding[3] = y\n    }\n  }\n\n  overlapBounding = overlapBounding\n\n  // point inside bounding box\n  isInsideBounding(p: number[], bb: number[][]): boolean {\n    if (\n      p[0] < bb[0][0] ||\n      p[1] < bb[0][1] ||\n      p[0] > bb[1][0] ||\n      p[1] > bb[1][1]\n    ) {\n      return false\n    }\n    return true\n  }\n\n  // Convert a hex value to its decimal value - the inputted hex must be in the\n  // format of a hex triplet - the kind we use for HTML colours. The function\n  // will return an array with three values.\n  hex2num(hex: string): number[] {\n    if (hex.charAt(0) == \"#\") {\n      hex = hex.slice(1)\n    // Remove the '#' char - if there is one.\n    }\n    hex = hex.toUpperCase()\n    const hex_alphabets = \"0123456789ABCDEF\"\n    const value = new Array(3)\n    let k = 0\n    let int1, int2\n    for (let i = 0; i < 6; i += 2) {\n      int1 = hex_alphabets.indexOf(hex.charAt(i))\n      int2 = hex_alphabets.indexOf(hex.charAt(i + 1))\n      value[k] = int1 * 16 + int2\n      k++\n    }\n    return value\n  }\n\n  // Give a array with three values as the argument and the function will return\n  // the corresponding hex triplet.\n  num2hex(triplet: number[]): string {\n    const hex_alphabets = \"0123456789ABCDEF\"\n    let hex = \"#\"\n    let int1, int2\n    for (let i = 0; i < 3; i++) {\n      int1 = triplet[i] / 16\n      int2 = triplet[i] % 16\n\n      hex += hex_alphabets.charAt(int1) + hex_alphabets.charAt(int2)\n    }\n    return hex\n  }\n\n  closeAllContextMenus(ref_window: Window = window): void {\n    const elements = [...ref_window.document.querySelectorAll(\".litecontextmenu\")]\n    if (!elements.length) return\n\n    for (const element of elements) {\n      if (\"close\" in element && typeof element.close === \"function\") {\n        element.close()\n      } else {\n        element.remove()\n      }\n    }\n  }\n\n  extendClass(target: any, origin: any): void {\n    for (const i in origin) {\n      // copy class properties\n      if (target.hasOwnProperty(i)) continue\n      target[i] = origin[i]\n    }\n\n    if (origin.prototype) {\n      // copy prototype properties\n      for (const i in origin.prototype) {\n        // only enumerable\n        if (!origin.prototype.hasOwnProperty(i)) continue\n\n        // avoid overwriting existing ones\n        if (target.prototype.hasOwnProperty(i)) continue\n\n        // copy getters\n        if (origin.prototype.__lookupGetter__(i)) {\n          target.prototype.__defineGetter__(\n            i,\n            origin.prototype.__lookupGetter__(i),\n          )\n        } else {\n          target.prototype[i] = origin.prototype[i]\n        }\n\n        // and setters\n        if (origin.prototype.__lookupSetter__(i)) {\n          target.prototype.__defineSetter__(\n            i,\n            origin.prototype.__lookupSetter__(i),\n          )\n        }\n      }\n    }\n  }\n}\n","// @ts-expect-error Polyfill\nSymbol.dispose ??= Symbol(\"Symbol.dispose\")\n// @ts-expect-error Polyfill\nSymbol.asyncDispose ??= Symbol(\"Symbol.asyncDispose\")\n\n// API *************************************************\n// like rect but rounded corners\nexport function loadPolyfills() {\n  if (\n    typeof window != \"undefined\" &&\n    window.CanvasRenderingContext2D &&\n    !window.CanvasRenderingContext2D.prototype.roundRect\n  ) {\n    // @ts-expect-error Slightly broken polyfill - radius_low not impl. anywhere\n    window.CanvasRenderingContext2D.prototype.roundRect = function (\n      x: number,\n      y: number,\n      w: number,\n      h: number,\n      radius: number | number[],\n      radius_low: number | number[],\n    ) {\n      let top_left_radius = 0\n      let top_right_radius = 0\n      let bottom_left_radius = 0\n      let bottom_right_radius = 0\n\n      if (radius === 0) {\n        this.rect(x, y, w, h)\n        return\n      }\n\n      if (radius_low === undefined) radius_low = radius\n\n      // make it compatible with official one\n      if (Array.isArray(radius)) {\n        if (radius.length == 1) {\n          top_left_radius = top_right_radius = bottom_left_radius = bottom_right_radius = radius[0]\n        } else if (radius.length == 2) {\n          top_left_radius = bottom_right_radius = radius[0]\n          top_right_radius = bottom_left_radius = radius[1]\n        } else if (radius.length == 4) {\n          top_left_radius = radius[0]\n          top_right_radius = radius[1]\n          bottom_left_radius = radius[2]\n          bottom_right_radius = radius[3]\n        } else {\n          return\n        }\n      } else {\n        // old using numbers\n        top_left_radius = radius || 0\n        top_right_radius = radius || 0\n\n        const low = !Array.isArray(radius_low) && radius_low ? radius_low : 0\n        bottom_left_radius = low\n        bottom_right_radius = low\n      }\n\n      // top right\n      this.moveTo(x + top_left_radius, y)\n      this.lineTo(x + w - top_right_radius, y)\n      this.quadraticCurveTo(x + w, y, x + w, y + top_right_radius)\n\n      // bottom right\n      this.lineTo(x + w, y + h - bottom_right_radius)\n      this.quadraticCurveTo(\n        x + w,\n        y + h,\n        x + w - bottom_right_radius,\n        y + h,\n      )\n\n      // bottom left\n      this.lineTo(x + bottom_right_radius, y + h)\n      this.quadraticCurveTo(x, y + h, x, y + h - bottom_left_radius)\n\n      // top left\n      this.lineTo(x, y + bottom_left_radius)\n      this.quadraticCurveTo(x, y, x + top_left_radius, y)\n    }\n  }\n\n  if (typeof window != \"undefined\" && !window[\"requestAnimationFrame\"]) {\n    window.requestAnimationFrame =\n      // @ts-expect-error Legacy code\n      window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame ||\n      function (callback) {\n        window.setTimeout(callback, 1000 / 60)\n      }\n  }\n}\n","import type { ContextMenu } from \"./ContextMenu\"\nimport type { ConnectingLink, Point } from \"./interfaces\"\nimport type {\n  IContextMenuOptions,\n  INodeSlot,\n  Size,\n} from \"./interfaces\"\nimport type { LGraphNode } from \"./LGraphNode\"\nimport type { CanvasEventDetail } from \"./types/events\"\nimport type { RenderShape, TitleMode } from \"./types/globalEnums\"\n\n// Must remain above LiteGraphGlobal (circular dependency due to abstract factory behaviour in `configure`)\nexport { Subgraph } from \"./subgraph/Subgraph\"\n\nimport { LiteGraphGlobal } from \"./LiteGraphGlobal\"\nimport { loadPolyfills } from \"./polyfills\"\n\nexport const LiteGraph = new LiteGraphGlobal()\n\n// Load legacy polyfills\nloadPolyfills()\n\n// Backwards compat\n\n// Type definitions for litegraph.js 0.7.0\n// Project: litegraph.js\n// Definitions by: NateScarlet <https://github.com/NateScarlet>\n/** @deprecated Use {@link Point} instead. */\nexport type Vector2 = Point\n/** @deprecated Use {@link Rect} instead. */\nexport type Vector4 = [number, number, number, number]\n\nexport interface IContextMenuItem {\n  content: string\n  callback?: ContextMenuEventListener\n  /** Used as innerHTML for extra child element */\n  title?: string\n  disabled?: boolean\n  has_submenu?: boolean\n  submenu?: {\n    options: IContextMenuItem[]\n  } & IContextMenuOptions\n  className?: string\n}\n\nexport type ContextMenuEventListener = (\n  value: IContextMenuItem,\n  options: IContextMenuOptions,\n  event: MouseEvent,\n  parentMenu: ContextMenu<unknown> | undefined,\n  node: LGraphNode,\n) => boolean | void\n\nexport interface LinkReleaseContext {\n  node_to?: LGraphNode\n  node_from?: LGraphNode\n  slot_from: INodeSlot\n  type_filter_in?: string\n  type_filter_out?: string\n}\n\nexport interface LinkReleaseContextExtended {\n  links: ConnectingLink[]\n}\n\nexport interface LiteGraphCanvasEvent extends CustomEvent<CanvasEventDetail> {}\n\nexport interface LGraphNodeConstructor<T extends LGraphNode = LGraphNode> {\n  new (title: string, type?: string): T\n\n  title: string\n  type: string\n  size?: Size\n  min_height?: number\n  slot_start_y?: number\n  widgets_info?: any\n  collapsable?: boolean\n  color?: string\n  bgcolor?: string\n  shape?: RenderShape\n  title_mode?: TitleMode\n  title_color?: string\n  title_text_color?: string\n  keepAllLinksOnBypass: boolean\n}\n\n// End backwards compat\n\nexport { InputIndicators } from \"./canvas/InputIndicators\"\nexport { isOverNodeInput, isOverNodeOutput } from \"./canvas/measureSlots\"\nexport { CanvasPointer } from \"./CanvasPointer\"\nexport { ContextMenu } from \"./ContextMenu\"\nexport { CurveEditor } from \"./CurveEditor\"\nexport { DragAndScale } from \"./DragAndScale\"\nexport { LabelPosition, SlotDirection, SlotShape, SlotType } from \"./draw\"\nexport { strokeShape } from \"./draw\"\nexport { Rectangle } from \"./infrastructure/Rectangle\"\nexport type {\n  CanvasColour,\n  ColorOption,\n  ConnectingLink,\n  Direction,\n  IBoundaryNodes,\n  IColorable,\n  IContextMenuOptions,\n  IContextMenuValue,\n  IFoundSlot,\n  IInputOrOutput,\n  INodeFlags,\n  INodeInputSlot,\n  INodeOutputSlot,\n  INodeSlot,\n  ISlotType,\n  KeysOfType,\n  LinkNetwork,\n  LinkSegment,\n  MethodNames,\n  PickByType,\n  Point,\n  Positionable,\n  ReadonlyLinkNetwork,\n  ReadOnlyPoint,\n  ReadOnlyRect,\n  Rect,\n  Size,\n} from \"./interfaces\"\nexport { LGraph } from \"./LGraph\"\nexport { BadgePosition, LGraphBadge, type LGraphBadgeOptions } from \"./LGraphBadge\"\nexport { LGraphCanvas, type LGraphCanvasState } from \"./LGraphCanvas\"\nexport { LGraphGroup } from \"./LGraphGroup\"\nexport { LGraphNode, type NodeId } from \"./LGraphNode\"\nexport { type LinkId, LLink } from \"./LLink\"\nexport { clamp, createBounds } from \"./measure\"\nexport { Reroute, type RerouteId } from \"./Reroute\"\nexport type { CanvasPointerEvent } from \"./types/events\"\nexport {\n  CanvasItem,\n  EaseFunction,\n  LGraphEventMode,\n  LinkMarkerShape,\n  RenderShape,\n  TitleMode,\n} from \"./types/globalEnums\"\nexport type {\n  ExportedSubgraph,\n  ExportedSubgraphInstance,\n  ExportedSubgraphIONode,\n  ISerialisedGraph,\n  SerialisableGraph,\n  SerialisableLLink,\n  SubgraphIO,\n} from \"./types/serialisation\"\nexport type { IWidget } from \"./types/widgets\"\nexport { isColorable } from \"./utils/type\"\nexport { createUuidv4 } from \"./utils/uuid\"\nexport { BaseSteppedWidget } from \"./widgets/BaseSteppedWidget\"\nexport { BaseWidget } from \"./widgets/BaseWidget\"\nexport { BooleanWidget } from \"./widgets/BooleanWidget\"\nexport { ButtonWidget } from \"./widgets/ButtonWidget\"\nexport { ComboWidget } from \"./widgets/ComboWidget\"\nexport { KnobWidget } from \"./widgets/KnobWidget\"\nexport { LegacyWidget } from \"./widgets/LegacyWidget\"\nexport { NumberWidget } from \"./widgets/NumberWidget\"\nexport { SliderWidget } from \"./widgets/SliderWidget\"\nexport { TextWidget } from \"./widgets/TextWidget\"\nexport { isComboWidget } from \"./widgets/widgetMap\"\n"],"names":["NodeSlotType","RenderShape","CanvasItem","LinkDirection","LinkRenderType","LinkMarkerShape","TitleMode","LGraphEventMode","EaseFunction","node","reroute","e","x","width","SlotType","SlotShape","SlotDirection","LabelPosition","height","BadgePosition","canvas","v","delta","gradient","newValue","minWidth","widgetWidth","link","graph","network","value","prev_menu","entries","document","window","pointer","pos","options","str_value","name","data","y","type"],"mappings":"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"}