import { DragAndScale } from './DragAndScale';
import { IDrawBoundingOptions } from './draw';
import { ColorOption, DefaultConnectionColors, Dictionary, IColorable, IContextMenuValue, IFoundSlot, INodeFlags, INodeInputSlot, INodeOutputSlot, INodeSlotContextItem, IPinnable, ISlotType, Point, Positionable, ReadOnlyRect, Rect, Size } from './interfaces';
import { LGraph } from './LGraph';
import { Reroute, RerouteId } from './Reroute';
import { CanvasMouseEvent } from './types/events';
import { ISerialisedNode } from './types/serialisation';
import { IBaseWidget, IWidgetOptions, TWidgetType, TWidgetValue } from './types/widgets';
import { BadgePosition, LGraphBadge } from './LGraphBadge';
import { LGraphCanvas } from './LGraphCanvas';
import { LGraphNodeConstructor } from './litegraph';
import { LLink } from './LLink';
import { LGraphEventMode, RenderShape, TitleMode } from './types/globalEnums';
import { WidgetTypeMap } from './widgets/widgetMap';
export type NodeId = number | string;
export type NodeProperty = string | number | boolean | object;
export interface INodePropertyInfo {
    name: string;
    type?: string;
    default_value: NodeProperty | undefined;
}
export interface IMouseOverData {
    inputId?: number;
    outputId?: number;
    overWidget?: IBaseWidget;
}
export interface ConnectByTypeOptions {
    /** @deprecated Events */
    createEventInCase?: boolean;
    /** Allow our wildcard slot to connect to typed slots on remote node. Default: true */
    wildcardToTyped?: boolean;
    /** Allow our typed slot to connect to wildcard slots on remote node. Default: true */
    typedToWildcard?: boolean;
    /** The {@link Reroute.id} that the connection is being dragged from. */
    afterRerouteId?: RerouteId;
}
/** Internal type used for type safety when implementing generic checks for inputs & outputs */
export interface IGenericLinkOrLinks {
    links?: INodeOutputSlot["links"];
    link?: INodeInputSlot["link"];
}
export interface FindFreeSlotOptions {
    /** Slots matching these types will be ignored.  Default: [] */
    typesNotAccepted?: ISlotType[];
    /** If true, the slot itself is returned instead of the index.  Default: false */
    returnObj?: boolean;
}
interface DrawSlotsOptions {
    fromSlot?: INodeInputSlot | INodeOutputSlot;
    colorContext: DefaultConnectionColors;
    editorAlpha: number;
    lowQuality: boolean;
}
interface DrawWidgetsOptions {
    lowQuality?: boolean;
    editorAlpha?: number;
}
interface DrawTitleOptions {
    scale: number;
    title_height?: number;
    low_quality?: boolean;
}
interface DrawTitleTextOptions extends DrawTitleOptions {
    default_title_color: string;
}
interface DrawTitleBoxOptions extends DrawTitleOptions {
    box_size?: number;
}
export interface LGraphNode {
    constructor: LGraphNodeConstructor;
}
/**
 * Base class for all nodes
 * @param title a name for the node
 * @param type a type for the node
 */
export declare class LGraphNode implements Positionable, IPinnable, IColorable {
    #private;
    static title?: string;
    static MAX_CONSOLE?: number;
    static type?: string;
    static category?: string;
    static filter?: string;
    static skip_list?: boolean;
    /** Default setting for {@link LGraphNode.connectInputToOutput}. @see {@link INodeFlags.keepAllLinksOnBypass} */
    static keepAllLinksOnBypass: boolean;
    /** The title text of the node. */
    title: string;
    /**
     * The font style used to render the node's title text.
     */
    get titleFontStyle(): string;
    get innerFontStyle(): string;
    graph: LGraph | null;
    id: NodeId;
    type: string;
    inputs: INodeInputSlot[];
    outputs: INodeOutputSlot[];
    properties: Dictionary<NodeProperty | undefined>;
    properties_info: INodePropertyInfo[];
    flags: INodeFlags;
    widgets?: IBaseWidget[];
    /**
     * The amount of space available for widgets to grow into.
     * @see {@link layoutWidgets}
     */
    freeWidgetSpace?: number;
    locked?: boolean;
    /** Execution order, automatically computed during run @see {@link LGraph.computeExecutionOrder} */
    order: number;
    mode: LGraphEventMode;
    last_serialization?: ISerialisedNode;
    serialize_widgets?: boolean;
    /**
     * The overridden fg color used to render the node.
     * @see {@link renderingColor}
     */
    color?: string;
    /**
     * The overridden bg color used to render the node.
     * @see {@link renderingBgColor}
     */
    bgcolor?: string;
    /**
     * The overridden box color used to render the node.
     * @see {@link renderingBoxColor}
     */
    boxcolor?: string;
    /** The fg color used to render the node. */
    get renderingColor(): string;
    /** The bg color used to render the node. */
    get renderingBgColor(): string;
    /** The box color used to render the node. */
    get renderingBoxColor(): string;
    /** @inheritdoc {@link IColorable.setColorOption} */
    setColorOption(colorOption: ColorOption | null): void;
    /** @inheritdoc {@link IColorable.getColorOption} */
    getColorOption(): ColorOption | null;
    /**
     * The stroke styles that should be applied to the node.
     */
    strokeStyles: Record<string, (this: LGraphNode) => IDrawBoundingOptions | undefined>;
    /**
     * The progress of node execution. Used to render a progress bar. Value between 0 and 1.
     */
    progress?: number;
    exec_version?: number;
    action_call?: string;
    execute_triggered?: number;
    action_triggered?: number;
    widgets_up?: boolean;
    widgets_start_y?: number;
    lostFocusAt?: number;
    gotFocusAt?: number;
    badges: (LGraphBadge | (() => LGraphBadge))[];
    badgePosition: BadgePosition;
    onOutputRemoved?(this: LGraphNode, slot: number): void;
    onInputRemoved?(this: LGraphNode, slot: number, input: INodeInputSlot): void;
    /**
     * The width of the node when collapsed.
     * Updated by {@link LGraphCanvas.drawNode}
     */
    _collapsed_width?: number;
    /** Called once at the start of every frame.  Caller may change the values in {@link out}, which will be reflected in {@link boundingRect}. */
    onBounding?(this: LGraphNode, out: Rect): void;
    console?: string[];
    _level?: number;
    _shape?: RenderShape;
    mouseOver?: IMouseOverData;
    redraw_on_mouse?: boolean;
    resizable?: boolean;
    clonable?: boolean;
    _relative_id?: number;
    clip_area?: boolean;
    ignore_remove?: boolean;
    has_errors?: boolean;
    removable?: boolean;
    block_delete?: boolean;
    selected?: boolean;
    showAdvanced?: boolean;
    /**
     * Rect describing the node area, including shadows and any protrusions.
     * Determines if the node is visible.  Calculated once at the start of every frame.
     */
    get renderArea(): ReadOnlyRect;
    /**
     * Cached node position & area as `x, y, width, height`.  Includes changes made by {@link onBounding}, if present.
     *
     * Determines the node hitbox and other rendering effects.  Calculated once at the start of every frame.
     */
    get boundingRect(): ReadOnlyRect;
    /** {@link pos} and {@link size} values are backed by this {@link Rect}. */
    _posSize: Float32Array;
    _pos: Point;
    _size: Size;
    get pos(): Point;
    /** Node position does not necessarily correlate to the top-left corner. */
    set pos(value: Point);
    get size(): Size;
    set size(value: Size);
    /**
     * The size of the node used for rendering.
     */
    get renderingSize(): Size;
    get shape(): RenderShape | undefined;
    set shape(v: RenderShape | "default" | "box" | "round" | "circle" | "card");
    /**
     * The shape of the node used for rendering. @see {@link RenderShape}
     */
    get renderingShape(): RenderShape;
    get is_selected(): boolean | undefined;
    set is_selected(value: boolean);
    get title_mode(): TitleMode;
    onConnectInput?(this: LGraphNode, target_slot: number, type: unknown, output: INodeOutputSlot, node: LGraphNode, slot: number): boolean;
    onConnectOutput?(this: LGraphNode, slot: number, type: unknown, input: INodeInputSlot, target_node: number | LGraphNode, target_slot: number): boolean;
    onResize?(this: LGraphNode, size: Size): void;
    onPropertyChanged?(this: LGraphNode, name: string, value: unknown, prev_value?: unknown): boolean;
    /** Called for each connection that is created, updated, or removed. This includes "restored" connections when deserialising. */
    onConnectionsChange?(this: LGraphNode, type: ISlotType, index: number, isConnected: boolean, link_info: LLink | null | undefined, inputOrOutput: INodeInputSlot | INodeOutputSlot): void;
    onInputAdded?(this: LGraphNode, input: INodeInputSlot): void;
    onOutputAdded?(this: LGraphNode, output: INodeOutputSlot): void;
    onConfigure?(this: LGraphNode, serialisedNode: ISerialisedNode): void;
    onSerialize?(this: LGraphNode, serialised: ISerialisedNode): any;
    onExecute?(this: LGraphNode, param?: unknown, options?: {
        action_call?: any;
    }): void;
    onAction?(this: LGraphNode, action: string, param: unknown, options: {
        action_call?: string;
    }): void;
    onDrawBackground?(this: LGraphNode, ctx: CanvasRenderingContext2D): void;
    onNodeCreated?(this: LGraphNode): void;
    /**
     * Callback invoked by {@link connect} to override the target slot index.
     * Its return value overrides the target index selection.
     * @param target_slot The current input slot index
     * @param requested_slot The originally requested slot index - could be negative, or if using (deprecated) name search, a string
     * @returns {number | null} If a number is returned, the connection will be made to that input index.
     * If an invalid index or non-number (false, null, NaN etc) is returned, the connection will be cancelled.
     */
    onBeforeConnectInput?(this: LGraphNode, target_slot: number, requested_slot?: number | string): number | false | null;
    onShowCustomPanelInfo?(this: LGraphNode, panel: any): void;
    onAddPropertyToPanel?(this: LGraphNode, pName: string, panel: any): boolean;
    onWidgetChanged?(this: LGraphNode, name: string, value: unknown, old_value: unknown, w: IBaseWidget): void;
    onDeselected?(this: LGraphNode): void;
    onKeyUp?(this: LGraphNode, e: KeyboardEvent): void;
    onKeyDown?(this: LGraphNode, e: KeyboardEvent): void;
    onSelected?(this: LGraphNode): void;
    getExtraMenuOptions?(this: LGraphNode, canvas: LGraphCanvas, options: (IContextMenuValue<unknown> | null)[]): (IContextMenuValue<unknown> | null)[];
    getMenuOptions?(this: LGraphNode, canvas: LGraphCanvas): IContextMenuValue[];
    onAdded?(this: LGraphNode, graph: LGraph): void;
    onDrawCollapsed?(this: LGraphNode, ctx: CanvasRenderingContext2D, cavnas: LGraphCanvas): boolean;
    onDrawForeground?(this: LGraphNode, ctx: CanvasRenderingContext2D, canvas: LGraphCanvas, canvasElement: HTMLCanvasElement): void;
    onMouseLeave?(this: LGraphNode, e: CanvasMouseEvent): void;
    /**
     * Override the default slot menu options.
     */
    getSlotMenuOptions?(this: LGraphNode, slot: IFoundSlot): IContextMenuValue[];
    /**
     * Add extra menu options to the slot context menu.
     */
    getExtraSlotMenuOptions?(this: LGraphNode, slot: IFoundSlot): IContextMenuValue[];
    onDropItem?(this: LGraphNode, event: Event): boolean;
    onDropData?(this: LGraphNode, data: string | ArrayBuffer, filename: any, file: any): void;
    onDropFile?(this: LGraphNode, file: any): void;
    onInputClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void;
    onInputDblClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void;
    onOutputClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void;
    onOutputDblClick?(this: LGraphNode, index: number, e: CanvasMouseEvent): void;
    onGetPropertyInfo?(this: LGraphNode, property: string): any;
    onNodeOutputAdd?(this: LGraphNode, value: unknown): void;
    onNodeInputAdd?(this: LGraphNode, value: unknown): void;
    onMenuNodeInputs?(this: LGraphNode, entries: (IContextMenuValue<INodeSlotContextItem> | null)[]): (IContextMenuValue<INodeSlotContextItem> | null)[];
    onMenuNodeOutputs?(this: LGraphNode, entries: (IContextMenuValue<INodeSlotContextItem> | null)[]): (IContextMenuValue<INodeSlotContextItem> | null)[];
    onMouseUp?(this: LGraphNode, e: CanvasMouseEvent, pos: Point): void;
    onMouseEnter?(this: LGraphNode, e: CanvasMouseEvent): void;
    /** Blocks drag if return value is truthy. @param pos Offset from {@link LGraphNode.pos}. */
    onMouseDown?(this: LGraphNode, e: CanvasMouseEvent, pos: Point, canvas: LGraphCanvas): boolean;
    /** @param pos Offset from {@link LGraphNode.pos}. */
    onDblClick?(this: LGraphNode, e: CanvasMouseEvent, pos: Point, canvas: LGraphCanvas): void;
    /** @param pos Offset from {@link LGraphNode.pos}. */
    onNodeTitleDblClick?(this: LGraphNode, e: CanvasMouseEvent, pos: Point, canvas: LGraphCanvas): void;
    onDrawTitle?(this: LGraphNode, ctx: CanvasRenderingContext2D): void;
    onDrawTitleText?(this: LGraphNode, ctx: CanvasRenderingContext2D, title_height: number, size: Size, scale: number, title_text_font: string, selected?: boolean): void;
    onDrawTitleBox?(this: LGraphNode, ctx: CanvasRenderingContext2D, title_height: number, size: Size, scale: number): void;
    onDrawTitleBar?(this: LGraphNode, ctx: CanvasRenderingContext2D, title_height: number, size: Size, scale: number, fgcolor: any): void;
    onRemoved?(this: LGraphNode): void;
    onMouseMove?(this: LGraphNode, e: MouseEvent, pos: Point, arg2: LGraphCanvas): void;
    onPropertyChange?(this: LGraphNode): void;
    updateOutputData?(this: LGraphNode, origin_slot: number): void;
    constructor(title: string, type?: string);
    /**
     * configure a node from an object containing the serialized info
     */
    configure(info: ISerialisedNode): void;
    /**
     * serialize the content
     */
    serialize(): ISerialisedNode;
    clone(): LGraphNode | null;
    /**
     * serialize and stringify
     */
    toString(): string;
    /**
     * get the title string
     */
    getTitle(): string;
    /**
     * sets the value of a property
     * @param name
     * @param value
     */
    setProperty(name: string, value: TWidgetValue): void;
    /**
     * sets the output data
     * @param slot
     * @param data
     */
    setOutputData(slot: number, data: number | string | boolean | {
        toToolTip?(): string;
    }): void;
    /**
     * sets the output data type, useful when you want to be able to overwrite the data type
     */
    setOutputDataType(slot: number, type: ISlotType): void;
    /**
     * Retrieves the input data (data traveling through the connection) from one slot
     * @param slot
     * @param force_update if set to true it will force the connected node of this slot to output data into this link
     * @returns data or if it is not connected returns undefined
     */
    getInputData(slot: number, force_update?: boolean): unknown;
    /**
     * Retrieves the input data type (in case this supports multiple input types)
     * @param slot
     * @returns datatype in string format
     */
    getInputDataType(slot: number): ISlotType | null;
    /**
     * Retrieves the input data from one slot using its name instead of slot number
     * @param slot_name
     * @param force_update if set to true it will force the connected node of this slot to output data into this link
     * @returns data or if it is not connected returns null
     */
    getInputDataByName(slot_name: string, force_update: boolean): unknown;
    /**
     * tells you if there is a connection in one input slot
     * @param slot The 0-based index of the input to check
     * @returns `true` if the input slot has a link ID (does not perform validation)
     */
    isInputConnected(slot: number): boolean;
    /**
     * tells you info about an input connection (which node, type, etc)
     * @returns object or null { link: id, name: string, type: string or 0 }
     */
    getInputInfo(slot: number): INodeInputSlot | null;
    /**
     * Returns the link info in the connection of an input slot
     * @returns object or null
     */
    getInputLink(slot: number): LLink | null;
    /**
     * returns the node connected in the input slot
     * @returns node or null
     */
    getInputNode(slot: number): LGraphNode | null;
    /**
     * returns the value of an input with this name, otherwise checks if there is a property with that name
     * @returns value
     */
    getInputOrProperty(name: string): unknown;
    /**
     * tells you the last output data that went in that slot
     * @returns object or null
     */
    getOutputData(slot: number): unknown;
    /**
     * tells you info about an output connection (which node, type, etc)
     * @returns object or null { name: string, type: string, links: [ ids of links in number ] }
     */
    getOutputInfo(slot: number): INodeOutputSlot | null;
    /**
     * tells you if there is a connection in one output slot
     */
    isOutputConnected(slot: number): boolean;
    /**
     * tells you if there is any connection in the output slots
     */
    isAnyOutputConnected(): boolean;
    /**
     * retrieves all the nodes connected to this output slot
     */
    getOutputNodes(slot: number): LGraphNode[] | null;
    addOnTriggerInput(): number;
    addOnExecutedOutput(): number;
    onAfterExecuteNode(param: unknown, options?: {
        action_call?: any;
    }): void;
    changeMode(modeTo: number): boolean;
    /**
     * Triggers the node code execution, place a boolean/counter to mark the node as being executed
     */
    doExecute(param?: unknown, options?: {
        action_call?: any;
    }): void;
    /**
     * Triggers an action, wrapped by logics to control execution flow
     * @param action name
     */
    actionDo(action: string, param: unknown, options: {
        action_call?: string;
    }): void;
    /**
     * Triggers an event in this node, this will trigger any output with the same name
     * @param action name ( "on_play", ... ) if action is equivalent to false then the event is send to all
     */
    trigger(action: string, param: unknown, options: {
        action_call?: any;
    }): void;
    /**
     * Triggers a slot event in this node: cycle output slots and launch execute/action on connected nodes
     * @param slot the index of the output slot
     * @param link_id [optional] in case you want to trigger and specific output link in a slot
     */
    triggerSlot(slot: number, param: unknown, link_id: number | null, options?: {
        action_call?: any;
    }): void;
    /**
     * clears the trigger slot animation
     * @param slot the index of the output slot
     * @param link_id [optional] in case you want to trigger and specific output link in a slot
     */
    clearTriggeredSlot(slot: number, link_id: number): void;
    /**
     * changes node size and triggers callback
     */
    setSize(size: Size): void;
    /**
     * Expands the node size to fit its content.
     */
    expandToFitContent(): void;
    /**
     * add a new property to this node
     * @param type string defining the output type ("vec3","number",...)
     * @param extra_info this can be used to have special properties of the property (like values, etc)
     */
    addProperty(name: string, default_value: NodeProperty | undefined, type?: string, extra_info?: Partial<INodePropertyInfo>): INodePropertyInfo;
    /**
     * add a new output slot to use in this node
     * @param type string defining the output type ("vec3","number",...)
     * @param extra_info this can be used to have special properties of an output (label, special color, position, etc)
     */
    addOutput<TProperties extends Partial<INodeOutputSlot>>(name: string, type: ISlotType, extra_info?: TProperties): INodeOutputSlot & TProperties;
    /**
     * remove an existing output slot
     */
    removeOutput(slot: number): void;
    /**
     * add a new input slot to use in this node
     * @param type string defining the input type ("vec3","number",...), it its a generic one use 0
     * @param extra_info this can be used to have special properties of an input (label, color, position, etc)
     */
    addInput<TProperties extends Partial<INodeInputSlot>>(name: string, type: ISlotType, extra_info?: TProperties): INodeInputSlot & TProperties;
    /**
     * remove an existing input slot
     */
    removeInput(slot: number): void;
    /**
     * computes the minimum size of a node according to its inputs and output slots
     * @returns the total size
     */
    computeSize(out?: Size): Size;
    inResizeCorner(canvasX: number, canvasY: number): boolean;
    /**
     * returns all the info available about a property of this node.
     * @param property name of the property
     * @returns the object with all the available info
     */
    getPropertyInfo(property: string): any;
    /**
     * Defines a widget inside the node, it will be rendered on top of the node, you can control lots of properties
     * @param type the widget type
     * @param name the text to show on the widget
     * @param value the default value
     * @param callback function to call when it changes (optionally, it can be the name of the property to modify)
     * @param options the object that contains special properties of this widget
     * @returns the created widget object
     */
    addWidget<Type extends TWidgetType, TValue extends WidgetTypeMap[Type]["value"]>(type: Type, name: string, value: TValue, callback: IBaseWidget["callback"] | string | null, options?: IWidgetOptions | string): WidgetTypeMap[Type] | IBaseWidget;
    addCustomWidget<TPlainWidget extends IBaseWidget>(custom_widget: TPlainWidget): TPlainWidget | WidgetTypeMap[TPlainWidget["type"]];
    move(deltaX: number, deltaY: number): void;
    /**
     * Internal method to measure the node for rendering.  Prefer {@link boundingRect} where possible.
     *
     * Populates {@link out} with the results in graph space.
     * Populates {@link _collapsed_width} with the collapsed width if the node is collapsed.
     * Adjusts for title and collapsed status, but does not call {@link onBounding}.
     * @param out `x, y, width, height` are written to this array.
     * @param ctx The canvas context to use for measuring text.
     */
    measure(out: Rect, ctx: CanvasRenderingContext2D): void;
    /**
     * returns the bounding of the object, used for rendering purposes
     * @param out {Float32Array[4]?} [optional] a place to store the output, to free garbage
     * @param includeExternal {boolean?} [optional] set to true to
     * include the shadow and connection points in the bounding calculation
     * @returns the bounding box in format of [topleft_cornerx, topleft_cornery, width, height]
     */
    getBounding(out?: Rect, includeExternal?: boolean): Rect;
    /**
     * Calculates the render area of this node, populating both {@link boundingRect} and {@link renderArea}.
     * Called automatically at the start of every frame.
     */
    updateArea(ctx: CanvasRenderingContext2D): void;
    /**
     * checks if a point is inside the shape of a node
     */
    isPointInside(x: number, y: number): boolean;
    /**
     * Checks if the provided point is inside this node's collapse button area.
     * @param x X co-ordinate to check
     * @param y Y co-ordinate to check
     * @returns true if the x,y point is in the collapse button area, otherwise false
     */
    isPointInCollapse(x: number, y: number): boolean;
    /**
     * Returns the input slot at the given position. Uses full 20 height, and approximates the label length.
     * @param pos The graph co-ordinates to check
     * @returns The input slot at the given position if found, otherwise `undefined`.
     */
    getInputOnPos(pos: Point): INodeInputSlot | undefined;
    /**
     * Returns the output slot at the given position. Uses full 20x20 box for the slot.
     * @param pos The graph co-ordinates to check
     * @returns The output slot at the given position if found, otherwise `undefined`.
     */
    getOutputOnPos(pos: Point): INodeOutputSlot | undefined;
    /**
     * Returns the input or output slot at the given position.
     *
     * Tries {@link getNodeInputOnPos} first, then {@link getNodeOutputOnPos}.
     * @param pos The graph co-ordinates to check
     * @returns The input or output slot at the given position if found, otherwise `undefined`.
     */
    getSlotOnPos(pos: Point): INodeInputSlot | INodeOutputSlot | undefined;
    /**
     * @deprecated Use {@link getSlotOnPos} instead.
     * checks if a point is inside a node slot, and returns info about which slot
     * @param x
     * @param y
     * @returns if found the object contains { input|output: slot object, slot: number, link_pos: [x,y] }
     */
    getSlotInPosition(x: number, y: number): IFoundSlot | null;
    /**
     * Gets the widget on this node at the given co-ordinates.
     * @param canvasX X co-ordinate in graph space
     * @param canvasY Y co-ordinate in graph space
     * @returns The widget found, otherwise `null`
     */
    getWidgetOnPos(canvasX: number, canvasY: number, includeDisabled?: boolean): IBaseWidget | undefined;
    /**
     * Returns the input slot with a given name (used for dynamic slots), -1 if not found
     * @param name the name of the slot to find
     * @param returnObj if the obj itself wanted
     * @returns the slot (-1 if not found)
     */
    findInputSlot<TReturn extends false>(name: string, returnObj?: TReturn): number;
    findInputSlot<TReturn extends true>(name: string, returnObj?: TReturn): INodeInputSlot;
    /**
     * returns the output slot with a given name (used for dynamic slots), -1 if not found
     * @param name the name of the slot to find
     * @param returnObj if the obj itself wanted
     * @returns the slot (-1 if not found)
     */
    findOutputSlot<TReturn extends false>(name: string, returnObj?: TReturn): number;
    findOutputSlot<TReturn extends true>(name: string, returnObj?: TReturn): INodeOutputSlot;
    /**
     * Finds the first free input slot.
     * @param optsIn
     * @returns The index of the first matching slot, the slot itself if returnObj is true, or -1 if not found.
     */
    findInputSlotFree<TReturn extends false>(optsIn?: FindFreeSlotOptions & {
        returnObj?: TReturn;
    }): number;
    findInputSlotFree<TReturn extends true>(optsIn?: FindFreeSlotOptions & {
        returnObj?: TReturn;
    }): INodeInputSlot | -1;
    /**
     * Finds the first free output slot.
     * @param optsIn
     * @returns The index of the first matching slot, the slot itself if returnObj is true, or -1 if not found.
     */
    findOutputSlotFree<TReturn extends false>(optsIn?: FindFreeSlotOptions & {
        returnObj?: TReturn;
    }): number;
    findOutputSlotFree<TReturn extends true>(optsIn?: FindFreeSlotOptions & {
        returnObj?: TReturn;
    }): INodeOutputSlot | -1;
    /**
     * findSlotByType for INPUTS
     */
    findInputSlotByType<TReturn extends false>(type: ISlotType, returnObj?: TReturn, preferFreeSlot?: boolean, doNotUseOccupied?: boolean): number;
    findInputSlotByType<TReturn extends true>(type: ISlotType, returnObj?: TReturn, preferFreeSlot?: boolean, doNotUseOccupied?: boolean): INodeInputSlot;
    /**
     * findSlotByType for OUTPUTS
     */
    findOutputSlotByType<TReturn extends false>(type: ISlotType, returnObj?: TReturn, preferFreeSlot?: boolean, doNotUseOccupied?: boolean): number;
    findOutputSlotByType<TReturn extends true>(type: ISlotType, returnObj?: TReturn, preferFreeSlot?: boolean, doNotUseOccupied?: boolean): INodeOutputSlot;
    /**
     * returns the output (or input) slot with a given type, -1 if not found
     * @param input uise inputs instead of outputs
     * @param type the type of the slot to find
     * @param returnObj if the obj itself wanted
     * @param preferFreeSlot if we want a free slot (if not found, will return the first of the type anyway)
     * @returns the slot (-1 if not found)
     */
    findSlotByType<TSlot extends true | false, TReturn extends false>(input: TSlot, type: ISlotType, returnObj?: TReturn, preferFreeSlot?: boolean, doNotUseOccupied?: boolean): number;
    findSlotByType<TSlot extends true, TReturn extends true>(input: TSlot, type: ISlotType, returnObj?: TReturn, preferFreeSlot?: boolean, doNotUseOccupied?: boolean): INodeInputSlot | -1;
    findSlotByType<TSlot extends false, TReturn extends true>(input: TSlot, type: ISlotType, returnObj?: TReturn, preferFreeSlot?: boolean, doNotUseOccupied?: boolean): INodeOutputSlot | -1;
    /**
     * Determines the slot index to connect to when attempting to connect by type.
     * @param findInputs If true, searches for an input.  Otherwise, an output.
     * @param node The node at the other end of the connection.
     * @param slotType The type of slot at the other end of the connection.
     * @param options Search restrictions to adhere to.
     * @see {connectByType}
     * @see {connectByTypeOutput}
     */
    findConnectByTypeSlot(findInputs: boolean, node: LGraphNode, slotType: ISlotType, options?: ConnectByTypeOptions): number | undefined;
    /**
     * Finds the first free output slot with any of the comma-delimited types in {@link type}.
     *
     * If no slots are free, falls back in order to:
     * - The first free wildcard slot
     * - The first occupied slot
     * - The first occupied wildcard slot
     * @param type The {@link ISlotType type} of slot to find
     * @returns The index and slot if found, otherwise `undefined`.
     */
    findOutputByType(type: ISlotType): {
        index: number;
        slot: INodeOutputSlot;
    } | undefined;
    /**
     * Finds the first free input slot with any of the comma-delimited types in {@link type}.
     *
     * If no slots are free, falls back in order to:
     * - The first free wildcard slot
     * - The first occupied slot
     * - The first occupied wildcard slot
     * @param type The {@link ISlotType type} of slot to find
     * @returns The index and slot if found, otherwise `undefined`.
     */
    findInputByType(type: ISlotType): {
        index: number;
        slot: INodeInputSlot;
    } | undefined;
    /**
     * connect this node output to the input of another node BY TYPE
     * @param slot (could be the number of the slot or the string with the name of the slot)
     * @param target_node the target node
     * @param target_slotType the input slot type of the target node
     * @returns the link_info is created, otherwise null
     */
    connectByType(slot: number | string, target_node: LGraphNode, target_slotType: ISlotType, optsIn?: ConnectByTypeOptions): LLink | null;
    /**
     * connect this node input to the output of another node BY TYPE
     * @param slot (could be the number of the slot or the string with the name of the slot)
     * @param source_node the target node
     * @param source_slotType the output slot type of the target node
     * @returns the link_info is created, otherwise null
     */
    connectByTypeOutput(slot: number | string, source_node: LGraphNode, source_slotType: ISlotType, optsIn?: ConnectByTypeOptions): LLink | null;
    canConnectTo(node: LGraphNode, toSlot: INodeInputSlot, fromSlot: INodeOutputSlot): boolean;
    /**
     * Connect an output of this node to an input of another node
     * @param slot (could be the number of the slot or the string with the name of the slot)
     * @param target_node the target node
     * @param target_slot the input slot of the target node (could be the number of the slot or the string with the name of the slot, or -1 to connect a trigger)
     * @returns the link_info is created, otherwise null
     */
    connect(slot: number | string, target_node: LGraphNode, target_slot: ISlotType, afterRerouteId?: RerouteId): LLink | null;
    /**
     * Connect two slots between two nodes
     * @param output The output slot to connect
     * @param inputNode The node that the input slot is on
     * @param input The input slot to connect
     * @param afterRerouteId The reroute ID to use for the link
     * @returns The link that was created, or null if the connection was blocked
     */
    connectSlots(output: INodeOutputSlot, inputNode: LGraphNode, input: INodeInputSlot, afterRerouteId: RerouteId | undefined): LLink | null | undefined;
    connectFloatingReroute(pos: Point, slot: INodeInputSlot | INodeOutputSlot, afterRerouteId?: RerouteId): Reroute;
    /**
     * disconnect one output to an specific node
     * @param slot (could be the number of the slot or the string with the name of the slot)
     * @param target_node the target node to which this slot is connected [Optional,
     * if not target_node is specified all nodes will be disconnected]
     * @returns if it was disconnected successfully
     */
    disconnectOutput(slot: string | number, target_node?: LGraphNode): boolean;
    /**
     * Disconnect one input
     * @param slot Input slot index, or the name of the slot
     * @param keepReroutes If `true`, reroutes will not be garbage collected.
     * @returns true if disconnected successfully or already disconnected, otherwise false
     */
    disconnectInput(slot: number | string, keepReroutes?: boolean): boolean;
    /**
     * @deprecated Use {@link getInputPos} or {@link getOutputPos} instead.
     * returns the center of a connection point in canvas coords
     * @param is_input true if if a input slot, false if it is an output
     * @param slot_number (could be the number of the slot or the string with the name of the slot)
     * @param out [optional] a place to store the output, to free garbage
     * @returns the position
     */
    getConnectionPos(is_input: boolean, slot_number: number, out?: Point): Point;
    /**
     * Gets the position of an input slot, in graph co-ordinates.
     *
     * This method is preferred over the legacy {@link getConnectionPos} method.
     * @param slot Input slot index
     * @returns Position of the input slot
     */
    getInputPos(slot: number): Point;
    /**
     * Gets the position of an input slot, in graph co-ordinates.
     * @param input The actual node input object
     * @returns Position of the centre of the input slot in graph co-ordinates.
     */
    getInputSlotPos(input: INodeInputSlot): Point;
    /**
     * Gets the position of an output slot, in graph co-ordinates.
     *
     * This method is preferred over the legacy {@link getConnectionPos} method.
     * @param slot Output slot index
     * @returns Position of the output slot
     */
    getOutputPos(slot: number): Point;
    /** @inheritdoc */
    snapToGrid(snapTo: number): boolean;
    /** @see {@link snapToGrid} */
    alignToGrid(): void;
    trace(msg: string): void;
    setDirtyCanvas(dirty_foreground: boolean, dirty_background?: boolean): void;
    loadImage(url: string): HTMLImageElement;
    /**
     * Allows to get onMouseMove and onMouseUp events even if the mouse is out of focus
     * @deprecated Use {@link LGraphCanvas.pointer} instead.
     */
    captureInput(v: boolean): void;
    get collapsed(): boolean;
    get collapsible(): boolean;
    /**
     * Toggle node collapse (makes it smaller on the canvas)
     */
    collapse(force?: boolean): void;
    /**
     * Toggles advanced mode of the node, showing advanced widgets
     */
    toggleAdvanced(): void;
    get pinned(): boolean;
    /**
     * Prevents the node being accidentally moved or resized by mouse interaction.
     * Toggles pinned state if no value is provided.
     */
    pin(v?: boolean): void;
    unpin(): void;
    localToScreen(x: number, y: number, dragAndScale: DragAndScale): Point;
    get width(): number;
    /**
     * Returns the height of the node, including the title bar.
     */
    get height(): number;
    /**
     * Returns the height of the node, excluding the title bar.
     */
    get bodyHeight(): number;
    drawBadges(ctx: CanvasRenderingContext2D, { gap }?: {
        gap?: number | undefined;
    }): void;
    /**
     * Renders the node's title bar background
     */
    drawTitleBarBackground(ctx: CanvasRenderingContext2D, { scale, title_height, low_quality, }: DrawTitleOptions): void;
    /**
     * Renders the node's title box, i.e. the dot in front of the title text that
     * when clicked toggles the node's collapsed state. The term `title box` comes
     * from the original LiteGraph implementation.
     */
    drawTitleBox(ctx: CanvasRenderingContext2D, { scale, low_quality, title_height, box_size, }: DrawTitleBoxOptions): void;
    /**
     * Renders the node's title text.
     */
    drawTitleText(ctx: CanvasRenderingContext2D, { scale, default_title_color, low_quality, title_height, }: DrawTitleTextOptions): void;
    /**
     * Attempts to gracefully bypass this node in all of its connections by reconnecting all links.
     *
     * Each input is checked against each output.  This is done on a matching index basis, i.e. input 3 -> output 3.
     * If there are any input links remaining,
     * and {@link flags}.{@link INodeFlags.keepAllLinksOnBypass keepAllLinksOnBypass} is `true`,
     * each input will check for outputs that match, and take the first one that matches
     * `true`: Try the index matching first, then every input to every output.
     * `false`: Only matches indexes, e.g. input 3 to output 3.
     *
     * If {@link flags}.{@link INodeFlags.keepAllLinksOnBypass keepAllLinksOnBypass} is `undefined`, it will fall back to
     * the static {@link keepAllLinksOnBypass}.
     * @returns `true` if any new links were established, otherwise `false`.
     * @todo Decision: Change API to return array of new links instead?
     */
    connectInputToOutput(): boolean | undefined;
    /**
     * Returns `true` if the widget is visible, otherwise `false`.
     */
    isWidgetVisible(widget: IBaseWidget): boolean;
    drawWidgets(ctx: CanvasRenderingContext2D, { lowQuality, editorAlpha, }: DrawWidgetsOptions): void;
    /**
     * When {@link LGraphNode.collapsed} is `true`, this method draws the node's collapsed slots.
     */
    drawCollapsedSlots(ctx: CanvasRenderingContext2D): void;
    get slots(): (INodeInputSlot | INodeOutputSlot)[];
    /**
     * Returns the input slot that is associated with the given widget.
     */
    getSlotFromWidget(widget: IBaseWidget | undefined): INodeInputSlot | undefined;
    /**
     * Returns the widget that is associated with the given input slot.
     */
    getWidgetFromSlot(slot: INodeInputSlot): IBaseWidget | undefined;
    /**
     * Draws the node's input and output slots.
     */
    drawSlots(ctx: CanvasRenderingContext2D, { fromSlot, colorContext, editorAlpha, lowQuality, }: DrawSlotsOptions): void;
    /**
     * @internal Sets the internal concrete slot arrays, ensuring they are instances of
     * {@link NodeInputSlot} or {@link NodeOutputSlot}.
     *
     * A temporary workaround until duck-typed inputs and outputs
     * have been removed from the ecosystem.
     */
    _setConcreteSlots(): void;
    /**
     * Arranges node elements in preparation for rendering (slots & widgets).
     */
    arrange(): void;
    /**
     * Draws a progress bar on the node.
     * @param ctx The canvas context to draw on
     */
    drawProgressBar(ctx: CanvasRenderingContext2D): void;
}
export {};
