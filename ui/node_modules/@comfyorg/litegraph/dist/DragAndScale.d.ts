import { Point, ReadOnlyRect, Rect } from './interfaces';
import { EaseFunction, Rectangle } from './litegraph';
export interface DragAndScaleState {
    /**
     * The offset from the top-left of the current canvas viewport to `[0, 0]` in graph space.
     * Or said another way, the inverse offset of the viewport.
     */
    offset: [number, number];
    /** The scale of the graph. */
    scale: number;
}
export type AnimationOptions = {
    /** Duration of the animation in milliseconds. */
    duration?: number;
    /** Relative target zoom level. 1 means the view is fit exactly on the bounding box. */
    zoom?: number;
    /** The animation easing function (curve) */
    easing?: EaseFunction;
};
export declare class DragAndScale {
    #private;
    /**
     * The state of this DragAndScale instance.
     *
     * Implemented as a POCO that can be proxied without side-effects.
     */
    state: DragAndScaleState;
    lastState: DragAndScaleState;
    /** Maximum scale (zoom in) */
    max_scale: number;
    /** Minimum scale (zoom out) */
    min_scale: number;
    enabled: boolean;
    last_mouse: Point;
    element: HTMLCanvasElement;
    visible_area: Rectangle;
    dragging?: boolean;
    viewport?: Rect;
    onredraw?(das: DragAndScale): void;
    onChanged?(scale: number, offset: Point): void;
    get offset(): [number, number];
    set offset(value: Point);
    get scale(): number;
    set scale(value: number);
    constructor(element: HTMLCanvasElement);
    computeVisibleArea(viewport: Rect | undefined): void;
    toCanvasContext(ctx: CanvasRenderingContext2D): void;
    convertOffsetToCanvas(pos: Point): Point;
    convertCanvasToOffset(pos: Point, out?: Point): Point;
    /** @deprecated Has not been kept up to date */
    mouseDrag(x: number, y: number): void;
    changeScale(value: number, zooming_center?: Point, roundToScaleOne?: boolean): void;
    changeDeltaScale(value: number, zooming_center?: Point): void;
    /**
     * Fits the view to the specified bounds.
     * @param bounds The bounds to fit the view to, defined by a rectangle.
     */
    fitToBounds(bounds: ReadOnlyRect, { zoom }?: {
        zoom?: number;
    }): void;
    /**
     * Starts an animation to fit the view around the specified selection of nodes.
     * @param bounds The bounds to animate the view to, defined by a rectangle.
     */
    animateToBounds(bounds: ReadOnlyRect, setDirty: () => void, { duration, zoom, easing, }?: AnimationOptions): void;
    reset(): void;
}
