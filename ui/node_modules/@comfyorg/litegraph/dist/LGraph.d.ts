import { DragAndScaleState } from './DragAndScale';
import { Dictionary, IContextMenuValue, LinkNetwork, LinkSegment, MethodNames, OptionalProps, Point, Positionable } from './interfaces';
import { ISerialisedGraph, Serialisable, SerialisableGraph, SerialisableReroute } from './types/serialisation';
import { UUID } from './utils/uuid';
import { LGraphCanvas } from './LGraphCanvas';
import { LGraphGroup } from './LGraphGroup';
import { LGraphNode, NodeId } from './LGraphNode';
import { LinkId, LLink } from './LLink';
import { Reroute, RerouteId } from './Reroute';
import { LGraphEventMode } from './types/globalEnums';
export interface LGraphState {
    lastGroupId: number;
    lastNodeId: number;
    lastLinkId: number;
    lastRerouteId: number;
}
type ParamsArray<T extends Record<any, any>, K extends MethodNames<T>> = Parameters<T[K]>[1] extends undefined ? Parameters<T[K]> | Parameters<T[K]>[0] : Parameters<T[K]>;
/** Configuration used by {@link LGraph} `config`. */
export interface LGraphConfig {
    /** @deprecated Legacy config - unused */
    align_to_grid?: any;
    links_ontop?: any;
}
export interface LGraphExtra extends Dictionary<unknown> {
    reroutes?: SerialisableReroute[];
    linkExtensions?: {
        id: number;
        parentId: number | undefined;
    }[];
    ds?: DragAndScaleState;
}
export interface BaseLGraph {
    readonly rootGraph: LGraph;
}
/**
 * LGraph is the class that contain a full graph. We instantiate one and add nodes to it, and then we can run the execution loop.
 * supported callbacks:
 * + onNodeAdded: when a new node is added to the graph
 * + onNodeRemoved: when a node inside this graph is removed
 */
export declare class LGraph implements LinkNetwork, BaseLGraph, Serialisable<SerialisableGraph> {
    #private;
    static serialisedSchemaVersion: 1;
    static STATUS_STOPPED: number;
    static STATUS_RUNNING: number;
    id: UUID;
    revision: number;
    _version: number;
    /** The backing store for links.  Keys are wrapped in String() */
    _links: Map<LinkId, LLink>;
    /**
     * Indexed property access is deprecated.
     * Backwards compatibility with a Proxy has been added, but will eventually be removed.
     *
     * Use {@link Map} methods:
     * ```
     * const linkId = 123
     * const link = graph.links.get(linkId)
     * // Deprecated: const link = graph.links[linkId]
     * ```
     */
    links: Map<LinkId, LLink> & Record<LinkId, LLink>;
    list_of_graphcanvas: LGraphCanvas[] | null;
    status: number;
    state: LGraphState;
    _nodes: LGraphNode[];
    _nodes_by_id: Record<NodeId, LGraphNode>;
    _nodes_in_order: LGraphNode[];
    _nodes_executable: LGraphNode[] | null;
    _groups: LGraphGroup[];
    iteration: number;
    globaltime: number;
    /** @deprecated Unused */
    runningtime: number;
    fixedtime: number;
    fixedtime_lapse: number;
    elapsed_time: number;
    last_update_time: number;
    starttime: number;
    catch_errors: boolean;
    execution_timer_id?: number | null;
    errors_in_execution?: boolean;
    /** @deprecated Unused */
    execution_time: number;
    _last_trigger_time?: number;
    filter?: string;
    /** Must contain serialisable values, e.g. primitive types */
    config: LGraphConfig;
    vars: Dictionary<unknown>;
    nodes_executing: boolean[];
    nodes_actioning: (string | boolean)[];
    nodes_executedAction: string[];
    extra: LGraphExtra;
    /** @deprecated Deserialising a workflow sets this unused property. */
    version?: number;
    /** @returns Whether the graph has no items */
    get empty(): boolean;
    /** @returns All items on the canvas that can be selected */
    positionableItems(): Generator<LGraphNode | LGraphGroup | Reroute>;
    get floatingLinks(): ReadonlyMap<LinkId, LLink>;
    /** All reroutes in this graph. */
    get reroutes(): Map<RerouteId, Reroute>;
    get rootGraph(): LGraph;
    get isRootGraph(): boolean;
    /** @deprecated See {@link state}.{@link LGraphState.lastNodeId lastNodeId} */
    get last_node_id(): number;
    set last_node_id(value: number);
    /** @deprecated See {@link state}.{@link LGraphState.lastLinkId lastLinkId} */
    get last_link_id(): number;
    set last_link_id(value: number);
    onAfterStep?(): void;
    onBeforeStep?(): void;
    onPlayEvent?(): void;
    onStopEvent?(): void;
    onAfterExecute?(): void;
    onExecuteStep?(): void;
    onNodeAdded?(node: LGraphNode): void;
    onNodeRemoved?(node: LGraphNode): void;
    onTrigger?(action: string, param: unknown): void;
    onBeforeChange?(graph: LGraph, info?: LGraphNode): void;
    onAfterChange?(graph: LGraph, info?: LGraphNode | null): void;
    onConnectionChange?(node: LGraphNode): void;
    on_change?(graph: LGraph): void;
    onSerialize?(data: ISerialisedGraph | SerialisableGraph): void;
    onConfigure?(data: ISerialisedGraph | SerialisableGraph): void;
    onGetNodeMenuOptions?(options: (IContextMenuValue<unknown> | null)[], node: LGraphNode): void;
    private _input_nodes?;
    /**
     * See {@link LGraph}
     * @param o data from previous serialization [optional]
     */
    constructor(o?: ISerialisedGraph | SerialisableGraph);
    /**
     * Removes all nodes from this graph
     */
    clear(): void;
    get nodes(): LGraphNode[];
    get groups(): LGraphGroup[];
    /**
     * Attach Canvas to this graph
     */
    attachCanvas(canvas: LGraphCanvas): void;
    /**
     * Detach Canvas from this graph
     */
    detachCanvas(canvas: LGraphCanvas): void;
    /**
     * @deprecated Will be removed in 0.9
     * Starts running this graph every interval milliseconds.
     * @param interval amount of milliseconds between executions, if 0 then it renders to the monitor refresh rate
     */
    start(interval?: number): void;
    /**
     * @deprecated Will be removed in 0.9
     * Stops the execution loop of the graph
     */
    stop(): void;
    /**
     * Run N steps (cycles) of the graph
     * @param num number of steps to run, default is 1
     * @param do_not_catch_errors [optional] if you want to try/catch errors
     * @param limit max number of nodes to execute (used to execute from start to a node)
     */
    runStep(num: number, do_not_catch_errors: boolean, limit?: number): void;
    /**
     * Updates the graph execution order according to relevance of the nodes (nodes with only outputs have more relevance than
     * nodes with only inputs.
     */
    updateExecutionOrder(): void;
    computeExecutionOrder(only_onExecute: boolean, set_level?: boolean): LGraphNode[];
    /**
     * Positions every node in a more readable manner
     */
    arrange(margin?: number, layout?: string): void;
    /**
     * Returns the amount of time the graph has been running in milliseconds
     * @returns number of milliseconds the graph has been running
     */
    getTime(): number;
    /**
     * Returns the amount of time accumulated using the fixedtime_lapse var.
     * This is used in context where the time increments should be constant
     * @returns number of milliseconds the graph has been running
     */
    getFixedTime(): number;
    /**
     * Returns the amount of time it took to compute the latest iteration.
     * Take into account that this number could be not correct
     * if the nodes are using graphical actions
     * @returns number of milliseconds it took the last cycle
     */
    getElapsedTime(): number;
    /**
     * @deprecated Will be removed in 0.9
     * Sends an event to all the nodes, useful to trigger stuff
     * @param eventname the name of the event (function to be called)
     * @param params parameters in array format
     */
    sendEventToAllNodes(eventname: string, params?: object | object[], mode?: LGraphEventMode): void;
    /**
     * Runs an action on every canvas registered to this graph.
     * @param action Action to run for every canvas
     */
    canvasAction(action: (canvas: LGraphCanvas) => void): void;
    /** @deprecated See {@link LGraph.canvasAction} */
    sendActionToCanvas<T extends MethodNames<LGraphCanvas>>(action: T, params?: ParamsArray<LGraphCanvas, T>): void;
    /**
     * Adds a new node instance to this graph
     * @param node the instance of the node
     */
    add(node: LGraphNode | LGraphGroup, skip_compute_order?: boolean): LGraphNode | null | undefined;
    /**
     * Removes a node from the graph
     * @param node the instance of the node
     */
    remove(node: LGraphNode | LGraphGroup): void;
    /**
     * Returns a node by its id.
     */
    getNodeById(id: NodeId | null | undefined): LGraphNode | null;
    /**
     * Returns a list of nodes that matches a class
     * @param classObject the class itself (not an string)
     * @returns a list with all the nodes of this type
     */
    findNodesByClass(classObject: Function, result?: LGraphNode[]): LGraphNode[];
    /**
     * Returns a list of nodes that matches a type
     * @param type the name of the node type
     * @returns a list with all the nodes of this type
     */
    findNodesByType(type: string, result: LGraphNode[]): LGraphNode[];
    /**
     * Returns the first node that matches a name in its title
     * @param title the name of the node to search
     * @returns the node or null
     */
    findNodeByTitle(title: string): LGraphNode | null;
    /**
     * Returns a list of nodes that matches a name
     * @param title the name of the node to search
     * @returns a list with all the nodes with this name
     */
    findNodesByTitle(title: string): LGraphNode[];
    /**
     * Returns the top-most node in this position of the canvas
     * @param x the x coordinate in canvas space
     * @param y the y coordinate in canvas space
     * @param nodeList a list with all the nodes to search from, by default is all the nodes in the graph
     * @returns the node at this position or null
     */
    getNodeOnPos(x: number, y: number, nodeList?: LGraphNode[]): LGraphNode | null;
    /**
     * Returns the top-most group in that position
     * @param x The x coordinate in canvas space
     * @param y The y coordinate in canvas space
     * @returns The group or null
     */
    getGroupOnPos(x: number, y: number): LGraphGroup | undefined;
    /**
     * Returns the top-most group with a titlebar in the provided position.
     * @param x The x coordinate in canvas space
     * @param y The y coordinate in canvas space
     * @returns The group or null
     */
    getGroupTitlebarOnPos(x: number, y: number): LGraphGroup | undefined;
    /**
     * Finds a reroute a the given graph point
     * @param x X co-ordinate in graph space
     * @param y Y co-ordinate in graph space
     * @returns The first reroute under the given co-ordinates, or undefined
     */
    getRerouteOnPos(x: number, y: number, reroutes?: Iterable<Reroute>): Reroute | undefined;
    /**
     * Snaps the provided items to a grid.
     *
     * Item positions are reounded to the nearest multiple of {@link LiteGraph.CANVAS_GRID_SIZE}.
     *
     * When {@link LiteGraph.alwaysSnapToGrid} is enabled
     * and the grid size is falsy, a default of 1 is used.
     * @param items The items to be snapped to the grid
     * @todo Currently only snaps nodes.
     */
    snapToGrid(items: Set<Positionable>): void;
    /**
     * Finds the size of the grid that items should be snapped to when moved.
     * @returns The size of the grid that items should be snapped to
     */
    getSnapToGridSize(): number;
    /**
     * @deprecated Will be removed in 0.9
     * Checks that the node type matches the node type registered,
     * used when replacing a nodetype by a newer version during execution
     * this replaces the ones using the old version with the new version
     */
    checkNodeTypes(): void;
    trigger(action: string, param: unknown): void;
    /** @todo Clean up - never implemented. */
    triggerInput(name: string, value: any): void;
    /** @todo Clean up - never implemented. */
    setCallback(name: string, func: any): void;
    beforeChange(info?: LGraphNode): void;
    afterChange(info?: LGraphNode | null): void;
    connectionChange(node: LGraphNode): void;
    /**
     * clears the triggered slot animation in all links (stop visual animation)
     */
    clearTriggeredSlots(): void;
    change(): void;
    setDirtyCanvas(fg: boolean, bg?: boolean): void;
    addFloatingLink(link: LLink): LLink;
    removeFloatingLink(link: LLink): void;
    /**
     * Finds the link with the provided ID.
     * @param id ID of link to find
     * @returns The link with the provided {@link id}, otherwise `undefined`. Always returns `undefined` if `id` is nullish.
     */
    getLink(id: null | undefined): undefined;
    getLink(id: LinkId | null | undefined): LLink | undefined;
    /**
     * Finds the reroute with the provided ID.
     * @param id ID of reroute to find
     * @returns The reroute with the provided {@link id}, otherwise `undefined`. Always returns `undefined` if `id` is nullish.
     */
    getReroute(id: null | undefined): undefined;
    getReroute(id: RerouteId | null | undefined): Reroute | undefined;
    /**
     * Configures a reroute on the graph where ID is already known (probably deserialisation).
     * Creates the object if it does not exist.
     * @param serialisedReroute See {@link SerialisableReroute}
     */
    setReroute({ id, parentId, pos, linkIds, floating }: OptionalProps<SerialisableReroute, "id">): Reroute;
    /**
     * Creates a new reroute and adds it to the graph.
     * @param pos Position in graph space
     * @param before The existing link segment (reroute, link) that will be after this reroute,
     * going from the node output to input.
     * @returns The newly created reroute - typically ignored.
     */
    createReroute(pos: Point, before: LinkSegment): Reroute;
    /**
     * Removes a reroute from the graph
     * @param id ID of reroute to remove
     */
    removeReroute(id: RerouteId): void;
    /**
     * Destroys a link
     */
    removeLink(link_id: LinkId): void;
    /**
     * Creates a Object containing all the info about this graph, it can be serialized
     * @deprecated Use {@link asSerialisable}, which returns the newer schema version.
     * @returns value of the node
     */
    serialize(option?: {
        sortNodes: boolean;
    }): ISerialisedGraph;
    /**
     * Prepares a shallow copy of this object for immediate serialisation or structuredCloning.
     * The return value should be discarded immediately.
     * @param options Serialise options = currently `sortNodes: boolean`, whether to sort nodes by ID.
     * @returns A shallow copy of parts of this graph, with shallow copies of its serialisable objects.
     * Mutating the properties of the return object may result in changes to your graph.
     * It is intended for use with {@link structuredClone} or {@link JSON.stringify}.
     */
    asSerialisable(options?: {
        sortNodes: boolean;
    }): SerialisableGraph & Required<Pick<SerialisableGraph, "nodes" | "groups" | "extra">>;
    /**
     * Configure a graph from a JSON string
     * @param data The deserialised object to configure this graph from
     * @param keep_old If `true`, the graph will not be cleared prior to
     * adding the configuration.
     */
    configure(data: ISerialisedGraph | SerialisableGraph, keep_old?: boolean): boolean | undefined;
    load(url: string | Blob | URL | File, callback: () => void): void;
}
export {};
