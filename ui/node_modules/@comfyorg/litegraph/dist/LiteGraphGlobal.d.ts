import { Dictionary, ISlotType, Rect, WhenNullish } from './interfaces';
import { InputIndicators } from './canvas/InputIndicators';
import { ContextMenu } from './ContextMenu';
import { CurveEditor } from './CurveEditor';
import { DragAndScale } from './DragAndScale';
import { LabelPosition, SlotDirection, SlotShape, SlotType } from './draw';
import { LGraph } from './LGraph';
import { LGraphCanvas } from './LGraphCanvas';
import { LGraphGroup } from './LGraphGroup';
import { LGraphNode } from './LGraphNode';
import { LLink } from './LLink';
import { distance, isInsideRectangle, overlapBounding } from './measure';
import { Reroute } from './Reroute';
import { LGraphEventMode, LinkDirection, LinkRenderType, NodeSlotType, RenderShape, TitleMode } from './types/globalEnums';
import { createUuidv4 } from './utils/uuid';
/**
 * The Global Scope. It contains all the registered node classes.
 */
export declare class LiteGraphGlobal {
    SlotShape: typeof SlotShape;
    SlotDirection: typeof SlotDirection;
    SlotType: typeof SlotType;
    LabelPosition: typeof LabelPosition;
    /** Used in serialised graphs at one point. */
    VERSION: 0.4;
    CANVAS_GRID_SIZE: number;
    NODE_TITLE_HEIGHT: number;
    NODE_TITLE_TEXT_Y: number;
    NODE_SLOT_HEIGHT: number;
    NODE_WIDGET_HEIGHT: number;
    NODE_WIDTH: number;
    NODE_MIN_WIDTH: number;
    NODE_COLLAPSED_RADIUS: number;
    NODE_COLLAPSED_WIDTH: number;
    NODE_TITLE_COLOR: string;
    NODE_SELECTED_TITLE_COLOR: string;
    NODE_TEXT_SIZE: number;
    NODE_TEXT_COLOR: string;
    NODE_TEXT_HIGHLIGHT_COLOR: string;
    NODE_SUBTEXT_SIZE: number;
    NODE_DEFAULT_COLOR: string;
    NODE_DEFAULT_BGCOLOR: string;
    NODE_DEFAULT_BOXCOLOR: string;
    NODE_DEFAULT_SHAPE: RenderShape;
    NODE_BOX_OUTLINE_COLOR: string;
    NODE_ERROR_COLOUR: string;
    NODE_FONT: string;
    DEFAULT_FONT: string;
    DEFAULT_SHADOW_COLOR: string;
    DEFAULT_GROUP_FONT: number;
    DEFAULT_GROUP_FONT_SIZE?: any;
    GROUP_FONT: string;
    WIDGET_BGCOLOR: string;
    WIDGET_OUTLINE_COLOR: string;
    WIDGET_ADVANCED_OUTLINE_COLOR: string;
    WIDGET_TEXT_COLOR: string;
    WIDGET_SECONDARY_TEXT_COLOR: string;
    WIDGET_DISABLED_TEXT_COLOR: string;
    LINK_COLOR: string;
    EVENT_LINK_COLOR: string;
    CONNECTING_LINK_COLOR: string;
    /** avoid infinite loops */
    MAX_NUMBER_OF_NODES: number;
    /** default node position */
    DEFAULT_POSITION: number[];
    /** ,"circle" */
    VALID_SHAPES: ("default" | "box" | "round" | "card")[];
    ROUND_RADIUS: number;
    BOX_SHAPE: RenderShape;
    ROUND_SHAPE: RenderShape;
    CIRCLE_SHAPE: RenderShape;
    CARD_SHAPE: RenderShape;
    ARROW_SHAPE: RenderShape;
    /** intended for slot arrays */
    GRID_SHAPE: RenderShape;
    INPUT: NodeSlotType;
    OUTPUT: NodeSlotType;
    /** for outputs */
    EVENT: -1;
    /** for inputs */
    ACTION: -1;
    /** helper, will add "On Request" and more in the future */
    NODE_MODES: string[];
    /** use with node_box_coloured_by_mode */
    NODE_MODES_COLORS: string[];
    ALWAYS: LGraphEventMode;
    ON_EVENT: LGraphEventMode;
    NEVER: LGraphEventMode;
    ON_TRIGGER: LGraphEventMode;
    UP: LinkDirection;
    DOWN: LinkDirection;
    LEFT: LinkDirection;
    RIGHT: LinkDirection;
    CENTER: LinkDirection;
    /** helper */
    LINK_RENDER_MODES: string[];
    HIDDEN_LINK: LinkRenderType;
    STRAIGHT_LINK: LinkRenderType;
    LINEAR_LINK: LinkRenderType;
    SPLINE_LINK: LinkRenderType;
    NORMAL_TITLE: TitleMode;
    NO_TITLE: TitleMode;
    TRANSPARENT_TITLE: TitleMode;
    AUTOHIDE_TITLE: TitleMode;
    /** arrange nodes vertically */
    VERTICAL_LAYOUT: string;
    /** used to redirect calls */
    proxy: null;
    node_images_path: string;
    debug: boolean;
    catch_exceptions: boolean;
    throw_errors: boolean;
    /** if set to true some nodes like Formula would be allowed to evaluate code that comes from unsafe sources (like node configuration), which could lead to exploits */
    allow_scripts: boolean;
    /** nodetypes by string */
    registered_node_types: Record<string, typeof LGraphNode>;
    /** @deprecated used for dropping files in the canvas.  It appears the code that enables this was removed, but the object remains and is references by built-in drag drop. */
    node_types_by_file_extension: Record<string, {
        type: string;
    }>;
    /** node types by classname */
    Nodes: Record<string, typeof LGraphNode>;
    /** used to store vars between graphs */
    Globals: {};
    /** @deprecated Unused and will be deleted. */
    searchbox_extras: Dictionary<unknown>;
    /** [true!] this make the nodes box (top left circle) coloured when triggered (execute/action), visual feedback */
    node_box_coloured_when_on: boolean;
    /** [true!] nodebox based on node mode, visual feedback */
    node_box_coloured_by_mode: boolean;
    /** [false on mobile] better true if not touch device, TODO add an helper/listener to close if false */
    dialog_close_on_mouse_leave: boolean;
    dialog_close_on_mouse_leave_delay: number;
    /** [false!] prefer false if results too easy to break links - implement with ALT or TODO custom keys */
    shift_click_do_break_link_from: boolean;
    /** [false!]prefer false, way too easy to break links */
    click_do_break_link_to: boolean;
    /** [true!] who accidentally ctrl-alt-clicks on an in/output? nobody! that's who! */
    ctrl_alt_click_do_break_link: boolean;
    /** [true!] snaps links when dragging connections over valid targets */
    snaps_for_comfy: boolean;
    /** [true!] renders a partial border to highlight when a dragged link is snapped to a node */
    snap_highlights_node: boolean;
    /**
     * If `true`, items always snap to the grid - modifier keys are ignored.
     * When {@link snapToGrid} is falsy, a value of `1` is used.
     * Default: `false`
     */
    alwaysSnapToGrid?: boolean;
    /**
     * When set to a positive number, when nodes are moved their positions will
     * be rounded to the nearest multiple of this value.  Half up.
     * Default: `undefined`
     * @todo Not implemented - see {@link LiteGraph.CANVAS_GRID_SIZE}
     */
    snapToGrid?: number;
    /** [false on mobile] better true if not touch device, TODO add an helper/listener to close if false */
    search_hide_on_mouse_leave: boolean;
    /**
     * [true!] enable filtering slots type in the search widget
     * !requires auto_load_slot_types or manual set registered_slot_[in/out]_types and slot_types_[in/out]
     */
    search_filter_enabled: boolean;
    /** [true!] opens the results list when opening the search widget */
    search_show_all_on_open: boolean;
    /**
     * [if want false, use true, run, get vars values to be statically set, than disable]
     * nodes types and nodeclass association with node types need to be calculated,
     * if dont want this, calculate once and set registered_slot_[in/out]_types and slot_types_[in/out]
     */
    auto_load_slot_types: boolean;
    /** slot types for nodeclass */
    registered_slot_in_types: Record<string, {
        nodes: string[];
    }>;
    /** slot types for nodeclass */
    registered_slot_out_types: Record<string, {
        nodes: string[];
    }>;
    /** slot types IN */
    slot_types_in: string[];
    /** slot types OUT */
    slot_types_out: string[];
    /**
     * specify for each IN slot type a(/many) default node(s), use single string, array, or object
     * (with node, title, parameters, ..) like for search
     */
    slot_types_default_in: Record<string, string[]>;
    /**
     * specify for each OUT slot type a(/many) default node(s), use single string, array, or object
     * (with node, title, parameters, ..) like for search
     */
    slot_types_default_out: Record<string, string[]>;
    /** [true!] very handy, ALT click to clone and drag the new node */
    alt_drag_do_clone_nodes: boolean;
    /**
     * [true!] will create and connect event slots when using action/events connections,
     * !WILL CHANGE node mode when using onTrigger (enable mode colors), onExecuted does not need this
     */
    do_add_triggers_slots: boolean;
    /** [false!] being events, it is strongly reccomended to use them sequentially, one by one */
    allow_multi_output_for_events: boolean;
    /** [true!] allows to create and connect a ndoe clicking with the third button (wheel) */
    middle_click_slot_add_default_node: boolean;
    /** [true!] dragging a link to empty space will open a menu, add from list, search or defaults */
    release_link_on_empty_shows_menu: boolean;
    /** "mouse"|"pointer" use mouse for retrocompatibility issues? (none found @ now) */
    pointerevents_method: string;
    /**
     * [true!] allows ctrl + shift + v to paste nodes with the outputs of the unselected nodes connected
     * with the inputs of the newly pasted nodes
     */
    ctrl_shift_v_paste_connect_unselected_outputs: boolean;
    use_uuids: boolean;
    highlight_selected_group: boolean;
    /** Whether to scale context with the graph when zooming in.  Zooming out never makes context menus smaller. */
    context_menu_scaling: boolean;
    /**
     * Debugging flag. Repeats deprecation warnings every time they are reported.
     * May impact performance.
     */
    alwaysRepeatWarnings: boolean;
    /**
     * Array of callbacks to execute when Litegraph first reports a deprecated API being used.
     * @see alwaysRepeatWarnings By default, will not repeat identical messages.
     */
    onDeprecationWarning: ((message: string, source?: object) => void)[];
    /**
     * If `true`, mouse wheel events will be interpreted as trackpad gestures.
     * Tested on MacBook M4 Pro.
     * @default false
     * @see macGesturesRequireMac
     */
    macTrackpadGestures: boolean;
    /**
     * If both this setting and {@link macTrackpadGestures} are `true`, trackpad gestures will
     * only be enabled when the browser user agent includes "Mac".
     * @default true
     * @see macTrackpadGestures
     */
    macGesturesRequireMac: boolean;
    /**
     * If `true`, widget labels and values will both be truncated (proportionally to size),
     * until they fit within the widget.
     *
     * Otherwise, the label will be truncated completely before the value is truncated.
     * @default false
     */
    truncateWidgetTextEvenly: boolean;
    /**
     * If `true`, widget values will be completely truncated when shrinking a widget,
     * before truncating widget labels.  {@link truncateWidgetTextEvenly} must be `false`.
     * @default false
     */
    truncateWidgetValuesFirst: boolean;
    /**
     * If `true`, the current viewport scale & offset of the first attached canvas will be included with the graph when exporting.
     * @default true
     */
    saveViewportWithGraph: boolean;
    LGraph: typeof LGraph;
    LLink: typeof LLink;
    LGraphNode: typeof LGraphNode;
    LGraphGroup: typeof LGraphGroup;
    DragAndScale: typeof DragAndScale;
    LGraphCanvas: typeof LGraphCanvas;
    ContextMenu: typeof ContextMenu;
    CurveEditor: typeof CurveEditor;
    Reroute: typeof Reroute;
    InputIndicators: typeof InputIndicators;
    onNodeTypeRegistered?(type: string, base_class: typeof LGraphNode): void;
    onNodeTypeReplaced?(type: string, base_class: typeof LGraphNode, prev: unknown): void;
    /**
     * Register a node class so it can be listed when the user wants to create a new one
     * @param type name of the node and path
     * @param base_class class containing the structure of a node
     */
    registerNodeType(type: string, base_class: typeof LGraphNode): void;
    /**
     * removes a node type from the system
     * @param type name of the node or the node constructor itself
     */
    unregisterNodeType(type: string | typeof LGraphNode): void;
    /**
     * Save a slot type and his node
     * @param type name of the node or the node constructor itself
     * @param slot_type name of the slot type (variable type), eg. string, number, array, boolean, ..
     */
    registerNodeAndSlotType(type: LGraphNode, slot_type: ISlotType, out?: boolean): void;
    /**
     * Removes all previously registered node's types
     */
    clearRegisteredTypes(): void;
    /**
     * Create a node of a given type with a name. The node is not attached to any graph yet.
     * @param type full name of the node class. p.e. "math/sin"
     * @param title a name to distinguish from other nodes
     * @param options to set options
     */
    createNode(type: string, title?: string, options?: Dictionary<unknown>): LGraphNode | null;
    /**
     * Returns a registered node type with a given name
     * @param type full name of the node class. p.e. "math/sin"
     * @returns the node class
     */
    getNodeType(type: string): typeof LGraphNode;
    /**
     * Returns a list of node types matching one category
     * @param category category name
     * @returns array with all the node classes
     */
    getNodeTypesInCategory(category: string, filter?: string): (typeof LGraphNode)[];
    /**
     * Returns a list with all the node type categories
     * @param filter only nodes with ctor.filter equal can be shown
     * @returns array with all the names of the categories
     */
    getNodeTypesCategories(filter?: string): string[];
    reloadNodes(folder_wildcard: string): void;
    /** @deprecated Prefer {@link structuredClone} */
    cloneObject<T extends object | undefined | null>(obj: T, target?: T): WhenNullish<T, null>;
    /** @see {@link createUuidv4} @inheritdoc */
    uuidv4: typeof createUuidv4;
    /**
     * Returns if the types of two slots are compatible (taking into account wildcards, etc)
     * @param type_a output
     * @param type_b input
     * @returns true if they can be connected
     */
    isValidConnection(type_a: ISlotType, type_b: ISlotType): boolean;
    getParameterNames(func: (...args: any) => any): string[];
    pointerListenerAdd(oDOM: Node, sEvIn: string, fCall: (e: Event) => boolean | void, capture?: boolean): void;
    pointerListenerRemove(oDOM: Node, sEvent: string, fCall: (e: Event) => boolean | void, capture?: boolean): void;
    getTime(): number;
    distance: typeof distance;
    colorToString(c: [number, number, number, number]): string;
    isInsideRectangle: typeof isInsideRectangle;
    growBounding(bounding: Rect, x: number, y: number): void;
    overlapBounding: typeof overlapBounding;
    isInsideBounding(p: number[], bb: number[][]): boolean;
    hex2num(hex: string): number[];
    num2hex(triplet: number[]): string;
    closeAllContextMenus(ref_window?: Window): void;
    extendClass(target: any, origin: any): void;
}
