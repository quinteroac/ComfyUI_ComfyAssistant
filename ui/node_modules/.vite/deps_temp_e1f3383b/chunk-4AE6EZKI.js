import {
  useShallow
} from "./chunk-3BGZJQKZ.js";
import {
  Anchor22 as Anchor2,
  Content22 as Content2,
  Content23 as Content22,
  Item22 as Item2,
  Portal23 as Portal2,
  Portal3 as Portal,
  Root24 as Root2,
  Root25 as Root22,
  Separator2,
  Trigger,
  Trigger2,
  composeEventHandlers,
  createDropdownMenuScope,
  createPopoverScope,
  useCallbackRef,
  useEscapeKeydown
} from "./chunk-YDLZUPUI.js";
import {
  require_react_dom
} from "./chunk-H4KYLSX2.js";
import {
  composeRefs,
  useComposedRefs
} from "./chunk-XJ36GILZ.js";
import {
  require_jsx_runtime
} from "./chunk-S66HWGJ3.js";
import {
  require_react
} from "./chunk-K7ZT2U4U.js";
import {
  __commonJS,
  __export,
  __privateAdd,
  __privateGet,
  __privateSet,
  __publicField,
  __toESM
} from "./chunk-UN725CXD.js";

// node_modules/secure-json-parse/index.js
var require_secure_json_parse = __commonJS({
  "node_modules/secure-json-parse/index.js"(exports, module) {
    "use strict";
    var hasBuffer = typeof Buffer !== "undefined";
    var suspectProtoRx = /"(?:_|\\u005[Ff])(?:_|\\u005[Ff])(?:p|\\u0070)(?:r|\\u0072)(?:o|\\u006[Ff])(?:t|\\u0074)(?:o|\\u006[Ff])(?:_|\\u005[Ff])(?:_|\\u005[Ff])"\s*:/;
    var suspectConstructorRx = /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/;
    function _parse2(text, reviver, options) {
      if (options == null) {
        if (reviver !== null && typeof reviver === "object") {
          options = reviver;
          reviver = void 0;
        }
      }
      if (hasBuffer && Buffer.isBuffer(text)) {
        text = text.toString();
      }
      if (text && text.charCodeAt(0) === 65279) {
        text = text.slice(1);
      }
      const obj = JSON.parse(text, reviver);
      if (obj === null || typeof obj !== "object") {
        return obj;
      }
      const protoAction = options && options.protoAction || "error";
      const constructorAction = options && options.constructorAction || "error";
      if (protoAction === "ignore" && constructorAction === "ignore") {
        return obj;
      }
      if (protoAction !== "ignore" && constructorAction !== "ignore") {
        if (suspectProtoRx.test(text) === false && suspectConstructorRx.test(text) === false) {
          return obj;
        }
      } else if (protoAction !== "ignore" && constructorAction === "ignore") {
        if (suspectProtoRx.test(text) === false) {
          return obj;
        }
      } else {
        if (suspectConstructorRx.test(text) === false) {
          return obj;
        }
      }
      return filter(obj, { protoAction, constructorAction, safe: options && options.safe });
    }
    function filter(obj, { protoAction = "error", constructorAction = "error", safe } = {}) {
      let next = [obj];
      while (next.length) {
        const nodes = next;
        next = [];
        for (const node of nodes) {
          if (protoAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "__proto__")) {
            if (safe === true) {
              return null;
            } else if (protoAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.__proto__;
          }
          if (constructorAction !== "ignore" && Object.prototype.hasOwnProperty.call(node, "constructor") && node.constructor !== null && typeof node.constructor === "object" && Object.prototype.hasOwnProperty.call(node.constructor, "prototype")) {
            if (safe === true) {
              return null;
            } else if (constructorAction === "error") {
              throw new SyntaxError("Object contains forbidden prototype property");
            }
            delete node.constructor;
          }
          for (const key in node) {
            const value = node[key];
            if (value && typeof value === "object") {
              next.push(value);
            }
          }
        }
      }
      return obj;
    }
    function parse3(text, reviver, options) {
      const { stackTraceLimit } = Error;
      Error.stackTraceLimit = 0;
      try {
        return _parse2(text, reviver, options);
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    function safeParse3(text, reviver) {
      const { stackTraceLimit } = Error;
      Error.stackTraceLimit = 0;
      try {
        return _parse2(text, reviver, { safe: true });
      } catch {
        return void 0;
      } finally {
        Error.stackTraceLimit = stackTraceLimit;
      }
    }
    module.exports = parse3;
    module.exports.default = parse3;
    module.exports.parse = parse3;
    module.exports.safeParse = safeParse3;
    module.exports.scan = filter;
  }
});

// node_modules/@assistant-ui/tap/dist/react/use-resource.js
var import_react = __toESM(require_react(), 1);

// node_modules/@assistant-ui/tap/dist/core/commit.js
function commitRender(renderResult) {
  const errors = [];
  for (const task of renderResult.commitTasks) {
    try {
      task();
    } catch (error48) {
      errors.push(error48);
    }
  }
  if (errors.length > 0) {
    if (errors.length === 1) {
      throw errors[0];
    } else {
      for (const error48 of errors) {
        console.error(error48);
      }
      throw new AggregateError(errors, "Errors during commit");
    }
  }
}
function cleanupAllEffects(executionContext) {
  var _a3;
  const errors = [];
  for (const cell of executionContext.cells) {
    if ((cell == null ? void 0 : cell.type) === "effect") {
      cell.deps = null;
      if (cell.cleanup) {
        try {
          (_a3 = cell.cleanup) == null ? void 0 : _a3.call(cell);
        } catch (e) {
          errors.push(e);
        } finally {
          cell.cleanup = void 0;
        }
      }
    }
  }
  if (errors.length > 0) {
    if (errors.length === 1) {
      throw errors[0];
    } else {
      for (const error48 of errors) {
        console.error(error48);
      }
      throw new AggregateError(errors, "Errors during cleanup");
    }
  }
}

// node_modules/@assistant-ui/tap/dist/core/env.js
var isDevelopment = typeof process !== "undefined" && true;

// node_modules/@assistant-ui/tap/dist/core/execution-context.js
var currentResourceFiber = null;
function withResourceFiber(fiber, fn) {
  fiber.currentIndex = 0;
  const previousContext = currentResourceFiber;
  currentResourceFiber = fiber;
  try {
    fn();
    fiber.isFirstRender = false;
    if (fiber.cells.length !== fiber.currentIndex) {
      throw new Error(`Rendered ${fiber.currentIndex} hooks but expected ${fiber.cells.length}. Hooks must be called in the exact same order in every render.`);
    }
  } finally {
    currentResourceFiber = previousContext;
  }
}
function getCurrentResourceFiber() {
  if (!currentResourceFiber) {
    throw new Error("No resource fiber available");
  }
  return currentResourceFiber;
}
function getDevStrictMode(enable) {
  if (!isDevelopment)
    return null;
  if (currentResourceFiber == null ? void 0 : currentResourceFiber.devStrictMode)
    return currentResourceFiber.isFirstRender ? "child" : "root";
  return enable ? "root" : null;
}

// node_modules/@assistant-ui/tap/dist/core/callResourceFn.js
function callResourceFn(resource2, props) {
  const fn = resource2[fnSymbol];
  if (!fn) {
    throw new Error("ResourceElement.type is not a valid Resource");
  }
  return fn(props);
}
var fnSymbol = Symbol("fnSymbol");

// node_modules/@assistant-ui/tap/dist/core/ResourceFiber.js
function createResourceFiber(type, dispatchUpdate, strictMode = getDevStrictMode(false)) {
  return {
    type,
    dispatchUpdate,
    devStrictMode: strictMode,
    cells: [],
    currentIndex: 0,
    renderContext: void 0,
    isFirstRender: true,
    isMounted: false,
    isNeverMounted: true
  };
}
function unmountResourceFiber(fiber) {
  if (!fiber.isMounted)
    throw new Error("Tried to unmount a fiber that is already unmounted");
  fiber.isMounted = false;
  cleanupAllEffects(fiber);
}
function renderResourceFiber(fiber, props) {
  const result = {
    commitTasks: [],
    props,
    output: void 0
  };
  withResourceFiber(fiber, () => {
    fiber.renderContext = result;
    try {
      result.output = callResourceFn(fiber.type, props);
    } finally {
      fiber.renderContext = void 0;
    }
  });
  return result;
}
function commitResourceFiber(fiber, result) {
  fiber.isMounted = true;
  if (isDevelopment && fiber.isNeverMounted && fiber.devStrictMode === "root") {
    commitRender(result);
    cleanupAllEffects(fiber);
  }
  fiber.isNeverMounted = false;
  commitRender(result);
}

// node_modules/@assistant-ui/tap/dist/react/use-resource.js
var useDevStrictMode = () => {
  if (!isDevelopment)
    return null;
  const count = (0, import_react.useRef)(0);
  const isFirstRender = count.current === 0;
  (0, import_react.useState)(() => count.current++);
  if (count.current !== 2)
    return null;
  return isFirstRender ? "child" : "root";
};
var resourceReducer = (version3, callback) => {
  return version3 + (callback() ? 1 : 0);
};
function useResource(element) {
  const [, dispatch] = (0, import_react.useReducer)(resourceReducer, 0);
  const devStrictMode = useDevStrictMode();
  const fiber = (0, import_react.useMemo)(() => {
    return createResourceFiber(element.type, dispatch, devStrictMode);
  }, [element.type, element.key]);
  const result = renderResourceFiber(fiber, element.props);
  (0, import_react.useLayoutEffect)(() => {
    return () => unmountResourceFiber(fiber);
  }, [fiber]);
  (0, import_react.useLayoutEffect)(() => {
    commitResourceFiber(fiber, result);
  });
  return result.output;
}

// node_modules/@assistant-ui/tap/dist/core/resource.js
function resource(fn) {
  const type = (props) => {
    return {
      type,
      props
    };
  };
  type[fnSymbol] = fn;
  return type;
}

// node_modules/@assistant-ui/tap/dist/core/withKey.js
function withKey(key, element) {
  return { ...element, key };
}

// node_modules/@assistant-ui/tap/dist/hooks/tap-state.js
var dispatchOnFiber = (fiber, callback) => {
  if (fiber.renderContext) {
    throw new Error("Resource updated during render");
  }
  if (fiber.isMounted) {
    fiber.dispatchUpdate(callback);
  } else if (fiber.isNeverMounted) {
    throw new Error("Resource updated before mount");
  }
};
function getStateCell(initialValue) {
  const fiber = getCurrentResourceFiber();
  const index3 = fiber.currentIndex++;
  if (!fiber.isFirstRender && index3 >= fiber.cells.length) {
    throw new Error("Rendered more hooks than during the previous render. Hooks must be called in the exact same order in every render.");
  }
  const cell = fiber.cells[index3];
  if (cell) {
    if (cell.type !== "state")
      throw new Error("Hook order changed between renders");
    return cell;
  }
  const value = typeof initialValue === "function" ? initialValue() : initialValue;
  if (isDevelopment && fiber.devStrictMode && typeof initialValue === "function") {
    void initialValue();
  }
  const newCell = {
    type: "state",
    value,
    set: (updater) => {
      dispatchOnFiber(fiber, () => {
        const currentValue = newCell.value;
        const nextValue = typeof updater === "function" ? updater(currentValue) : updater;
        if (isDevelopment && fiber.devStrictMode && typeof updater === "function") {
          void updater(currentValue);
        }
        if (Object.is(currentValue, nextValue))
          return false;
        newCell.value = nextValue;
        return true;
      });
    }
  };
  fiber.cells[index3] = newCell;
  return newCell;
}
function tapState(initial) {
  const cell = getStateCell(initial);
  return [cell.value, cell.set];
}

// node_modules/@assistant-ui/tap/dist/hooks/utils/depsShallowEqual.js
var depsShallowEqual = (a, b) => {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    if (!Object.is(a[i], b[i]))
      return false;
  }
  return true;
};

// node_modules/@assistant-ui/tap/dist/hooks/utils/tapHook.js
var tapHook = (type, init) => {
  const fiber = getCurrentResourceFiber();
  const index3 = fiber.currentIndex++;
  if (!fiber.isFirstRender && index3 >= fiber.cells.length) {
    throw new Error("Rendered more hooks than during the previous render. Hooks must be called in the exact same order in every render.");
  }
  let cell = fiber.cells[index3];
  if (!cell) {
    cell = init();
    fiber.cells[index3] = cell;
  }
  if (cell.type !== type) {
    throw new Error("Hook order changed between renders");
  }
  return cell;
};
var registerRenderMountTask = (task) => {
  const fiber = getCurrentResourceFiber();
  fiber.renderContext.commitTasks.push(task);
};

// node_modules/@assistant-ui/tap/dist/hooks/tap-effect.js
var newEffect = () => ({
  type: "effect",
  cleanup: void 0,
  deps: null
  // null means the effect has never been run
});
function tapEffect(effect, deps) {
  const cell = tapHook("effect", newEffect);
  if (deps && cell.deps && depsShallowEqual(cell.deps, deps))
    return;
  if (cell.deps !== null && !!deps !== !!cell.deps)
    throw new Error("tapEffect called with and without dependencies across re-renders");
  registerRenderMountTask(() => {
    var _a3;
    const errors = [];
    try {
      (_a3 = cell.cleanup) == null ? void 0 : _a3.call(cell);
    } catch (error48) {
      errors.push(error48);
    } finally {
      cell.cleanup = void 0;
    }
    try {
      const cleanup = effect();
      if (cleanup !== void 0 && typeof cleanup !== "function") {
        throw new Error(`An effect function must either return a cleanup function or nothing. Received: ${typeof cleanup}`);
      }
      cell.cleanup = cleanup;
    } catch (error48) {
      errors.push(error48);
    }
    cell.deps = deps;
    if (errors.length > 0) {
      if (errors.length === 1) {
        throw errors[0];
      } else {
        for (const error48 of errors) {
          console.error(error48);
        }
        throw new AggregateError(errors, "Errors during commit");
      }
    }
  });
}

// node_modules/@assistant-ui/tap/dist/hooks/tap-ref.js
function tapRef(initialValue) {
  const [state] = tapState(() => ({
    current: initialValue
  }));
  return state;
}

// node_modules/@assistant-ui/tap/dist/hooks/tap-const.js
function tapConst(getValue, _deps) {
  const [state] = tapState(getValue);
  return state;
}

// node_modules/@assistant-ui/tap/dist/hooks/tap-memo.js
var tapMemo = (fn, deps) => {
  const dataRef = tapRef();
  if (!dataRef.current) {
    if (isDevelopment) {
      const fiber = getCurrentResourceFiber();
      if (fiber.devStrictMode) {
        void fn();
      }
    }
    dataRef.current = { value: fn(), deps };
  }
  if (!depsShallowEqual(dataRef.current.deps, deps)) {
    dataRef.current.value = fn();
    dataRef.current.deps = deps;
  }
  return dataRef.current.value;
};

// node_modules/@assistant-ui/tap/dist/hooks/tap-callback.js
var tapCallback = (fn, deps) => {
  return tapMemo(() => fn, deps);
};

// node_modules/@assistant-ui/tap/dist/hooks/tap-effect-event.js
function tapEffectEvent(callback) {
  const callbackRef = tapRef(callback);
  tapEffect(() => {
    callbackRef.current = callback;
  });
  if (isDevelopment) {
    const fiber = getCurrentResourceFiber();
    return tapCallback((...args) => {
      if (fiber.renderContext)
        throw new Error("tapEffectEvent cannot be called during render");
      return callbackRef.current(...args);
    }, [fiber]);
  }
  return callbackRef.current;
}

// node_modules/@assistant-ui/tap/dist/hooks/tap-resource.js
function tapResource(element, propsDeps) {
  const [version3, setVersion] = tapState(0);
  const rerender = tapConst(() => () => setVersion((v) => v + 1), []);
  const fiber = tapMemo(() => {
    void element.key;
    return createResourceFiber(element.type, (callback) => {
      if (callback())
        rerender();
    });
  }, [element.type, element.key]);
  const result = propsDeps ? (
    // biome-ignore lint/correctness/useExhaustiveDependencies: user provided deps instead of prop identity
    tapMemo(() => renderResourceFiber(fiber, element.props), [fiber, ...propsDeps, version3])
  ) : renderResourceFiber(fiber, element.props);
  tapEffect(() => () => unmountResourceFiber(fiber), [fiber]);
  tapEffect(() => {
    commitResourceFiber(fiber, result);
  }, [fiber, result]);
  return result.output;
}

// node_modules/@assistant-ui/tap/dist/hooks/tap-inline-resource.js
function tapInlineResource(element) {
  return callResourceFn(element.type, element.props);
}

// node_modules/@assistant-ui/tap/dist/hooks/tap-resources.js
function tapResources(getElements, getElementsDeps) {
  const [version3, setVersion] = tapState(0);
  const rerender = tapConst(() => () => setVersion((v) => v + 1), []);
  const fibers = tapConst(() => /* @__PURE__ */ new Map(), []);
  const getElementsMemo = getElementsDeps ? (
    // biome-ignore lint/correctness/useExhaustiveDependencies: library code
    tapCallback(getElements, getElementsDeps)
  ) : getElements;
  const res = tapMemo(() => {
    const elementsArray = getElementsMemo();
    const seenKeys = /* @__PURE__ */ new Set();
    const results = [];
    let newCount = 0;
    for (let i = 0; i < elementsArray.length; i++) {
      const element = elementsArray[i];
      const elementKey = element.key;
      if (elementKey === void 0) {
        throw new Error(`tapResources did not provide a key for array at index ${i}`);
      }
      if (seenKeys.has(elementKey))
        throw new Error(`Duplicate key ${elementKey} in tapResources`);
      seenKeys.add(elementKey);
      let state = fibers.get(elementKey);
      if (!state) {
        const fiber = createResourceFiber(element.type, (callback) => {
          if (callback())
            rerender();
        });
        const result = renderResourceFiber(fiber, element.props);
        state = {
          fiber,
          next: result
        };
        newCount++;
        fibers.set(elementKey, state);
        results.push(result.output);
      } else if (state.fiber.type !== element.type) {
        const fiber = createResourceFiber(element.type, (callback) => {
          if (callback())
            rerender();
        });
        const result = renderResourceFiber(fiber, element.props);
        state.next = [fiber, result];
        results.push(result.output);
      } else {
        state.next = renderResourceFiber(state.fiber, element.props);
        results.push(state.next.output);
      }
    }
    if (fibers.size > results.length - newCount) {
      for (const key of fibers.keys()) {
        if (!seenKeys.has(key)) {
          fibers.get(key).next = "delete";
        }
      }
    }
    return results;
  }, [getElementsMemo, version3]);
  tapEffect(() => {
    return () => {
      for (const key of fibers.keys()) {
        const fiber = fibers.get(key).fiber;
        unmountResourceFiber(fiber);
      }
    };
  }, []);
  tapEffect(() => {
    res;
    for (const [key, state] of fibers.entries()) {
      if (state.next === "delete") {
        if (state.fiber.isMounted) {
          unmountResourceFiber(state.fiber);
        }
        fibers.delete(key);
      } else if (Array.isArray(state.next)) {
        unmountResourceFiber(state.fiber);
        state.fiber = state.next[0];
        commitResourceFiber(state.fiber, state.next[1]);
      } else {
        commitResourceFiber(state.fiber, state.next);
      }
    }
  }, [res]);
  return res;
}

// node_modules/@assistant-ui/tap/dist/core/scheduler.js
var MAX_FLUSH_LIMIT = 50;
var flushState = {
  schedulers: /* @__PURE__ */ new Set([]),
  isScheduled: false
};
var UpdateScheduler = class {
  constructor(_task) {
    __publicField(this, "_task");
    __publicField(this, "_isDirty", false);
    this._task = _task;
  }
  get isDirty() {
    return this._isDirty;
  }
  markDirty() {
    this._isDirty = true;
    flushState.schedulers.add(this);
    scheduleFlush();
  }
  runTask() {
    this._isDirty = false;
    this._task();
  }
};
var scheduleFlush = () => {
  if (flushState.isScheduled)
    return;
  flushState.isScheduled = true;
  queueMicrotask(flushScheduled);
};
var flushScheduled = () => {
  try {
    const errors = [];
    let flushDepth = 0;
    for (const scheduler of flushState.schedulers) {
      flushState.schedulers.delete(scheduler);
      if (!scheduler.isDirty)
        continue;
      flushDepth++;
      if (flushDepth > MAX_FLUSH_LIMIT) {
        throw new Error(`Maximum update depth exceeded. This can happen when a resource repeatedly calls setState inside tapEffect.`);
      }
      try {
        scheduler.runTask();
      } catch (error48) {
        errors.push(error48);
      }
    }
    if (errors.length > 0) {
      if (errors.length === 1) {
        throw errors[0];
      } else {
        for (const error48 of errors) {
          console.error(error48);
        }
        throw new AggregateError(errors, "Errors occurred during flushSync");
      }
    }
  } finally {
    flushState.schedulers.clear();
    flushState.isScheduled = false;
  }
};
var flushResourcesSync = (callback) => {
  const prev = flushState;
  flushState = {
    schedulers: /* @__PURE__ */ new Set([]),
    isScheduled: true
  };
  try {
    const result = callback();
    flushScheduled();
    return result;
  } finally {
    flushState = prev;
  }
};

// node_modules/@assistant-ui/tap/dist/tapSubscribableResource.js
var tapSubscribableResource = (element) => {
  const scheduler = tapConst(() => new UpdateScheduler(() => {
    lastRenderRef.current = null;
    handleUpdate();
  }), []);
  const fiber = tapMemo(() => {
    void element.key;
    return createResourceFiber(element.type, (callback) => {
      if (callback()) {
        scheduler.markDirty();
      }
    });
  }, [element.type, element.key]);
  const lastRenderRef = tapRef(null);
  lastRenderRef.current = renderResourceFiber(fiber, element.props);
  const isMountedRef = tapRef(false);
  const committedPropsRef = tapRef(element.props);
  const valueRef = tapRef(lastRenderRef.current.output);
  const subscribers = tapConst(() => /* @__PURE__ */ new Set(), []);
  const handleUpdate = tapEffectEvent(() => {
    if (!isMountedRef.current)
      return;
    if (lastRenderRef.current === null) {
      lastRenderRef.current = renderResourceFiber(fiber, committedPropsRef.current);
    }
    if (scheduler.isDirty)
      return;
    committedPropsRef.current = lastRenderRef.current.props;
    commitResourceFiber(fiber, lastRenderRef.current);
    if (scheduler.isDirty || valueRef.current === lastRenderRef.current.output)
      return;
    valueRef.current = lastRenderRef.current.output;
    subscribers.forEach((callback) => callback());
  });
  tapEffect(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
      unmountResourceFiber(fiber);
    };
  }, [fiber]);
  tapEffect(() => {
    flushResourcesSync(handleUpdate);
  });
  return tapMemo(() => ({
    getValue: () => valueRef.current,
    subscribe: (listener) => {
      subscribers.add(listener);
      return () => subscribers.delete(listener);
    }
  }), []);
};

// node_modules/@assistant-ui/tap/dist/core/createResource.js
var HandleWrapperResource = resource((state) => {
  const [, setElement] = tapState(state.elementRef.current);
  const output = tapResource(state.elementRef.current);
  const subscribers = tapConst(() => /* @__PURE__ */ new Set(), []);
  const valueRef = tapRef(output);
  tapEffect(() => {
    if (output !== valueRef.current) {
      valueRef.current = output;
      subscribers.forEach((callback) => callback());
    }
  });
  const handle = tapMemo(() => ({
    getValue: () => valueRef.current,
    subscribe: (callback) => {
      subscribers.add(callback);
      return () => subscribers.delete(callback);
    },
    render: (el) => {
      const changed = state.elementRef.current !== el;
      state.elementRef.current = el;
      if (state.onRender(changed)) {
        setElement(el);
      }
    },
    unmount: state.onUnmount
  }), [state]);
  return handle;
});

// node_modules/@assistant-ui/tap/dist/core/context.js
var contextValue = Symbol("tap.Context");
var createResourceContext = (defaultValue) => {
  return {
    [contextValue]: defaultValue
  };
};
var withContextProvider = (context2, value, fn) => {
  const previousValue = context2[contextValue];
  context2[contextValue] = value;
  try {
    return fn();
  } finally {
    context2[contextValue] = previousValue;
  }
};
var tap = (context2) => {
  return context2[contextValue];
};

// node_modules/@assistant-ui/store/dist/utils/react-assistant-context.js
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react2 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/store/dist/utils/tap-client-stack-context.js
var SYMBOL_CLIENT_INDEX = Symbol("assistant-ui.store.clientIndex");
var getClientIndex = (client) => {
  return client[SYMBOL_CLIENT_INDEX];
};
var ClientStackContext = createResourceContext([]);
var tapClientStack = () => {
  return tap(ClientStackContext);
};
var tapWithClientStack = (client, callback) => {
  const currentStack = tapClientStack();
  const newStack = tapMemo(() => [...currentStack, client], [currentStack, client]);
  return withContextProvider(ClientStackContext, newStack, callback);
};

// node_modules/@assistant-ui/store/dist/utils/BaseProxyHandler.js
var INTROSPECTION_PROPS = /* @__PURE__ */ new Set(["$$typeof", "nodeType", "then"]);
var handleIntrospectionProp = (prop, name) => {
  if (prop === Symbol.toStringTag)
    return name;
  if (typeof prop === "symbol")
    return void 0;
  if (prop === "toJSON")
    return () => name;
  if (INTROSPECTION_PROPS.has(prop))
    return void 0;
  return false;
};
var BaseProxyHandler = class {
  getOwnPropertyDescriptor(_, prop) {
    const value = this.get(_, prop);
    if (value === void 0)
      return void 0;
    return {
      value,
      writable: false,
      enumerable: true,
      configurable: false
    };
  }
  set() {
    return false;
  }
  setPrototypeOf() {
    return false;
  }
  defineProperty() {
    return false;
  }
  deleteProperty() {
    return false;
  }
  preventExtensions() {
    return false;
  }
};

// node_modules/@assistant-ui/store/dist/wrapperResource.js
var wrapperResource = (fn) => {
  const res = resource(fn);
  return (props) => {
    const el = res(props);
    if (props.key === void 0)
      return el;
    return withKey(props.key, el);
  };
};

// node_modules/@assistant-ui/store/dist/tapClientResource.js
var SYMBOL_GET_OUTPUT = Symbol("assistant-ui.store.getValue");
var getClientState = (client) => {
  const output = client[SYMBOL_GET_OUTPUT];
  if (!output) {
    throw new Error("Client scope contains a non-client resource. Ensure your Derived get() returns a client created with tapClientResource(), not a plain resource.");
  }
  return output.state;
};
var fieldAccessFns = /* @__PURE__ */ new Map();
function getOrCreateProxyFn(prop) {
  let template = fieldAccessFns.get(prop);
  if (!template) {
    template = function(...args) {
      if (!this || typeof this !== "object") {
        throw new Error(`Method "${String(prop)}" called without proper context. This may indicate the function was called incorrectly.`);
      }
      const output = this[SYMBOL_GET_OUTPUT];
      if (!output) {
        throw new Error(`Method "${String(prop)}" called on invalid client proxy. Ensure you are calling this method on a valid client instance.`);
      }
      const method = output.methods[prop];
      if (!method)
        throw new Error(`Method "${String(prop)}" is not implemented.`);
      if (typeof method !== "function")
        throw new Error(`"${String(prop)}" is not a function.`);
      return method(...args);
    };
    fieldAccessFns.set(prop, template);
  }
  return template;
}
var ClientProxyHandler = class extends BaseProxyHandler {
  constructor(outputRef, index3) {
    super();
    __publicField(this, "outputRef");
    __publicField(this, "index");
    __publicField(this, "boundFns");
    __publicField(this, "cachedReceiver");
    this.outputRef = outputRef;
    this.index = index3;
  }
  get(_, prop, receiver) {
    if (prop === SYMBOL_GET_OUTPUT)
      return this.outputRef.current;
    if (prop === SYMBOL_CLIENT_INDEX)
      return this.index;
    const introspection = handleIntrospectionProp(prop, "ClientProxy");
    if (introspection !== false)
      return introspection;
    const value = this.outputRef.current.methods[prop];
    if (typeof value === "function") {
      if (this.cachedReceiver !== receiver) {
        this.boundFns = /* @__PURE__ */ new Map();
        this.cachedReceiver = receiver;
      }
      let bound = this.boundFns.get(prop);
      if (!bound) {
        bound = getOrCreateProxyFn(prop).bind(receiver);
        this.boundFns.set(prop, bound);
      }
      return bound;
    }
    return value;
  }
  ownKeys() {
    return Object.keys(this.outputRef.current.methods);
  }
  has(_, prop) {
    if (prop === SYMBOL_GET_OUTPUT)
      return true;
    if (prop === SYMBOL_CLIENT_INDEX)
      return true;
    return prop in this.outputRef.current.methods;
  }
};
var ClientResource = wrapperResource((element) => {
  const valueRef = tapRef(null);
  const index3 = tapClientStack().length;
  const methods = tapMemo(() => new Proxy({}, new ClientProxyHandler(valueRef, index3)), [index3]);
  const value = tapWithClientStack(methods, () => tapResource(element));
  if (!valueRef.current) {
    valueRef.current = value;
  }
  tapEffect(() => {
    valueRef.current = value;
  });
  return { methods, state: value.state, key: element.key };
});
var tapClientResource = (element) => {
  return tapInlineResource(ClientResource(element));
};

// node_modules/@assistant-ui/store/dist/utils/proxied-assistant-state.js
var PROXIED_ASSISTANT_STATE_SYMBOL = Symbol("assistant-ui.store.proxiedAssistantState");
var isIgnoredKey = (key) => {
  return key === "on" || key === "subscribe" || typeof key === "symbol";
};
var createProxiedAssistantState = (client) => {
  class ProxiedAssistantStateProxyHandler extends BaseProxyHandler {
    get(_, prop) {
      const introspection = handleIntrospectionProp(prop, "AssistantState");
      if (introspection !== false)
        return introspection;
      const scope = prop;
      if (isIgnoredKey(scope))
        return void 0;
      return getClientState(client[scope]());
    }
    ownKeys() {
      return Object.keys(client).filter((key) => !isIgnoredKey(key));
    }
    has(_, prop) {
      return !isIgnoredKey(prop) && prop in client;
    }
  }
  return new Proxy({}, new ProxiedAssistantStateProxyHandler());
};
var getProxiedAssistantState = (client) => {
  return client[PROXIED_ASSISTANT_STATE_SYMBOL];
};

// node_modules/@assistant-ui/store/dist/utils/react-assistant-context.js
var NO_OP_SUBSCRIBE = () => () => {
};
var createErrorClientField = (message) => {
  const fn = () => {
    throw new Error(message);
  };
  fn.source = null;
  fn.query = null;
  return fn;
};
var DefaultAssistantClientProxyHandler = class extends BaseProxyHandler {
  get(_, prop) {
    if (prop === "subscribe")
      return NO_OP_SUBSCRIBE;
    if (prop === "on")
      return NO_OP_SUBSCRIBE;
    if (prop === PROXIED_ASSISTANT_STATE_SYMBOL)
      return DefaultAssistantClientProxiedAssistantState;
    const introspection = handleIntrospectionProp(prop, "DefaultAssistantClient");
    if (introspection !== false)
      return introspection;
    return createErrorClientField("You are using a component or hook that requires an AuiProvider. Wrap your component in an <AuiProvider> component.");
  }
  ownKeys() {
    return ["subscribe", "on", PROXIED_ASSISTANT_STATE_SYMBOL];
  }
  has(_, prop) {
    return prop === "subscribe" || prop === "on" || prop === PROXIED_ASSISTANT_STATE_SYMBOL;
  }
};
var DefaultAssistantClient = new Proxy({}, new DefaultAssistantClientProxyHandler());
var DefaultAssistantClientProxiedAssistantState = createProxiedAssistantState(DefaultAssistantClient);
var createRootAssistantClient = () => new Proxy({}, {
  get(_, prop) {
    const introspection = handleIntrospectionProp(prop, "AssistantClient");
    if (introspection !== false)
      return introspection;
    return createErrorClientField(`The current scope does not have a "${String(prop)}" property.`);
  }
});
var AssistantContext = (0, import_react2.createContext)(DefaultAssistantClient);
var useAssistantContextValue = () => {
  return (0, import_react2.useContext)(AssistantContext);
};
var AuiProvider = ({ value, children }) => {
  return (0, import_jsx_runtime.jsx)(AssistantContext.Provider, { value, children });
};

// node_modules/@assistant-ui/store/dist/Derived.js
var Derived = resource((_config) => {
  return null;
});

// node_modules/@assistant-ui/store/dist/attachDefaultPeers.js
var DEFAULT_PEERS = Symbol("assistant-ui.default-peers");
function attachDefaultPeers(resource2, peers) {
  const resourceWithPeers = resource2;
  const existing = resourceWithPeers[DEFAULT_PEERS] ?? {};
  for (const key of Object.keys(peers)) {
    if (key in existing) {
      throw new Error(`Default peer "${key}" is already attached to this resource`);
    }
  }
  resourceWithPeers[DEFAULT_PEERS] = { ...existing, ...peers };
}
function getDefaultPeers(resource2) {
  return resource2[DEFAULT_PEERS];
}

// node_modules/@assistant-ui/store/dist/utils/splitClients.js
function splitClients(clients, baseClient) {
  const rootClients = {};
  const derivedClients = {};
  for (const [key, clientElement] of Object.entries(clients)) {
    if (clientElement.type === Derived) {
      derivedClients[key] = clientElement;
    } else {
      rootClients[key] = clientElement;
    }
  }
  const gatherDefaultPeers = (clientElement, visited = /* @__PURE__ */ new Set()) => {
    if (visited.has(clientElement))
      return [];
    visited.add(clientElement);
    const defaultPeers = getDefaultPeers(clientElement.type);
    if (!defaultPeers)
      return [];
    const result = [];
    for (const [key, peerElement] of Object.entries(defaultPeers)) {
      result.push([key, peerElement]);
      if (peerElement.type !== Derived) {
        const nestedPeers = gatherDefaultPeers(peerElement, visited);
        result.push(...nestedPeers);
      }
    }
    return result;
  };
  for (const [_clientKey, clientElement] of Object.entries(rootClients)) {
    const allPeers = gatherDefaultPeers(clientElement);
    for (const [key, peerElement] of allPeers) {
      if (key in rootClients || key in derivedClients || baseClient[key].source !== null)
        continue;
      if (peerElement.type === Derived) {
        derivedClients[key] = peerElement;
      } else {
        rootClients[key] = peerElement;
      }
    }
  }
  return { rootClients, derivedClients };
}
var tapShallowMemoObject = (object2) => {
  return tapMemo(() => object2, [...Object.entries(object2).flat()]);
};
var tapSplitClients = (clients, baseClient) => {
  const { rootClients, derivedClients } = splitClients(clients, baseClient);
  return {
    rootClients: tapShallowMemoObject(rootClients),
    derivedClients: tapShallowMemoObject(derivedClients)
  };
};

// node_modules/@assistant-ui/store/dist/types/events.js
var normalizeEventSelector = (selector) => {
  if (typeof selector === "string") {
    const source = selector.split(".")[0];
    return { scope: source, event: selector };
  }
  return { scope: selector.scope, event: selector.event };
};

// node_modules/@assistant-ui/store/dist/utils/NotificationManager.js
var NotificationManager = resource(() => {
  return tapConst(() => {
    const listeners = /* @__PURE__ */ new Map();
    const wildcardListeners = /* @__PURE__ */ new Set();
    const subscribers = /* @__PURE__ */ new Set();
    return {
      on(event, callback) {
        const cb = callback;
        if (event === "*") {
          wildcardListeners.add(cb);
          return () => wildcardListeners.delete(cb);
        }
        let set2 = listeners.get(event);
        if (!set2) {
          set2 = /* @__PURE__ */ new Set();
          listeners.set(event, set2);
        }
        set2.add(cb);
        return () => {
          set2.delete(cb);
          if (set2.size === 0)
            listeners.delete(event);
        };
      },
      emit(event, payload, clientStack) {
        const eventListeners = listeners.get(event);
        if (!eventListeners && wildcardListeners.size === 0)
          return;
        queueMicrotask(() => {
          const errors = [];
          if (eventListeners) {
            for (const cb of eventListeners) {
              try {
                cb(payload, clientStack);
              } catch (e) {
                errors.push(e);
              }
            }
          }
          if (wildcardListeners.size > 0) {
            const wrapped = { event, payload };
            for (const cb of wildcardListeners) {
              try {
                cb(wrapped, clientStack);
              } catch (e) {
                errors.push(e);
              }
            }
          }
          if (errors.length > 0) {
            if (errors.length === 1) {
              throw errors[0];
            } else {
              for (const error48 of errors) {
                console.error(error48);
              }
              throw new AggregateError(errors, "Errors occurred during event emission");
            }
          }
        });
      },
      subscribe(callback) {
        subscribers.add(callback);
        return () => subscribers.delete(callback);
      },
      notifySubscribers() {
        for (const cb of subscribers) {
          try {
            cb();
          } catch (e) {
            console.error("NotificationManager: subscriber callback error", e);
          }
        }
      }
    };
  }, []);
});

// node_modules/@assistant-ui/store/dist/utils/tap-assistant-context.js
var AssistantTapContext = createResourceContext(null);
var withAssistantTapContextProvider = (value, fn) => {
  return withContextProvider(AssistantTapContext, value, fn);
};
var tapAssistantTapContext = () => {
  const ctx = tap(AssistantTapContext);
  if (!ctx)
    throw new Error("AssistantTapContext is not available");
  return ctx;
};
var tapAssistantClientRef = () => {
  return tapAssistantTapContext().clientRef;
};
var tapAssistantEmit = () => {
  const { emit } = tapAssistantTapContext();
  const clientStack = tapClientStack();
  return tapEffectEvent((event, payload) => {
    emit(event, payload, clientStack);
  });
};

// node_modules/@assistant-ui/store/dist/useAui.js
var tapShallowMemoArray = (array2) => {
  return tapMemo(() => array2, array2);
};
var RootClientResource = resource(({ element, emit, clientRef }) => {
  const { methods, state } = withAssistantTapContextProvider({ clientRef, emit }, () => tapClientResource(element));
  return tapMemo(() => ({ state, methods }), [methods, state]);
});
var RootClientAccessorResource = resource(({ element, notifications, clientRef, name }) => {
  const store = tapSubscribableResource(RootClientResource({ element, emit: notifications.emit, clientRef }));
  tapEffect(() => {
    return store.subscribe(notifications.notifySubscribers);
  }, [store, notifications]);
  return tapMemo(() => {
    const clientFunction = () => store.getValue().methods;
    Object.defineProperties(clientFunction, {
      source: {
        value: "root",
        writable: false
      },
      query: {
        value: {},
        writable: false
      },
      name: {
        value: name,
        configurable: true
      }
    });
    return clientFunction;
  }, [store, name]);
});
var NoOpRootClientsAccessorsResource = resource(() => {
  return tapMemo(() => ({
    clients: [],
    subscribe: void 0,
    on: void 0
  }), []);
});
var RootClientsAccessorsResource = resource(({ clients: inputClients, clientRef }) => {
  const notifications = tapInlineResource(NotificationManager());
  tapEffect(() => clientRef.parent.subscribe(notifications.notifySubscribers), [clientRef, notifications]);
  const results = tapShallowMemoArray(tapResources(() => Object.keys(inputClients).map((key) => withKey(key, RootClientAccessorResource({
    element: inputClients[key],
    notifications,
    clientRef,
    name: key
  }))), [inputClients, notifications, clientRef]));
  return tapMemo(() => {
    return {
      clients: results,
      subscribe: notifications.subscribe,
      on: function(selector, callback) {
        if (!this) {
          throw new Error("const { on } = useAui() is not supported. Use aui.on() instead.");
        }
        const { scope, event } = normalizeEventSelector(selector);
        if (scope !== "*") {
          const source = this[scope].source;
          if (source === null) {
            throw new Error(`Scope "${scope}" is not available. Use { scope: "*", event: "${event}" } to listen globally.`);
          }
        }
        const localUnsub = notifications.on(event, (payload, clientStack) => {
          if (scope === "*") {
            callback(payload);
            return;
          }
          const scopeClient = this[scope]();
          const index3 = getClientIndex(scopeClient);
          if (scopeClient === clientStack[index3]) {
            callback(payload);
          }
        });
        if (scope !== "*" && clientRef.parent[scope].source === null)
          return localUnsub;
        const parentUnsub = clientRef.parent.on(selector, callback);
        return () => {
          localUnsub();
          parentUnsub();
        };
      }
    };
  }, [results, notifications, clientRef]);
});
var getMeta = (props, clientRef, memo10) => {
  if ("source" in props && "query" in props)
    return props;
  if (memo10.dep === props)
    return memo10.meta;
  const meta3 = props.getMeta(clientRef.current);
  memo10.meta = meta3;
  memo10.dep = props;
  return meta3;
};
var DerivedClientAccessorResource = resource(({ element, clientRef, name }) => {
  const get = tapEffectEvent(() => element.props);
  return tapMemo(() => {
    const clientFunction = () => get().get(clientRef.current);
    const metaMemo = {};
    Object.defineProperties(clientFunction, {
      source: {
        get: () => getMeta(get(), clientRef, metaMemo).source
      },
      query: {
        get: () => getMeta(get(), clientRef, metaMemo).query
      },
      name: {
        value: name,
        configurable: true
      }
    });
    return clientFunction;
  }, [clientRef, name]);
});
var DerivedClientsAccessorsResource = resource(({ clients, clientRef }) => {
  return tapShallowMemoArray(tapResources(() => Object.keys(clients).map((key) => withKey(key, DerivedClientAccessorResource({
    element: clients[key],
    clientRef,
    name: key
  }))), [clients, clientRef]));
});
var AssistantClientResource = resource(({ parent, clients }) => {
  const { rootClients, derivedClients } = tapSplitClients(clients, parent);
  const clientRef = tapRef({
    parent,
    current: null
  }).current;
  tapEffect(() => {
    clientRef.current = client;
  });
  const rootFields = tapResource(Object.keys(rootClients).length > 0 ? RootClientsAccessorsResource({ clients: rootClients, clientRef }) : NoOpRootClientsAccessorsResource());
  const derivedFields = tapInlineResource(DerivedClientsAccessorsResource({ clients: derivedClients, clientRef }));
  const client = tapMemo(() => {
    const proto = parent === DefaultAssistantClient ? createRootAssistantClient() : parent;
    const client2 = Object.create(proto);
    Object.assign(client2, {
      subscribe: rootFields.subscribe ?? parent.subscribe,
      on: rootFields.on ?? parent.on,
      [PROXIED_ASSISTANT_STATE_SYMBOL]: createProxiedAssistantState(client2)
    });
    for (const field of rootFields.clients) {
      client2[field.name] = field;
    }
    for (const field of derivedFields) {
      client2[field.name] = field;
    }
    return client2;
  }, [parent, rootFields, derivedFields]);
  if (clientRef.current === null) {
    clientRef.current = client;
  }
  return client;
});
function useAui(clients, { parent } = {
  parent: useAssistantContextValue()
}) {
  if (clients) {
    return useResource(AssistantClientResource({
      parent: parent ?? DefaultAssistantClient,
      clients
    }));
  }
  if (parent === null)
    throw new Error("received null parent, this usage is not allowed");
  return parent;
}

// node_modules/@assistant-ui/store/dist/useAuiState.js
var import_react4 = __toESM(require_react(), 1);
var useAuiState = (selector) => {
  const aui = useAui();
  const proxiedState = getProxiedAssistantState(aui);
  const slice = (0, import_react4.useSyncExternalStore)(aui.subscribe, () => selector(proxiedState), () => selector(proxiedState));
  if (slice === proxiedState) {
    throw new Error("You tried to return the entire AssistantState. This is not supported due to technical limitations.");
  }
  (0, import_react4.useDebugValue)(slice);
  return slice;
};

// node_modules/@assistant-ui/store/dist/useAuiEvent.js
var import_react6 = __toESM(require_react(), 1);

// node_modules/use-effect-event/dist/index.js
var import_react5 = __toESM(require_react());
var context = import_react5.default.createContext(true);
function forbiddenInRender() {
  throw new Error("A function wrapped in useEffectEvent can't be called during rendering.");
}
var isInvalidExecutionContextForEventFunction = "use" in import_react5.default ? () => {
  try {
    return import_react5.default.use(context);
  } catch {
    return false;
  }
} : () => false;
function useEffectEvent(fn) {
  const ref = import_react5.default.useRef(forbiddenInRender);
  return import_react5.default.useInsertionEffect(() => {
    ref.current = fn;
  }, [fn]), (...args) => {
    isInvalidExecutionContextForEventFunction() && forbiddenInRender();
    const latestFn = ref.current;
    return latestFn(...args);
  };
}

// node_modules/@assistant-ui/store/dist/useAuiEvent.js
var useAuiEvent = (selector, callback) => {
  const aui = useAui();
  const callbackRef = useEffectEvent(callback);
  const { scope, event } = normalizeEventSelector(selector);
  (0, import_react6.useEffect)(() => aui.on({ scope, event }, callbackRef), [aui, scope, event, callbackRef]);
};

// node_modules/@assistant-ui/store/dist/AuiIf.js
var AuiIf = ({ children, condition }) => {
  const result = useAuiState(condition);
  return result ? children : null;
};
AuiIf.displayName = "AuiIf";

// node_modules/@assistant-ui/store/dist/tapClientLookup.js
var ClientResourceWithKey = wrapperResource((el) => {
  if (el.key === void 0) {
    throw new Error("tapClientResource: Element has no key");
  }
  return tapInlineResource(ClientResource(el));
});
function tapClientLookup(getElements, getElementsDeps) {
  const resources = tapResources(
    () => getElements().map((el) => ClientResourceWithKey(el)),
    // biome-ignore lint/correctness/useExhaustiveDependencies: getElementsDeps is passed through from caller
    getElementsDeps
  );
  const keys = tapMemo(() => Object.keys(resources), [resources]);
  const keyToIndex = tapMemo(() => {
    return resources.reduce((acc, resource2, index3) => {
      acc[resource2.key] = index3;
      return acc;
    }, {});
  }, [resources]);
  const state = tapMemo(() => {
    return resources.map((r) => r.state);
  }, [resources]);
  return {
    state,
    get: (lookup) => {
      if ("index" in lookup) {
        if (lookup.index < 0 || lookup.index >= keys.length) {
          throw new Error(`tapClientLookup: Index ${lookup.index} out of bounds (length: ${keys.length})`);
        }
        return resources[lookup.index].methods;
      }
      const index3 = keyToIndex[lookup.key];
      if (index3 === void 0) {
        throw new Error(`tapClientLookup: Key "${lookup.key}" not found`);
      }
      return resources[index3].methods;
    }
  };
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/useRemoteThreadListRuntime.js
var import_react34 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/model-context/ModelContextTypes.js
var mergeModelContexts = (configSet) => {
  const configs = Array.from(configSet).map((c) => c.getModelContext()).sort((a, b) => (b.priority ?? 0) - (a.priority ?? 0));
  return configs.reduce((acc, config2) => {
    var _a3;
    if (config2.system) {
      if (acc.system) {
        acc.system += `

${config2.system}`;
      } else {
        acc.system = config2.system;
      }
    }
    if (config2.tools) {
      for (const [name, tool2] of Object.entries(config2.tools)) {
        const existing = (_a3 = acc.tools) == null ? void 0 : _a3[name];
        if (existing && existing !== tool2) {
          throw new Error(`You tried to define a tool with the name ${name}, but it already exists.`);
        }
        if (!acc.tools)
          acc.tools = {};
        acc.tools[name] = tool2;
      }
    }
    if (config2.config) {
      acc.config = {
        ...acc.config,
        ...config2.config
      };
    }
    if (config2.callSettings) {
      acc.callSettings = {
        ...acc.callSettings,
        ...config2.callSettings
      };
    }
    return acc;
  }, {});
};

// node_modules/@assistant-ui/react/dist/utils/CompositeContextProvider.js
var CompositeContextProvider = class {
  constructor() {
    __publicField(this, "_providers", /* @__PURE__ */ new Set());
    __publicField(this, "_subscribers", /* @__PURE__ */ new Set());
  }
  getModelContext() {
    return mergeModelContexts(this._providers);
  }
  registerModelContextProvider(provider) {
    var _a3;
    this._providers.add(provider);
    const unsubscribe = (_a3 = provider.subscribe) == null ? void 0 : _a3.call(provider, () => {
      this.notifySubscribers();
    });
    this.notifySubscribers();
    return () => {
      this._providers.delete(provider);
      unsubscribe == null ? void 0 : unsubscribe();
      this.notifySubscribers();
    };
  }
  notifySubscribers() {
    for (const callback of this._subscribers)
      callback();
  }
  subscribe(callback) {
    this._subscribers.add(callback);
    return () => this._subscribers.delete(callback);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/core/BaseAssistantRuntimeCore.js
var BaseAssistantRuntimeCore = class {
  constructor() {
    __publicField(this, "_contextProvider", new CompositeContextProvider());
  }
  registerModelContextProvider(provider) {
    return this._contextProvider.registerModelContextProvider(provider);
  }
  getModelContextProvider() {
    return this._contextProvider;
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/RemoteThreadListThreadListRuntimeCore.js
var import_jsx_runtime16 = __toESM(require_jsx_runtime(), 1);

// node_modules/@assistant-ui/react/dist/internal.js
var internal_exports = {};
__export(internal_exports, {
  AssistantRuntimeImpl: () => AssistantRuntimeImpl,
  BaseAssistantRuntimeCore: () => BaseAssistantRuntimeCore,
  CompositeContextProvider: () => CompositeContextProvider,
  DefaultThreadComposerRuntimeCore: () => DefaultThreadComposerRuntimeCore,
  MessageRepository: () => MessageRepository,
  ThreadRuntimeImpl: () => ThreadRuntimeImpl,
  fromThreadMessageLike: () => fromThreadMessageLike,
  generateId: () => generateId,
  getAutoStatus: () => getAutoStatus,
  splitLocalRuntimeOptions: () => splitLocalRuntimeOptions,
  useSmooth: () => useSmooth,
  useSmoothStatus: () => useSmoothStatus,
  useToolInvocations: () => useToolInvocations,
  withSmoothContextProvider: () => withSmoothContextProvider
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/BaseSubscribable.js
var BaseSubscribable = class {
  constructor() {
    __publicField(this, "_subscribers", /* @__PURE__ */ new Set());
  }
  subscribe(callback) {
    this._subscribers.add(callback);
    return () => this._subscribers.delete(callback);
  }
  waitForUpdate() {
    return new Promise((resolve) => {
      const unsubscribe = this.subscribe(() => {
        unsubscribe();
        resolve();
      });
    });
  }
  _notifySubscribers() {
    const errors = [];
    for (const callback of this._subscribers) {
      try {
        callback();
      } catch (error48) {
        errors.push(error48);
      }
    }
    if (errors.length > 0) {
      if (errors.length === 1) {
        throw errors[0];
      } else {
        for (const error48 of errors) {
          console.error(error48);
        }
        throw new AggregateError(errors);
      }
    }
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/composer/BaseComposerRuntimeCore.js
var isAttachmentComplete = (a) => a.status.type === "complete";
var BaseComposerRuntimeCore = class extends BaseSubscribable {
  constructor() {
    super(...arguments);
    __publicField(this, "isEditing", true);
    __publicField(this, "_attachments", []);
    __publicField(this, "_text", "");
    __publicField(this, "_role", "user");
    __publicField(this, "_runConfig", {});
    __publicField(this, "_dictation");
    __publicField(this, "_dictationSession");
    __publicField(this, "_dictationUnsubscribes", []);
    __publicField(this, "_dictationBaseText", "");
    __publicField(this, "_currentInterimText", "");
    __publicField(this, "_dictationSessionIdCounter", 0);
    __publicField(this, "_activeDictationSessionId");
    __publicField(this, "_isCleaningDictation", false);
    __publicField(this, "_eventSubscribers", /* @__PURE__ */ new Map());
  }
  get attachmentAccept() {
    var _a3;
    return ((_a3 = this.getAttachmentAdapter()) == null ? void 0 : _a3.accept) ?? "*";
  }
  get attachments() {
    return this._attachments;
  }
  setAttachments(value) {
    this._attachments = value;
    this._notifySubscribers();
  }
  get isEmpty() {
    return !this.text.trim() && !this.attachments.length;
  }
  get text() {
    return this._text;
  }
  get role() {
    return this._role;
  }
  get runConfig() {
    return this._runConfig;
  }
  setText(value) {
    if (this._text === value)
      return;
    this._text = value;
    if (this._dictation) {
      this._dictationBaseText = value;
      this._currentInterimText = "";
      const { status, inputDisabled } = this._dictation;
      this._dictation = inputDisabled ? { status, inputDisabled } : { status };
    }
    this._notifySubscribers();
  }
  setRole(role) {
    if (this._role === role)
      return;
    this._role = role;
    this._notifySubscribers();
  }
  setRunConfig(runConfig) {
    if (this._runConfig === runConfig)
      return;
    this._runConfig = runConfig;
    this._notifySubscribers();
  }
  _emptyTextAndAttachments() {
    this._attachments = [];
    this._text = "";
    this._notifySubscribers();
  }
  async _onClearAttachments() {
    const adapter = this.getAttachmentAdapter();
    if (adapter) {
      await Promise.all(this._attachments.map((a) => adapter.remove(a)));
    }
  }
  async reset() {
    if (this._attachments.length === 0 && this._text === "" && this._role === "user" && Object.keys(this._runConfig).length === 0) {
      return;
    }
    this._role = "user";
    this._runConfig = {};
    const task = this._onClearAttachments();
    this._emptyTextAndAttachments();
    await task;
  }
  async clearAttachments() {
    const task = this._onClearAttachments();
    this.setAttachments([]);
    await task;
  }
  async send() {
    if (this._dictationSession) {
      this._dictationSession.cancel();
      this._cleanupDictation();
    }
    const adapter = this.getAttachmentAdapter();
    const attachments = adapter && this.attachments.length > 0 ? Promise.all(this.attachments.map(async (a) => {
      if (isAttachmentComplete(a))
        return a;
      const result = await adapter.send(a);
      return result;
    })) : [];
    const text = this.text;
    this._emptyTextAndAttachments();
    const message = {
      createdAt: /* @__PURE__ */ new Date(),
      role: this.role,
      content: text ? [{ type: "text", text }] : [],
      attachments: await attachments,
      runConfig: this.runConfig,
      metadata: { custom: {} }
    };
    this.handleSend(message);
    this._notifyEventSubscribers("send");
  }
  cancel() {
    this.handleCancel();
  }
  async addAttachment(file2) {
    const adapter = this.getAttachmentAdapter();
    if (!adapter)
      throw new Error("Attachments are not supported");
    const upsertAttachment = (a) => {
      const idx = this._attachments.findIndex((attachment) => attachment.id === a.id);
      if (idx !== -1)
        this._attachments = [
          ...this._attachments.slice(0, idx),
          a,
          ...this._attachments.slice(idx + 1)
        ];
      else {
        this._attachments = [...this._attachments, a];
      }
      this._notifySubscribers();
    };
    const promiseOrGenerator = adapter.add({ file: file2 });
    if (Symbol.asyncIterator in promiseOrGenerator) {
      for await (const r of promiseOrGenerator) {
        upsertAttachment(r);
      }
    } else {
      upsertAttachment(await promiseOrGenerator);
    }
    this._notifyEventSubscribers("attachmentAdd");
    this._notifySubscribers();
  }
  async removeAttachment(attachmentId) {
    const adapter = this.getAttachmentAdapter();
    if (!adapter)
      throw new Error("Attachments are not supported");
    const index3 = this._attachments.findIndex((a) => a.id === attachmentId);
    if (index3 === -1)
      throw new Error("Attachment not found");
    const attachment = this._attachments[index3];
    await adapter.remove(attachment);
    this._attachments = [
      ...this._attachments.slice(0, index3),
      ...this._attachments.slice(index3 + 1)
    ];
    this._notifySubscribers();
  }
  get dictation() {
    return this._dictation;
  }
  _isActiveSession(sessionId, session) {
    return this._activeDictationSessionId === sessionId && this._dictationSession === session;
  }
  startDictation() {
    const adapter = this.getDictationAdapter();
    if (!adapter) {
      throw new Error("Dictation adapter not configured");
    }
    if (this._dictationSession) {
      for (const unsub of this._dictationUnsubscribes) {
        unsub();
      }
      this._dictationUnsubscribes = [];
      const oldSession = this._dictationSession;
      oldSession.stop().catch(() => {
      });
      this._dictationSession = void 0;
    }
    const inputDisabled = adapter.disableInputDuringDictation ?? false;
    this._dictationBaseText = this._text;
    this._currentInterimText = "";
    const session = adapter.listen();
    this._dictationSession = session;
    const sessionId = ++this._dictationSessionIdCounter;
    this._activeDictationSessionId = sessionId;
    this._dictation = { status: session.status, inputDisabled };
    this._notifySubscribers();
    const unsubSpeech = session.onSpeech((result) => {
      if (!this._isActiveSession(sessionId, session))
        return;
      const isFinal = result.isFinal !== false;
      const needsSeparator = this._dictationBaseText && !this._dictationBaseText.endsWith(" ") && result.transcript;
      const separator = needsSeparator ? " " : "";
      if (isFinal) {
        this._dictationBaseText = this._dictationBaseText + separator + result.transcript;
        this._currentInterimText = "";
        this._text = this._dictationBaseText;
        if (this._dictation) {
          const { transcript: _, ...rest } = this._dictation;
          this._dictation = rest;
        }
        this._notifySubscribers();
      } else {
        this._currentInterimText = separator + result.transcript;
        this._text = this._dictationBaseText + this._currentInterimText;
        if (this._dictation) {
          this._dictation = {
            ...this._dictation,
            transcript: result.transcript
          };
        }
        this._notifySubscribers();
      }
    });
    this._dictationUnsubscribes.push(unsubSpeech);
    const unsubStart = session.onSpeechStart(() => {
      var _a3;
      if (!this._isActiveSession(sessionId, session))
        return;
      this._dictation = {
        status: { type: "running" },
        inputDisabled,
        ...((_a3 = this._dictation) == null ? void 0 : _a3.transcript) && {
          transcript: this._dictation.transcript
        }
      };
      this._notifySubscribers();
    });
    this._dictationUnsubscribes.push(unsubStart);
    const unsubEnd = session.onSpeechEnd(() => {
      this._cleanupDictation({ sessionId });
    });
    this._dictationUnsubscribes.push(unsubEnd);
    const statusInterval = setInterval(() => {
      if (!this._isActiveSession(sessionId, session))
        return;
      if (session.status.type === "ended") {
        this._cleanupDictation({ sessionId });
      }
    }, 100);
    this._dictationUnsubscribes.push(() => clearInterval(statusInterval));
  }
  stopDictation() {
    if (!this._dictationSession)
      return;
    const session = this._dictationSession;
    const sessionId = this._activeDictationSessionId;
    session.stop().finally(() => {
      this._cleanupDictation({ sessionId });
    });
  }
  _cleanupDictation(options) {
    const isStaleSession = (options == null ? void 0 : options.sessionId) !== void 0 && options.sessionId !== this._activeDictationSessionId;
    if (isStaleSession || this._isCleaningDictation)
      return;
    this._isCleaningDictation = true;
    try {
      for (const unsub of this._dictationUnsubscribes) {
        unsub();
      }
      this._dictationUnsubscribes = [];
      this._dictationSession = void 0;
      this._activeDictationSessionId = void 0;
      this._dictation = void 0;
      this._dictationBaseText = "";
      this._currentInterimText = "";
      this._notifySubscribers();
    } finally {
      this._isCleaningDictation = false;
    }
  }
  _notifyEventSubscribers(event) {
    const subscribers = this._eventSubscribers.get(event);
    if (!subscribers)
      return;
    for (const callback of subscribers)
      callback();
  }
  unstable_on(event, callback) {
    const subscribers = this._eventSubscribers.get(event);
    if (!subscribers) {
      this._eventSubscribers.set(event, /* @__PURE__ */ new Set([callback]));
    } else {
      subscribers.add(callback);
    }
    return () => {
      const subscribers2 = this._eventSubscribers.get(event);
      if (!subscribers2)
        return;
      subscribers2.delete(callback);
    };
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/composer/DefaultThreadComposerRuntimeCore.js
var DefaultThreadComposerRuntimeCore = class extends BaseComposerRuntimeCore {
  constructor(runtime) {
    super();
    __publicField(this, "runtime");
    __publicField(this, "_canCancel", false);
    this.runtime = runtime;
    this.connect();
  }
  get canCancel() {
    return this._canCancel;
  }
  get attachments() {
    return super.attachments;
  }
  getAttachmentAdapter() {
    var _a3;
    return (_a3 = this.runtime.adapters) == null ? void 0 : _a3.attachments;
  }
  getDictationAdapter() {
    var _a3;
    return (_a3 = this.runtime.adapters) == null ? void 0 : _a3.dictation;
  }
  connect() {
    return this.runtime.subscribe(() => {
      if (this.canCancel !== this.runtime.capabilities.cancel) {
        this._canCancel = this.runtime.capabilities.cancel;
        this._notifySubscribers();
      }
    });
  }
  async handleSend(message) {
    var _a3;
    this.runtime.append({
      ...message,
      parentId: ((_a3 = this.runtime.messages.at(-1)) == null ? void 0 : _a3.id) ?? null,
      sourceId: null
    });
  }
  async handleCancel() {
    this.runtime.cancelRun();
  }
};

// node_modules/@assistant-ui/react/node_modules/nanoid/non-secure/index.js
var customAlphabet = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};

// node_modules/@assistant-ui/react/dist/utils/idUtils.js
var generateId = customAlphabet("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 7);
var optimisticPrefix = "__optimistic__";
var generateOptimisticId = () => `${optimisticPrefix}${generateId()}`;
var errorPrefix = "__error__";
var generateErrorMessageId = () => `${errorPrefix}${generateId()}`;

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/auto-status.js
var symbolAutoStatus = Symbol("autoStatus");
var AUTO_STATUS_RUNNING = Object.freeze(Object.assign({ type: "running" }, { [symbolAutoStatus]: true }));
var AUTO_STATUS_COMPLETE = Object.freeze(Object.assign({
  type: "complete",
  reason: "unknown"
}, { [symbolAutoStatus]: true }));
var AUTO_STATUS_PENDING = Object.freeze(Object.assign({
  type: "requires-action",
  reason: "tool-calls"
}, { [symbolAutoStatus]: true }));
var AUTO_STATUS_INTERRUPT = Object.freeze(Object.assign({
  type: "requires-action",
  reason: "interrupt"
}, { [symbolAutoStatus]: true }));
var isAutoStatus = (status) => status[symbolAutoStatus] === true;
var getAutoStatus = (isLast, isRunning, hasInterruptedToolCalls, hasPendingToolCalls, error48) => {
  if (isLast && error48) {
    return Object.assign({
      type: "incomplete",
      reason: "error",
      error: error48
    }, { [symbolAutoStatus]: true });
  }
  return isLast && isRunning ? AUTO_STATUS_RUNNING : hasInterruptedToolCalls ? AUTO_STATUS_INTERRUPT : hasPendingToolCalls ? AUTO_STATUS_PENDING : AUTO_STATUS_COMPLETE;
};

// node_modules/assistant-stream/dist/utils/json/parse-partial-json-object.js
var import_secure_json_parse = __toESM(require_secure_json_parse(), 1);

// node_modules/assistant-stream/dist/utils/json/fix-json.js
function fixJson(input) {
  const stack = ["ROOT"];
  let lastValidIndex = -1;
  let literalStart = null;
  const path = [];
  let currentKey;
  function pushCurrentKeyToPath() {
    if (currentKey !== void 0) {
      path.push(JSON.parse(`"${currentKey}"`));
      currentKey = void 0;
    }
  }
  function processValueStart(char, i, swapState) {
    switch (char) {
      case '"': {
        lastValidIndex = i;
        stack.pop();
        stack.push(swapState);
        stack.push("INSIDE_STRING");
        pushCurrentKeyToPath();
        break;
      }
      case "f":
      case "t":
      case "n": {
        lastValidIndex = i;
        literalStart = i;
        stack.pop();
        stack.push(swapState);
        stack.push("INSIDE_LITERAL");
        break;
      }
      case "-": {
        stack.pop();
        stack.push(swapState);
        stack.push("INSIDE_NUMBER");
        pushCurrentKeyToPath();
        break;
      }
      case "0":
      case "1":
      case "2":
      case "3":
      case "4":
      case "5":
      case "6":
      case "7":
      case "8":
      case "9": {
        lastValidIndex = i;
        stack.pop();
        stack.push(swapState);
        stack.push("INSIDE_NUMBER");
        pushCurrentKeyToPath();
        break;
      }
      case "{": {
        lastValidIndex = i;
        stack.pop();
        stack.push(swapState);
        stack.push("INSIDE_OBJECT_START");
        pushCurrentKeyToPath();
        break;
      }
      case "[": {
        lastValidIndex = i;
        stack.pop();
        stack.push(swapState);
        stack.push("INSIDE_ARRAY_START");
        pushCurrentKeyToPath();
        break;
      }
    }
  }
  function processAfterObjectValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_OBJECT_AFTER_COMMA");
        break;
      }
      case "}": {
        lastValidIndex = i;
        stack.pop();
        currentKey = path.pop();
        break;
      }
    }
  }
  function processAfterArrayValue(char, i) {
    switch (char) {
      case ",": {
        stack.pop();
        stack.push("INSIDE_ARRAY_AFTER_COMMA");
        currentKey = (Number(currentKey) + 1).toString();
        break;
      }
      case "]": {
        lastValidIndex = i;
        stack.pop();
        currentKey = path.pop();
        break;
      }
    }
  }
  for (let i = 0; i < input.length; i++) {
    const char = input[i];
    const currentState = stack[stack.length - 1];
    switch (currentState) {
      case "ROOT":
        processValueStart(char, i, "FINISH");
        break;
      case "INSIDE_OBJECT_START": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            currentKey = "";
            break;
          }
          case "}": {
            lastValidIndex = i;
            stack.pop();
            currentKey = path.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_COMMA": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_KEY");
            currentKey = "";
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_KEY": {
        switch (char) {
          case '"': {
            stack.pop();
            stack.push("INSIDE_OBJECT_AFTER_KEY");
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            currentKey += char;
            break;
          }
          default: {
            currentKey += char;
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_AFTER_KEY": {
        switch (char) {
          case ":": {
            stack.pop();
            stack.push("INSIDE_OBJECT_BEFORE_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_OBJECT_BEFORE_VALUE": {
        processValueStart(char, i, "INSIDE_OBJECT_AFTER_VALUE");
        break;
      }
      case "INSIDE_OBJECT_AFTER_VALUE": {
        processAfterObjectValue(char, i);
        break;
      }
      case "INSIDE_STRING": {
        switch (char) {
          case '"': {
            stack.pop();
            lastValidIndex = i;
            currentKey = path.pop();
            break;
          }
          case "\\": {
            stack.push("INSIDE_STRING_ESCAPE");
            break;
          }
          default: {
            lastValidIndex = i;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_START": {
        switch (char) {
          case "]": {
            lastValidIndex = i;
            stack.pop();
            currentKey = path.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            currentKey = "0";
            processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_VALUE": {
        switch (char) {
          case ",": {
            stack.pop();
            stack.push("INSIDE_ARRAY_AFTER_COMMA");
            currentKey = (Number(currentKey) + 1).toString();
            break;
          }
          case "]": {
            lastValidIndex = i;
            stack.pop();
            currentKey = path.pop();
            break;
          }
          default: {
            lastValidIndex = i;
            break;
          }
        }
        break;
      }
      case "INSIDE_ARRAY_AFTER_COMMA": {
        processValueStart(char, i, "INSIDE_ARRAY_AFTER_VALUE");
        break;
      }
      case "INSIDE_STRING_ESCAPE": {
        stack.pop();
        if (stack[stack.length - 1] === "INSIDE_STRING") {
          lastValidIndex = i;
        } else if (stack[stack.length - 1] === "INSIDE_OBJECT_KEY") {
          currentKey += char;
        }
        break;
      }
      case "INSIDE_NUMBER": {
        switch (char) {
          case "0":
          case "1":
          case "2":
          case "3":
          case "4":
          case "5":
          case "6":
          case "7":
          case "8":
          case "9": {
            lastValidIndex = i;
            break;
          }
          case "e":
          case "E":
          case "-":
          case ".": {
            break;
          }
          case ",": {
            stack.pop();
            currentKey = path.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "}": {
            stack.pop();
            currentKey = path.pop();
            if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
              processAfterObjectValue(char, i);
            }
            break;
          }
          case "]": {
            stack.pop();
            currentKey = path.pop();
            if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
              processAfterArrayValue(char, i);
            }
            break;
          }
          default: {
            stack.pop();
            currentKey = path.pop();
            break;
          }
        }
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, i + 1);
        if (!"false".startsWith(partialLiteral) && !"true".startsWith(partialLiteral) && !"null".startsWith(partialLiteral)) {
          stack.pop();
          if (stack[stack.length - 1] === "INSIDE_OBJECT_AFTER_VALUE") {
            processAfterObjectValue(char, i);
          } else if (stack[stack.length - 1] === "INSIDE_ARRAY_AFTER_VALUE") {
            processAfterArrayValue(char, i);
          }
        } else {
          lastValidIndex = i;
        }
        break;
      }
    }
  }
  let result = input.slice(0, lastValidIndex + 1);
  for (let i = stack.length - 1; i >= 0; i--) {
    const state = stack[i];
    switch (state) {
      case "INSIDE_STRING": {
        result += '"';
        break;
      }
      case "INSIDE_OBJECT_KEY":
      case "INSIDE_OBJECT_AFTER_KEY":
      case "INSIDE_OBJECT_AFTER_COMMA":
      case "INSIDE_OBJECT_START":
      case "INSIDE_OBJECT_BEFORE_VALUE":
      case "INSIDE_OBJECT_AFTER_VALUE": {
        result += "}";
        break;
      }
      case "INSIDE_ARRAY_START":
      case "INSIDE_ARRAY_AFTER_COMMA":
      case "INSIDE_ARRAY_AFTER_VALUE": {
        result += "]";
        break;
      }
      case "INSIDE_LITERAL": {
        const partialLiteral = input.substring(literalStart, input.length);
        if ("true".startsWith(partialLiteral)) {
          result += "true".slice(partialLiteral.length);
        } else if ("false".startsWith(partialLiteral)) {
          result += "false".slice(partialLiteral.length);
        } else if ("null".startsWith(partialLiteral)) {
          result += "null".slice(partialLiteral.length);
        }
      }
    }
  }
  return [result, path];
}

// node_modules/assistant-stream/dist/utils/json/parse-partial-json-object.js
var PARTIAL_JSON_OBJECT_META_SYMBOL = Symbol("aui.parse-partial-json-object.meta");
var getPartialJsonObjectMeta = (obj) => {
  return obj == null ? void 0 : obj[PARTIAL_JSON_OBJECT_META_SYMBOL];
};
var parsePartialJsonObject = (json2) => {
  if (json2.length === 0)
    return {
      [PARTIAL_JSON_OBJECT_META_SYMBOL]: { state: "partial", partialPath: [] }
    };
  try {
    const res = import_secure_json_parse.default.parse(json2);
    if (typeof res !== "object" || res === null)
      throw new Error("argsText is expected to be an object");
    res[PARTIAL_JSON_OBJECT_META_SYMBOL] = {
      state: "complete",
      partialPath: []
    };
    return res;
  } catch {
    try {
      const [fixedJson, partialPath] = fixJson(json2);
      const res = import_secure_json_parse.default.parse(fixedJson);
      if (typeof res !== "object" || res === null)
        throw new Error("argsText is expected to be an object");
      res[PARTIAL_JSON_OBJECT_META_SYMBOL] = {
        state: "partial",
        partialPath
      };
      return res;
    } catch {
      return void 0;
    }
  }
};
var getFieldState = (parent, parentMeta, fieldPath) => {
  if (typeof parent !== "object" || parent === null)
    return parentMeta.state;
  if (parentMeta.state === "complete")
    return "complete";
  if (fieldPath.length === 0)
    return parentMeta.state;
  const [field, ...restPath] = fieldPath;
  if (!Object.prototype.hasOwnProperty.call(parent, field))
    return "partial";
  const [partialField, ...restPartialPath] = parentMeta.partialPath;
  if (field !== partialField)
    return "complete";
  const child = parent[field];
  const childMeta = {
    state: "partial",
    partialPath: restPartialPath
  };
  return getFieldState(child, childMeta, restPath);
};
var getPartialJsonObjectFieldState = (obj, fieldPath) => {
  const meta3 = getPartialJsonObjectMeta(obj);
  if (!meta3)
    throw new Error("unable to determine object state");
  return getFieldState(obj, meta3, fieldPath.map(String));
};

// node_modules/assistant-stream/dist/utils/AsyncIterableStream.js
async function* streamGeneratorPolyfill() {
  const reader = this.getReader();
  try {
    while (true) {
      const { done, value } = await reader.read();
      if (done)
        break;
      yield value;
    }
  } finally {
    reader.releaseLock();
  }
}
function asAsyncIterableStream(source) {
  var _a3;
  source[_a3 = Symbol.asyncIterator] ?? (source[_a3] = streamGeneratorPolyfill);
  return source;
}

// node_modules/assistant-stream/dist/core/AssistantStream.js
var AssistantStream = {
  toResponse(stream, transformer) {
    return new Response(AssistantStream.toByteStream(stream, transformer), {
      headers: transformer.headers ?? {}
    });
  },
  fromResponse(response, transformer) {
    return AssistantStream.fromByteStream(response.body, transformer);
  },
  toByteStream(stream, transformer) {
    return stream.pipeThrough(transformer);
  },
  fromByteStream(readable, transformer) {
    return readable.pipeThrough(transformer);
  }
};

// node_modules/assistant-stream/dist/utils/promiseWithResolvers.js
var promiseWithResolvers = function() {
  let resolve;
  let reject;
  const promise2 = new Promise((res, rej) => {
    resolve = res;
    reject = rej;
  });
  if (!resolve || !reject)
    throw new Error("Failed to create promise");
  return { promise: promise2, resolve, reject };
};

// node_modules/assistant-stream/dist/core/utils/stream/merge.js
var createMergeStream = () => {
  const list = [];
  let sealed = false;
  let controller;
  let currentPull;
  const handlePull = (item) => {
    if (!item.promise) {
      item.promise = item.reader.read().then(({ done, value }) => {
        item.promise = void 0;
        if (done) {
          list.splice(list.indexOf(item), 1);
          if (sealed && list.length === 0) {
            controller.close();
          }
        } else {
          controller.enqueue(value);
        }
        currentPull == null ? void 0 : currentPull.resolve();
        currentPull = void 0;
      }).catch((e) => {
        console.error(e);
        list.forEach((item2) => {
          item2.reader.cancel();
        });
        list.length = 0;
        controller.error(e);
        currentPull == null ? void 0 : currentPull.reject(e);
        currentPull = void 0;
      });
    }
  };
  const readable = new ReadableStream({
    start(c) {
      controller = c;
    },
    pull() {
      currentPull = promiseWithResolvers();
      list.forEach((item) => {
        handlePull(item);
      });
      return currentPull.promise;
    },
    cancel() {
      list.forEach((item) => {
        item.reader.cancel();
      });
      list.length = 0;
    }
  });
  return {
    readable,
    isSealed() {
      return sealed;
    },
    seal() {
      sealed = true;
      if (list.length === 0)
        controller.close();
    },
    addStream(stream) {
      if (sealed)
        throw new Error("Cannot add streams after the run callback has settled.");
      const item = { reader: stream.getReader() };
      list.push(item);
      handlePull(item);
    },
    enqueue(chunk) {
      this.addStream(new ReadableStream({
        start(c) {
          c.enqueue(chunk);
          c.close();
        }
      }));
    }
  };
};

// node_modules/assistant-stream/dist/core/modules/text.js
var TextStreamControllerImpl = class {
  constructor(controller) {
    __publicField(this, "_controller");
    __publicField(this, "_isClosed", false);
    this._controller = controller;
  }
  append(textDelta) {
    this._controller.enqueue({
      type: "text-delta",
      path: [],
      textDelta
    });
    return this;
  }
  close() {
    if (this._isClosed)
      return;
    this._isClosed = true;
    this._controller.enqueue({
      type: "part-finish",
      path: []
    });
    this._controller.close();
  }
};
var createTextStream = (readable) => {
  return new ReadableStream({
    start(c) {
      var _a3;
      return (_a3 = readable.start) == null ? void 0 : _a3.call(readable, new TextStreamControllerImpl(c));
    },
    pull(c) {
      var _a3;
      return (_a3 = readable.pull) == null ? void 0 : _a3.call(readable, new TextStreamControllerImpl(c));
    },
    cancel(c) {
      var _a3;
      return (_a3 = readable.cancel) == null ? void 0 : _a3.call(readable, c);
    }
  });
};
var createTextStreamController = () => {
  let controller;
  const stream = createTextStream({
    start(c) {
      controller = c;
    }
  });
  return [stream, controller];
};

// node_modules/assistant-stream/dist/core/modules/tool-call.js
var ToolCallStreamControllerImpl = class {
  constructor(_controller) {
    __publicField(this, "_controller");
    __publicField(this, "_isClosed", false);
    __publicField(this, "_mergeTask");
    __publicField(this, "_argsTextController");
    this._controller = _controller;
    const stream = createTextStream({
      start: (c) => {
        this._argsTextController = c;
      }
    });
    let hasArgsText = false;
    this._mergeTask = stream.pipeTo(new WritableStream({
      write: (chunk) => {
        switch (chunk.type) {
          case "text-delta":
            hasArgsText = true;
            this._controller.enqueue(chunk);
            break;
          case "part-finish":
            if (!hasArgsText) {
              this._controller.enqueue({
                type: "text-delta",
                textDelta: "{}",
                path: []
              });
            }
            this._controller.enqueue({
              type: "tool-call-args-text-finish",
              path: []
            });
            break;
          default:
            throw new Error(`Unexpected chunk type: ${chunk.type}`);
        }
      }
    }));
  }
  get argsText() {
    return this._argsTextController;
  }
  async setResponse(response) {
    this._argsTextController.close();
    await Promise.resolve();
    this._controller.enqueue({
      type: "result",
      path: [],
      ...response.artifact !== void 0 ? { artifact: response.artifact } : {},
      result: response.result,
      isError: response.isError ?? false
    });
  }
  async close() {
    if (this._isClosed)
      return;
    this._isClosed = true;
    this._argsTextController.close();
    await this._mergeTask;
    this._controller.enqueue({
      type: "part-finish",
      path: []
    });
    this._controller.close();
  }
};
var createToolCallStream = (readable) => {
  return new ReadableStream({
    start(c) {
      var _a3;
      return (_a3 = readable.start) == null ? void 0 : _a3.call(readable, new ToolCallStreamControllerImpl(c));
    },
    pull(c) {
      var _a3;
      return (_a3 = readable.pull) == null ? void 0 : _a3.call(readable, new ToolCallStreamControllerImpl(c));
    },
    cancel(c) {
      var _a3;
      return (_a3 = readable.cancel) == null ? void 0 : _a3.call(readable, c);
    }
  });
};
var createToolCallStreamController = () => {
  let controller;
  const stream = createToolCallStream({
    start(c) {
      controller = c;
    }
  });
  return [stream, controller];
};

// node_modules/assistant-stream/dist/core/utils/Counter.js
var Counter = class {
  constructor() {
    __publicField(this, "value", -1);
  }
  up() {
    return ++this.value;
  }
};

// node_modules/assistant-stream/dist/core/utils/stream/path-utils.js
var PathAppendEncoder = class extends TransformStream {
  constructor(idx) {
    super({
      transform(chunk, controller) {
        controller.enqueue({
          ...chunk,
          path: [idx, ...chunk.path]
        });
      }
    });
  }
};
var PathAppendDecoder = class extends TransformStream {
  constructor(idx) {
    super({
      transform(chunk, controller) {
        const { path: [idx2, ...path] } = chunk;
        if (idx !== idx2)
          throw new Error(`Path mismatch: expected ${idx}, got ${idx2}`);
        controller.enqueue({
          ...chunk,
          path
        });
      }
    });
  }
};
var PathMergeEncoder = class extends TransformStream {
  constructor(counter) {
    const innerCounter = new Counter();
    const mapping = /* @__PURE__ */ new Map();
    super({
      transform(chunk, controller) {
        if (chunk.type === "part-start" && chunk.path.length === 0) {
          mapping.set(innerCounter.up(), counter.up());
        }
        const [idx, ...path] = chunk.path;
        if (idx === void 0) {
          controller.enqueue(chunk);
          return;
        }
        const mappedIdx = mapping.get(idx);
        if (mappedIdx === void 0)
          throw new Error("Path not found");
        controller.enqueue({
          ...chunk,
          path: [mappedIdx, ...path]
        });
      }
    });
  }
};

// node_modules/assistant-stream/dist/core/utils/stream/PipeableTransformStream.js
var PipeableTransformStream = class extends TransformStream {
  constructor(transform2) {
    super();
    const readable = transform2(super.readable);
    Object.defineProperty(this, "readable", {
      value: readable,
      writable: false
    });
  }
};

// node_modules/assistant-stream/dist/core/serialization/data-stream/chunk-types.js
var DataStreamStreamChunkType;
(function(DataStreamStreamChunkType2) {
  DataStreamStreamChunkType2["TextDelta"] = "0";
  DataStreamStreamChunkType2["Data"] = "2";
  DataStreamStreamChunkType2["Error"] = "3";
  DataStreamStreamChunkType2["Annotation"] = "8";
  DataStreamStreamChunkType2["ToolCall"] = "9";
  DataStreamStreamChunkType2["ToolCallResult"] = "a";
  DataStreamStreamChunkType2["StartToolCall"] = "b";
  DataStreamStreamChunkType2["ToolCallArgsTextDelta"] = "c";
  DataStreamStreamChunkType2["FinishMessage"] = "d";
  DataStreamStreamChunkType2["FinishStep"] = "e";
  DataStreamStreamChunkType2["StartStep"] = "f";
  DataStreamStreamChunkType2["ReasoningDelta"] = "g";
  DataStreamStreamChunkType2["Source"] = "h";
  DataStreamStreamChunkType2["RedactedReasoning"] = "i";
  DataStreamStreamChunkType2["ReasoningSignature"] = "j";
  DataStreamStreamChunkType2["File"] = "k";
  DataStreamStreamChunkType2["AuiUpdateStateOperations"] = "aui-state";
  DataStreamStreamChunkType2["AuiTextDelta"] = "aui-text-delta";
  DataStreamStreamChunkType2["AuiReasoningDelta"] = "aui-reasoning-delta";
})(DataStreamStreamChunkType || (DataStreamStreamChunkType = {}));

// node_modules/assistant-stream/dist/core/utils/stream/LineDecoderStream.js
var LineDecoderStream = class extends TransformStream {
  constructor() {
    super({
      transform: (chunk, controller) => {
        this.buffer += chunk;
        const lines = this.buffer.split("\n");
        for (let i = 0; i < lines.length - 1; i++) {
          controller.enqueue(lines[i]);
        }
        this.buffer = lines[lines.length - 1] || "";
      },
      flush: () => {
        if (this.buffer) {
          throw new Error(`Stream ended with an incomplete line: "${this.buffer}"`);
        }
      }
    });
    __publicField(this, "buffer", "");
  }
};

// node_modules/assistant-stream/dist/core/serialization/data-stream/serialization.js
var DataStreamChunkEncoder = class extends TransformStream {
  constructor() {
    super({
      transform: (chunk, controller) => {
        controller.enqueue(`${chunk.type}:${JSON.stringify(chunk.value)}
`);
      }
    });
  }
};
var DataStreamChunkDecoder = class extends TransformStream {
  constructor() {
    super({
      transform: (chunk, controller) => {
        const index3 = chunk.indexOf(":");
        if (index3 === -1)
          throw new Error("Invalid stream part");
        controller.enqueue({
          type: chunk.slice(0, index3),
          value: JSON.parse(chunk.slice(index3 + 1))
        });
      }
    });
  }
};

// node_modules/assistant-stream/dist/core/utils/stream/AssistantMetaTransformStream.js
var AssistantMetaTransformStream = class extends TransformStream {
  constructor() {
    const parts = [];
    super({
      transform(chunk, controller) {
        if (chunk.type === "part-start") {
          if (chunk.path.length !== 0) {
            controller.error(new Error("Nested parts are not supported"));
            return;
          }
          parts.push(chunk.part);
          controller.enqueue(chunk);
          return;
        }
        if (chunk.type === "text-delta" || chunk.type === "result" || chunk.type === "part-finish" || chunk.type === "tool-call-args-text-finish") {
          if (chunk.path.length !== 1) {
            controller.error(new Error(`${chunk.type} chunks must have a path of length 1`));
            return;
          }
          const idx = chunk.path[0];
          if (idx < 0 || idx >= parts.length) {
            controller.error(new Error(`Invalid path index: ${idx}`));
            return;
          }
          const part = parts[idx];
          controller.enqueue({
            ...chunk,
            meta: part
            // TODO
          });
          return;
        }
        controller.enqueue(chunk);
      }
    });
  }
};

// node_modules/assistant-stream/dist/core/serialization/data-stream/DataStream.js
var TOOL_CALL_ARGS_CLOSING_CHUNKS = [
  DataStreamStreamChunkType.StartToolCall,
  DataStreamStreamChunkType.ToolCall,
  DataStreamStreamChunkType.TextDelta,
  DataStreamStreamChunkType.ReasoningDelta,
  DataStreamStreamChunkType.Source,
  DataStreamStreamChunkType.Error,
  DataStreamStreamChunkType.FinishStep,
  DataStreamStreamChunkType.FinishMessage,
  DataStreamStreamChunkType.AuiTextDelta,
  DataStreamStreamChunkType.AuiReasoningDelta
];
var DataStreamDecoder = class extends PipeableTransformStream {
  constructor() {
    super((readable) => {
      const toolCallControllers = /* @__PURE__ */ new Map();
      let activeToolCallArgsText;
      const transform2 = new AssistantTransformStream({
        transform(chunk, controller) {
          const { type, value } = chunk;
          if (TOOL_CALL_ARGS_CLOSING_CHUNKS.includes(type)) {
            activeToolCallArgsText == null ? void 0 : activeToolCallArgsText.close();
            activeToolCallArgsText = void 0;
          }
          switch (type) {
            case DataStreamStreamChunkType.ReasoningDelta:
              controller.appendReasoning(value);
              break;
            case DataStreamStreamChunkType.TextDelta:
              controller.appendText(value);
              break;
            case DataStreamStreamChunkType.AuiTextDelta:
              controller.withParentId(value.parentId).appendText(value.textDelta);
              break;
            case DataStreamStreamChunkType.AuiReasoningDelta:
              controller.withParentId(value.parentId).appendReasoning(value.reasoningDelta);
              break;
            case DataStreamStreamChunkType.StartToolCall: {
              const { toolCallId, toolName, parentId } = value;
              const ctrl = parentId ? controller.withParentId(parentId) : controller;
              if (toolCallControllers.has(toolCallId))
                throw new Error(`Encountered duplicate tool call id: ${toolCallId}`);
              const toolCallController = ctrl.addToolCallPart({
                toolCallId,
                toolName
              });
              toolCallControllers.set(toolCallId, toolCallController);
              activeToolCallArgsText = toolCallController.argsText;
              break;
            }
            case DataStreamStreamChunkType.ToolCallArgsTextDelta: {
              const { toolCallId, argsTextDelta } = value;
              const toolCallController = toolCallControllers.get(toolCallId);
              if (!toolCallController)
                throw new Error(`Encountered tool call with unknown id: ${toolCallId}`);
              toolCallController.argsText.append(argsTextDelta);
              break;
            }
            case DataStreamStreamChunkType.ToolCallResult: {
              const { toolCallId, artifact, result, isError } = value;
              const toolCallController = toolCallControllers.get(toolCallId);
              if (!toolCallController)
                throw new Error(`Encountered tool call result with unknown id: ${toolCallId}`);
              toolCallController.setResponse({
                artifact,
                result,
                isError
              });
              break;
            }
            case DataStreamStreamChunkType.ToolCall: {
              const { toolCallId, toolName, args } = value;
              let toolCallController = toolCallControllers.get(toolCallId);
              if (toolCallController) {
                toolCallController.argsText.close();
              } else {
                toolCallController = controller.addToolCallPart({
                  toolCallId,
                  toolName,
                  args
                });
                toolCallControllers.set(toolCallId, toolCallController);
              }
              break;
            }
            case DataStreamStreamChunkType.FinishMessage:
              controller.enqueue({
                type: "message-finish",
                path: [],
                ...value
              });
              break;
            case DataStreamStreamChunkType.StartStep:
              controller.enqueue({
                type: "step-start",
                path: [],
                ...value
              });
              break;
            case DataStreamStreamChunkType.FinishStep:
              controller.enqueue({
                type: "step-finish",
                path: [],
                ...value
              });
              break;
            case DataStreamStreamChunkType.Data:
              controller.enqueue({
                type: "data",
                path: [],
                data: value
              });
              break;
            case DataStreamStreamChunkType.Annotation:
              controller.enqueue({
                type: "annotations",
                path: [],
                annotations: value
              });
              break;
            case DataStreamStreamChunkType.Source: {
              const { parentId, ...sourceData } = value;
              const ctrl = parentId ? controller.withParentId(parentId) : controller;
              ctrl.appendSource({
                type: "source",
                ...sourceData
              });
              break;
            }
            case DataStreamStreamChunkType.Error:
              controller.enqueue({
                type: "error",
                path: [],
                error: value
              });
              break;
            case DataStreamStreamChunkType.File:
              controller.appendFile({
                type: "file",
                ...value
              });
              break;
            case DataStreamStreamChunkType.AuiUpdateStateOperations:
              controller.enqueue({
                type: "update-state",
                path: [],
                operations: value
              });
              break;
            case DataStreamStreamChunkType.ReasoningSignature:
            case DataStreamStreamChunkType.RedactedReasoning:
              break;
            default: {
              const exhaustiveCheck = type;
              throw new Error(`unsupported chunk type: ${exhaustiveCheck}`);
            }
          }
        },
        flush() {
          activeToolCallArgsText == null ? void 0 : activeToolCallArgsText.close();
          activeToolCallArgsText = void 0;
          toolCallControllers.forEach((controller) => controller.close());
          toolCallControllers.clear();
        }
      });
      return readable.pipeThrough(new TextDecoderStream()).pipeThrough(new LineDecoderStream()).pipeThrough(new DataStreamChunkDecoder()).pipeThrough(transform2);
    });
  }
};

// node_modules/assistant-stream/node_modules/nanoid/non-secure/index.js
var customAlphabet2 = (alphabet, defaultSize = 21) => {
  return (size = defaultSize) => {
    let id = "";
    let i = size | 0;
    while (i--) {
      id += alphabet[Math.random() * alphabet.length | 0];
    }
    return id;
  };
};

// node_modules/assistant-stream/dist/core/utils/generateId.js
var generateId2 = customAlphabet2("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 7);

// node_modules/assistant-stream/dist/core/modules/assistant-stream.js
var AssistantStreamControllerImpl = class _AssistantStreamControllerImpl {
  constructor(state) {
    __publicField(this, "_state");
    __publicField(this, "_parentId");
    this._state = state || {
      merger: createMergeStream(),
      contentCounter: new Counter()
    };
  }
  get __internal_isClosed() {
    return this._state.merger.isSealed();
  }
  __internal_getReadable() {
    return this._state.merger.readable;
  }
  __internal_subscribeToClose(callback) {
    this._state.closeSubscriber = callback;
  }
  _addPart(part, stream) {
    if (this._state.append) {
      this._state.append.controller.close();
      this._state.append = void 0;
    }
    this.enqueue({
      type: "part-start",
      part,
      path: []
    });
    this._state.merger.addStream(stream.pipeThrough(new PathAppendEncoder(this._state.contentCounter.value)));
  }
  merge(stream) {
    this._state.merger.addStream(stream.pipeThrough(new PathMergeEncoder(this._state.contentCounter)));
  }
  appendText(textDelta) {
    var _a3;
    if (((_a3 = this._state.append) == null ? void 0 : _a3.kind) !== "text") {
      this._state.append = {
        kind: "text",
        controller: this.addTextPart()
      };
    }
    this._state.append.controller.append(textDelta);
  }
  appendReasoning(textDelta) {
    var _a3;
    if (((_a3 = this._state.append) == null ? void 0 : _a3.kind) !== "reasoning") {
      this._state.append = {
        kind: "reasoning",
        controller: this.addReasoningPart()
      };
    }
    this._state.append.controller.append(textDelta);
  }
  addTextPart() {
    const [stream, controller] = createTextStreamController();
    this._addPart({ type: "text" }, stream);
    return controller;
  }
  addReasoningPart() {
    const [stream, controller] = createTextStreamController();
    this._addPart({ type: "reasoning" }, stream);
    return controller;
  }
  addToolCallPart(options) {
    const opt = typeof options === "string" ? { toolName: options } : options;
    const toolName = opt.toolName;
    const toolCallId = opt.toolCallId ?? generateId2();
    const [stream, controller] = createToolCallStreamController();
    this._addPart({
      type: "tool-call",
      toolName,
      toolCallId,
      ...this._parentId && { parentId: this._parentId }
    }, stream);
    if (opt.argsText !== void 0) {
      controller.argsText.append(opt.argsText);
      controller.argsText.close();
    }
    if (opt.args !== void 0) {
      controller.argsText.append(JSON.stringify(opt.args));
      controller.argsText.close();
    }
    if (opt.response !== void 0) {
      controller.setResponse(opt.response);
    }
    return controller;
  }
  appendSource(options) {
    this._addPart({ ...options, ...this._parentId && { parentId: this._parentId } }, new ReadableStream({
      start(controller) {
        controller.enqueue({
          type: "part-finish",
          path: []
        });
        controller.close();
      }
    }));
  }
  appendFile(options) {
    this._addPart(options, new ReadableStream({
      start(controller) {
        controller.enqueue({
          type: "part-finish",
          path: []
        });
        controller.close();
      }
    }));
  }
  enqueue(chunk) {
    this._state.merger.enqueue(chunk);
    if (chunk.type === "part-start" && chunk.path.length === 0) {
      this._state.contentCounter.up();
    }
  }
  withParentId(parentId) {
    const controller = new _AssistantStreamControllerImpl(this._state);
    controller._parentId = parentId;
    return controller;
  }
  close() {
    var _a3, _b, _c, _d;
    (_b = (_a3 = this._state.append) == null ? void 0 : _a3.controller) == null ? void 0 : _b.close();
    this._state.merger.seal();
    (_d = (_c = this._state).closeSubscriber) == null ? void 0 : _d.call(_c);
  }
};
function createAssistantStream(callback) {
  const controller = new AssistantStreamControllerImpl();
  const runTask = async () => {
    try {
      await callback(controller);
    } catch (e) {
      if (!controller.__internal_isClosed) {
        controller.enqueue({
          type: "error",
          path: [],
          error: String(e)
        });
      }
      throw e;
    } finally {
      if (!controller.__internal_isClosed) {
        controller.close();
      }
    }
  };
  runTask();
  return controller.__internal_getReadable();
}
function createAssistantStreamController() {
  const { resolve, promise: promise2 } = promiseWithResolvers();
  let controller;
  const stream = createAssistantStream((c) => {
    controller = c;
    controller.__internal_subscribeToClose(resolve);
    return promise2;
  });
  return [stream, controller];
}

// node_modules/assistant-stream/dist/core/utils/stream/AssistantTransformStream.js
var AssistantTransformStream = class extends TransformStream {
  constructor(transformer, writableStrategy, readableStrategy) {
    const [stream, runController] = createAssistantStreamController();
    let runPipeTask;
    super({
      start(controller) {
        var _a3;
        runPipeTask = stream.pipeTo(new WritableStream({
          write(chunk) {
            controller.enqueue(chunk);
          },
          abort(reason) {
            controller.error(reason);
          },
          close() {
            controller.terminate();
          }
        })).catch((error48) => {
          controller.error(error48);
        });
        return (_a3 = transformer.start) == null ? void 0 : _a3.call(transformer, runController);
      },
      transform(chunk) {
        var _a3;
        return (_a3 = transformer.transform) == null ? void 0 : _a3.call(transformer, chunk, runController);
      },
      async flush() {
        var _a3;
        await ((_a3 = transformer.flush) == null ? void 0 : _a3.call(transformer, runController));
        runController.close();
        await runPipeTask;
      }
    }, writableStrategy, readableStrategy);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/ThreadMessageLike.js
var fromThreadMessageLike = (like, fallbackId, fallbackStatus) => {
  const { role, id, createdAt, attachments, status, metadata } = like;
  const common = {
    id: id ?? fallbackId,
    createdAt: createdAt ?? /* @__PURE__ */ new Date()
  };
  const content = typeof like.content === "string" ? [{ type: "text", text: like.content }] : like.content;
  const sanitizeImageContent = ({ image, ...rest }) => {
    const match = image.match(/^data:image\/(png|jpeg|jpg|gif|webp);base64,(.*)$/);
    if (match) {
      return { ...rest, image };
    }
    console.warn(`Invalid image data format detected`);
    return null;
  };
  if (role !== "user" && (attachments == null ? void 0 : attachments.length))
    throw new Error("attachments are only supported for user messages");
  if (role !== "assistant" && status)
    throw new Error("status is only supported for assistant messages");
  if (role !== "assistant" && (metadata == null ? void 0 : metadata.steps))
    throw new Error("metadata.steps is only supported for assistant messages");
  switch (role) {
    case "assistant":
      return {
        ...common,
        role,
        content: content.map((part) => {
          const type = part.type;
          switch (type) {
            case "text":
            case "reasoning":
              if (part.text.trim().length === 0)
                return null;
              return part;
            case "file":
            case "source":
              return part;
            case "image":
              return sanitizeImageContent(part);
            case "data":
              return part;
            case "tool-call": {
              const { parentId, messages, ...basePart } = part;
              const commonProps = {
                ...basePart,
                toolCallId: part.toolCallId ?? `tool-${generateId()}`,
                ...parentId !== void 0 && { parentId },
                ...messages !== void 0 && { messages }
              };
              if (part.args) {
                return {
                  ...commonProps,
                  args: part.args,
                  argsText: part.argsText ?? JSON.stringify(part.args)
                };
              }
              return {
                ...commonProps,
                args: parsePartialJsonObject(part.argsText ?? "") ?? {},
                argsText: part.argsText ?? ""
              };
            }
            default: {
              const unhandledType = type;
              throw new Error(`Unsupported assistant message part type: ${unhandledType}`);
            }
          }
        }).filter((c) => !!c),
        status: status ?? fallbackStatus,
        metadata: {
          unstable_state: (metadata == null ? void 0 : metadata.unstable_state) ?? null,
          unstable_annotations: (metadata == null ? void 0 : metadata.unstable_annotations) ?? [],
          unstable_data: (metadata == null ? void 0 : metadata.unstable_data) ?? [],
          custom: (metadata == null ? void 0 : metadata.custom) ?? {},
          steps: (metadata == null ? void 0 : metadata.steps) ?? [],
          ...(metadata == null ? void 0 : metadata.submittedFeedback) && {
            submittedFeedback: metadata.submittedFeedback
          }
        }
      };
    case "user":
      return {
        ...common,
        role,
        content: content.map((part) => {
          const type = part.type;
          switch (type) {
            case "text":
            case "image":
            case "audio":
            case "file":
              return part;
            default: {
              const unhandledType = type;
              throw new Error(`Unsupported user message part type: ${unhandledType}`);
            }
          }
        }),
        attachments: attachments ?? [],
        metadata: {
          custom: (metadata == null ? void 0 : metadata.custom) ?? {}
        }
      };
    case "system":
      if (content.length !== 1 || content[0].type !== "text")
        throw new Error("System messages must have exactly one text message part.");
      return {
        ...common,
        role,
        content,
        metadata: {
          custom: (metadata == null ? void 0 : metadata.custom) ?? {}
        }
      };
    default: {
      const unsupportedRole = role;
      throw new Error(`Unknown message role: ${unsupportedRole}`);
    }
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/utils/MessageRepository.js
var ExportedMessageRepository = {
  /**
   * Converts an array of messages to an ExportedMessageRepository format.
   * Creates parent-child relationships based on the order of messages in the array.
   *
   * @param messages - Array of message-like objects to convert
   * @returns ExportedMessageRepository with parent-child relationships established
   */
  fromArray: (messages) => {
    const conv = messages.map((m) => fromThreadMessageLike(m, generateId(), getAutoStatus(false, false, false, false, void 0)));
    return {
      messages: conv.map((m, idx) => ({
        parentId: idx > 0 ? conv[idx - 1].id : null,
        message: m
      }))
    };
  }
};
var findHead = (message) => {
  if (message.next)
    return findHead(message.next);
  if ("current" in message)
    return message;
  return null;
};
var CachedValue = class {
  /**
   * @param func - The function that computes the cached value
   */
  constructor(func) {
    __publicField(this, "func");
    __publicField(this, "_value", null);
    this.func = func;
  }
  /**
   * Gets the cached value, computing it if necessary.
   */
  get value() {
    if (this._value === null) {
      this._value = this.func();
    }
    return this._value;
  }
  /**
   * Invalidates the cache, forcing recomputation on next access.
   */
  dirty() {
    this._value = null;
  }
};
var MessageRepository = class {
  constructor() {
    /** Map of message IDs to repository message objects */
    __publicField(this, "messages", /* @__PURE__ */ new Map());
    /** Reference to the current head (most recent) message in the active branch */
    __publicField(this, "head", null);
    /** Root node of the tree structure */
    __publicField(this, "root", {
      children: [],
      next: null
    });
    /** Cached array of messages in the current active branch, from root to head */
    __publicField(this, "_messages", new CachedValue(() => {
      var _a3;
      const messages = new Array((((_a3 = this.head) == null ? void 0 : _a3.level) ?? -1) + 1);
      for (let current = this.head; current; current = current.prev) {
        messages[current.level] = current.current;
      }
      return messages;
    }));
  }
  /**
   * Recursively updates the level of a message and all its descendants.
   *
   * @param message - The message to update
   * @param newLevel - The new level for the message
   */
  updateLevels(message, newLevel) {
    message.level = newLevel;
    for (const childId of message.children) {
      const childMessage = this.messages.get(childId);
      if (childMessage) {
        this.updateLevels(childMessage, newLevel + 1);
      }
    }
  }
  /**
   * Performs link/unlink operations between messages in the tree.
   *
   * @param newParent - The new parent message, or null
   * @param child - The child message to operate on
   * @param operation - The type of operation to perform:
   *   - "cut": Remove the child from its current parent
   *   - "link": Add the child to a new parent
   *   - "relink": Both cut and link operations
   */
  performOp(newParent, child, operation) {
    const parentOrRoot = child.prev ?? this.root;
    const newParentOrRoot = newParent ?? this.root;
    if (operation === "relink" && parentOrRoot === newParentOrRoot)
      return;
    if (operation !== "link") {
      parentOrRoot.children = parentOrRoot.children.filter((m) => m !== child.current.id);
      if (parentOrRoot.next === child) {
        const fallbackId = parentOrRoot.children.at(-1);
        const fallback = fallbackId ? this.messages.get(fallbackId) : null;
        if (fallback === void 0) {
          throw new Error("MessageRepository(performOp/cut): Fallback sibling message not found. This is likely an internal bug in assistant-ui.");
        }
        parentOrRoot.next = fallback;
      }
    }
    if (operation !== "cut") {
      for (let current = newParent; current; current = current.prev) {
        if (current.current.id === child.current.id) {
          throw new Error("MessageRepository(performOp/link): A message with the same id already exists in the parent tree. This error occurs if the same message id is found multiple times. This is likely an internal bug in assistant-ui.");
        }
      }
      newParentOrRoot.children = [
        ...newParentOrRoot.children,
        child.current.id
      ];
      if (findHead(child) === this.head || newParentOrRoot.next === null) {
        newParentOrRoot.next = child;
      }
      child.prev = newParent;
      const newLevel = newParent ? newParent.level + 1 : 0;
      this.updateLevels(child, newLevel);
    }
  }
  /**
   * Gets the ID of the current head message.
   * @returns The ID of the head message, or null if no messages exist
   */
  get headId() {
    var _a3;
    return ((_a3 = this.head) == null ? void 0 : _a3.current.id) ?? null;
  }
  /**
   * Gets all messages in the current active branch, from root to head.
   * @param headId - Optional ID of the head message to get messages for. If not provided, uses the current head.
   * @returns Array of messages in the specified branch
   */
  getMessages(headId) {
    var _a3;
    if (headId === void 0 || headId === ((_a3 = this.head) == null ? void 0 : _a3.current.id)) {
      return this._messages.value;
    }
    const headMessage = this.messages.get(headId);
    if (!headMessage) {
      throw new Error("MessageRepository(getMessages): Head message not found. This is likely an internal bug in assistant-ui.");
    }
    const messages = new Array(headMessage.level + 1);
    for (let current = headMessage; current; current = current.prev) {
      messages[current.level] = current.current;
    }
    return messages;
  }
  /**
   * Adds a new message or updates an existing one in the repository.
   * If the message ID already exists, the message is updated and potentially relinked to a new parent.
   * If the message is new, it's added as a child of the specified parent.
   *
   * @param parentId - ID of the parent message, or null for root messages
   * @param message - The message to add or update
   * @throws Error if the parent message is not found
   */
  addOrUpdateMessage(parentId, message) {
    const existingItem = this.messages.get(message.id);
    const prev = parentId ? this.messages.get(parentId) : null;
    if (prev === void 0)
      throw new Error("MessageRepository(addOrUpdateMessage): Parent message not found. This is likely an internal bug in assistant-ui.");
    if (existingItem) {
      existingItem.current = message;
      this.performOp(prev, existingItem, "relink");
      this._messages.dirty();
      return;
    }
    const newItem = {
      prev,
      current: message,
      next: null,
      children: [],
      level: prev ? prev.level + 1 : 0
    };
    this.messages.set(message.id, newItem);
    this.performOp(prev, newItem, "link");
    if (this.head === prev) {
      this.head = newItem;
    }
    this._messages.dirty();
  }
  /**
   * Gets a message and its parent ID by message ID.
   *
   * @param messageId - ID of the message to retrieve
   * @returns Object containing the message and its parent ID
   * @throws Error if the message is not found
   */
  getMessage(messageId) {
    var _a3;
    const message = this.messages.get(messageId);
    if (!message)
      throw new Error("MessageRepository(updateMessage): Message not found. This is likely an internal bug in assistant-ui.");
    return {
      parentId: ((_a3 = message.prev) == null ? void 0 : _a3.current.id) ?? null,
      message: message.current,
      index: message.level
    };
  }
  /**
   * Adds an optimistic message to the repository.
   * An optimistic message is a temporary placeholder that will be replaced by a real message later.
   *
   * @param parentId - ID of the parent message, or null for root messages
   * @param message - The core message to convert to an optimistic message
   * @returns The generated optimistic ID
   */
  appendOptimisticMessage(parentId, message) {
    let optimisticId;
    do {
      optimisticId = generateOptimisticId();
    } while (this.messages.has(optimisticId));
    this.addOrUpdateMessage(parentId, fromThreadMessageLike(message, optimisticId, { type: "running" }));
    return optimisticId;
  }
  /**
   * Deletes a message from the repository and relinks its children.
   *
   * @param messageId - ID of the message to delete
   * @param replacementId - Optional ID of the message to become the new parent of the children,
   *                       undefined means use the deleted message's parent,
   *                       null means use the root
   * @throws Error if the message or replacement is not found
   */
  deleteMessage(messageId, replacementId) {
    const message = this.messages.get(messageId);
    if (!message)
      throw new Error("MessageRepository(deleteMessage): Message not found. This is likely an internal bug in assistant-ui.");
    const replacement = replacementId === void 0 ? message.prev : replacementId === null ? null : this.messages.get(replacementId);
    if (replacement === void 0)
      throw new Error("MessageRepository(deleteMessage): Replacement not found. This is likely an internal bug in assistant-ui.");
    for (const child of message.children) {
      const childMessage = this.messages.get(child);
      if (!childMessage)
        throw new Error("MessageRepository(deleteMessage): Child message not found. This is likely an internal bug in assistant-ui.");
      this.performOp(replacement, childMessage, "relink");
    }
    this.performOp(null, message, "cut");
    this.messages.delete(messageId);
    if (this.head === message) {
      this.head = findHead(replacement ?? this.root);
    }
    this._messages.dirty();
  }
  /**
   * Gets all branch IDs (sibling messages) at the level of a specified message.
   *
   * @param messageId - ID of the message to find branches for
   * @returns Array of message IDs representing branches
   * @throws Error if the message is not found
   */
  getBranches(messageId) {
    const message = this.messages.get(messageId);
    if (!message)
      throw new Error("MessageRepository(getBranches): Message not found. This is likely an internal bug in assistant-ui.");
    const { children } = message.prev ?? this.root;
    return children;
  }
  /**
   * Switches the active branch to the one containing the specified message.
   *
   * @param messageId - ID of the message in the branch to switch to
   * @throws Error if the branch is not found
   */
  switchToBranch(messageId) {
    const message = this.messages.get(messageId);
    if (!message)
      throw new Error("MessageRepository(switchToBranch): Branch not found. This is likely an internal bug in assistant-ui.");
    const prevOrRoot = message.prev ?? this.root;
    prevOrRoot.next = message;
    this.head = findHead(message);
    this._messages.dirty();
  }
  /**
   * Resets the head to a specific message or null.
   *
   * @param messageId - ID of the message to set as head, or null to clear the head
   * @throws Error if the message is not found
   */
  resetHead(messageId) {
    if (messageId === null) {
      this.clear();
      return;
    }
    const message = this.messages.get(messageId);
    if (!message)
      throw new Error("MessageRepository(resetHead): Branch not found. This is likely an internal bug in assistant-ui.");
    if (message.children.length > 0) {
      const deleteDescendants = (msg) => {
        for (const childId of msg.children) {
          const childMessage = this.messages.get(childId);
          if (childMessage) {
            deleteDescendants(childMessage);
            this.messages.delete(childId);
          }
        }
      };
      deleteDescendants(message);
      message.children = [];
      message.next = null;
    }
    this.head = message;
    for (let current = message; current; current = current.prev) {
      if (current.prev) {
        current.prev.next = current;
      }
    }
    this._messages.dirty();
  }
  /**
   * Clears all messages from the repository.
   */
  clear() {
    this.messages.clear();
    this.head = null;
    this.root = {
      children: [],
      next: null
    };
    this._messages.dirty();
  }
  /**
   * Exports the repository state for persistence.
   *
   * @returns Exportable repository state
   */
  export() {
    var _a3, _b;
    const exportItems = [];
    for (const [, message] of this.messages) {
      exportItems.push({
        message: message.current,
        parentId: ((_a3 = message.prev) == null ? void 0 : _a3.current.id) ?? null
      });
    }
    return {
      headId: ((_b = this.head) == null ? void 0 : _b.current.id) ?? null,
      messages: exportItems
    };
  }
  /**
   * Imports repository state from an exported repository.
   *
   * @param repository - The exported repository state to import
   */
  import({ headId, messages }) {
    var _a3;
    for (const { message, parentId } of messages) {
      this.addOrUpdateMessage(parentId, message);
    }
    this.resetHead(headId ?? ((_a3 = messages.at(-1)) == null ? void 0 : _a3.message.id) ?? null);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/subscribable/BaseSubject.js
var BaseSubject = class {
  constructor() {
    __publicField(this, "_subscriptions", /* @__PURE__ */ new Set());
    __publicField(this, "_connection");
  }
  get isConnected() {
    return !!this._connection;
  }
  notifySubscribers() {
    for (const callback of this._subscriptions)
      callback();
  }
  _updateConnection() {
    var _a3;
    if (this._subscriptions.size > 0) {
      if (this._connection)
        return;
      this._connection = this._connect();
    } else {
      (_a3 = this._connection) == null ? void 0 : _a3.call(this);
      this._connection = void 0;
    }
  }
  subscribe(callback) {
    this._subscriptions.add(callback);
    this._updateConnection();
    return () => {
      this._subscriptions.delete(callback);
      this._updateConnection();
    };
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/subscribable/SKIP_UPDATE.js
var SKIP_UPDATE = Symbol("skip-update");

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/subscribable/LazyMemoizeSubject.js
var LazyMemoizeSubject = class extends BaseSubject {
  constructor(binding) {
    super();
    __publicField(this, "binding");
    __publicField(this, "_previousStateDirty", true);
    __publicField(this, "_previousState");
    __publicField(this, "getState", () => {
      if (!this.isConnected || this._previousStateDirty) {
        const newState = this.binding.getState();
        if (newState !== SKIP_UPDATE) {
          this._previousState = newState;
        }
        this._previousStateDirty = false;
      }
      if (this._previousState === void 0)
        throw new Error("Entry not available in the store");
      return this._previousState;
    });
    this.binding = binding;
  }
  get path() {
    return this.binding.path;
  }
  _connect() {
    const callback = () => {
      this._previousStateDirty = true;
      this.notifySubscribers();
    };
    return this.binding.subscribe(callback);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/ThreadListItemRuntime.js
var ThreadListItemRuntimeImpl = class {
  constructor(_core, _threadListBinding) {
    __publicField(this, "_core");
    __publicField(this, "_threadListBinding");
    this._core = _core;
    this._threadListBinding = _threadListBinding;
    this.__internal_bindMethods();
  }
  get path() {
    return this._core.path;
  }
  __internal_bindMethods() {
    this.switchTo = this.switchTo.bind(this);
    this.rename = this.rename.bind(this);
    this.archive = this.archive.bind(this);
    this.unarchive = this.unarchive.bind(this);
    this.delete = this.delete.bind(this);
    this.initialize = this.initialize.bind(this);
    this.generateTitle = this.generateTitle.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.unstable_on = this.unstable_on.bind(this);
    this.getState = this.getState.bind(this);
    this.detach = this.detach.bind(this);
  }
  getState() {
    return this._core.getState();
  }
  switchTo() {
    const state = this._core.getState();
    return this._threadListBinding.switchToThread(state.id);
  }
  rename(newTitle) {
    const state = this._core.getState();
    return this._threadListBinding.rename(state.id, newTitle);
  }
  archive() {
    const state = this._core.getState();
    return this._threadListBinding.archive(state.id);
  }
  unarchive() {
    const state = this._core.getState();
    return this._threadListBinding.unarchive(state.id);
  }
  delete() {
    const state = this._core.getState();
    return this._threadListBinding.delete(state.id);
  }
  initialize() {
    const state = this._core.getState();
    return this._threadListBinding.initialize(state.id);
  }
  generateTitle() {
    const state = this._core.getState();
    return this._threadListBinding.generateTitle(state.id);
  }
  unstable_on(event, callback) {
    let prevIsMain = this._core.getState().isMain;
    let prevThreadId = this._core.getState().id;
    return this.subscribe(() => {
      const currentState = this._core.getState();
      const newIsMain = currentState.isMain;
      const newThreadId = currentState.id;
      if (prevIsMain === newIsMain && prevThreadId === newThreadId)
        return;
      prevIsMain = newIsMain;
      prevThreadId = newThreadId;
      if (event === "switchedTo" && !newIsMain)
        return;
      if (event === "switchedAway" && newIsMain)
        return;
      callback();
    });
  }
  subscribe(callback) {
    return this._core.subscribe(callback);
  }
  detach() {
    const state = this._core.getState();
    this._threadListBinding.detach(state.id);
  }
  /** @internal */
  __internal_getRuntime() {
    return this;
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/subscribable/shallowEqual.js
function shallowEqual(objA, objB) {
  if (objA === void 0 && objB === void 0)
    return true;
  if (objA === void 0)
    return false;
  if (objB === void 0)
    return false;
  for (const key of Object.keys(objA)) {
    const valueA = objA[key];
    const valueB = objB[key];
    if (!Object.is(valueA, valueB))
      return false;
  }
  return true;
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/subscribable/ShallowMemoizeSubject.js
var ShallowMemoizeSubject = class extends BaseSubject {
  constructor(binding) {
    super();
    __publicField(this, "binding");
    __publicField(this, "_previousState");
    __publicField(this, "getState", () => {
      if (!this.isConnected)
        this._syncState();
      return this._previousState;
    });
    this.binding = binding;
    const state = binding.getState();
    if (state === SKIP_UPDATE)
      throw new Error("Entry not available in the store");
    this._previousState = state;
  }
  get path() {
    return this.binding.path;
  }
  _syncState() {
    const state = this.binding.getState();
    if (state === SKIP_UPDATE)
      return false;
    if (shallowEqual(state, this._previousState))
      return false;
    this._previousState = state;
    return true;
  }
  _connect() {
    const callback = () => {
      if (this._syncState()) {
        this.notifySubscribers();
      }
    };
    return this.binding.subscribe(callback);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/getExternalStoreMessage.js
var symbolInnerMessage = Symbol("innerMessage");
var symbolInnerMessages = Symbol("innerMessages");
var getExternalStoreMessage = (input) => {
  const withInnerMessages = input;
  return withInnerMessages[symbolInnerMessage];
};
var EMPTY_ARRAY = [];
var getExternalStoreMessages = (input) => {
  const container = "messages" in input ? input.messages : input;
  const value = container[symbolInnerMessages] || container[symbolInnerMessage];
  if (!value)
    return EMPTY_ARRAY;
  if (Array.isArray(value)) {
    return value;
  }
  container[symbolInnerMessages] = [value];
  return container[symbolInnerMessages];
};

// node_modules/@assistant-ui/react/dist/utils/getThreadMessageText.js
var getThreadMessageText = (message) => {
  const textParts = message.content.filter((part) => part.type === "text");
  return textParts.map((part) => part.text).join("\n\n");
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/AttachmentRuntime.js
var AttachmentRuntimeImpl = class {
  constructor(_core) {
    __publicField(this, "_core");
    this._core = _core;
    this.__internal_bindMethods();
  }
  get path() {
    return this._core.path;
  }
  __internal_bindMethods() {
    this.getState = this.getState.bind(this);
    this.remove = this.remove.bind(this);
    this.subscribe = this.subscribe.bind(this);
  }
  getState() {
    return this._core.getState();
  }
  subscribe(callback) {
    return this._core.subscribe(callback);
  }
};
var ComposerAttachmentRuntime = class extends AttachmentRuntimeImpl {
  constructor(core, _composerApi) {
    super(core);
    __publicField(this, "_composerApi");
    this._composerApi = _composerApi;
  }
  remove() {
    const core = this._composerApi.getState();
    if (!core)
      throw new Error("Composer is not available");
    return core.removeAttachment(this.getState().id);
  }
};
var ThreadComposerAttachmentRuntimeImpl = class extends ComposerAttachmentRuntime {
  get source() {
    return "thread-composer";
  }
};
var EditComposerAttachmentRuntimeImpl = class extends ComposerAttachmentRuntime {
  get source() {
    return "edit-composer";
  }
};
var MessageAttachmentRuntimeImpl = class extends AttachmentRuntimeImpl {
  get source() {
    return "message";
  }
  constructor(core) {
    super(core);
  }
  remove() {
    throw new Error("Message attachments cannot be removed");
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/subscribable/EventSubscriptionSubject.js
var EventSubscriptionSubject = class extends BaseSubject {
  constructor(config2) {
    super();
    __publicField(this, "config");
    this.config = config2;
  }
  getState() {
    return this.config.binding.getState();
  }
  outerSubscribe(callback) {
    return this.config.binding.subscribe(callback);
  }
  _connect() {
    const callback = () => {
      this.notifySubscribers();
    };
    let lastState = this.config.binding.getState();
    let innerUnsubscribe = lastState == null ? void 0 : lastState.unstable_on(this.config.event, callback);
    const onRuntimeUpdate = () => {
      var _a3;
      const newState = this.config.binding.getState();
      if (newState === lastState)
        return;
      lastState = newState;
      innerUnsubscribe == null ? void 0 : innerUnsubscribe();
      innerUnsubscribe = (_a3 = this.config.binding.getState()) == null ? void 0 : _a3.unstable_on(this.config.event, callback);
    };
    const outerUnsubscribe = this.outerSubscribe(onRuntimeUpdate);
    return () => {
      outerUnsubscribe == null ? void 0 : outerUnsubscribe();
      innerUnsubscribe == null ? void 0 : innerUnsubscribe();
    };
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/ComposerRuntime.js
var EMPTY_ARRAY2 = Object.freeze([]);
var EMPTY_OBJECT = Object.freeze({});
var getThreadComposerState = (runtime) => {
  return Object.freeze({
    type: "thread",
    isEditing: (runtime == null ? void 0 : runtime.isEditing) ?? false,
    canCancel: (runtime == null ? void 0 : runtime.canCancel) ?? false,
    isEmpty: (runtime == null ? void 0 : runtime.isEmpty) ?? true,
    attachments: (runtime == null ? void 0 : runtime.attachments) ?? EMPTY_ARRAY2,
    text: (runtime == null ? void 0 : runtime.text) ?? "",
    role: (runtime == null ? void 0 : runtime.role) ?? "user",
    runConfig: (runtime == null ? void 0 : runtime.runConfig) ?? EMPTY_OBJECT,
    attachmentAccept: (runtime == null ? void 0 : runtime.attachmentAccept) ?? "",
    dictation: runtime == null ? void 0 : runtime.dictation,
    value: (runtime == null ? void 0 : runtime.text) ?? ""
  });
};
var getEditComposerState = (runtime) => {
  return Object.freeze({
    type: "edit",
    isEditing: (runtime == null ? void 0 : runtime.isEditing) ?? false,
    canCancel: (runtime == null ? void 0 : runtime.canCancel) ?? false,
    isEmpty: (runtime == null ? void 0 : runtime.isEmpty) ?? true,
    text: (runtime == null ? void 0 : runtime.text) ?? "",
    role: (runtime == null ? void 0 : runtime.role) ?? "user",
    attachments: (runtime == null ? void 0 : runtime.attachments) ?? EMPTY_ARRAY2,
    runConfig: (runtime == null ? void 0 : runtime.runConfig) ?? EMPTY_OBJECT,
    attachmentAccept: (runtime == null ? void 0 : runtime.attachmentAccept) ?? "",
    dictation: runtime == null ? void 0 : runtime.dictation,
    value: (runtime == null ? void 0 : runtime.text) ?? ""
  });
};
var ComposerRuntimeImpl = class {
  constructor(_core) {
    __publicField(this, "_core");
    __publicField(this, "_eventSubscriptionSubjects", /* @__PURE__ */ new Map());
    this._core = _core;
  }
  get path() {
    return this._core.path;
  }
  __internal_bindMethods() {
    this.setText = this.setText.bind(this);
    this.setRunConfig = this.setRunConfig.bind(this);
    this.getState = this.getState.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.addAttachment = this.addAttachment.bind(this);
    this.reset = this.reset.bind(this);
    this.clearAttachments = this.clearAttachments.bind(this);
    this.send = this.send.bind(this);
    this.cancel = this.cancel.bind(this);
    this.setRole = this.setRole.bind(this);
    this.getAttachmentByIndex = this.getAttachmentByIndex.bind(this);
    this.startDictation = this.startDictation.bind(this);
    this.stopDictation = this.stopDictation.bind(this);
    this.unstable_on = this.unstable_on.bind(this);
  }
  setText(text) {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    core.setText(text);
  }
  setRunConfig(runConfig) {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    core.setRunConfig(runConfig);
  }
  addAttachment(file2) {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    return core.addAttachment(file2);
  }
  reset() {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    return core.reset();
  }
  clearAttachments() {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    return core.clearAttachments();
  }
  send() {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    core.send();
  }
  cancel() {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    core.cancel();
  }
  setRole(role) {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    core.setRole(role);
  }
  startDictation() {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    core.startDictation();
  }
  stopDictation() {
    const core = this._core.getState();
    if (!core)
      throw new Error("Composer is not available");
    core.stopDictation();
  }
  subscribe(callback) {
    return this._core.subscribe(callback);
  }
  unstable_on(event, callback) {
    let subject = this._eventSubscriptionSubjects.get(event);
    if (!subject) {
      subject = new EventSubscriptionSubject({
        event,
        binding: this._core
      });
      this._eventSubscriptionSubjects.set(event, subject);
    }
    return subject.subscribe(callback);
  }
};
var ThreadComposerRuntimeImpl = class extends ComposerRuntimeImpl {
  constructor(core) {
    const stateBinding = new LazyMemoizeSubject({
      path: core.path,
      getState: () => getThreadComposerState(core.getState()),
      subscribe: (callback) => core.subscribe(callback)
    });
    super({
      path: core.path,
      getState: () => core.getState(),
      subscribe: (callback) => stateBinding.subscribe(callback)
    });
    __publicField(this, "_getState");
    this._getState = stateBinding.getState.bind(stateBinding);
    this.__internal_bindMethods();
  }
  get path() {
    return this._core.path;
  }
  get type() {
    return "thread";
  }
  getState() {
    return this._getState();
  }
  getAttachmentByIndex(idx) {
    return new ThreadComposerAttachmentRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ...this.path,
        attachmentSource: "thread-composer",
        attachmentSelector: { type: "index", index: idx },
        ref: `${this.path.ref}.attachments[${idx}]`
      },
      getState: () => {
        const attachments = this.getState().attachments;
        const attachment = attachments[idx];
        if (!attachment)
          return SKIP_UPDATE;
        return {
          ...attachment,
          source: "thread-composer"
        };
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }), this._core);
  }
};
var EditComposerRuntimeImpl = class extends ComposerRuntimeImpl {
  constructor(core, _beginEdit) {
    const stateBinding = new LazyMemoizeSubject({
      path: core.path,
      getState: () => getEditComposerState(core.getState()),
      subscribe: (callback) => core.subscribe(callback)
    });
    super({
      path: core.path,
      getState: () => core.getState(),
      subscribe: (callback) => stateBinding.subscribe(callback)
    });
    __publicField(this, "_beginEdit");
    __publicField(this, "_getState");
    this._beginEdit = _beginEdit;
    this._getState = stateBinding.getState.bind(stateBinding);
    this.__internal_bindMethods();
  }
  get path() {
    return this._core.path;
  }
  get type() {
    return "edit";
  }
  __internal_bindMethods() {
    super.__internal_bindMethods();
    this.beginEdit = this.beginEdit.bind(this);
  }
  getState() {
    return this._getState();
  }
  beginEdit() {
    this._beginEdit();
  }
  getAttachmentByIndex(idx) {
    return new EditComposerAttachmentRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ...this.path,
        attachmentSource: "edit-composer",
        attachmentSelector: { type: "index", index: idx },
        ref: `${this.path.ref}.attachments[${idx}]`
      },
      getState: () => {
        const attachments = this.getState().attachments;
        const attachment = attachments[idx];
        if (!attachment)
          return SKIP_UPDATE;
        return {
          ...attachment,
          source: "edit-composer"
        };
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }), this._core);
  }
};

// node_modules/assistant-stream/dist/core/object/ObjectStreamAccumulator.js
var ObjectStreamAccumulator = class _ObjectStreamAccumulator {
  constructor(initialValue = null) {
    __publicField(this, "_state");
    this._state = initialValue;
  }
  get state() {
    return this._state;
  }
  append(ops) {
    this._state = ops.reduce((state, op) => _ObjectStreamAccumulator.apply(state, op), this._state);
  }
  static apply(state, op) {
    const type = op.type;
    switch (type) {
      case "set":
        return _ObjectStreamAccumulator.updatePath(state, op.path, () => op.value);
      case "append-text":
        return _ObjectStreamAccumulator.updatePath(state, op.path, (current) => {
          if (typeof current !== "string")
            throw new Error(`Expected string at path [${op.path.join(", ")}]`);
          return current + op.value;
        });
      default: {
        const _exhaustiveCheck = type;
        throw new Error(`Invalid operation type: ${_exhaustiveCheck}`);
      }
    }
  }
  static updatePath(state, path, updater) {
    if (path.length === 0)
      return updater(state);
    state ?? (state = {});
    if (typeof state !== "object") {
      throw new Error(`Invalid path: [${path.join(", ")}]`);
    }
    const [key, ...rest] = path;
    if (Array.isArray(state)) {
      const idx = Number(key);
      if (Number.isNaN(idx))
        throw new Error(`Expected array index at [${path.join(", ")}]`);
      if (idx > state.length || idx < 0)
        throw new Error(`Insert array index out of bounds`);
      const nextState2 = [...state];
      nextState2[idx] = this.updatePath(nextState2[idx], rest, updater);
      return nextState2;
    }
    const nextState = { ...state };
    nextState[key] = this.updatePath(nextState[key], rest, updater);
    return nextState;
  }
};

// node_modules/assistant-stream/dist/core/accumulators/assistant-message-accumulator.js
var createInitialMessage = ({ unstable_state = null } = {}) => ({
  role: "assistant",
  status: { type: "running" },
  parts: [],
  get content() {
    return this.parts;
  },
  metadata: {
    unstable_state,
    unstable_data: [],
    unstable_annotations: [],
    steps: [],
    custom: {}
  }
});
var updatePartForPath = (message, chunk, updater) => {
  if (message.parts.length === 0) {
    throw new Error("No parts available to update.");
  }
  if (chunk.path.length !== 1)
    throw new Error("Nested paths are not supported yet.");
  const partIndex = chunk.path[0];
  const updatedPart = updater(message.parts[partIndex]);
  return {
    ...message,
    parts: [
      ...message.parts.slice(0, partIndex),
      updatedPart,
      ...message.parts.slice(partIndex + 1)
    ],
    get content() {
      return this.parts;
    }
  };
};
var handlePartStart = (message, chunk) => {
  const partInit = chunk.part;
  if (partInit.type === "text" || partInit.type === "reasoning") {
    const newTextPart = {
      type: partInit.type,
      text: "",
      status: { type: "running" },
      ...partInit.parentId && { parentId: partInit.parentId }
    };
    return {
      ...message,
      parts: [...message.parts, newTextPart],
      get content() {
        return this.parts;
      }
    };
  } else if (partInit.type === "tool-call") {
    const newToolCallPart = {
      type: "tool-call",
      state: "partial-call",
      status: { type: "running", isArgsComplete: false },
      toolCallId: partInit.toolCallId,
      toolName: partInit.toolName,
      argsText: "",
      args: {},
      ...partInit.parentId && { parentId: partInit.parentId }
    };
    return {
      ...message,
      parts: [...message.parts, newToolCallPart],
      get content() {
        return this.parts;
      }
    };
  } else if (partInit.type === "source") {
    const newSourcePart = {
      type: "source",
      sourceType: partInit.sourceType,
      id: partInit.id,
      url: partInit.url,
      ...partInit.title ? { title: partInit.title } : void 0,
      ...partInit.parentId && { parentId: partInit.parentId }
    };
    return {
      ...message,
      parts: [...message.parts, newSourcePart],
      get content() {
        return this.parts;
      }
    };
  } else if (partInit.type === "file") {
    const newFilePart = {
      type: "file",
      mimeType: partInit.mimeType,
      data: partInit.data
    };
    return {
      ...message,
      parts: [...message.parts, newFilePart],
      get content() {
        return this.parts;
      }
    };
  } else {
    throw new Error(`Unsupported part type: ${partInit.type}`);
  }
};
var handleToolCallArgsTextFinish = (message, chunk) => {
  return updatePartForPath(message, chunk, (part) => {
    if (part.type !== "tool-call") {
      throw new Error("Last is not a tool call");
    }
    if (part.state !== "partial-call")
      return part;
    return {
      ...part,
      state: "call"
    };
  });
};
var handlePartFinish = (message, chunk) => {
  return updatePartForPath(message, chunk, (part) => ({
    ...part,
    status: { type: "complete", reason: "unknown" }
  }));
};
var handleTextDelta = (message, chunk) => {
  return updatePartForPath(message, chunk, (part) => {
    if (part.type === "text" || part.type === "reasoning") {
      return { ...part, text: part.text + chunk.textDelta };
    } else if (part.type === "tool-call") {
      const newArgsText = part.argsText + chunk.textDelta;
      const newArgs = parsePartialJsonObject(newArgsText) ?? part.args;
      return { ...part, argsText: newArgsText, args: newArgs };
    } else {
      throw new Error("text-delta received but part is neither text nor tool-call");
    }
  });
};
var handleResult = (message, chunk) => {
  return updatePartForPath(message, chunk, (part) => {
    if (part.type === "tool-call") {
      return {
        ...part,
        state: "result",
        ...chunk.artifact !== void 0 ? { artifact: chunk.artifact } : {},
        result: chunk.result,
        isError: chunk.isError ?? false,
        status: { type: "complete", reason: "stop" }
      };
    } else {
      throw new Error("Result chunk received but part is not a tool-call");
    }
  });
};
var handleMessageFinish = (message, chunk) => {
  var _a3, _b;
  if (((_a3 = message.status) == null ? void 0 : _a3.type) === "incomplete" && ((_b = message.status) == null ? void 0 : _b.reason) === "error") {
    return message;
  }
  const newStatus = getStatus(chunk);
  return { ...message, status: newStatus };
};
var getStatus = (chunk) => {
  if (chunk.finishReason === "tool-calls") {
    return {
      type: "requires-action",
      reason: "tool-calls"
    };
  } else if (chunk.finishReason === "stop" || chunk.finishReason === "unknown") {
    return {
      type: "complete",
      reason: chunk.finishReason
    };
  } else {
    return {
      type: "incomplete",
      reason: chunk.finishReason
    };
  }
};
var handleAnnotations = (message, chunk) => {
  return {
    ...message,
    metadata: {
      ...message.metadata,
      unstable_annotations: [
        ...message.metadata.unstable_annotations,
        ...chunk.annotations
      ]
    }
  };
};
var handleData = (message, chunk) => {
  return {
    ...message,
    metadata: {
      ...message.metadata,
      unstable_data: [...message.metadata.unstable_data, ...chunk.data]
    }
  };
};
var handleStepStart = (message, chunk) => {
  return {
    ...message,
    metadata: {
      ...message.metadata,
      steps: [
        ...message.metadata.steps,
        { state: "started", messageId: chunk.messageId }
      ]
    }
  };
};
var handleStepFinish = (message, chunk) => {
  var _a3;
  const steps = message.metadata.steps.slice();
  const lastIndex = steps.length - 1;
  if (steps.length > 0 && ((_a3 = steps[lastIndex]) == null ? void 0 : _a3.state) === "started") {
    steps[lastIndex] = {
      ...steps[lastIndex],
      state: "finished",
      finishReason: chunk.finishReason,
      usage: chunk.usage,
      isContinued: chunk.isContinued
    };
  } else {
    steps.push({
      state: "finished",
      messageId: generateId2(),
      finishReason: chunk.finishReason,
      usage: chunk.usage,
      isContinued: chunk.isContinued
    });
  }
  return {
    ...message,
    metadata: {
      ...message.metadata,
      steps
    }
  };
};
var handleErrorChunk = (message, chunk) => {
  return {
    ...message,
    status: { type: "incomplete", reason: "error", error: chunk.error }
  };
};
var handleUpdateState = (message, chunk) => {
  const acc = new ObjectStreamAccumulator(message.metadata.unstable_state);
  acc.append(chunk.operations);
  return {
    ...message,
    metadata: {
      ...message.metadata,
      unstable_state: acc.state
    }
  };
};
var throttleCallback = (callback) => {
  let hasScheduled = false;
  return () => {
    if (hasScheduled)
      return;
    hasScheduled = true;
    queueMicrotask(() => {
      hasScheduled = false;
      callback();
    });
  };
};
var AssistantMessageAccumulator = class extends TransformStream {
  constructor({ initialMessage, throttle, onError } = {}) {
    let message = initialMessage ?? createInitialMessage();
    let controller;
    const emitChunk = throttle ? throttleCallback(() => {
      controller == null ? void 0 : controller.enqueue(message);
    }) : () => {
      controller == null ? void 0 : controller.enqueue(message);
    };
    super({
      start(c) {
        controller = c;
      },
      transform(chunk) {
        const type = chunk.type;
        switch (type) {
          case "part-start":
            message = handlePartStart(message, chunk);
            break;
          case "tool-call-args-text-finish":
            message = handleToolCallArgsTextFinish(message, chunk);
            break;
          case "part-finish":
            message = handlePartFinish(message, chunk);
            break;
          case "text-delta":
            message = handleTextDelta(message, chunk);
            break;
          case "result":
            message = handleResult(message, chunk);
            break;
          case "message-finish":
            message = handleMessageFinish(message, chunk);
            break;
          case "annotations":
            message = handleAnnotations(message, chunk);
            break;
          case "data":
            message = handleData(message, chunk);
            break;
          case "step-start":
            message = handleStepStart(message, chunk);
            break;
          case "step-finish":
            message = handleStepFinish(message, chunk);
            break;
          case "error":
            message = handleErrorChunk(message, chunk);
            onError == null ? void 0 : onError(chunk.error);
            break;
          case "update-state":
            message = handleUpdateState(message, chunk);
            break;
          default: {
            const unhandledType = type;
            throw new Error(`Unsupported chunk type: ${unhandledType}`);
          }
        }
        emitChunk();
      },
      flush(controller2) {
        var _a3, _b;
        if (((_a3 = message.status) == null ? void 0 : _a3.type) === "running") {
          const requiresAction = ((_b = message.parts) == null ? void 0 : _b.some((part) => part.type === "tool-call" && (part.state === "call" || part.state === "partial-call") && part.result === void 0)) ?? false;
          message = handleMessageFinish(message, {
            type: "message-finish",
            path: [],
            finishReason: requiresAction ? "tool-calls" : "unknown",
            usage: {
              promptTokens: 0,
              completionTokens: 0
            }
          });
          controller2.enqueue(message);
        }
      }
    });
  }
};

// node_modules/assistant-stream/dist/core/serialization/PlainText.js
var PlainTextDecoder = class extends PipeableTransformStream {
  constructor() {
    super((readable) => {
      const transform2 = new AssistantTransformStream({
        transform(chunk, controller) {
          controller.appendText(chunk);
        }
      });
      return readable.pipeThrough(new TextDecoderStream()).pipeThrough(transform2);
    });
  }
};

// node_modules/assistant-stream/dist/core/serialization/assistant-transport/AssistantTransport.js
var SSEEventStream = class extends TransformStream {
  constructor() {
    let eventBuffer = {};
    let dataLines = [];
    super({
      start() {
        eventBuffer = {};
        dataLines = [];
      },
      transform(line, controller) {
        if (line.startsWith(":"))
          return;
        if (line === "") {
          if (dataLines.length > 0) {
            controller.enqueue({
              event: eventBuffer.event || "message",
              data: dataLines.join("\n"),
              id: eventBuffer.id,
              retry: eventBuffer.retry
            });
          }
          eventBuffer = {};
          dataLines = [];
          return;
        }
        const [field, ...rest] = line.split(":");
        const value = rest.join(":").trimStart();
        switch (field) {
          case "event":
            eventBuffer.event = value;
            break;
          case "data":
            dataLines.push(value);
            break;
          case "id":
            eventBuffer.id = value;
            break;
          case "retry":
            eventBuffer.retry = Number(value);
            break;
        }
      },
      flush(controller) {
        if (dataLines.length > 0) {
          controller.enqueue({
            event: eventBuffer.event || "message",
            data: dataLines.join("\n"),
            id: eventBuffer.id,
            retry: eventBuffer.retry
          });
        }
      }
    });
  }
};
var AssistantTransportDecoder = class extends PipeableTransformStream {
  constructor() {
    super((readable) => {
      let receivedDone = false;
      return readable.pipeThrough(new TextDecoderStream()).pipeThrough(new LineDecoderStream()).pipeThrough(new SSEEventStream()).pipeThrough(new TransformStream({
        transform(event, controller) {
          switch (event.event) {
            case "message":
              if (event.data === "[DONE]") {
                receivedDone = true;
                controller.terminate();
              } else {
                controller.enqueue(JSON.parse(event.data));
              }
              break;
            default:
              throw new Error(`Unknown SSE event type: ${event.event}`);
          }
        },
        flush() {
          if (!receivedDone) {
            throw new Error("Stream ended abruptly without receiving [DONE] marker");
          }
        }
      }));
    });
  }
};

// node_modules/assistant-stream/dist/core/serialization/ui-message-stream/UIMessageStream.js
var SSEEventStream2 = class extends TransformStream {
  constructor() {
    let eventBuffer = {};
    let dataLines = [];
    super({
      start() {
        eventBuffer = {};
        dataLines = [];
      },
      transform(line, controller) {
        if (line.startsWith(":"))
          return;
        if (line === "") {
          if (dataLines.length > 0) {
            controller.enqueue({
              event: eventBuffer.event || "message",
              data: dataLines.join("\n"),
              id: eventBuffer.id,
              retry: eventBuffer.retry
            });
          }
          eventBuffer = {};
          dataLines = [];
          return;
        }
        const [field, ...rest] = line.split(":");
        const value = rest.join(":").trimStart();
        switch (field) {
          case "event":
            eventBuffer.event = value;
            break;
          case "data":
            dataLines.push(value);
            break;
          case "id":
            eventBuffer.id = value;
            break;
          case "retry":
            eventBuffer.retry = Number(value);
            break;
        }
      },
      flush(controller) {
        if (dataLines.length > 0) {
          controller.enqueue({
            event: eventBuffer.event || "message",
            data: dataLines.join("\n"),
            id: eventBuffer.id,
            retry: eventBuffer.retry
          });
        }
      }
    });
  }
};

// node_modules/assistant-stream/dist/core/accumulators/AssistantMessageStream.js
var AssistantMessageStream = class _AssistantMessageStream {
  constructor(readable) {
    __publicField(this, "readable");
    this.readable = readable;
    this.readable = readable;
  }
  static fromAssistantStream(stream) {
    return new _AssistantMessageStream(stream.pipeThrough(new AssistantMessageAccumulator()));
  }
  async unstable_result() {
    let last;
    for await (const chunk of this) {
      last = chunk;
    }
    if (!last) {
      return {
        role: "assistant",
        status: { type: "complete", reason: "unknown" },
        parts: [],
        content: [],
        metadata: {
          unstable_state: null,
          unstable_data: [],
          unstable_annotations: [],
          steps: [],
          custom: {}
        }
      };
    }
    return last;
  }
  [Symbol.asyncIterator]() {
    const reader = this.readable.getReader();
    return {
      async next() {
        const { done, value } = await reader.read();
        return done ? { done: true, value: void 0 } : { done: false, value };
      }
    };
  }
  tee() {
    const [readable1, readable2] = this.readable.tee();
    return [
      new _AssistantMessageStream(readable1),
      new _AssistantMessageStream(readable2)
    ];
  }
};

// node_modules/assistant-stream/dist/core/tool/ToolResponse.js
var TOOL_RESPONSE_SYMBOL = Symbol.for("aui.tool-response");
var ToolResponse = class _ToolResponse {
  constructor(options) {
    __publicField(this, "artifact");
    __publicField(this, "result");
    __publicField(this, "isError");
    if (options.artifact !== void 0) {
      this.artifact = options.artifact;
    }
    this.result = options.result;
    this.isError = options.isError ?? false;
  }
  get [TOOL_RESPONSE_SYMBOL]() {
    return true;
  }
  static [Symbol.hasInstance](obj) {
    return typeof obj === "object" && obj !== null && TOOL_RESPONSE_SYMBOL in obj;
  }
  static toResponse(result) {
    if (result instanceof _ToolResponse) {
      return result;
    }
    return new _ToolResponse({
      result: result === void 0 ? "<no result>" : result
    });
  }
};

// node_modules/assistant-stream/dist/core/tool/ToolExecutionStream.js
var import_secure_json_parse2 = __toESM(require_secure_json_parse(), 1);

// node_modules/assistant-stream/dist/core/utils/withPromiseOrValue.js
function withPromiseOrValue(callback, thenHandler, catchHandler) {
  try {
    const promiseOrValue = callback();
    if (typeof promiseOrValue === "object" && promiseOrValue !== null && "then" in promiseOrValue) {
      return promiseOrValue.then(thenHandler, catchHandler);
    } else {
      thenHandler(promiseOrValue);
    }
  } catch (e) {
    catchHandler(e);
  }
}

// node_modules/assistant-stream/dist/core/tool/ToolCallReader.js
function getField(obj, fieldPath) {
  let current = obj;
  for (const key of fieldPath) {
    if (current === void 0 || current === null) {
      return void 0;
    }
    current = current[key];
  }
  return current;
}
var GetHandle = class {
  constructor(resolve, reject, fieldPath) {
    __publicField(this, "resolve");
    __publicField(this, "reject");
    __publicField(this, "disposed", false);
    __publicField(this, "fieldPath");
    this.resolve = resolve;
    this.reject = reject;
    this.fieldPath = fieldPath;
  }
  update(args) {
    if (this.disposed)
      return;
    try {
      if (getPartialJsonObjectFieldState(args, this.fieldPath) === "complete") {
        const value = getField(args, this.fieldPath);
        if (value !== void 0) {
          this.resolve(value);
          this.dispose();
        }
      }
    } catch (e) {
      this.reject(e);
      this.dispose();
    }
  }
  dispose() {
    this.disposed = true;
  }
};
var StreamValuesHandle = class {
  constructor(controller, fieldPath) {
    __publicField(this, "controller");
    __publicField(this, "disposed", false);
    __publicField(this, "fieldPath");
    this.controller = controller;
    this.fieldPath = fieldPath;
  }
  update(args) {
    if (this.disposed)
      return;
    try {
      const value = getField(args, this.fieldPath);
      if (value !== void 0) {
        this.controller.enqueue(value);
      }
      if (getPartialJsonObjectFieldState(args, this.fieldPath) === "complete") {
        this.controller.close();
        this.dispose();
      }
    } catch (e) {
      this.controller.error(e);
      this.dispose();
    }
  }
  dispose() {
    this.disposed = true;
  }
};
var StreamTextHandle = class {
  constructor(controller, fieldPath) {
    __publicField(this, "controller");
    __publicField(this, "disposed", false);
    __publicField(this, "fieldPath");
    __publicField(this, "lastValue");
    this.controller = controller;
    this.fieldPath = fieldPath;
  }
  update(args) {
    var _a3;
    if (this.disposed)
      return;
    try {
      const value = getField(args, this.fieldPath);
      if (value !== void 0 && typeof value === "string") {
        const delta = value.substring(((_a3 = this.lastValue) == null ? void 0 : _a3.length) || 0);
        this.lastValue = value;
        this.controller.enqueue(delta);
      }
      if (getPartialJsonObjectFieldState(args, this.fieldPath) === "complete") {
        this.controller.close();
        this.dispose();
      }
    } catch (e) {
      this.controller.error(e);
      this.dispose();
    }
  }
  dispose() {
    this.disposed = true;
  }
};
var ForEachHandle = class {
  constructor(controller, fieldPath) {
    __publicField(this, "controller");
    __publicField(this, "disposed", false);
    __publicField(this, "fieldPath");
    __publicField(this, "processedIndexes", /* @__PURE__ */ new Set());
    this.controller = controller;
    this.fieldPath = fieldPath;
  }
  update(args) {
    if (this.disposed)
      return;
    try {
      const array2 = getField(args, this.fieldPath);
      if (!Array.isArray(array2)) {
        return;
      }
      for (let i = 0; i < array2.length; i++) {
        if (!this.processedIndexes.has(i)) {
          const elementPath = [...this.fieldPath, i];
          if (getPartialJsonObjectFieldState(args, elementPath) === "complete") {
            this.controller.enqueue(array2[i]);
            this.processedIndexes.add(i);
          }
        }
      }
      if (getPartialJsonObjectFieldState(args, this.fieldPath) === "complete") {
        this.controller.close();
        this.dispose();
      }
    } catch (e) {
      this.controller.error(e);
      this.dispose();
    }
  }
  dispose() {
    this.disposed = true;
  }
};
var ToolCallArgsReaderImpl = class {
  constructor(argTextDeltas) {
    __publicField(this, "argTextDeltas");
    __publicField(this, "handles", /* @__PURE__ */ new Set());
    __publicField(this, "args", parsePartialJsonObject(""));
    this.argTextDeltas = argTextDeltas;
    this.processStream();
  }
  async processStream() {
    try {
      let accumulatedText = "";
      const reader = this.argTextDeltas.getReader();
      while (true) {
        const { value, done } = await reader.read();
        if (done)
          break;
        accumulatedText += value;
        const parsedArgs = parsePartialJsonObject(accumulatedText);
        if (parsedArgs !== void 0) {
          this.args = parsedArgs;
          for (const handle of this.handles) {
            handle.update(parsedArgs);
          }
        }
      }
    } catch (error48) {
      console.error("Error processing argument stream:", error48);
      for (const handle of this.handles) {
        handle.dispose();
      }
    }
  }
  get(...fieldPath) {
    return new Promise((resolve, reject) => {
      const handle = new GetHandle(resolve, reject, fieldPath);
      if (this.args && getPartialJsonObjectFieldState(this.args, fieldPath) === "complete") {
        const value = getField(this.args, fieldPath);
        if (value !== void 0) {
          resolve(value);
          return;
        }
      }
      this.handles.add(handle);
      handle.update(this.args);
    });
  }
  streamValues(...fieldPath) {
    const simplePath = fieldPath;
    const stream = new ReadableStream({
      start: (controller) => {
        const handle = new StreamValuesHandle(controller, simplePath);
        this.handles.add(handle);
        handle.update(this.args);
      },
      cancel: () => {
        for (const handle of this.handles) {
          if (handle instanceof StreamValuesHandle) {
            handle.dispose();
            this.handles.delete(handle);
            break;
          }
        }
      }
    });
    return asAsyncIterableStream(stream);
  }
  streamText(...fieldPath) {
    const simplePath = fieldPath;
    const stream = new ReadableStream({
      start: (controller) => {
        const handle = new StreamTextHandle(controller, simplePath);
        this.handles.add(handle);
        handle.update(this.args);
      },
      cancel: () => {
        for (const handle of this.handles) {
          if (handle instanceof StreamTextHandle) {
            handle.dispose();
            this.handles.delete(handle);
            break;
          }
        }
      }
    });
    return asAsyncIterableStream(stream);
  }
  forEach(...fieldPath) {
    const simplePath = fieldPath;
    const stream = new ReadableStream({
      start: (controller) => {
        const handle = new ForEachHandle(controller, simplePath);
        this.handles.add(handle);
        handle.update(this.args);
      },
      cancel: () => {
        for (const handle of this.handles) {
          if (handle instanceof ForEachHandle) {
            handle.dispose();
            this.handles.delete(handle);
            break;
          }
        }
      }
    });
    return asAsyncIterableStream(stream);
  }
};
var ToolCallResponseReaderImpl = class {
  constructor(promise2) {
    __publicField(this, "promise");
    this.promise = promise2;
  }
  get() {
    return this.promise;
  }
};
var ToolCallReaderImpl = class {
  constructor() {
    __publicField(this, "args");
    __publicField(this, "response");
    __publicField(this, "writable");
    __publicField(this, "resolve");
    __publicField(this, "argsText", "");
    __publicField(this, "result", {
      get: async () => {
        const response = await this.response.get();
        return response.result;
      }
    });
    const stream = new TransformStream();
    this.writable = stream.writable;
    this.args = new ToolCallArgsReaderImpl(stream.readable);
    const { promise: promise2, resolve } = promiseWithResolvers();
    this.resolve = resolve;
    this.response = new ToolCallResponseReaderImpl(promise2);
  }
  async appendArgsTextDelta(text) {
    const writer = this.writable.getWriter();
    try {
      await writer.write(text);
    } catch (err) {
      console.warn(err);
    } finally {
      writer.releaseLock();
    }
    this.argsText += text;
  }
  setResponse(value) {
    this.resolve(value);
  }
};

// node_modules/assistant-stream/dist/core/tool/ToolExecutionStream.js
var ToolExecutionStream = class extends PipeableTransformStream {
  constructor(options) {
    const toolCallPromises = /* @__PURE__ */ new Map();
    const toolCallControllers = /* @__PURE__ */ new Map();
    super((readable) => {
      const transform2 = new TransformStream({
        transform(chunk, controller) {
          if (chunk.type !== "part-finish" || chunk.meta.type !== "tool-call") {
            controller.enqueue(chunk);
          }
          const type = chunk.type;
          switch (type) {
            case "part-start":
              if (chunk.part.type === "tool-call") {
                const reader = new ToolCallReaderImpl();
                toolCallControllers.set(chunk.part.toolCallId, reader);
                options.streamCall({
                  reader,
                  toolCallId: chunk.part.toolCallId,
                  toolName: chunk.part.toolName
                });
              }
              break;
            case "text-delta": {
              if (chunk.meta.type === "tool-call") {
                const toolCallId = chunk.meta.toolCallId;
                const controller2 = toolCallControllers.get(toolCallId);
                if (!controller2)
                  throw new Error("No controller found for tool call");
                controller2.appendArgsTextDelta(chunk.textDelta);
              }
              break;
            }
            case "result": {
              if (chunk.meta.type !== "tool-call")
                break;
              const { toolCallId } = chunk.meta;
              const controller2 = toolCallControllers.get(toolCallId);
              if (!controller2)
                throw new Error("No controller found for tool call");
              controller2.setResponse(new ToolResponse({
                result: chunk.result,
                artifact: chunk.artifact,
                isError: chunk.isError
              }));
              break;
            }
            case "tool-call-args-text-finish": {
              if (chunk.meta.type !== "tool-call")
                break;
              const { toolCallId, toolName } = chunk.meta;
              const streamController = toolCallControllers.get(toolCallId);
              if (!streamController)
                throw new Error("No controller found for tool call");
              let isExecuting = false;
              const promise2 = withPromiseOrValue(() => {
                var _a3;
                let args;
                try {
                  args = import_secure_json_parse2.default.parse(streamController.argsText);
                } catch (e) {
                  throw new Error(`Function parameter parsing failed. ${JSON.stringify(e.message)}`);
                }
                const executeResult = options.execute({
                  toolCallId,
                  toolName,
                  args
                });
                if (executeResult !== void 0) {
                  isExecuting = true;
                  (_a3 = options.onExecutionStart) == null ? void 0 : _a3.call(options, toolCallId, toolName);
                }
                return executeResult;
              }, (c) => {
                var _a3;
                if (isExecuting) {
                  (_a3 = options.onExecutionEnd) == null ? void 0 : _a3.call(options, toolCallId, toolName);
                }
                if (c === void 0)
                  return;
                const result = new ToolResponse({
                  artifact: c.artifact,
                  result: c.result,
                  isError: c.isError
                });
                streamController.setResponse(result);
                controller.enqueue({
                  type: "result",
                  path: chunk.path,
                  ...result
                });
              }, (e) => {
                var _a3;
                if (isExecuting) {
                  (_a3 = options.onExecutionEnd) == null ? void 0 : _a3.call(options, toolCallId, toolName);
                }
                const result = new ToolResponse({
                  result: String(e),
                  isError: true
                });
                streamController.setResponse(result);
                controller.enqueue({
                  type: "result",
                  path: chunk.path,
                  ...result
                });
              });
              if (promise2) {
                toolCallPromises.set(toolCallId, promise2);
              }
              break;
            }
            case "part-finish": {
              if (chunk.meta.type !== "tool-call")
                break;
              const { toolCallId } = chunk.meta;
              const toolCallPromise = toolCallPromises.get(toolCallId);
              if (toolCallPromise) {
                toolCallPromise.then(() => {
                  toolCallPromises.delete(toolCallId);
                  toolCallControllers.delete(toolCallId);
                  controller.enqueue(chunk);
                });
              } else {
                controller.enqueue(chunk);
              }
            }
          }
        },
        async flush() {
          await Promise.all(toolCallPromises.values());
        }
      });
      return readable.pipeThrough(new AssistantMetaTransformStream()).pipeThrough(transform2);
    });
  }
};

// node_modules/assistant-stream/dist/core/tool/toolResultStream.js
var isStandardSchemaV1 = (schema) => {
  return typeof schema === "object" && schema !== null && "~standard" in schema && schema["~standard"].version === 1;
};
function getToolResponse(tools, abortSignal, toolCall, human) {
  const tool2 = tools == null ? void 0 : tools[toolCall.toolName];
  if (!tool2 || !tool2.execute)
    return void 0;
  const getResult = async (toolExecute) => {
    if (abortSignal.aborted) {
      return new ToolResponse({
        result: "Tool execution was cancelled.",
        isError: true
      });
    }
    let executeFn = toolExecute;
    if (isStandardSchemaV1(tool2.parameters)) {
      let result = tool2.parameters["~standard"].validate(toolCall.args);
      if (result instanceof Promise)
        result = await result;
      if (result.issues) {
        executeFn = tool2.experimental_onSchemaValidationError ?? (() => {
          throw new Error(`Function parameter validation failed. ${JSON.stringify(result.issues)}`);
        });
      }
    }
    const abortPromise = new Promise((resolve) => {
      const onAbort = () => {
        queueMicrotask(() => {
          queueMicrotask(() => {
            resolve(new ToolResponse({
              result: "Tool execution was cancelled.",
              isError: true
            }));
          });
        });
      };
      if (abortSignal.aborted) {
        onAbort();
      } else {
        abortSignal.addEventListener("abort", onAbort, { once: true });
      }
    });
    const executePromise = (async () => {
      const result = await executeFn(toolCall.args, {
        toolCallId: toolCall.toolCallId,
        abortSignal,
        human: (payload) => human(toolCall.toolCallId, payload)
      });
      return ToolResponse.toResponse(result);
    })();
    return Promise.race([executePromise, abortPromise]);
  };
  return getResult(tool2.execute);
}
function getToolStreamResponse(tools, abortSignal, reader, context2, human) {
  var _a3, _b;
  (_b = (_a3 = tools == null ? void 0 : tools[context2.toolName]) == null ? void 0 : _a3.streamCall) == null ? void 0 : _b.call(_a3, reader, {
    toolCallId: context2.toolCallId,
    abortSignal,
    human: (payload) => human(context2.toolCallId, payload)
  });
}
function toolResultStream(tools, abortSignal, human, options) {
  const toolsFn = typeof tools === "function" ? tools : () => tools;
  const abortSignalFn = typeof abortSignal === "function" ? abortSignal : () => abortSignal;
  return new ToolExecutionStream({
    execute: (toolCall) => getToolResponse(toolsFn(), abortSignalFn(), toolCall, human),
    streamCall: ({ reader, ...context2 }) => getToolStreamResponse(toolsFn(), abortSignalFn(), reader, context2, human),
    onExecutionStart: options == null ? void 0 : options.onExecutionStart,
    onExecutionEnd: options == null ? void 0 : options.onExecutionEnd
  });
}

// node_modules/assistant-stream/dist/core/tool/schema-utils.js
function isStandardSchema(schema) {
  return typeof schema === "object" && schema !== null && "~standard" in schema && typeof schema["~standard"] === "object";
}
function hasToJSONSchemaMethod(schema) {
  return typeof schema === "object" && schema !== null && "toJSONSchema" in schema && typeof schema.toJSONSchema === "function";
}
function hasToJSONMethod(schema) {
  return typeof schema === "object" && schema !== null && "toJSON" in schema && typeof schema.toJSON === "function";
}
function toJSONSchema(schema) {
  if (isStandardSchema(schema)) {
    const toJSONSchemaMethod = schema["~standard"].toJSONSchema;
    if (typeof toJSONSchemaMethod === "function") {
      return toJSONSchemaMethod();
    }
  }
  if (hasToJSONSchemaMethod(schema)) {
    return schema.toJSONSchema();
  }
  if (hasToJSONMethod(schema)) {
    return schema.toJSON();
  }
  return schema;
}
function defaultToolFilter(_name, tool2) {
  return !tool2.disabled && tool2.type !== "backend";
}
function toToolsJSONSchema(tools, options = {}) {
  if (!tools)
    return {};
  const filter = options.filter ?? defaultToolFilter;
  return Object.fromEntries(Object.entries(tools).filter(([name, tool2]) => filter(name, tool2) && tool2.parameters).map(([name, tool2]) => [
    name,
    {
      ...tool2.description && { description: tool2.description },
      parameters: toJSONSchema(tool2.parameters)
    }
  ]));
}

// node_modules/assistant-stream/dist/core/utils/stream/SSE.js
var _SSEEncoder = class _SSEEncoder extends PipeableTransformStream {
  constructor() {
    super((readable) => readable.pipeThrough(new TransformStream({
      transform(chunk, controller) {
        controller.enqueue(`data: ${JSON.stringify(chunk)}

`);
      }
    })).pipeThrough(new TextEncoderStream()));
    __publicField(this, "headers", _SSEEncoder.headers);
  }
};
__publicField(_SSEEncoder, "headers", new Headers({
  "Content-Type": "text/event-stream",
  "Cache-Control": "no-cache",
  Connection: "keep-alive"
}));
var SSEEncoder = _SSEEncoder;
var SSEEventStream3 = class extends TransformStream {
  constructor() {
    let eventBuffer = {};
    let dataLines = [];
    super({
      start() {
        eventBuffer = {};
        dataLines = [];
      },
      transform(line, controller) {
        if (line.startsWith(":"))
          return;
        if (line === "") {
          if (dataLines.length > 0) {
            controller.enqueue({
              event: eventBuffer.event || "message",
              data: dataLines.join("\n"),
              id: eventBuffer.id,
              retry: eventBuffer.retry
            });
          }
          eventBuffer = {};
          dataLines = [];
          return;
        }
        const [field, ...rest] = line.split(":");
        const value = rest.join(":").trimStart();
        switch (field) {
          case "event":
            eventBuffer.event = value;
            break;
          case "data":
            dataLines.push(value);
            break;
          case "id":
            eventBuffer.id = value;
            break;
          case "retry":
            eventBuffer.retry = Number(value);
            break;
        }
      },
      flush(controller) {
        if (dataLines.length > 0) {
          controller.enqueue({
            event: eventBuffer.event || "message",
            data: dataLines.join("\n"),
            id: eventBuffer.id,
            retry: eventBuffer.retry
          });
        }
      }
    });
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/MessagePartRuntime.js
var MessagePartRuntimeImpl = class {
  constructor(contentBinding, messageApi, threadApi) {
    __publicField(this, "contentBinding");
    __publicField(this, "messageApi");
    __publicField(this, "threadApi");
    this.contentBinding = contentBinding;
    this.messageApi = messageApi;
    this.threadApi = threadApi;
    this.__internal_bindMethods();
  }
  get path() {
    return this.contentBinding.path;
  }
  __internal_bindMethods() {
    this.addToolResult = this.addToolResult.bind(this);
    this.resumeToolCall = this.resumeToolCall.bind(this);
    this.getState = this.getState.bind(this);
    this.subscribe = this.subscribe.bind(this);
  }
  getState() {
    return this.contentBinding.getState();
  }
  addToolResult(result) {
    const state = this.contentBinding.getState();
    if (!state)
      throw new Error("Message part is not available");
    if (state.type !== "tool-call")
      throw new Error("Tried to add tool result to non-tool message part");
    if (!this.messageApi)
      throw new Error("Message API is not available. This is likely a bug in assistant-ui.");
    if (!this.threadApi)
      throw new Error("Thread API is not available");
    const message = this.messageApi.getState();
    if (!message)
      throw new Error("Message is not available");
    const toolName = state.toolName;
    const toolCallId = state.toolCallId;
    const response = ToolResponse.toResponse(result);
    this.threadApi.getState().addToolResult({
      messageId: message.id,
      toolName,
      toolCallId,
      result: response.result,
      artifact: response.artifact,
      isError: response.isError
    });
  }
  resumeToolCall(payload) {
    const state = this.contentBinding.getState();
    if (!state)
      throw new Error("Message part is not available");
    if (state.type !== "tool-call")
      throw new Error("Tried to resume tool call on non-tool message part");
    if (!this.threadApi)
      throw new Error("Thread API is not available");
    const toolCallId = state.toolCallId;
    this.threadApi.getState().resumeToolCall({
      toolCallId,
      payload
    });
  }
  subscribe(callback) {
    return this.contentBinding.subscribe(callback);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/subscribable/NestedSubscriptionSubject.js
var NestedSubscriptionSubject = class extends BaseSubject {
  constructor(binding) {
    super();
    __publicField(this, "binding");
    this.binding = binding;
  }
  get path() {
    return this.binding.path;
  }
  getState() {
    return this.binding.getState();
  }
  outerSubscribe(callback) {
    return this.binding.subscribe(callback);
  }
  _connect() {
    const callback = () => {
      this.notifySubscribers();
    };
    let lastState = this.binding.getState();
    let innerUnsubscribe = lastState == null ? void 0 : lastState.subscribe(callback);
    const onRuntimeUpdate = () => {
      var _a3;
      const newState = this.binding.getState();
      if (newState === lastState)
        return;
      lastState = newState;
      innerUnsubscribe == null ? void 0 : innerUnsubscribe();
      innerUnsubscribe = (_a3 = this.binding.getState()) == null ? void 0 : _a3.subscribe(callback);
      callback();
    };
    const outerUnsubscribe = this.outerSubscribe(onRuntimeUpdate);
    return () => {
      outerUnsubscribe == null ? void 0 : outerUnsubscribe();
      innerUnsubscribe == null ? void 0 : innerUnsubscribe();
    };
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/MessageRuntime.js
var COMPLETE_STATUS = Object.freeze({
  type: "complete"
});
var toMessagePartStatus = (message, partIndex, part) => {
  if (message.role !== "assistant")
    return COMPLETE_STATUS;
  if (part.type === "tool-call") {
    if (!part.result) {
      return message.status;
    } else {
      return COMPLETE_STATUS;
    }
  }
  const isLastPart = partIndex === Math.max(0, message.content.length - 1);
  if (message.status.type === "requires-action")
    return COMPLETE_STATUS;
  return isLastPart ? message.status : COMPLETE_STATUS;
};
var getMessagePartState = (message, partIndex) => {
  const part = message.content[partIndex];
  if (!part) {
    return SKIP_UPDATE;
  }
  const status = toMessagePartStatus(message, partIndex, part);
  return Object.freeze({
    ...part,
    ...{ [symbolInnerMessage]: part[symbolInnerMessage] },
    status
  });
};
var MessageRuntimeImpl = class {
  constructor(_core, _threadBinding) {
    __publicField(this, "_core");
    __publicField(this, "_threadBinding");
    __publicField(this, "composer");
    __publicField(this, "_getEditComposerRuntimeCore", () => {
      return this._threadBinding.getState().getEditComposer(this._core.getState().id);
    });
    this._core = _core;
    this._threadBinding = _threadBinding;
    this.composer = new EditComposerRuntimeImpl(new NestedSubscriptionSubject({
      path: {
        ...this.path,
        ref: `${this.path.ref}${this.path.ref}.composer`,
        composerSource: "edit"
      },
      getState: this._getEditComposerRuntimeCore,
      subscribe: (callback) => this._threadBinding.subscribe(callback)
    }), () => this._threadBinding.getState().beginEdit(this._core.getState().id));
    this.__internal_bindMethods();
  }
  get path() {
    return this._core.path;
  }
  __internal_bindMethods() {
    this.reload = this.reload.bind(this);
    this.getState = this.getState.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.getMessagePartByIndex = this.getMessagePartByIndex.bind(this);
    this.getMessagePartByToolCallId = this.getMessagePartByToolCallId.bind(this);
    this.getAttachmentByIndex = this.getAttachmentByIndex.bind(this);
    this.unstable_getCopyText = this.unstable_getCopyText.bind(this);
    this.speak = this.speak.bind(this);
    this.stopSpeaking = this.stopSpeaking.bind(this);
    this.submitFeedback = this.submitFeedback.bind(this);
    this.switchToBranch = this.switchToBranch.bind(this);
  }
  getState() {
    return this._core.getState();
  }
  reload(reloadConfig = {}) {
    const editComposerRuntimeCore = this._getEditComposerRuntimeCore();
    const composerRuntimeCore = editComposerRuntimeCore ?? this._threadBinding.getState().composer;
    const composer = editComposerRuntimeCore ?? composerRuntimeCore;
    const { runConfig = composer.runConfig } = reloadConfig;
    const state = this._core.getState();
    if (state.role !== "assistant")
      throw new Error("Can only reload assistant messages");
    this._threadBinding.getState().startRun({
      parentId: state.parentId,
      sourceId: state.id,
      runConfig
    });
  }
  speak() {
    const state = this._core.getState();
    return this._threadBinding.getState().speak(state.id);
  }
  stopSpeaking() {
    var _a3;
    const state = this._core.getState();
    const thread = this._threadBinding.getState();
    if (((_a3 = thread.speech) == null ? void 0 : _a3.messageId) === state.id) {
      this._threadBinding.getState().stopSpeaking();
    } else {
      throw new Error("Message is not being spoken");
    }
  }
  submitFeedback({ type }) {
    const state = this._core.getState();
    this._threadBinding.getState().submitFeedback({
      messageId: state.id,
      type
    });
  }
  switchToBranch({ position, branchId }) {
    const state = this._core.getState();
    if (branchId && position) {
      throw new Error("May not specify both branchId and position");
    } else if (!branchId && !position) {
      throw new Error("Must specify either branchId or position");
    }
    const thread = this._threadBinding.getState();
    const branches = thread.getBranches(state.id);
    let targetBranch = branchId;
    if (position === "previous") {
      targetBranch = branches[state.branchNumber - 2];
    } else if (position === "next") {
      targetBranch = branches[state.branchNumber];
    }
    if (!targetBranch)
      throw new Error("Branch not found");
    this._threadBinding.getState().switchToBranch(targetBranch);
  }
  unstable_getCopyText() {
    return getThreadMessageText(this.getState());
  }
  subscribe(callback) {
    return this._core.subscribe(callback);
  }
  getMessagePartByIndex(idx) {
    if (idx < 0)
      throw new Error("Message part index must be >= 0");
    return new MessagePartRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ...this.path,
        ref: `${this.path.ref}${this.path.ref}.content[${idx}]`,
        messagePartSelector: { type: "index", index: idx }
      },
      getState: () => {
        return getMessagePartState(this.getState(), idx);
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }), this._core, this._threadBinding);
  }
  getMessagePartByToolCallId(toolCallId) {
    return new MessagePartRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ...this.path,
        ref: this.path.ref + `${this.path.ref}.content[toolCallId=${JSON.stringify(toolCallId)}]`,
        messagePartSelector: { type: "toolCallId", toolCallId }
      },
      getState: () => {
        const state = this._core.getState();
        const idx = state.content.findIndex((part) => part.type === "tool-call" && part.toolCallId === toolCallId);
        if (idx === -1)
          return SKIP_UPDATE;
        return getMessagePartState(state, idx);
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }), this._core, this._threadBinding);
  }
  getAttachmentByIndex(idx) {
    return new MessageAttachmentRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ...this.path,
        ref: `${this.path.ref}${this.path.ref}.attachments[${idx}]`,
        attachmentSource: "message",
        attachmentSelector: { type: "index", index: idx }
      },
      getState: () => {
        const attachments = this.getState().attachments;
        const attachment = attachments == null ? void 0 : attachments[idx];
        if (!attachment)
          return SKIP_UPDATE;
        return {
          ...attachment,
          source: "message"
        };
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }));
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/ThreadRuntime.js
var toResumeRunConfig = (message) => {
  return {
    parentId: message.parentId ?? null,
    sourceId: message.sourceId ?? null,
    runConfig: message.runConfig ?? {},
    ...message.stream ? { stream: message.stream } : {}
  };
};
var toStartRunConfig = (message) => {
  return {
    parentId: message.parentId ?? null,
    sourceId: message.sourceId ?? null,
    runConfig: message.runConfig ?? {}
  };
};
var toAppendMessage = (messages, message) => {
  var _a3, _b;
  if (typeof message === "string") {
    return {
      createdAt: /* @__PURE__ */ new Date(),
      parentId: ((_a3 = messages.at(-1)) == null ? void 0 : _a3.id) ?? null,
      sourceId: null,
      runConfig: {},
      role: "user",
      content: [{ type: "text", text: message }],
      attachments: [],
      metadata: { custom: {} }
    };
  }
  return {
    createdAt: message.createdAt ?? /* @__PURE__ */ new Date(),
    parentId: message.parentId ?? ((_b = messages.at(-1)) == null ? void 0 : _b.id) ?? null,
    sourceId: message.sourceId ?? null,
    role: message.role ?? "user",
    content: message.content,
    attachments: message.attachments ?? [],
    metadata: message.metadata ?? { custom: {} },
    runConfig: message.runConfig ?? {},
    startRun: message.startRun
  };
};
var getThreadState = (runtime, threadListItemState) => {
  const lastMessage = runtime.messages.at(-1);
  return Object.freeze({
    threadId: threadListItemState.id,
    metadata: threadListItemState,
    capabilities: runtime.capabilities,
    isDisabled: runtime.isDisabled,
    isLoading: runtime.isLoading,
    isRunning: (lastMessage == null ? void 0 : lastMessage.role) !== "assistant" ? false : lastMessage.status.type === "running",
    messages: runtime.messages,
    state: runtime.state,
    suggestions: runtime.suggestions,
    extras: runtime.extras,
    speech: runtime.speech
  });
};
var ThreadRuntimeImpl = class {
  constructor(threadBinding, threadListItemBinding) {
    __publicField(this, "_threadBinding");
    __publicField(this, "composer");
    __publicField(this, "_eventSubscriptionSubjects", /* @__PURE__ */ new Map());
    const stateBinding = new ShallowMemoizeSubject({
      path: threadBinding.path,
      getState: () => getThreadState(threadBinding.getState(), threadListItemBinding.getState()),
      subscribe: (callback) => {
        const sub1 = threadBinding.subscribe(callback);
        const sub2 = threadListItemBinding.subscribe(callback);
        return () => {
          sub1();
          sub2();
        };
      }
    });
    this._threadBinding = {
      path: threadBinding.path,
      getState: () => threadBinding.getState(),
      getStateState: () => stateBinding.getState(),
      outerSubscribe: (callback) => threadBinding.outerSubscribe(callback),
      subscribe: (callback) => threadBinding.subscribe(callback)
    };
    this.composer = new ThreadComposerRuntimeImpl(new NestedSubscriptionSubject({
      path: {
        ...this.path,
        ref: `${this.path.ref}${this.path.ref}.composer`,
        composerSource: "thread"
      },
      getState: () => this._threadBinding.getState().composer,
      subscribe: (callback) => this._threadBinding.subscribe(callback)
    }));
    this.__internal_bindMethods();
  }
  get path() {
    return this._threadBinding.path;
  }
  get __internal_threadBinding() {
    return this._threadBinding;
  }
  __internal_bindMethods() {
    this.append = this.append.bind(this);
    this.unstable_resumeRun = this.unstable_resumeRun.bind(this);
    this.unstable_loadExternalState = this.unstable_loadExternalState.bind(this);
    this.importExternalState = this.importExternalState.bind(this);
    this.exportExternalState = this.exportExternalState.bind(this);
    this.startRun = this.startRun.bind(this);
    this.cancelRun = this.cancelRun.bind(this);
    this.stopSpeaking = this.stopSpeaking.bind(this);
    this.export = this.export.bind(this);
    this.import = this.import.bind(this);
    this.reset = this.reset.bind(this);
    this.getMessageByIndex = this.getMessageByIndex.bind(this);
    this.getMessageById = this.getMessageById.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.unstable_on = this.unstable_on.bind(this);
    this.getModelContext = this.getModelContext.bind(this);
    this.getModelConfig = this.getModelConfig.bind(this);
    this.getState = this.getState.bind(this);
  }
  getState() {
    return this._threadBinding.getStateState();
  }
  append(message) {
    this._threadBinding.getState().append(toAppendMessage(this._threadBinding.getState().messages, message));
  }
  subscribe(callback) {
    return this._threadBinding.subscribe(callback);
  }
  getModelContext() {
    return this._threadBinding.getState().getModelContext();
  }
  getModelConfig() {
    return this.getModelContext();
  }
  startRun(configOrParentId) {
    const config2 = configOrParentId === null || typeof configOrParentId === "string" ? { parentId: configOrParentId } : configOrParentId;
    return this._threadBinding.getState().startRun(toStartRunConfig(config2));
  }
  unstable_resumeRun(config2) {
    return this._threadBinding.getState().resumeRun(toResumeRunConfig(config2));
  }
  exportExternalState() {
    return this._threadBinding.getState().exportExternalState();
  }
  importExternalState(state) {
    this._threadBinding.getState().importExternalState(state);
  }
  unstable_loadExternalState(state) {
    this._threadBinding.getState().unstable_loadExternalState(state);
  }
  cancelRun() {
    this._threadBinding.getState().cancelRun();
  }
  stopSpeaking() {
    return this._threadBinding.getState().stopSpeaking();
  }
  export() {
    return this._threadBinding.getState().export();
  }
  import(data) {
    this._threadBinding.getState().import(data);
  }
  reset(initialMessages) {
    this._threadBinding.getState().reset(initialMessages);
  }
  getMessageByIndex(idx) {
    if (idx < 0)
      throw new Error("Message index must be >= 0");
    return this._getMessageRuntime({
      ...this.path,
      ref: `${this.path.ref}${this.path.ref}.messages[${idx}]`,
      messageSelector: { type: "index", index: idx }
    }, () => {
      var _a3;
      const messages = this._threadBinding.getState().messages;
      const message = messages[idx];
      if (!message)
        return void 0;
      return {
        message,
        parentId: ((_a3 = messages[idx - 1]) == null ? void 0 : _a3.id) ?? null,
        index: idx
      };
    });
  }
  getMessageById(messageId) {
    return this._getMessageRuntime({
      ...this.path,
      ref: this.path.ref + `${this.path.ref}.messages[messageId=${JSON.stringify(messageId)}]`,
      messageSelector: { type: "messageId", messageId }
    }, () => this._threadBinding.getState().getMessageById(messageId));
  }
  _getMessageRuntime(path, callback) {
    return new MessageRuntimeImpl(new ShallowMemoizeSubject({
      path,
      getState: () => {
        var _a3;
        const { message, parentId, index: index3 } = callback() ?? {};
        const { messages, speech: speechState } = this._threadBinding.getState();
        if (!message || parentId === void 0 || index3 === void 0)
          return SKIP_UPDATE;
        const thread = this._threadBinding.getState();
        const branches = thread.getBranches(message.id);
        const submittedFeedback = message.metadata.submittedFeedback;
        return {
          ...message,
          ...{ [symbolInnerMessage]: message[symbolInnerMessage] },
          index: index3,
          isLast: ((_a3 = messages.at(-1)) == null ? void 0 : _a3.id) === message.id,
          parentId,
          branchNumber: branches.indexOf(message.id) + 1,
          branchCount: branches.length,
          speech: (speechState == null ? void 0 : speechState.messageId) === message.id ? speechState : void 0,
          submittedFeedback
        };
      },
      subscribe: (callback2) => this._threadBinding.subscribe(callback2)
    }), this._threadBinding);
  }
  unstable_on(event, callback) {
    let subject = this._eventSubscriptionSubjects.get(event);
    if (!subject) {
      subject = new EventSubscriptionSubject({
        event,
        binding: this._threadBinding
      });
      this._eventSubscriptionSubjects.set(event, subject);
    }
    return subject.subscribe(callback);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/ThreadListRuntime.js
var getThreadListState = (threadList) => {
  return {
    mainThreadId: threadList.mainThreadId,
    newThreadId: threadList.newThreadId,
    threadIds: threadList.threadIds,
    archivedThreadIds: threadList.archivedThreadIds,
    isLoading: threadList.isLoading,
    threadItems: threadList.threadItems
  };
};
var getThreadListItemState = (threadList, threadId) => {
  if (threadId === void 0)
    return SKIP_UPDATE;
  const threadData = threadList.getItemById(threadId);
  if (!threadData)
    return SKIP_UPDATE;
  return {
    id: threadData.id,
    remoteId: threadData.remoteId,
    externalId: threadData.externalId,
    title: threadData.title,
    status: threadData.status,
    isMain: threadData.id === threadList.mainThreadId
  };
};
var ThreadListRuntimeImpl = class {
  constructor(_core, _runtimeFactory = ThreadRuntimeImpl) {
    __publicField(this, "_core");
    __publicField(this, "_runtimeFactory");
    __publicField(this, "_getState");
    __publicField(this, "_mainThreadListItemRuntime");
    __publicField(this, "main");
    this._core = _core;
    this._runtimeFactory = _runtimeFactory;
    const stateBinding = new LazyMemoizeSubject({
      path: {},
      getState: () => getThreadListState(_core),
      subscribe: (callback) => _core.subscribe(callback)
    });
    this._getState = stateBinding.getState.bind(stateBinding);
    this._mainThreadListItemRuntime = new ThreadListItemRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ref: `threadItems[main]`,
        threadSelector: { type: "main" }
      },
      getState: () => {
        return getThreadListItemState(this._core, this._core.mainThreadId);
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }), this._core);
    this.main = new _runtimeFactory(new NestedSubscriptionSubject({
      path: {
        ref: "threads.main",
        threadSelector: { type: "main" }
      },
      getState: () => _core.getMainThreadRuntimeCore(),
      subscribe: (callback) => _core.subscribe(callback)
    }), this._mainThreadListItemRuntime);
    this.__internal_bindMethods();
  }
  __internal_bindMethods() {
    this.switchToThread = this.switchToThread.bind(this);
    this.switchToNewThread = this.switchToNewThread.bind(this);
    this.getState = this.getState.bind(this);
    this.subscribe = this.subscribe.bind(this);
    this.getById = this.getById.bind(this);
    this.getItemById = this.getItemById.bind(this);
    this.getItemByIndex = this.getItemByIndex.bind(this);
    this.getArchivedItemByIndex = this.getArchivedItemByIndex.bind(this);
  }
  switchToThread(threadId) {
    return this._core.switchToThread(threadId);
  }
  switchToNewThread() {
    return this._core.switchToNewThread();
  }
  getState() {
    return this._getState();
  }
  subscribe(callback) {
    return this._core.subscribe(callback);
  }
  get mainItem() {
    return this._mainThreadListItemRuntime;
  }
  getById(threadId) {
    return new this._runtimeFactory(new NestedSubscriptionSubject({
      path: {
        ref: `threads[threadId=${JSON.stringify(threadId)}]`,
        threadSelector: { type: "threadId", threadId }
      },
      getState: () => this._core.getThreadRuntimeCore(threadId),
      subscribe: (callback) => this._core.subscribe(callback)
    }), this.mainItem);
  }
  getItemByIndex(idx) {
    return new ThreadListItemRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ref: `threadItems[${idx}]`,
        threadSelector: { type: "index", index: idx }
      },
      getState: () => {
        return getThreadListItemState(this._core, this._core.threadIds[idx]);
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }), this._core);
  }
  getArchivedItemByIndex(idx) {
    return new ThreadListItemRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ref: `archivedThreadItems[${idx}]`,
        threadSelector: { type: "archiveIndex", index: idx }
      },
      getState: () => {
        return getThreadListItemState(this._core, this._core.archivedThreadIds[idx]);
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }), this._core);
  }
  getItemById(threadId) {
    return new ThreadListItemRuntimeImpl(new ShallowMemoizeSubject({
      path: {
        ref: `threadItems[threadId=${threadId}]`,
        threadSelector: { type: "threadId", threadId }
      },
      getState: () => {
        return getThreadListItemState(this._core, threadId);
      },
      subscribe: (callback) => this._core.subscribe(callback)
    }), this._core);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/adapters/attachment/SimpleImageAttachmentAdapter.js
var SimpleImageAttachmentAdapter = class {
  constructor() {
    __publicField(this, "accept", "image/*");
  }
  async add(state) {
    return {
      id: state.file.name,
      type: "image",
      name: state.file.name,
      contentType: state.file.type,
      file: state.file,
      status: { type: "requires-action", reason: "composer-send" }
    };
  }
  async send(attachment) {
    return {
      ...attachment,
      status: { type: "complete" },
      content: [
        {
          type: "image",
          image: await getFileDataURL(attachment.file)
        }
      ]
    };
  }
  async remove() {
  }
};
var getFileDataURL = (file2) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => resolve(reader.result);
  reader.onerror = (error48) => reject(error48);
  reader.readAsDataURL(file2);
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/adapters/attachment/SimpleTextAttachmentAdapter.js
var SimpleTextAttachmentAdapter = class {
  constructor() {
    __publicField(this, "accept", "text/plain,text/html,text/markdown,text/csv,text/xml,text/json,text/css");
  }
  async add(state) {
    return {
      id: state.file.name,
      type: "document",
      name: state.file.name,
      contentType: state.file.type,
      file: state.file,
      status: { type: "requires-action", reason: "composer-send" }
    };
  }
  async send(attachment) {
    return {
      ...attachment,
      status: { type: "complete" },
      content: [
        {
          type: "text",
          text: `<attachment name=${attachment.name}>
${await getFileText(attachment.file)}
</attachment>`
        }
      ]
    };
  }
  async remove() {
  }
};
var getFileText = (file2) => new Promise((resolve, reject) => {
  const reader = new FileReader();
  reader.onload = () => resolve(reader.result);
  reader.onerror = (error48) => reject(error48);
  reader.readAsText(file2);
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/adapters/attachment/CompositeAttachmentAdapter.js
function fileMatchesAccept(file2, acceptString) {
  if (acceptString === "*") {
    return true;
  }
  const allowedTypes = acceptString.split(",").map((type) => type.trim().toLowerCase());
  const fileExtension = `.${file2.name.split(".").pop().toLowerCase()}`;
  const fileMimeType = file2.type.toLowerCase();
  for (const type of allowedTypes) {
    if (type.startsWith(".") && type === fileExtension) {
      return true;
    }
    if (type.includes("/") && type === fileMimeType) {
      return true;
    }
    if (type === "image/*" || type === "video/*" || type === "audio/*") {
      if (type.endsWith("/*")) {
        const generalType = type.split("/")[0];
        if (fileMimeType.startsWith(`${generalType}/`)) {
          return true;
        }
      }
    }
  }
  return false;
}
var CompositeAttachmentAdapter = class {
  constructor(adapters) {
    __publicField(this, "_adapters");
    __publicField(this, "accept");
    this._adapters = adapters;
    const wildcardIdx = adapters.findIndex((a) => a.accept === "*");
    if (wildcardIdx !== -1) {
      if (wildcardIdx !== adapters.length - 1)
        throw new Error("A wildcard adapter (handling all files) can only be specified as the last adapter.");
      this.accept = "*";
    } else {
      this.accept = adapters.map((a) => a.accept).join(",");
    }
  }
  add(state) {
    for (const adapter of this._adapters) {
      if (fileMatchesAccept(state.file, adapter.accept)) {
        return adapter.add(state);
      }
    }
    throw new Error("No matching adapter found for file");
  }
  async send(attachment) {
    const adapters = this._adapters.slice();
    for (const adapter of adapters) {
      if (fileMatchesAccept(attachment.file, adapter.accept)) {
        return adapter.send(attachment);
      }
    }
    throw new Error("No matching adapter found for attachment");
  }
  async remove(attachment) {
    const adapters = this._adapters.slice();
    for (const adapter of adapters) {
      if (fileMatchesAccept({
        name: attachment.name,
        type: attachment.contentType
      }, adapter.accept)) {
        return adapter.remove(attachment);
      }
    }
    throw new Error("No matching adapter found for attachment");
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/adapters/attachment/CloudFileAttachmentAdapter.js
var guessAttachmentType = (contentType) => {
  if (contentType.startsWith("image/"))
    return "image";
  if (contentType.startsWith("text/"))
    return "document";
  return "file";
};
var CloudFileAttachmentAdapter = class {
  constructor(cloud) {
    __publicField(this, "cloud");
    __publicField(this, "accept", "*");
    __publicField(this, "uploadedUrls", /* @__PURE__ */ new Map());
    this.cloud = cloud;
  }
  async *add({ file: file2 }) {
    const id = crypto.randomUUID();
    const type = guessAttachmentType(file2.type);
    let attachment = {
      id,
      type,
      name: file2.name,
      contentType: file2.type,
      file: file2,
      status: { type: "running", reason: "uploading", progress: 0 }
    };
    yield attachment;
    try {
      const { signedUrl, publicUrl } = await this.cloud.files.generatePresignedUploadUrl({
        filename: file2.name
      });
      await fetch(signedUrl, {
        method: "PUT",
        body: file2,
        headers: {
          "Content-Type": file2.type
        },
        mode: "cors"
      });
      this.uploadedUrls.set(id, publicUrl);
      attachment = {
        ...attachment,
        status: { type: "requires-action", reason: "composer-send" }
      };
      yield attachment;
    } catch {
      attachment = {
        ...attachment,
        status: { type: "incomplete", reason: "error" }
      };
      yield attachment;
    }
  }
  async remove(attachment) {
    this.uploadedUrls.delete(attachment.id);
  }
  async send(attachment) {
    const url2 = this.uploadedUrls.get(attachment.id);
    if (!url2)
      throw new Error("Attachment not uploaded");
    this.uploadedUrls.delete(attachment.id);
    let content;
    if (attachment.type === "image") {
      content = [{ type: "image", image: url2, filename: attachment.name }];
    } else {
      content = [
        {
          type: "file",
          data: url2,
          mimeType: attachment.contentType,
          filename: attachment.name
        }
      ];
    }
    return {
      ...attachment,
      status: { type: "complete" },
      content
    };
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/adapters/speech/WebSpeechSynthesisAdapter.js
var WebSpeechSynthesisAdapter = class {
  speak(text) {
    const utterance = new SpeechSynthesisUtterance(text);
    const subscribers = /* @__PURE__ */ new Set();
    const handleEnd = (reason, error48) => {
      if (res.status.type === "ended")
        return;
      res.status = { type: "ended", reason, error: error48 };
      subscribers.forEach((handler) => handler());
    };
    utterance.addEventListener("end", () => handleEnd("finished"));
    utterance.addEventListener("error", (e) => handleEnd("error", e.error));
    window.speechSynthesis.speak(utterance);
    const res = {
      status: { type: "running" },
      cancel: () => {
        window.speechSynthesis.cancel();
        handleEnd("cancelled");
      },
      subscribe: (callback) => {
        if (res.status.type === "ended") {
          let cancelled = false;
          queueMicrotask(() => {
            if (!cancelled)
              callback();
          });
          return () => {
            cancelled = true;
          };
        } else {
          subscribers.add(callback);
          return () => {
            subscribers.delete(callback);
          };
        }
      }
    };
    return res;
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/adapters/speech/WebSpeechDictationAdapter.js
var getSpeechRecognitionAPI = () => {
  if (typeof window === "undefined")
    return void 0;
  return window.SpeechRecognition ?? window.webkitSpeechRecognition;
};
var WebSpeechDictationAdapter = class {
  constructor(options = {}) {
    __publicField(this, "_language");
    __publicField(this, "_continuous");
    __publicField(this, "_interimResults");
    const defaultLanguage = typeof navigator !== "undefined" && navigator.language ? navigator.language : "en-US";
    this._language = options.language ?? defaultLanguage;
    this._continuous = options.continuous ?? true;
    this._interimResults = options.interimResults ?? true;
  }
  /**
   * Check if the browser supports the Web Speech Recognition API.
   */
  static isSupported() {
    return getSpeechRecognitionAPI() !== void 0;
  }
  listen() {
    const SpeechRecognitionAPI = getSpeechRecognitionAPI();
    if (!SpeechRecognitionAPI) {
      throw new Error("SpeechRecognition is not supported in this browser. Try using Chrome, Edge, or Safari.");
    }
    const recognition = new SpeechRecognitionAPI();
    recognition.lang = this._language;
    recognition.continuous = this._continuous;
    recognition.interimResults = this._interimResults;
    const speechStartCallbacks = /* @__PURE__ */ new Set();
    const speechEndCallbacks = /* @__PURE__ */ new Set();
    const speechCallbacks = /* @__PURE__ */ new Set();
    let finalTranscript = "";
    const session = {
      status: { type: "starting" },
      stop: async () => {
        recognition.stop();
        return new Promise((resolve) => {
          const checkEnded = () => {
            if (session.status.type === "ended") {
              resolve();
            } else {
              setTimeout(checkEnded, 50);
            }
          };
          checkEnded();
        });
      },
      cancel: () => {
        recognition.abort();
      },
      onSpeechStart: (callback) => {
        speechStartCallbacks.add(callback);
        return () => {
          speechStartCallbacks.delete(callback);
        };
      },
      onSpeechEnd: (callback) => {
        speechEndCallbacks.add(callback);
        return () => {
          speechEndCallbacks.delete(callback);
        };
      },
      onSpeech: (callback) => {
        speechCallbacks.add(callback);
        return () => {
          speechCallbacks.delete(callback);
        };
      }
    };
    const updateStatus = (newStatus) => {
      session.status = newStatus;
    };
    recognition.addEventListener("speechstart", () => {
      for (const cb of speechStartCallbacks)
        cb();
    });
    recognition.addEventListener("start", () => {
      updateStatus({ type: "running" });
    });
    recognition.addEventListener("result", (event) => {
      var _a3;
      const speechEvent = event;
      for (let i = speechEvent.resultIndex; i < speechEvent.results.length; i++) {
        const result = speechEvent.results[i];
        if (!result)
          continue;
        const transcript = ((_a3 = result[0]) == null ? void 0 : _a3.transcript) ?? "";
        if (result.isFinal) {
          finalTranscript += transcript;
          for (const cb of speechCallbacks)
            cb({ transcript, isFinal: true });
        } else {
          for (const cb of speechCallbacks)
            cb({ transcript, isFinal: false });
        }
      }
    });
    recognition.addEventListener("speechend", () => {
    });
    recognition.addEventListener("end", () => {
      const currentStatus = session.status;
      if (currentStatus.type !== "ended") {
        updateStatus({ type: "ended", reason: "stopped" });
      }
      if (finalTranscript) {
        for (const cb of speechEndCallbacks)
          cb({ transcript: finalTranscript });
        finalTranscript = "";
      }
    });
    recognition.addEventListener("error", (event) => {
      const errorEvent = event;
      if (errorEvent.error === "aborted") {
        updateStatus({ type: "ended", reason: "cancelled" });
      } else {
        updateStatus({ type: "ended", reason: "error" });
        console.error("Dictation error:", errorEvent.error, errorEvent.message);
      }
    });
    try {
      recognition.start();
    } catch (error48) {
      updateStatus({ type: "ended", reason: "error" });
      throw error48;
    }
    return session;
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/adapters/RuntimeAdapterProvider.js
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var RuntimeAdaptersContext = (0, import_react7.createContext)(null);
var RuntimeAdapterProvider = ({ adapters, children }) => {
  const context2 = (0, import_react7.useContext)(RuntimeAdaptersContext);
  return (0, import_jsx_runtime2.jsx)(RuntimeAdaptersContext.Provider, { value: {
    ...context2,
    ...adapters
  }, children });
};
var useRuntimeAdapters = () => {
  const adapters = (0, import_react7.useContext)(RuntimeAdaptersContext);
  return adapters;
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/useExternalStoreRuntime.js
var import_react8 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/ExternalStoreThreadListRuntimeCore.js
var EMPTY_ARRAY3 = Object.freeze([]);
var DEFAULT_THREAD_ID = "DEFAULT_THREAD_ID";
var DEFAULT_THREADS = Object.freeze([DEFAULT_THREAD_ID]);
var DEFAULT_THREAD = Object.freeze({
  id: DEFAULT_THREAD_ID,
  remoteId: void 0,
  externalId: void 0,
  status: "regular"
});
var RESOLVED_PROMISE = Promise.resolve();
var DEFAULT_THREAD_DATA = Object.freeze({
  [DEFAULT_THREAD_ID]: DEFAULT_THREAD
});
var ExternalStoreThreadListRuntimeCore = class {
  constructor(adapter = {}, threadFactory) {
    __publicField(this, "adapter");
    __publicField(this, "threadFactory");
    __publicField(this, "_mainThreadId", DEFAULT_THREAD_ID);
    __publicField(this, "_threads", DEFAULT_THREADS);
    __publicField(this, "_archivedThreads", EMPTY_ARRAY3);
    __publicField(this, "_threadData", DEFAULT_THREAD_DATA);
    __publicField(this, "_mainThread");
    __publicField(this, "_subscriptions", /* @__PURE__ */ new Set());
    this.adapter = adapter;
    this.threadFactory = threadFactory;
    this._mainThread = this.threadFactory();
    this.__internal_setAdapter(adapter, true);
  }
  get isLoading() {
    return this.adapter.isLoading ?? false;
  }
  get newThreadId() {
    return void 0;
  }
  get threadIds() {
    return this._threads;
  }
  get archivedThreadIds() {
    return this._archivedThreads;
  }
  get threadItems() {
    return this._threadData;
  }
  getLoadThreadsPromise() {
    return RESOLVED_PROMISE;
  }
  get mainThreadId() {
    return this._mainThreadId;
  }
  getMainThreadRuntimeCore() {
    return this._mainThread;
  }
  getThreadRuntimeCore() {
    throw new Error("Method not implemented.");
  }
  getItemById(threadId) {
    for (const thread of this.adapter.threads ?? []) {
      if (thread.id === threadId)
        return thread;
    }
    for (const thread of this.adapter.archivedThreads ?? []) {
      if (thread.id === threadId)
        return thread;
    }
    if (threadId === DEFAULT_THREAD_ID)
      return DEFAULT_THREAD;
    return void 0;
  }
  __internal_setAdapter(adapter, initialLoad = false) {
    var _a3, _b, _c, _d;
    const previousAdapter = this.adapter;
    this.adapter = adapter;
    const newThreadId = adapter.threadId ?? DEFAULT_THREAD_ID;
    const newThreads = adapter.threads ?? EMPTY_ARRAY3;
    const newArchivedThreads = adapter.archivedThreads ?? EMPTY_ARRAY3;
    const previousThreadId = previousAdapter.threadId ?? DEFAULT_THREAD_ID;
    const previousThreads = previousAdapter.threads ?? EMPTY_ARRAY3;
    const previousArchivedThreads = previousAdapter.archivedThreads ?? EMPTY_ARRAY3;
    if (!initialLoad && previousThreadId === newThreadId && previousThreads === newThreads && previousArchivedThreads === newArchivedThreads) {
      return;
    }
    this._threadData = {
      ...DEFAULT_THREAD_DATA,
      ...Object.fromEntries(((_a3 = adapter.threads) == null ? void 0 : _a3.map((t) => [
        t.id,
        {
          ...t,
          remoteId: t.remoteId,
          externalId: t.externalId,
          status: "regular"
        }
      ])) ?? []),
      ...Object.fromEntries(((_b = adapter.archivedThreads) == null ? void 0 : _b.map((t) => [
        t.id,
        {
          ...t,
          remoteId: t.remoteId,
          externalId: t.externalId,
          status: "archived"
        }
      ])) ?? [])
    };
    if (previousThreads !== newThreads) {
      this._threads = ((_c = this.adapter.threads) == null ? void 0 : _c.map((t) => t.id)) ?? EMPTY_ARRAY3;
    }
    if (previousArchivedThreads !== newArchivedThreads) {
      this._archivedThreads = ((_d = this.adapter.archivedThreads) == null ? void 0 : _d.map((t) => t.id)) ?? EMPTY_ARRAY3;
    }
    if (previousThreadId !== newThreadId) {
      this._mainThreadId = newThreadId;
      this._mainThread = this.threadFactory();
    }
    this._notifySubscribers();
  }
  async switchToThread(threadId) {
    if (this._mainThreadId === threadId)
      return;
    const onSwitchToThread = this.adapter.onSwitchToThread;
    if (!onSwitchToThread)
      throw new Error("External store adapter does not support switching to thread");
    onSwitchToThread(threadId);
  }
  async switchToNewThread() {
    const onSwitchToNewThread = this.adapter.onSwitchToNewThread;
    if (!onSwitchToNewThread)
      throw new Error("External store adapter does not support switching to new thread");
    onSwitchToNewThread();
  }
  async rename(threadId, newTitle) {
    const onRename = this.adapter.onRename;
    if (!onRename)
      throw new Error("External store adapter does not support renaming");
    onRename(threadId, newTitle);
  }
  async detach() {
  }
  async archive(threadId) {
    const onArchive = this.adapter.onArchive;
    if (!onArchive)
      throw new Error("External store adapter does not support archiving");
    onArchive(threadId);
  }
  async unarchive(threadId) {
    const onUnarchive = this.adapter.onUnarchive;
    if (!onUnarchive)
      throw new Error("External store adapter does not support unarchiving");
    onUnarchive(threadId);
  }
  async delete(threadId) {
    const onDelete = this.adapter.onDelete;
    if (!onDelete)
      throw new Error("External store adapter does not support deleting");
    onDelete(threadId);
  }
  initialize(threadId) {
    return Promise.resolve({ remoteId: threadId, externalId: void 0 });
  }
  generateTitle() {
    throw new Error("Method not implemented.");
  }
  subscribe(callback) {
    this._subscriptions.add(callback);
    return () => this._subscriptions.delete(callback);
  }
  _notifySubscribers() {
    for (const callback of this._subscriptions)
      callback();
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/ThreadMessageConverter.js
var ThreadMessageConverter = class {
  constructor() {
    __publicField(this, "cache", /* @__PURE__ */ new WeakMap());
  }
  convertMessages(messages, converter) {
    return messages.map((m, idx) => {
      const cached2 = this.cache.get(m);
      const newMessage = converter(cached2, m, idx);
      this.cache.set(m, newMessage);
      return newMessage;
    });
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/composer/DefaultEditComposerRuntimeCore.js
var DefaultEditComposerRuntimeCore = class extends BaseComposerRuntimeCore {
  constructor(runtime, endEditCallback, { parentId, message }) {
    super();
    __publicField(this, "runtime");
    __publicField(this, "endEditCallback");
    __publicField(this, "_nonTextParts");
    __publicField(this, "_previousText");
    __publicField(this, "_parentId");
    __publicField(this, "_sourceId");
    this.runtime = runtime;
    this.endEditCallback = endEditCallback;
    this._parentId = parentId;
    this._sourceId = message.id;
    this._previousText = getThreadMessageText(message);
    this.setText(this._previousText);
    this.setRole(message.role);
    this.setAttachments(message.attachments ?? []);
    this._nonTextParts = message.content.filter((part) => part.type !== "text");
    this.setRunConfig({ ...runtime.composer.runConfig });
  }
  get canCancel() {
    return true;
  }
  getAttachmentAdapter() {
    var _a3;
    return (_a3 = this.runtime.adapters) == null ? void 0 : _a3.attachments;
  }
  getDictationAdapter() {
    var _a3;
    return (_a3 = this.runtime.adapters) == null ? void 0 : _a3.dictation;
  }
  async handleSend(message) {
    const text = getThreadMessageText(message);
    if (text !== this._previousText) {
      this.runtime.append({
        ...message,
        content: [...message.content, ...this._nonTextParts],
        parentId: this._parentId,
        sourceId: this._sourceId
      });
    }
    this.handleCancel();
  }
  handleCancel() {
    this.endEditCallback();
    this._notifySubscribers();
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/core/BaseThreadRuntimeCore.js
var BaseThreadRuntimeCore = class {
  constructor(_contextProvider) {
    __publicField(this, "_contextProvider");
    __publicField(this, "_subscriptions", /* @__PURE__ */ new Set());
    __publicField(this, "_isInitialized", false);
    __publicField(this, "repository", new MessageRepository());
    __publicField(this, "composer", new DefaultThreadComposerRuntimeCore(this));
    __publicField(this, "_editComposers", /* @__PURE__ */ new Map());
    __publicField(this, "_stopSpeaking");
    __publicField(this, "speech");
    __publicField(this, "_eventSubscribers", /* @__PURE__ */ new Map());
    this._contextProvider = _contextProvider;
  }
  get messages() {
    return this.repository.getMessages();
  }
  get state() {
    let mostRecentAssistantMessage;
    for (const message of this.messages) {
      if (message.role === "assistant") {
        mostRecentAssistantMessage = message;
        break;
      }
    }
    return (mostRecentAssistantMessage == null ? void 0 : mostRecentAssistantMessage.metadata.unstable_state) ?? null;
  }
  getModelContext() {
    return this._contextProvider.getModelContext();
  }
  getEditComposer(messageId) {
    return this._editComposers.get(messageId);
  }
  beginEdit(messageId) {
    if (this._editComposers.has(messageId))
      throw new Error("Edit already in progress");
    this._editComposers.set(messageId, new DefaultEditComposerRuntimeCore(this, () => this._editComposers.delete(messageId), this.repository.getMessage(messageId)));
    this._notifySubscribers();
  }
  getMessageById(messageId) {
    try {
      return this.repository.getMessage(messageId);
    } catch {
      return void 0;
    }
  }
  getBranches(messageId) {
    return this.repository.getBranches(messageId);
  }
  switchToBranch(branchId) {
    this.repository.switchToBranch(branchId);
    this._notifySubscribers();
  }
  _notifySubscribers() {
    for (const callback of this._subscriptions)
      callback();
  }
  _notifyEventSubscribers(event) {
    const subscribers = this._eventSubscribers.get(event);
    if (!subscribers)
      return;
    for (const callback of subscribers)
      callback();
  }
  subscribe(callback) {
    this._subscriptions.add(callback);
    return () => this._subscriptions.delete(callback);
  }
  submitFeedback({ messageId, type }) {
    var _a3;
    const adapter = (_a3 = this.adapters) == null ? void 0 : _a3.feedback;
    if (!adapter)
      throw new Error("Feedback adapter not configured");
    const { message, parentId } = this.repository.getMessage(messageId);
    adapter.submit({ message, type });
    if (message.role === "assistant") {
      const updatedMessage = {
        ...message,
        metadata: {
          ...message.metadata,
          submittedFeedback: { type }
        }
      };
      this.repository.addOrUpdateMessage(parentId, updatedMessage);
    }
    this._notifySubscribers();
  }
  speak(messageId) {
    var _a3, _b;
    const adapter = (_a3 = this.adapters) == null ? void 0 : _a3.speech;
    if (!adapter)
      throw new Error("Speech adapter not configured");
    const { message } = this.repository.getMessage(messageId);
    (_b = this._stopSpeaking) == null ? void 0 : _b.call(this);
    const utterance = adapter.speak(getThreadMessageText(message));
    const unsub = utterance.subscribe(() => {
      if (utterance.status.type === "ended") {
        this._stopSpeaking = void 0;
        this.speech = void 0;
      } else {
        this.speech = { messageId, status: utterance.status };
      }
      this._notifySubscribers();
    });
    this.speech = { messageId, status: utterance.status };
    this._notifySubscribers();
    this._stopSpeaking = () => {
      utterance.cancel();
      unsub();
      this.speech = void 0;
      this._stopSpeaking = void 0;
    };
  }
  stopSpeaking() {
    if (!this._stopSpeaking)
      throw new Error("No message is being spoken");
    this._stopSpeaking();
    this._notifySubscribers();
  }
  ensureInitialized() {
    if (!this._isInitialized) {
      this._isInitialized = true;
      this._notifyEventSubscribers("initialize");
    }
  }
  // TODO import()/export() on external store doesn't make much sense
  export() {
    return this.repository.export();
  }
  import(data) {
    this.ensureInitialized();
    this.repository.clear();
    this.repository.import(data);
    this._notifySubscribers();
  }
  reset(initialMessages) {
    this.import(ExportedMessageRepository.fromArray(initialMessages ?? []));
  }
  unstable_on(event, callback) {
    var _a3, _b;
    if (event === "modelContextUpdate") {
      return ((_b = (_a3 = this._contextProvider).subscribe) == null ? void 0 : _b.call(_a3, callback)) ?? (() => {
      });
    }
    const subscribers = this._eventSubscribers.get(event);
    if (!subscribers) {
      this._eventSubscribers.set(event, /* @__PURE__ */ new Set([callback]));
    } else {
      subscribers.add(callback);
    }
    return () => {
      const subscribers2 = this._eventSubscribers.get(event);
      subscribers2.delete(callback);
    };
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/ExternalStoreThreadRuntimeCore.js
var EMPTY_ARRAY4 = Object.freeze([]);
var hasUpcomingMessage = (isRunning, messages) => {
  var _a3;
  return isRunning && ((_a3 = messages[messages.length - 1]) == null ? void 0 : _a3.role) !== "assistant";
};
var ExternalStoreThreadRuntimeCore = class extends BaseThreadRuntimeCore {
  constructor(contextProvider, store) {
    super(contextProvider);
    __publicField(this, "_assistantOptimisticId", null);
    __publicField(this, "_capabilities", {
      switchToBranch: false,
      switchBranchDuringRun: false,
      edit: false,
      reload: false,
      cancel: false,
      unstable_copy: false,
      speech: false,
      dictation: false,
      attachments: false,
      feedback: false
    });
    __publicField(this, "_messages");
    __publicField(this, "isDisabled");
    __publicField(this, "suggestions", []);
    __publicField(this, "extras");
    __publicField(this, "_converter", new ThreadMessageConverter());
    __publicField(this, "_store");
    __publicField(this, "updateMessages", (messages) => {
      var _a3, _b, _c, _d;
      const hasConverter = this._store.convertMessage !== void 0;
      if (hasConverter) {
        (_b = (_a3 = this._store).setMessages) == null ? void 0 : _b.call(_a3, messages.flatMap(getExternalStoreMessage).filter((m) => m != null));
      } else {
        (_d = (_c = this._store).setMessages) == null ? void 0 : _d.call(_c, messages);
      }
    });
    this.__internal_setAdapter(store);
  }
  get capabilities() {
    return this._capabilities;
  }
  get isLoading() {
    return this._store.isLoading ?? false;
  }
  get messages() {
    return this._messages;
  }
  get state() {
    return this._store.state ?? super.state;
  }
  get adapters() {
    return this._store.adapters;
  }
  beginEdit(messageId) {
    if (!this._store.onEdit)
      throw new Error("Runtime does not support editing.");
    super.beginEdit(messageId);
  }
  __internal_setAdapter(store) {
    var _a3, _b, _c, _d, _e, _f, _g;
    if (this._store === store)
      return;
    const isRunning = store.isRunning ?? false;
    this.isDisabled = store.isDisabled ?? false;
    const oldStore = this._store;
    this._store = store;
    this.extras = store.extras;
    this.suggestions = store.suggestions ?? EMPTY_ARRAY4;
    this._capabilities = {
      switchToBranch: this._store.setMessages !== void 0,
      switchBranchDuringRun: false,
      // External store never supports branch switching during run
      edit: this._store.onEdit !== void 0,
      reload: this._store.onReload !== void 0,
      cancel: this._store.onCancel !== void 0,
      speech: ((_a3 = this._store.adapters) == null ? void 0 : _a3.speech) !== void 0,
      dictation: ((_b = this._store.adapters) == null ? void 0 : _b.dictation) !== void 0,
      unstable_copy: ((_c = this._store.unstable_capabilities) == null ? void 0 : _c.copy) !== false,
      // default true
      attachments: !!((_d = this._store.adapters) == null ? void 0 : _d.attachments),
      feedback: !!((_e = this._store.adapters) == null ? void 0 : _e.feedback)
    };
    let messages;
    if (store.messageRepository) {
      if (oldStore && oldStore.isRunning === store.isRunning && oldStore.messageRepository === store.messageRepository) {
        this._notifySubscribers();
        return;
      }
      this.repository.clear();
      this._assistantOptimisticId = null;
      this.repository.import(store.messageRepository);
      messages = this.repository.getMessages();
    } else if (store.messages) {
      if (oldStore) {
        if (oldStore.convertMessage !== store.convertMessage) {
          this._converter = new ThreadMessageConverter();
        } else if (oldStore.isRunning === store.isRunning && oldStore.messages === store.messages) {
          this._notifySubscribers();
          return;
        }
      }
      messages = !store.convertMessage ? store.messages : this._converter.convertMessages(store.messages, (cache, m, idx) => {
        var _a4;
        if (!store.convertMessage)
          return m;
        const isLast = idx === (((_a4 = store.messages) == null ? void 0 : _a4.length) ?? 0) - 1;
        const autoStatus = getAutoStatus(isLast, isRunning, false, false, void 0);
        if (cache && (cache.role !== "assistant" || !isAutoStatus(cache.status) || cache.status === autoStatus))
          return cache;
        const messageLike = store.convertMessage(m, idx);
        const newMessage = fromThreadMessageLike(messageLike, idx.toString(), autoStatus);
        newMessage[symbolInnerMessage] = m;
        return newMessage;
      });
      for (let i = 0; i < messages.length; i++) {
        const message = messages[i];
        const parent = messages[i - 1];
        this.repository.addOrUpdateMessage((parent == null ? void 0 : parent.id) ?? null, message);
      }
    } else {
      throw new Error("ExternalStoreAdapter must provide either 'messages' or 'messageRepository'");
    }
    if (messages.length > 0)
      this.ensureInitialized();
    if (((oldStore == null ? void 0 : oldStore.isRunning) ?? false) !== (store.isRunning ?? false)) {
      if (store.isRunning) {
        this._notifyEventSubscribers("runStart");
      } else {
        this._notifyEventSubscribers("runEnd");
      }
    }
    if (this._assistantOptimisticId) {
      this.repository.deleteMessage(this._assistantOptimisticId);
      this._assistantOptimisticId = null;
    }
    if (hasUpcomingMessage(isRunning, messages)) {
      this._assistantOptimisticId = this.repository.appendOptimisticMessage(((_f = messages.at(-1)) == null ? void 0 : _f.id) ?? null, {
        role: "assistant",
        content: []
      });
    }
    this.repository.resetHead(this._assistantOptimisticId ?? ((_g = messages.at(-1)) == null ? void 0 : _g.id) ?? null);
    this._messages = this.repository.getMessages();
    this._notifySubscribers();
  }
  switchToBranch(branchId) {
    if (!this._store.setMessages)
      throw new Error("Runtime does not support switching branches.");
    if (this._store.isRunning) {
      return;
    }
    this.repository.switchToBranch(branchId);
    this.updateMessages(this.repository.getMessages());
  }
  async append(message) {
    var _a3;
    if (message.parentId !== (((_a3 = this.messages.at(-1)) == null ? void 0 : _a3.id) ?? null)) {
      if (!this._store.onEdit)
        throw new Error("Runtime does not support editing messages.");
      await this._store.onEdit(message);
    } else {
      await this._store.onNew(message);
    }
  }
  async startRun(config2) {
    if (!this._store.onReload)
      throw new Error("Runtime does not support reloading messages.");
    await this._store.onReload(config2.parentId, config2);
  }
  async resumeRun(config2) {
    if (!this._store.onResume)
      throw new Error("Runtime does not support resuming runs.");
    await this._store.onResume(config2);
  }
  exportExternalState() {
    if (!this._store.onExportExternalState)
      throw new Error("Runtime does not support exporting external states.");
    return this._store.onExportExternalState();
  }
  importExternalState(state) {
    if (!this._store.onLoadExternalState)
      throw new Error("Runtime does not support importing external states.");
    this._store.onLoadExternalState(state);
  }
  unstable_loadExternalState(state) {
    this.importExternalState(state);
  }
  cancelRun() {
    var _a3;
    if (!this._store.onCancel)
      throw new Error("Runtime does not support cancelling runs.");
    this._store.onCancel();
    if (this._assistantOptimisticId) {
      this.repository.deleteMessage(this._assistantOptimisticId);
      this._assistantOptimisticId = null;
    }
    let messages = this.repository.getMessages();
    const previousMessage = messages[messages.length - 1];
    if ((previousMessage == null ? void 0 : previousMessage.role) === "user" && previousMessage.id === ((_a3 = messages.at(-1)) == null ? void 0 : _a3.id)) {
      this.repository.deleteMessage(previousMessage.id);
      if (!this.composer.text.trim()) {
        this.composer.setText(getThreadMessageText(previousMessage));
      }
      messages = this.repository.getMessages();
    } else {
      this._notifySubscribers();
    }
    setTimeout(() => {
      this.updateMessages(messages);
    }, 0);
  }
  addToolResult(options) {
    var _a3, _b;
    if (!this._store.onAddToolResult && !this._store.onAddToolResult)
      throw new Error("Runtime does not support tool results.");
    (_b = (_a3 = this._store).onAddToolResult) == null ? void 0 : _b.call(_a3, options);
  }
  resumeToolCall(options) {
    if (!this._store.onResumeToolCall)
      throw new Error("Runtime does not support resuming tool calls.");
    this._store.onResumeToolCall(options);
  }
  reset(initialMessages) {
    const repo = new MessageRepository();
    repo.import(ExportedMessageRepository.fromArray(initialMessages ?? []));
    this.updateMessages(repo.getMessages());
  }
  import(data) {
    this._assistantOptimisticId = null;
    super.import(data);
    if (this._store.onImport) {
      this._store.onImport(this.repository.getMessages());
    }
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/ExternalStoreRuntimeCore.js
var getThreadListAdapter = (store) => {
  var _a3;
  return ((_a3 = store.adapters) == null ? void 0 : _a3.threadList) ?? {};
};
var ExternalStoreRuntimeCore = class extends BaseAssistantRuntimeCore {
  constructor(adapter) {
    super();
    __publicField(this, "threads");
    this.threads = new ExternalStoreThreadListRuntimeCore(getThreadListAdapter(adapter), () => new ExternalStoreThreadRuntimeCore(this._contextProvider, adapter));
  }
  setAdapter(adapter) {
    this.threads.__internal_setAdapter(getThreadListAdapter(adapter));
    this.threads.getMainThreadRuntimeCore().__internal_setAdapter(adapter);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/useExternalStoreRuntime.js
var useExternalStoreRuntime = (store) => {
  const [runtime] = (0, import_react8.useState)(() => new ExternalStoreRuntimeCore(store));
  (0, import_react8.useEffect)(() => {
    runtime.setAdapter(store);
  });
  const { modelContext } = useRuntimeAdapters() ?? {};
  (0, import_react8.useEffect)(() => {
    if (!modelContext)
      return void 0;
    return runtime.registerModelContextProvider(modelContext);
  }, [modelContext, runtime]);
  return (0, import_react8.useMemo)(() => new AssistantRuntimeImpl(runtime), [runtime]);
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/useAssistantTransportRuntime.js
var import_react14 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/commandQueue.js
var import_react9 = __toESM(require_react(), 1);
var createInitialQueueState = () => ({
  queued: [],
  inTransit: []
});
var useCommandQueue = (opts) => {
  const onQueueRef = (0, import_react9.useRef)(opts.onQueue);
  (0, import_react9.useEffect)(() => {
    onQueueRef.current = opts.onQueue;
  });
  const [, rerender] = (0, import_react9.useState)(0);
  const queueStateRef = (0, import_react9.useRef)(createInitialQueueState());
  const enqueue = (command) => {
    queueStateRef.current = {
      queued: [...queueStateRef.current.queued, command],
      inTransit: queueStateRef.current.inTransit
    };
    rerender((prev) => prev + 1);
    onQueueRef.current();
  };
  const flush = () => {
    if (queueStateRef.current.queued.length === 0)
      return [];
    const queued = queueStateRef.current.queued;
    queueStateRef.current = {
      queued: [],
      inTransit: [...queueStateRef.current.inTransit, ...queued]
    };
    rerender((prev) => prev + 1);
    return queued;
  };
  const markDelivered = () => {
    queueStateRef.current = { ...queueStateRef.current, inTransit: [] };
    rerender((prev) => prev + 1);
  };
  const reset = (0, import_react9.useCallback)(() => {
    queueStateRef.current = createInitialQueueState();
    rerender((prev) => prev + 1);
  }, []);
  return {
    state: queueStateRef.current,
    enqueue,
    flush,
    markDelivered,
    reset
  };
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/runManager.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/useLatestRef.js
var import_react10 = __toESM(require_react(), 1);
function useLatestRef(value) {
  const ref = (0, import_react10.useRef)(value);
  (0, import_react10.useEffect)(() => {
    ref.current = value;
  }, [value]);
  return ref;
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/runManager.js
function useRunManager(config2) {
  const [isRunning, setIsRunning] = (0, import_react11.useState)(false);
  const stateRef = (0, import_react11.useRef)({
    pending: false,
    abortController: null
  });
  const onRunRef = useLatestRef(config2.onRun);
  const onFinishRef = useLatestRef(config2.onFinish);
  const onCancelRef = useLatestRef(config2.onCancel);
  const onErrorRef = useLatestRef(config2.onError);
  const startRun = (0, import_react11.useCallback)(() => {
    setIsRunning(true);
    stateRef.current.pending = false;
    const ac = new AbortController();
    stateRef.current.abortController = ac;
    queueMicrotask(async () => {
      var _a3, _b, _c;
      try {
        await onRunRef.current(ac.signal);
      } catch (error48) {
        stateRef.current.pending = false;
        if (ac.signal.aborted) {
          (_a3 = onCancelRef.current) == null ? void 0 : _a3.call(onCancelRef);
        } else {
          await ((_b = onErrorRef.current) == null ? void 0 : _b.call(onErrorRef, error48));
        }
      } finally {
        (_c = onFinishRef.current) == null ? void 0 : _c.call(onFinishRef);
        if (stateRef.current.pending) {
          startRun();
        } else {
          setIsRunning(false);
          stateRef.current.abortController = null;
        }
      }
    });
  }, [onRunRef, onFinishRef, onErrorRef, onCancelRef]);
  const schedule = (0, import_react11.useCallback)(() => {
    if (stateRef.current.abortController) {
      stateRef.current.pending = true;
      return;
    }
    startRun();
  }, [startRun]);
  const cancel = (0, import_react11.useCallback)(() => {
    var _a3;
    stateRef.current.pending = false;
    (_a3 = stateRef.current.abortController) == null ? void 0 : _a3.abort();
  }, []);
  return {
    isRunning,
    schedule,
    cancel
  };
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/useConvertedState.js
var import_react12 = __toESM(require_react(), 1);
function useConvertedState(converter, agentState, pendingCommands, isSending, toolStatuses) {
  return (0, import_react12.useMemo)(() => converter(agentState, { pendingCommands, isSending, toolStatuses }), [converter, agentState, pendingCommands, isSending, toolStatuses]);
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/useToolInvocations.js
var import_react13 = __toESM(require_react(), 1);
var isArgsTextComplete = (argsText) => {
  try {
    JSON.parse(argsText);
    return true;
  } catch {
    return false;
  }
};
function useToolInvocations({ state, getTools, onResult, setToolStatuses }) {
  const lastToolStates = (0, import_react13.useRef)({});
  const humanInputRef = (0, import_react13.useRef)(/* @__PURE__ */ new Map());
  const acRef = (0, import_react13.useRef)(new AbortController());
  const executingCountRef = (0, import_react13.useRef)(0);
  const settledResolversRef = (0, import_react13.useRef)([]);
  const [controller] = (0, import_react13.useState)(() => {
    const [stream, controller2] = createAssistantStreamController();
    const transform2 = toolResultStream(getTools, () => {
      var _a3;
      return ((_a3 = acRef.current) == null ? void 0 : _a3.signal) ?? new AbortController().signal;
    }, (toolCallId, payload) => {
      return new Promise((resolve, reject) => {
        const previous = humanInputRef.current.get(toolCallId);
        if (previous) {
          previous.reject(new Error("Human input request was superseded by a new request"));
        }
        humanInputRef.current.set(toolCallId, { resolve, reject });
        setToolStatuses((prev) => ({
          ...prev,
          [toolCallId]: {
            type: "interrupt",
            payload: { type: "human", payload }
          }
        }));
      });
    }, {
      onExecutionStart: (toolCallId) => {
        executingCountRef.current++;
        setToolStatuses((prev) => ({
          ...prev,
          [toolCallId]: { type: "executing" }
        }));
      },
      onExecutionEnd: (toolCallId) => {
        executingCountRef.current--;
        setToolStatuses((prev) => {
          const next = { ...prev };
          delete next[toolCallId];
          return next;
        });
        if (executingCountRef.current === 0) {
          settledResolversRef.current.forEach((resolve) => resolve());
          settledResolversRef.current = [];
        }
      }
    });
    stream.pipeThrough(transform2).pipeThrough(new AssistantMetaTransformStream()).pipeTo(new WritableStream({
      write(chunk) {
        var _a3;
        if (chunk.type === "result") {
          if ((_a3 = lastToolStates.current[chunk.meta.toolCallId]) == null ? void 0 : _a3.hasResult)
            return;
          onResult({
            type: "add-tool-result",
            toolCallId: chunk.meta.toolCallId,
            toolName: chunk.meta.toolName,
            result: chunk.result,
            isError: chunk.isError,
            ...chunk.artifact && { artifact: chunk.artifact }
          });
        }
      }
    }));
    return controller2;
  });
  const ignoredToolIds = (0, import_react13.useRef)(/* @__PURE__ */ new Set());
  const isInitialState = (0, import_react13.useRef)(true);
  (0, import_react13.useEffect)(() => {
    const processMessages = (messages) => {
      messages.forEach((message) => {
        message.content.forEach((content) => {
          if (content.type === "tool-call") {
            if (isInitialState.current) {
              ignoredToolIds.current.add(content.toolCallId);
            } else {
              if (ignoredToolIds.current.has(content.toolCallId)) {
                return;
              }
              let lastState = lastToolStates.current[content.toolCallId];
              if (!lastState) {
                const toolCallController = controller.addToolCallPart({
                  toolName: content.toolName,
                  toolCallId: content.toolCallId
                });
                lastState = {
                  argsText: "",
                  hasResult: false,
                  argsComplete: false,
                  controller: toolCallController
                };
                lastToolStates.current[content.toolCallId] = lastState;
              }
              if (content.argsText !== lastState.argsText) {
                if (lastState.argsComplete) {
                  if (true) {
                    console.warn("argsText updated after controller was closed:", {
                      previous: lastState.argsText,
                      next: content.argsText
                    });
                  }
                } else {
                  if (!content.argsText.startsWith(lastState.argsText)) {
                    if (isArgsTextComplete(lastState.argsText) && isArgsTextComplete(content.argsText)) {
                      lastState.controller.argsText.close();
                      lastToolStates.current[content.toolCallId] = {
                        argsText: content.argsText,
                        hasResult: lastState.hasResult,
                        argsComplete: true,
                        controller: lastState.controller
                      };
                      return;
                    }
                    throw new Error(`Tool call argsText can only be appended, not updated: ${content.argsText} does not start with ${lastState.argsText}`);
                  }
                  const argsTextDelta = content.argsText.slice(lastState.argsText.length);
                  lastState.controller.argsText.append(argsTextDelta);
                  const shouldClose = isArgsTextComplete(content.argsText);
                  if (shouldClose) {
                    lastState.controller.argsText.close();
                  }
                  lastToolStates.current[content.toolCallId] = {
                    argsText: content.argsText,
                    hasResult: lastState.hasResult,
                    argsComplete: shouldClose,
                    controller: lastState.controller
                  };
                }
              }
              if (content.result !== void 0 && !lastState.hasResult) {
                lastState.controller.setResponse(new ToolResponse({
                  result: content.result,
                  artifact: content.artifact,
                  isError: content.isError
                }));
                lastState.controller.close();
                lastToolStates.current[content.toolCallId] = {
                  hasResult: true,
                  argsComplete: true,
                  argsText: lastState.argsText,
                  controller: lastState.controller
                };
              }
            }
            if (content.messages) {
              processMessages(content.messages);
            }
          }
        });
      });
    };
    processMessages(state.messages);
    if (isInitialState.current) {
      isInitialState.current = false;
    }
  }, [state, controller]);
  const abort = () => {
    humanInputRef.current.forEach(({ reject }) => {
      reject(new Error("Tool execution aborted"));
    });
    humanInputRef.current.clear();
    acRef.current.abort();
    acRef.current = new AbortController();
    if (executingCountRef.current === 0) {
      return Promise.resolve();
    }
    return new Promise((resolve) => {
      settledResolversRef.current.push(resolve);
    });
  };
  return {
    reset: () => {
      void abort();
      isInitialState.current = true;
    },
    abort,
    resume: (toolCallId, payload) => {
      const handlers = humanInputRef.current.get(toolCallId);
      if (handlers) {
        humanInputRef.current.delete(toolCallId);
        setToolStatuses((prev) => ({
          ...prev,
          [toolCallId]: { type: "executing" }
        }));
        handlers.resolve(payload);
      } else {
        throw new Error(`Tool call ${toolCallId} is not waiting for human input`);
      }
    }
  };
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/utils.js
async function createRequestHeaders(headersValue) {
  const resolvedHeaders = typeof headersValue === "function" ? await headersValue() : headersValue;
  const headers = new Headers(resolvedHeaders);
  headers.set("Content-Type", "application/json");
  return headers;
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/adapter/in-memory.js
var InMemoryThreadListAdapter = class {
  list() {
    return Promise.resolve({
      threads: []
    });
  }
  rename() {
    return Promise.resolve();
  }
  archive() {
    return Promise.resolve();
  }
  unarchive() {
    return Promise.resolve();
  }
  delete() {
    return Promise.resolve();
  }
  initialize(threadId) {
    return Promise.resolve({ remoteId: threadId, externalId: void 0 });
  }
  generateTitle() {
    return Promise.resolve(new ReadableStream());
  }
  fetch(_threadId) {
    return Promise.reject(new Error("Thread not found"));
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/assistant-transport/useAssistantTransportRuntime.js
var symbolAssistantTransportExtras = Symbol("assistant-transport-extras");
var asAssistantTransportExtras = (extras) => {
  if (typeof extras !== "object" || extras == null || !(symbolAssistantTransportExtras in extras))
    throw new Error("This method can only be called when you are using useAssistantTransportRuntime");
  return extras;
};
var useAssistantTransportSendCommand = () => {
  const aui = useAui();
  return (command) => {
    const extras = aui.thread().getState().extras;
    const transportExtras = asAssistantTransportExtras(extras);
    transportExtras.sendCommand(command);
  };
};
function useAssistantTransportState(selector = (t) => t) {
  return useAuiState(({ thread }) => selector(asAssistantTransportExtras(thread.extras).state));
}
var useAssistantTransportThreadRuntime = (options) => {
  const agentStateRef = (0, import_react14.useRef)(options.initialState);
  const [, rerender] = (0, import_react14.useState)(0);
  const resumeFlagRef = (0, import_react14.useRef)(false);
  const parentIdRef = (0, import_react14.useRef)(void 0);
  const commandQueue = useCommandQueue({
    onQueue: () => runManager.schedule()
  });
  const threadId = useAuiState(({ threadListItem }) => threadListItem.remoteId);
  const runManager = useRunManager({
    onRun: async (signal) => {
      var _a3;
      const isResume = resumeFlagRef.current;
      resumeFlagRef.current = false;
      const commands = isResume ? [] : commandQueue.flush();
      if (commands.length === 0 && !isResume)
        throw new Error("No commands to send");
      const headers = await createRequestHeaders(options.headers);
      const bodyValue = typeof options.body === "function" ? await options.body() : options.body;
      const context2 = runtime.thread.getModelContext();
      const response = await fetch(isResume ? options.resumeApi : options.api, {
        method: "POST",
        headers,
        body: JSON.stringify({
          commands,
          state: agentStateRef.current,
          system: context2.system,
          tools: context2.tools ? toToolsJSONSchema(context2.tools) : void 0,
          threadId,
          ...parentIdRef.current !== void 0 && {
            parentId: parentIdRef.current
          },
          ...context2.callSettings,
          ...context2.config,
          ...bodyValue ?? {}
        }),
        signal
      });
      (_a3 = options.onResponse) == null ? void 0 : _a3.call(options, response);
      if (!response.ok) {
        throw new Error(`Status ${response.status}: ${await response.text()}`);
      }
      if (!response.body) {
        throw new Error("Response body is null");
      }
      const protocol = options.protocol ?? "data-stream";
      const decoder = protocol === "assistant-transport" ? new AssistantTransportDecoder() : new DataStreamDecoder();
      let err;
      const stream = response.body.pipeThrough(decoder).pipeThrough(new AssistantMessageAccumulator({
        initialMessage: createInitialMessage({
          unstable_state: agentStateRef.current ?? null
        }),
        throttle: isResume,
        onError: (error48) => {
          err = error48;
        }
      }));
      let markedDelivered = false;
      for await (const chunk of asAsyncIterableStream(stream)) {
        if (chunk.metadata.unstable_state === agentStateRef.current)
          continue;
        if (!markedDelivered) {
          commandQueue.markDelivered();
          markedDelivered = true;
        }
        agentStateRef.current = chunk.metadata.unstable_state;
        rerender((prev) => prev + 1);
      }
      if (err) {
        throw new Error(err);
      }
    },
    onFinish: options.onFinish,
    onCancel: () => {
      var _a3;
      const cmds = [
        ...commandQueue.state.inTransit,
        ...commandQueue.state.queued
      ];
      commandQueue.reset();
      (_a3 = options.onCancel) == null ? void 0 : _a3.call(options, {
        commands: cmds,
        updateState: (updater) => {
          agentStateRef.current = updater(agentStateRef.current);
          rerender((prev) => prev + 1);
        }
      });
    },
    onError: async (error48) => {
      var _a3, _b;
      const inTransitCmds = [...commandQueue.state.inTransit];
      const queuedCmds = [...commandQueue.state.queued];
      commandQueue.reset();
      try {
        await ((_a3 = options.onError) == null ? void 0 : _a3.call(options, error48, {
          commands: inTransitCmds,
          updateState: (updater) => {
            agentStateRef.current = updater(agentStateRef.current);
            rerender((prev) => prev + 1);
          }
        }));
      } finally {
        (_b = options.onCancel) == null ? void 0 : _b.call(options, {
          commands: queuedCmds,
          updateState: (updater) => {
            agentStateRef.current = updater(agentStateRef.current);
            rerender((prev) => prev + 1);
          },
          error: error48
        });
      }
    }
  });
  const [toolStatuses, setToolStatuses] = (0, import_react14.useState)({});
  const pendingCommands = (0, import_react14.useMemo)(() => [...commandQueue.state.inTransit, ...commandQueue.state.queued], [commandQueue.state]);
  const converted = useConvertedState(options.converter, agentStateRef.current, pendingCommands, runManager.isRunning, toolStatuses);
  const runtime = useExternalStoreRuntime({
    messages: converted.messages,
    state: converted.state,
    isRunning: converted.isRunning,
    adapters: options.adapters,
    extras: {
      [symbolAssistantTransportExtras]: true,
      sendCommand: (command) => {
        commandQueue.enqueue(command);
      },
      state: agentStateRef.current
    },
    onNew: async (message) => {
      var _a3;
      if (message.role !== "user")
        throw new Error("Only user messages are supported");
      parentIdRef.current = message.parentId;
      const parts = [];
      const content = [
        ...message.content,
        ...((_a3 = message.attachments) == null ? void 0 : _a3.flatMap((a) => a.content)) ?? []
      ];
      for (const contentPart of content) {
        if (contentPart.type === "text") {
          parts.push({ type: "text", text: contentPart.text });
        } else if (contentPart.type === "image") {
          parts.push({ type: "image", image: contentPart.image });
        }
      }
      const command = {
        type: "add-message",
        message: {
          role: "user",
          parts
        }
      };
      commandQueue.enqueue(command);
    },
    onCancel: async () => {
      runManager.cancel();
      await toolInvocations.abort();
    },
    onResume: async () => {
      if (!options.resumeApi)
        throw new Error("Must pass resumeApi to options to resume runs");
      resumeFlagRef.current = true;
      runManager.schedule();
    },
    onAddToolResult: async (toolOptions) => {
      const command = {
        type: "add-tool-result",
        toolCallId: toolOptions.toolCallId,
        result: toolOptions.result,
        toolName: toolOptions.toolName,
        isError: toolOptions.isError,
        ...toolOptions.artifact && { artifact: toolOptions.artifact }
      };
      commandQueue.enqueue(command);
    },
    onLoadExternalState: async (state) => {
      agentStateRef.current = state;
      toolInvocations.reset();
      rerender((prev) => prev + 1);
    }
  });
  const toolInvocations = useToolInvocations({
    state: converted,
    getTools: () => runtime.thread.getModelContext().tools,
    onResult: commandQueue.enqueue,
    setToolStatuses
  });
  return runtime;
};
var useAssistantTransportRuntime = (options) => {
  const runtime = useRemoteThreadListRuntime({
    runtimeHook: function RuntimeHook() {
      return useAssistantTransportThreadRuntime(options);
    },
    adapter: new InMemoryThreadListAdapter(),
    allowNesting: true
  });
  return runtime;
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/external-message-converter.js
var import_react15 = __toESM(require_react(), 1);
var joinExternalMessages = (messages) => {
  const assistantMessage = {
    role: "assistant",
    content: []
  };
  for (const output of messages) {
    if (output.role === "tool") {
      const toolCallIdx = assistantMessage.content.findIndex((c) => c.type === "tool-call" && c.toolCallId === output.toolCallId);
      if (toolCallIdx !== -1) {
        const toolCall = assistantMessage.content[toolCallIdx];
        if (output.toolName !== void 0) {
          if (toolCall.toolName !== output.toolName)
            throw new Error(`Tool call name ${output.toolCallId} ${output.toolName} does not match existing tool call ${toolCall.toolName}`);
        }
        assistantMessage.content[toolCallIdx] = {
          ...toolCall,
          ...{
            [symbolInnerMessage]: [
              ...toolCall[symbolInnerMessage] ?? [],
              output
            ]
          },
          result: output.result,
          artifact: output.artifact,
          isError: output.isError,
          messages: output.messages
        };
      } else {
        throw new Error(`Tool call ${output.toolCallId} ${output.toolName} not found in assistant message`);
      }
    } else {
      const role = output.role;
      const content = (typeof output.content === "string" ? [{ type: "text", text: output.content }] : output.content).map((c) => ({
        ...c,
        ...{ [symbolInnerMessage]: [output] }
      }));
      switch (role) {
        case "system":
        case "user":
          return {
            ...output,
            content
          };
        case "assistant":
          if (assistantMessage.content.length === 0) {
            assistantMessage.id = output.id;
            assistantMessage.createdAt ?? (assistantMessage.createdAt = output.createdAt);
            assistantMessage.status ?? (assistantMessage.status = output.status);
            if (output.attachments) {
              assistantMessage.attachments = [
                ...assistantMessage.attachments ?? [],
                ...output.attachments
              ];
            }
            if (output.metadata) {
              assistantMessage.metadata ?? (assistantMessage.metadata = {});
              if (output.metadata.unstable_state) {
                assistantMessage.metadata.unstable_state = output.metadata.unstable_state;
              }
              if (output.metadata.unstable_annotations) {
                assistantMessage.metadata.unstable_annotations = [
                  ...assistantMessage.metadata.unstable_annotations ?? [],
                  ...output.metadata.unstable_annotations
                ];
              }
              if (output.metadata.unstable_data) {
                assistantMessage.metadata.unstable_data = [
                  ...assistantMessage.metadata.unstable_data ?? [],
                  ...output.metadata.unstable_data
                ];
              }
              if (output.metadata.steps) {
                assistantMessage.metadata.steps = [
                  ...assistantMessage.metadata.steps ?? [],
                  ...output.metadata.steps
                ];
              }
              if (output.metadata.custom) {
                assistantMessage.metadata.custom = {
                  ...assistantMessage.metadata.custom ?? {},
                  ...output.metadata.custom
                };
              }
              if (output.metadata.submittedFeedback) {
                assistantMessage.metadata.submittedFeedback = output.metadata.submittedFeedback;
              }
            }
          }
          for (const part of content) {
            if (part.type === "reasoning" && "parentId" in part && part.parentId) {
              const existingIdx = assistantMessage.content.findIndex((c) => c.type === "reasoning" && "parentId" in c && c.parentId === part.parentId);
              if (existingIdx !== -1) {
                const existing = assistantMessage.content[existingIdx];
                assistantMessage.content[existingIdx] = {
                  ...existing,
                  text: `${existing.text}

${part.text}`,
                  ...{
                    [symbolInnerMessage]: [
                      ...existing[symbolInnerMessage] ?? [],
                      ...part[symbolInnerMessage] ?? []
                    ]
                  }
                };
                continue;
              }
            }
            assistantMessage.content.push(part);
          }
          break;
        default: {
          const unsupportedRole = role;
          throw new Error(`Unknown message role: ${unsupportedRole}`);
        }
      }
    }
  }
  return assistantMessage;
};
var chunkExternalMessages = (callbackResults, joinStrategy) => {
  var _a3;
  const results = [];
  let isAssistant = false;
  let pendingNone = false;
  let inputs = [];
  let outputs = [];
  const flush = () => {
    if (outputs.length) {
      results.push({
        inputs,
        outputs
      });
    }
    inputs = [];
    outputs = [];
    isAssistant = false;
    pendingNone = false;
  };
  for (const callbackResult of callbackResults) {
    for (const output of callbackResult.outputs) {
      if (pendingNone && output.role !== "tool" || !isAssistant || output.role === "user" || output.role === "system") {
        flush();
      }
      isAssistant = output.role === "assistant" || output.role === "tool";
      if (inputs.at(-1) !== callbackResult.input) {
        inputs.push(callbackResult.input);
      }
      outputs.push(output);
      if (output.role === "assistant" && (((_a3 = output.convertConfig) == null ? void 0 : _a3.joinStrategy) === "none" || joinStrategy === "none")) {
        pendingNone = true;
      }
    }
  }
  flush();
  return results;
};
function createErrorAssistantMessage(error48) {
  return Object.assign({
    id: generateErrorMessageId(),
    role: "assistant",
    content: [],
    status: { type: "incomplete", reason: "error", error: error48 },
    createdAt: /* @__PURE__ */ new Date(),
    metadata: {
      unstable_state: null,
      unstable_annotations: [],
      unstable_data: [],
      custom: {},
      steps: []
    }
  }, { [symbolInnerMessage]: [] });
}
var convertExternalMessages = (messages, callback, isRunning, metadata) => {
  const callbackResults = [];
  for (const message of messages) {
    const output = callback(message, metadata);
    const outputs = Array.isArray(output) ? output : [output];
    const result2 = { input: message, outputs };
    callbackResults.push(result2);
  }
  const chunks = chunkExternalMessages(callbackResults);
  const result = chunks.map((message, idx) => {
    const isLast = idx === chunks.length - 1;
    const joined = joinExternalMessages(message.outputs);
    const hasPendingToolCalls = typeof joined.content === "object" && joined.content.some((c) => c.type === "tool-call" && c.result === void 0);
    const autoStatus = getAutoStatus(isLast, isRunning, hasPendingToolCalls, hasPendingToolCalls, isLast ? metadata.error : void 0);
    const newMessage = fromThreadMessageLike(joined, idx.toString(), autoStatus);
    newMessage[symbolInnerMessage] = message.inputs;
    return newMessage;
  });
  if (metadata.error) {
    const lastMessage = result.at(-1);
    if (!lastMessage || lastMessage.role !== "assistant") {
      result.push(createErrorAssistantMessage(metadata.error));
    }
  }
  return result;
};
var useExternalMessageConverter = ({ callback, messages, isRunning, joinStrategy, metadata }) => {
  const state = (0, import_react15.useMemo)(() => ({
    metadata: metadata ?? {},
    callback,
    callbackCache: /* @__PURE__ */ new WeakMap(),
    chunkCache: /* @__PURE__ */ new WeakMap(),
    converterCache: new ThreadMessageConverter()
  }), [callback, metadata]);
  return (0, import_react15.useMemo)(() => {
    const callbackResults = [];
    for (const message of messages) {
      let result = state.callbackCache.get(message);
      if (!result) {
        const output = state.callback(message, state.metadata);
        const outputs = Array.isArray(output) ? output : [output];
        result = { input: message, outputs };
        state.callbackCache.set(message, result);
      }
      callbackResults.push(result);
    }
    const chunks = chunkExternalMessages(callbackResults, joinStrategy).map((m) => {
      const key = m.outputs[0];
      if (!key)
        return m;
      const cached2 = state.chunkCache.get(key);
      if (cached2 && shallowArrayEqual(cached2.outputs, m.outputs))
        return cached2;
      state.chunkCache.set(key, m);
      return m;
    });
    const threadMessages = state.converterCache.convertMessages(chunks, (cache, message, idx) => {
      const isLast = idx === chunks.length - 1;
      const joined = joinExternalMessages(message.outputs);
      const hasSuspendedToolCalls = typeof joined.content === "object" && joined.content.some((c) => c.type === "tool-call" && c.result === void 0);
      const hasPendingToolCalls = typeof joined.content === "object" && joined.content.some((c) => c.type === "tool-call" && c.result === void 0);
      const autoStatus = getAutoStatus(isLast, isRunning, hasSuspendedToolCalls, hasPendingToolCalls, isLast ? state.metadata.error : void 0);
      if (cache && (cache.role !== "assistant" || !isAutoStatus(cache.status) || cache.status === autoStatus)) {
        const inputs = getExternalStoreMessages(cache);
        if (shallowArrayEqual(inputs, message.inputs)) {
          return cache;
        }
      }
      const newMessage = fromThreadMessageLike(joined, idx.toString(), autoStatus);
      newMessage[symbolInnerMessage] = message.inputs;
      return newMessage;
    });
    threadMessages[symbolInnerMessage] = messages;
    if (state.metadata.error) {
      const lastMessage = threadMessages.at(-1);
      if (!lastMessage || lastMessage.role !== "assistant") {
        threadMessages.push(createErrorAssistantMessage(state.metadata.error));
      }
    }
    return threadMessages;
  }, [state, messages, isRunning, joinStrategy]);
};
var shallowArrayEqual = (a, b) => {
  if (a.length !== b.length)
    return false;
  for (let i = 0; i < a.length; i++) {
    if (a[i] !== b[i])
      return false;
  }
  return true;
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/external-store/createMessageConverter.js
var createMessageConverter = (callback) => {
  const result = {
    useThreadMessages: ({ messages, isRunning, joinStrategy, metadata }) => {
      return useExternalMessageConverter({
        callback,
        messages,
        isRunning,
        joinStrategy,
        metadata
      });
    },
    toThreadMessages: (messages, isRunning = false, metadata = {}) => {
      return convertExternalMessages(messages, callback, isRunning, metadata);
    },
    toOriginalMessages: (input) => {
      const messages = getExternalStoreMessages(input);
      if (messages.length === 0)
        throw new Error("No original messages found");
      return messages;
    },
    toOriginalMessage: (input) => {
      const messages = result.toOriginalMessages(input);
      return messages[0];
    },
    useOriginalMessage: () => {
      const messageMessages = result.useOriginalMessages();
      const first = messageMessages[0];
      return first;
    },
    useOriginalMessages: () => {
      const aui = useAui();
      const partMessages = useAuiState((s) => {
        if (aui.part.source)
          return getExternalStoreMessages(s.part);
        return void 0;
      });
      const messageMessages = useAuiState(({ message }) => getExternalStoreMessages(message));
      const messages = partMessages ?? messageMessages;
      if (messages.length === 0)
        throw new Error("No original messages found");
      return messages;
    }
  };
  return result;
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/local/useLocalRuntime.js
var import_react18 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/local/shouldContinue.js
var shouldContinue = (result, humanToolNames) => {
  var _a3, _b;
  if (humanToolNames === void 0) {
    return ((_a3 = result.status) == null ? void 0 : _a3.type) === "requires-action" && result.status.reason === "tool-calls" && result.content.every((c) => c.type !== "tool-call" || !!c.result);
  }
  return ((_b = result.status) == null ? void 0 : _b.type) === "requires-action" && result.status.reason === "tool-calls" && result.content.every((c) => c.type !== "tool-call" || !!c.result || !humanToolNames.includes(c.toolName));
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/local/LocalThreadRuntimeCore.js
var AbortError = class extends Error {
  constructor(detach, message) {
    super(message);
    __publicField(this, "name", "AbortError");
    __publicField(this, "detach");
    this.detach = detach;
  }
};
var LocalThreadRuntimeCore = class extends BaseThreadRuntimeCore {
  constructor(contextProvider, options) {
    super(contextProvider);
    __publicField(this, "capabilities", {
      switchToBranch: true,
      switchBranchDuringRun: true,
      edit: true,
      reload: true,
      cancel: true,
      unstable_copy: true,
      speech: false,
      dictation: false,
      attachments: false,
      feedback: false
    });
    __publicField(this, "abortController", null);
    __publicField(this, "isDisabled", false);
    __publicField(this, "_isLoading", false);
    __publicField(this, "_suggestions", []);
    __publicField(this, "_suggestionsController", null);
    __publicField(this, "_options");
    __publicField(this, "_lastRunConfig", {});
    __publicField(this, "_getThreadId");
    __publicField(this, "_getInitializePromise");
    __publicField(this, "_loadPromise");
    this.__internal_setOptions(options);
  }
  get isLoading() {
    return this._isLoading;
  }
  get suggestions() {
    return this._suggestions;
  }
  get adapters() {
    return this._options.adapters;
  }
  __internal_setGetThreadId(getThreadId) {
    this._getThreadId = getThreadId;
  }
  __internal_setGetInitializePromise(getPromise) {
    this._getInitializePromise = getPromise;
  }
  get extras() {
    return void 0;
  }
  __internal_setOptions(options) {
    var _a3, _b, _c, _d;
    if (this._options === options)
      return;
    this._options = options;
    let hasUpdates = false;
    const canSpeak = ((_a3 = options.adapters) == null ? void 0 : _a3.speech) !== void 0;
    if (this.capabilities.speech !== canSpeak) {
      this.capabilities.speech = canSpeak;
      hasUpdates = true;
    }
    const canDictate = ((_b = options.adapters) == null ? void 0 : _b.dictation) !== void 0;
    if (this.capabilities.dictation !== canDictate) {
      this.capabilities.dictation = canDictate;
      hasUpdates = true;
    }
    const canAttach = ((_c = options.adapters) == null ? void 0 : _c.attachments) !== void 0;
    if (this.capabilities.attachments !== canAttach) {
      this.capabilities.attachments = canAttach;
      hasUpdates = true;
    }
    const canFeedback = ((_d = options.adapters) == null ? void 0 : _d.feedback) !== void 0;
    if (this.capabilities.feedback !== canFeedback) {
      this.capabilities.feedback = canFeedback;
      hasUpdates = true;
    }
    if (hasUpdates)
      this._notifySubscribers();
  }
  __internal_load() {
    var _a3;
    if (this._loadPromise)
      return this._loadPromise;
    const promise2 = ((_a3 = this.adapters.history) == null ? void 0 : _a3.load()) ?? Promise.resolve(null);
    this._isLoading = true;
    this._notifySubscribers();
    this._loadPromise = promise2.then((repo) => {
      var _a4, _b;
      if (!repo)
        return;
      this.repository.import(repo);
      if (repo.messages.length > 0) {
        this.ensureInitialized();
      }
      this._notifySubscribers();
      const resume = (_b = (_a4 = this.adapters.history) == null ? void 0 : _a4.resume) == null ? void 0 : _b.bind(this.adapters.history);
      if (repo.unstable_resume && resume) {
        this.startRun({
          parentId: this.repository.headId,
          sourceId: this.repository.headId,
          runConfig: this._lastRunConfig
        }, resume);
      }
    }).finally(() => {
      this._isLoading = false;
      this._notifySubscribers();
    });
    return this._loadPromise;
  }
  async append(message) {
    var _a3, _b;
    this.ensureInitialized();
    const initPromise = (_a3 = this._getInitializePromise) == null ? void 0 : _a3.call(this);
    if (initPromise) {
      await initPromise;
    }
    const newMessage = fromThreadMessageLike(message, generateId(), {
      type: "complete",
      reason: "unknown"
    });
    this.repository.addOrUpdateMessage(message.parentId, newMessage);
    (_b = this._options.adapters.history) == null ? void 0 : _b.append({
      parentId: message.parentId,
      message: newMessage,
      ...message.runConfig !== void 0 && { runConfig: message.runConfig }
    });
    const startRun = message.startRun ?? message.role === "user";
    if (startRun) {
      await this.startRun({
        parentId: newMessage.id,
        sourceId: message.sourceId,
        runConfig: message.runConfig ?? {}
      });
    } else {
      this.repository.resetHead(newMessage.id);
      this._notifySubscribers();
    }
  }
  resumeRun({ stream, ...startConfig }) {
    if (!stream)
      throw new Error("You must pass a stream parameter to resume runs.");
    return this.startRun(startConfig, stream);
  }
  exportExternalState() {
    throw new Error("Runtime does not support exporting external states.");
  }
  importExternalState() {
    throw new Error("Runtime does not support importing external states.");
  }
  unstable_loadExternalState() {
    throw new Error("Runtime does not support importing external states.");
  }
  async startRun({ parentId, runConfig }, runCallback) {
    var _a3, _b, _c;
    this.ensureInitialized();
    const id = generateId();
    let message = {
      id,
      role: "assistant",
      status: { type: "running" },
      content: [],
      metadata: {
        unstable_state: this.state,
        unstable_annotations: [],
        unstable_data: [],
        steps: [],
        custom: {}
      },
      createdAt: /* @__PURE__ */ new Date()
    };
    this._notifyEventSubscribers("runStart");
    try {
      this._suggestions = [];
      (_a3 = this._suggestionsController) == null ? void 0 : _a3.abort();
      this._suggestionsController = null;
      this._notifySubscribers();
      do {
        message = await this.performRoundtrip(parentId, message, runConfig, runCallback);
        runCallback = void 0;
      } while (shouldContinue(message, this._options.unstable_humanToolNames));
    } finally {
      this._notifyEventSubscribers("runEnd");
    }
    this._suggestionsController = new AbortController();
    const signal = this._suggestionsController.signal;
    if (this.adapters.suggestion && ((_b = message.status) == null ? void 0 : _b.type) !== "requires-action") {
      const promiseOrGenerator = (_c = this.adapters.suggestion) == null ? void 0 : _c.generate({
        messages: this.messages
      });
      if (Symbol.asyncIterator in promiseOrGenerator) {
        for await (const r of promiseOrGenerator) {
          if (signal.aborted)
            break;
          this._suggestions = r;
          this._notifySubscribers();
        }
      } else {
        const result = await promiseOrGenerator;
        if (signal.aborted)
          return;
        this._suggestions = result;
        this._notifySubscribers();
      }
    }
  }
  async performRoundtrip(parentId, message, runConfig, runCallback) {
    var _a3, _b, _c, _d, _e, _f, _g, _h, _i;
    const messages = parentId ? this.repository.getMessages(parentId) : [];
    (_a3 = this.abortController) == null ? void 0 : _a3.abort();
    this.abortController = new AbortController();
    const initialContent = message.content;
    const initialAnnotations = (_b = message.metadata) == null ? void 0 : _b.unstable_annotations;
    const initialData = (_c = message.metadata) == null ? void 0 : _c.unstable_data;
    const initialSteps = (_d = message.metadata) == null ? void 0 : _d.steps;
    const initalCustom = (_e = message.metadata) == null ? void 0 : _e.custom;
    const updateMessage = (m) => {
      var _a4, _b2, _c2, _d2;
      const newSteps = (_a4 = m.metadata) == null ? void 0 : _a4.steps;
      const steps2 = newSteps ? [...initialSteps ?? [], ...newSteps] : void 0;
      const newAnnotations = (_b2 = m.metadata) == null ? void 0 : _b2.unstable_annotations;
      const newData = (_c2 = m.metadata) == null ? void 0 : _c2.unstable_data;
      const annotations = newAnnotations ? [...initialAnnotations ?? [], ...newAnnotations] : void 0;
      const data = newData ? [...initialData ?? [], ...newData] : void 0;
      message = {
        ...message,
        ...m.content ? { content: [...initialContent, ...m.content ?? []] } : void 0,
        status: m.status ?? message.status,
        ...m.metadata ? {
          metadata: {
            ...message.metadata,
            ...m.metadata.unstable_state ? { unstable_state: m.metadata.unstable_state } : void 0,
            ...annotations ? { unstable_annotations: annotations } : void 0,
            ...data ? { unstable_data: data } : void 0,
            ...steps2 ? { steps: steps2 } : void 0,
            ...((_d2 = m.metadata) == null ? void 0 : _d2.custom) ? {
              custom: { ...initalCustom ?? {}, ...m.metadata.custom }
            } : void 0
          }
        } : void 0
      };
      this.repository.addOrUpdateMessage(parentId, message);
      this._notifySubscribers();
    };
    const maxSteps = this._options.maxSteps ?? 2;
    const steps = ((_g = (_f = message.metadata) == null ? void 0 : _f.steps) == null ? void 0 : _g.length) ?? 0;
    if (steps >= maxSteps) {
      updateMessage({
        status: {
          type: "incomplete",
          reason: "tool-calls"
        }
      });
      return message;
    } else {
      updateMessage({
        status: {
          type: "running"
        }
      });
      this.repository.resetHead(message.id);
      this._notifySubscribers();
    }
    try {
      this._lastRunConfig = runConfig ?? {};
      const context2 = this.getModelContext();
      runCallback = runCallback ?? this.adapters.chatModel.run.bind(this.adapters.chatModel);
      const abortSignal = this.abortController.signal;
      const threadId = (_h = this._getThreadId) == null ? void 0 : _h.call(this);
      const promiseOrGenerator = runCallback({
        messages,
        runConfig: this._lastRunConfig,
        abortSignal,
        context: context2,
        config: context2,
        unstable_assistantMessageId: message.id,
        unstable_threadId: threadId,
        unstable_parentId: parentId,
        unstable_getMessage() {
          return message;
        }
      });
      if (Symbol.asyncIterator in promiseOrGenerator) {
        for await (const r of promiseOrGenerator) {
          if (abortSignal.aborted) {
            updateMessage({
              status: { type: "incomplete", reason: "cancelled" }
            });
            break;
          }
          updateMessage(r);
        }
      } else {
        updateMessage(await promiseOrGenerator);
      }
      if (message.status.type === "running") {
        updateMessage({
          status: { type: "complete", reason: "unknown" }
        });
      }
    } catch (e) {
      if (e instanceof AbortError) {
        updateMessage({
          status: { type: "incomplete", reason: "cancelled" }
        });
      } else if (e instanceof Error && e.name === "AbortError") {
        updateMessage({
          status: { type: "incomplete", reason: "cancelled" }
        });
      } else {
        updateMessage({
          status: {
            type: "incomplete",
            reason: "error",
            error: e instanceof Error ? e.message : `[${typeof e}] ${new String(e).toString()}`
          }
        });
        throw e;
      }
    } finally {
      this.abortController = null;
      if (message.status.type === "complete" || message.status.type === "incomplete") {
        await ((_i = this._options.adapters.history) == null ? void 0 : _i.append({
          parentId,
          message,
          runConfig: this._lastRunConfig
        }));
      }
    }
    return message;
  }
  detach() {
    var _a3;
    const error48 = new AbortError(true);
    (_a3 = this.abortController) == null ? void 0 : _a3.abort(error48);
    this.abortController = null;
  }
  cancelRun() {
    var _a3;
    const error48 = new AbortError(false);
    (_a3 = this.abortController) == null ? void 0 : _a3.abort(error48);
    this.abortController = null;
  }
  addToolResult({ messageId, toolCallId, result, isError, artifact }) {
    const messageData = this.repository.getMessage(messageId);
    const { parentId } = messageData;
    let { message } = messageData;
    if (message.role !== "assistant")
      throw new Error("Tried to add tool result to non-assistant message");
    let added = false;
    let found = false;
    const newContent = message.content.map((c) => {
      if (c.type !== "tool-call")
        return c;
      if (c.toolCallId !== toolCallId)
        return c;
      found = true;
      if (!c.result)
        added = true;
      return {
        ...c,
        result,
        artifact,
        isError
      };
    });
    if (!found)
      throw new Error("Tried to add tool result to non-existing tool call");
    message = {
      ...message,
      content: newContent
    };
    this.repository.addOrUpdateMessage(parentId, message);
    if (added && shouldContinue(message, this._options.unstable_humanToolNames)) {
      this.performRoundtrip(parentId, message, this._lastRunConfig);
    }
  }
  resumeToolCall(_options) {
    throw new Error("Local runtime does not support resuming tool calls.");
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/local/LocalThreadListRuntimeCore.js
var EMPTY_ARRAY5 = Object.freeze([]);
var DEFAULT_THREAD_ID2 = "__DEFAULT_ID__";
var DEFAULT_THREAD_DATA2 = Object.freeze({
  [DEFAULT_THREAD_ID2]: {
    id: DEFAULT_THREAD_ID2,
    remoteId: void 0,
    externalId: void 0,
    status: "regular",
    title: void 0
  }
});
var LocalThreadListRuntimeCore = class extends BaseSubscribable {
  constructor(_threadFactory) {
    super();
    __publicField(this, "_mainThread");
    this._mainThread = _threadFactory();
  }
  get isLoading() {
    return false;
  }
  getMainThreadRuntimeCore() {
    return this._mainThread;
  }
  get newThreadId() {
    throw new Error("Method not implemented.");
  }
  get threadIds() {
    throw EMPTY_ARRAY5;
  }
  get archivedThreadIds() {
    throw EMPTY_ARRAY5;
  }
  get mainThreadId() {
    return DEFAULT_THREAD_ID2;
  }
  get threadItems() {
    return DEFAULT_THREAD_DATA2;
  }
  getThreadRuntimeCore() {
    throw new Error("Method not implemented.");
  }
  getLoadThreadsPromise() {
    throw new Error("Method not implemented.");
  }
  getItemById(threadId) {
    if (threadId === this.mainThreadId) {
      return {
        status: "regular",
        id: this.mainThreadId,
        remoteId: this.mainThreadId,
        externalId: void 0,
        title: void 0,
        isMain: true
      };
    }
    throw new Error("Method not implemented");
  }
  async switchToThread() {
    throw new Error("Method not implemented.");
  }
  switchToNewThread() {
    throw new Error("Method not implemented.");
  }
  rename() {
    throw new Error("Method not implemented.");
  }
  archive() {
    throw new Error("Method not implemented.");
  }
  detach() {
    throw new Error("Method not implemented.");
  }
  unarchive() {
    throw new Error("Method not implemented.");
  }
  delete() {
    throw new Error("Method not implemented.");
  }
  initialize(threadId) {
    return Promise.resolve({ remoteId: threadId, externalId: void 0 });
  }
  generateTitle() {
    throw new Error("Method not implemented.");
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/local/LocalRuntimeCore.js
var LocalRuntimeCore = class extends BaseAssistantRuntimeCore {
  constructor(options, initialMessages) {
    super();
    __publicField(this, "threads");
    __publicField(this, "Provider");
    __publicField(this, "_options");
    this._options = options;
    this.threads = new LocalThreadListRuntimeCore(() => {
      return new LocalThreadRuntimeCore(this._contextProvider, this._options);
    });
    if (initialMessages) {
      this.threads.getMainThreadRuntimeCore().import(ExportedMessageRepository.fromArray(initialMessages));
    }
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/adapter/cloud.js
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react17 = __toESM(require_react(), 1);

// node_modules/assistant-cloud/dist/AssistantCloudAuthStrategy.js
var getJwtExpiry = (jwt2) => {
  try {
    const parts = jwt2.split(".");
    const bodyPart = parts[1];
    if (!bodyPart) {
      throw new Error("Invalid JWT format");
    }
    let base643 = bodyPart.replace(/-/g, "+").replace(/_/g, "/");
    while (base643.length % 4 !== 0) {
      base643 += "=";
    }
    const payload = atob(base643);
    const payloadObj = JSON.parse(payload);
    const exp = payloadObj.exp;
    if (!exp || typeof exp !== "number") {
      throw new Error('JWT does not contain a valid "exp" field');
    }
    return exp * 1e3;
  } catch (error48) {
    throw new Error(`Unable to determine the token expiry: ${error48}`);
  }
};
var _authTokenCallback;
var AssistantCloudJWTAuthStrategy = class {
  constructor(authTokenCallback) {
    __publicField(this, "strategy", "jwt");
    __publicField(this, "cachedToken", null);
    __publicField(this, "tokenExpiry", null);
    __privateAdd(this, _authTokenCallback);
    __privateSet(this, _authTokenCallback, authTokenCallback);
  }
  async getAuthHeaders() {
    const currentTime = Date.now();
    if (this.cachedToken && this.tokenExpiry && this.tokenExpiry - currentTime > 30 * 1e3) {
      return { Authorization: `Bearer ${this.cachedToken}` };
    }
    const newToken = await __privateGet(this, _authTokenCallback).call(this);
    if (!newToken)
      return false;
    this.cachedToken = newToken;
    this.tokenExpiry = getJwtExpiry(newToken);
    return { Authorization: `Bearer ${newToken}` };
  }
  readAuthHeaders(headers) {
    const authHeader = headers.get("Authorization");
    if (!authHeader)
      return;
    const [scheme, token] = authHeader.split(" ");
    if (scheme !== "Bearer" || !token) {
      throw new Error("Invalid auth header received");
    }
    this.cachedToken = token;
    this.tokenExpiry = getJwtExpiry(token);
  }
};
_authTokenCallback = new WeakMap();
var _apiKey, _userId, _workspaceId;
var AssistantCloudAPIKeyAuthStrategy = class {
  constructor(apiKey, userId, workspaceId) {
    __publicField(this, "strategy", "api-key");
    __privateAdd(this, _apiKey);
    __privateAdd(this, _userId);
    __privateAdd(this, _workspaceId);
    __privateSet(this, _apiKey, apiKey);
    __privateSet(this, _userId, userId);
    __privateSet(this, _workspaceId, workspaceId);
  }
  async getAuthHeaders() {
    return {
      Authorization: `Bearer ${__privateGet(this, _apiKey)}`,
      "Aui-User-Id": __privateGet(this, _userId),
      "Aui-Workspace-Id": __privateGet(this, _workspaceId)
    };
  }
  readAuthHeaders() {
  }
};
_apiKey = new WeakMap();
_userId = new WeakMap();
_workspaceId = new WeakMap();
var AUI_REFRESH_TOKEN_NAME = "aui:refresh_token";
var AssistantCloudAnonymousAuthStrategy = class {
  constructor(baseUrl2) {
    __publicField(this, "strategy", "anon");
    __publicField(this, "baseUrl");
    __publicField(this, "jwtStrategy");
    this.baseUrl = baseUrl2;
    this.jwtStrategy = new AssistantCloudJWTAuthStrategy(async () => {
      const currentTime = Date.now();
      const storedRefreshTokenJson = localStorage.getItem(AUI_REFRESH_TOKEN_NAME);
      const storedRefreshToken = storedRefreshTokenJson ? JSON.parse(storedRefreshTokenJson) : void 0;
      if (storedRefreshToken) {
        const refreshExpiry = new Date(storedRefreshToken.expires_at).getTime();
        if (refreshExpiry - currentTime > 30 * 1e3) {
          const response2 = await fetch(`${this.baseUrl}/v1/auth/tokens/refresh`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ refresh_token: storedRefreshToken.token })
          });
          if (response2.ok) {
            const data2 = await response2.json();
            const { access_token: access_token2, refresh_token: refresh_token2 } = data2;
            if (refresh_token2) {
              localStorage.setItem(AUI_REFRESH_TOKEN_NAME, JSON.stringify(refresh_token2));
            }
            return access_token2;
          }
        } else {
          localStorage.removeItem(AUI_REFRESH_TOKEN_NAME);
        }
      }
      const response = await fetch(`${this.baseUrl}/v1/auth/tokens/anonymous`, {
        method: "POST"
      });
      if (!response.ok)
        return null;
      const data = await response.json();
      const { access_token, refresh_token } = data;
      if (!access_token || !refresh_token)
        return null;
      localStorage.setItem(AUI_REFRESH_TOKEN_NAME, JSON.stringify(refresh_token));
      return access_token;
    });
  }
  async getAuthHeaders() {
    return this.jwtStrategy.getAuthHeaders();
  }
  readAuthHeaders(headers) {
    this.jwtStrategy.readAuthHeaders(headers);
  }
};

// node_modules/assistant-cloud/dist/AssistantCloudAPI.js
var CloudAPIError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "APIError";
  }
};
var AssistantCloudAPI = class {
  constructor(config2) {
    __publicField(this, "_auth");
    __publicField(this, "_baseUrl");
    if ("authToken" in config2) {
      this._baseUrl = config2.baseUrl;
      this._auth = new AssistantCloudJWTAuthStrategy(config2.authToken);
    } else if ("apiKey" in config2) {
      this._baseUrl = "https://backend.assistant-api.com";
      this._auth = new AssistantCloudAPIKeyAuthStrategy(config2.apiKey, config2.userId, config2.workspaceId);
    } else if ("anonymous" in config2) {
      this._baseUrl = config2.baseUrl;
      this._auth = new AssistantCloudAnonymousAuthStrategy(config2.baseUrl);
    } else {
      throw new Error("Invalid configuration: Must provide authToken, apiKey, or anonymous configuration");
    }
  }
  async initializeAuth() {
    return !!this._auth.getAuthHeaders();
  }
  async makeRawRequest(endpoint, options = {}) {
    const authHeaders = await this._auth.getAuthHeaders();
    if (!authHeaders)
      throw new Error("Authorization failed");
    const headers = {
      ...authHeaders,
      ...options.headers,
      "Content-Type": "application/json"
    };
    const queryParams = new URLSearchParams();
    if (options.query) {
      for (const [key, value] of Object.entries(options.query)) {
        if (value === false)
          continue;
        if (value === true) {
          queryParams.set(key, "true");
        } else {
          queryParams.set(key, value.toString());
        }
      }
    }
    const url2 = new URL(`${this._baseUrl}/v1${endpoint}`);
    url2.search = queryParams.toString();
    const response = await fetch(url2, {
      method: options.method ?? "GET",
      headers,
      body: options.body ? JSON.stringify(options.body) : null
    });
    this._auth.readAuthHeaders(response.headers);
    if (!response.ok) {
      const text = await response.text();
      try {
        const body = JSON.parse(text);
        throw new CloudAPIError(body.message);
      } catch {
        throw new Error(`Request failed with status ${response.status}, ${text}`);
      }
    }
    return response;
  }
  async makeRequest(endpoint, options = {}) {
    const response = await this.makeRawRequest(endpoint, options);
    return response.json();
  }
};

// node_modules/assistant-cloud/dist/AssistantCloudAuthTokens.js
var AssistantCloudAuthTokens = class {
  constructor(cloud) {
    __publicField(this, "cloud");
    this.cloud = cloud;
  }
  async create() {
    return this.cloud.makeRequest("/auth/tokens", { method: "POST" });
  }
};

// node_modules/assistant-cloud/dist/AssistantCloudRuns.js
var AssistantCloudRuns = class {
  constructor(cloud) {
    __publicField(this, "cloud");
    this.cloud = cloud;
  }
  __internal_getAssistantOptions(assistantId) {
    return {
      api: `${this.cloud._baseUrl}/v1/runs/stream`,
      headers: async () => {
        const headers = await this.cloud._auth.getAuthHeaders();
        if (!headers)
          throw new Error("Authorization failed");
        return {
          ...headers,
          Accept: "text/plain"
        };
      },
      body: {
        assistant_id: assistantId,
        response_format: "vercel-ai-data-stream/v1",
        thread_id: "unstable_todo"
      }
    };
  }
  async stream(body) {
    const response = await this.cloud.makeRawRequest("/runs/stream", {
      method: "POST",
      headers: {
        Accept: "text/plain"
      },
      body
    });
    return AssistantStream.fromResponse(response, new PlainTextDecoder());
  }
};

// node_modules/assistant-cloud/dist/AssistantCloudThreadMessages.js
var AssistantCloudThreadMessages = class {
  constructor(cloud) {
    __publicField(this, "cloud");
    this.cloud = cloud;
  }
  async list(threadId, query) {
    return this.cloud.makeRequest(`/threads/${encodeURIComponent(threadId)}/messages`, { query });
  }
  async create(threadId, body) {
    return this.cloud.makeRequest(`/threads/${encodeURIComponent(threadId)}/messages`, { method: "POST", body });
  }
};

// node_modules/assistant-cloud/dist/AssistantCloudThreads.js
var AssistantCloudThreads = class {
  constructor(cloud) {
    __publicField(this, "cloud");
    __publicField(this, "messages");
    this.cloud = cloud;
    this.messages = new AssistantCloudThreadMessages(cloud);
  }
  async list(query) {
    return this.cloud.makeRequest("/threads", { query });
  }
  async get(threadId) {
    return this.cloud.makeRequest(`/threads/${encodeURIComponent(threadId)}`);
  }
  async create(body) {
    return this.cloud.makeRequest("/threads", { method: "POST", body });
  }
  async update(threadId, body) {
    return this.cloud.makeRequest(`/threads/${encodeURIComponent(threadId)}`, {
      method: "PUT",
      body
    });
  }
  async delete(threadId) {
    return this.cloud.makeRequest(`/threads/${encodeURIComponent(threadId)}`, {
      method: "DELETE"
    });
  }
};

// node_modules/assistant-cloud/dist/AssistantCloudFiles.js
var AssistantCloudFiles = class {
  constructor(cloud) {
    __publicField(this, "cloud");
    this.cloud = cloud;
  }
  async pdfToImages(body) {
    return this.cloud.makeRequest("/files/pdf-to-images", {
      method: "POST",
      body
    });
  }
  async generatePresignedUploadUrl(body) {
    return this.cloud.makeRequest("/files/attachments/generate-presigned-upload-url", {
      method: "POST",
      body
    });
  }
};

// node_modules/assistant-cloud/dist/AssistantCloud.js
var AssistantCloud = class {
  constructor(config2) {
    __publicField(this, "threads");
    __publicField(this, "auth");
    __publicField(this, "runs");
    __publicField(this, "files");
    const api = new AssistantCloudAPI(config2);
    this.threads = new AssistantCloudThreads(api);
    this.auth = {
      tokens: new AssistantCloudAuthTokens(api)
    };
    this.runs = new AssistantCloudRuns(api);
    this.files = new AssistantCloudFiles(api);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/cloud/AssistantCloudThreadHistoryAdapter.js
var import_react16 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/utils/json/is-json.js
function isJSONValue(value, currentDepth = 0) {
  if (currentDepth > 100) {
    return false;
  }
  if (value === null || typeof value === "string" || typeof value === "boolean") {
    return true;
  }
  if (typeof value === "number") {
    return !Number.isNaN(value) && Number.isFinite(value);
  }
  if (Array.isArray(value)) {
    return value.every((item) => isJSONValue(item, currentDepth + 1));
  }
  if (typeof value === "object") {
    return Object.entries(value).every(([key, val]) => typeof key === "string" && isJSONValue(val, currentDepth + 1));
  }
  return false;
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/cloud/auiV0.js
var auiV0Encode = (message) => {
  var _a3;
  return {
    role: message.role,
    content: message.content.map((part) => {
      const type = part.type;
      switch (type) {
        case "text": {
          return {
            type: "text",
            text: part.text
          };
        }
        case "reasoning": {
          return {
            type: "reasoning",
            text: part.text
          };
        }
        case "source": {
          return {
            type: "source",
            sourceType: part.sourceType,
            id: part.id,
            url: part.url,
            ...part.title ? { title: part.title } : void 0
          };
        }
        case "tool-call": {
          if (!isJSONValue(part.result)) {
            console.warn(`tool-call result is not JSON! ${JSON.stringify(part)}`);
          }
          return {
            type: "tool-call",
            toolCallId: part.toolCallId,
            toolName: part.toolName,
            ...JSON.stringify(part.args) === part.argsText ? {
              args: part.args
            } : { argsText: part.argsText },
            ...part.result ? { result: part.result } : {},
            ...part.isError ? { isError: true } : {}
          };
        }
        case "image": {
          return {
            type: "image",
            image: part.image
          };
        }
        case "file": {
          return {
            type: "file",
            data: part.data,
            mimeType: part.mimeType,
            ...part.filename ? { filename: part.filename } : void 0
          };
        }
        default: {
          const unhandledType = type;
          throw new Error(`Message part type not supported by aui/v0: ${unhandledType}`);
        }
      }
    }),
    metadata: message.metadata,
    ...message.status ? {
      status: ((_a3 = message.status) == null ? void 0 : _a3.type) === "running" ? {
        type: "incomplete",
        reason: "cancelled"
      } : message.status
    } : void 0
  };
};
var auiV0Decode = (cloudMessage) => {
  const payload = cloudMessage.content;
  const message = fromThreadMessageLike({
    id: cloudMessage.id,
    createdAt: cloudMessage.created_at,
    ...payload
  }, cloudMessage.id, {
    type: "complete",
    reason: "unknown"
  });
  return {
    parentId: cloudMessage.parent_id,
    message
  };
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/cloud/AssistantCloudThreadHistoryAdapter.js
var globalMessageIdMapping = /* @__PURE__ */ new WeakMap();
var FormattedThreadHistoryAdapter = class {
  constructor(parent, formatAdapter) {
    __publicField(this, "parent");
    __publicField(this, "formatAdapter");
    this.parent = parent;
    this.formatAdapter = formatAdapter;
  }
  async append(item) {
    const encoded = this.formatAdapter.encode(item);
    const messageId = this.formatAdapter.getId(item.message);
    return this.parent._appendWithFormat(item.parentId, messageId, this.formatAdapter.format, encoded);
  }
  async load() {
    return this.parent._loadWithFormat(this.formatAdapter.format, (message) => this.formatAdapter.decode(message));
  }
};
var AssistantCloudThreadHistoryAdapter = class {
  constructor(cloudRef, aui) {
    __publicField(this, "cloudRef");
    __publicField(this, "aui");
    this.cloudRef = cloudRef;
    this.aui = aui;
  }
  get _getIdForLocalId() {
    if (!globalMessageIdMapping.has(this.aui.threadListItem())) {
      globalMessageIdMapping.set(this.aui.threadListItem(), {});
    }
    return globalMessageIdMapping.get(this.aui.threadListItem());
  }
  withFormat(formatAdapter) {
    return new FormattedThreadHistoryAdapter(this, formatAdapter);
  }
  async append({ parentId, message }) {
    const { remoteId } = await this.aui.threadListItem().initialize();
    const task = this.cloudRef.current.threads.messages.create(remoteId, {
      parent_id: parentId ? await this._getIdForLocalId[parentId] ?? parentId : null,
      format: "aui/v0",
      content: auiV0Encode(message)
    }).then(({ message_id }) => {
      this._getIdForLocalId[message.id] = message_id;
      return message_id;
    });
    this._getIdForLocalId[message.id] = task;
    return task.then(() => {
    });
  }
  async load() {
    const remoteId = this.aui.threadListItem().getState().remoteId;
    if (!remoteId)
      return { messages: [] };
    const { messages } = await this.cloudRef.current.threads.messages.list(remoteId, {
      format: "aui/v0"
    });
    const payload = {
      messages: messages.filter((m) => m.format === "aui/v0").map(auiV0Decode).reverse()
    };
    return payload;
  }
  // Internal methods for FormattedThreadHistoryAdapter
  async _appendWithFormat(parentId, messageId, format, content) {
    const { remoteId } = await this.aui.threadListItem().initialize();
    const task = this.cloudRef.current.threads.messages.create(remoteId, {
      parent_id: parentId ? await this._getIdForLocalId[parentId] ?? parentId : null,
      format,
      content
    }).then(({ message_id }) => {
      this._getIdForLocalId[messageId] = message_id;
      return message_id;
    });
    this._getIdForLocalId[messageId] = task;
    return task.then(() => {
    });
  }
  async _loadWithFormat(format, decoder) {
    const remoteId = this.aui.threadListItem().getState().remoteId;
    if (!remoteId)
      return { messages: [] };
    const { messages } = await this.cloudRef.current.threads.messages.list(remoteId, {
      format
    });
    return {
      messages: messages.filter((m) => m.format === format).map((m) => decoder({
        id: m.id,
        parent_id: m.parent_id,
        format: m.format,
        content: m.content
      })).reverse()
    };
  }
};
var useAssistantCloudThreadHistoryAdapter = (cloudRef) => {
  const aui = useAui();
  const [adapter] = (0, import_react16.useState)(() => new AssistantCloudThreadHistoryAdapter(cloudRef, aui));
  return adapter;
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/adapter/cloud.js
var _a;
var baseUrl = typeof process !== "undefined" && ((_a = process == null ? void 0 : process.env) == null ? void 0 : _a["NEXT_PUBLIC_ASSISTANT_BASE_URL"]);
var autoCloud = baseUrl ? new AssistantCloud({ baseUrl, anonymous: true }) : void 0;
var useCloudThreadListAdapter = (adapter) => {
  const adapterRef = (0, import_react17.useRef)(adapter);
  (0, import_react17.useEffect)(() => {
    adapterRef.current = adapter;
  }, [adapter]);
  const unstable_Provider = (0, import_react17.useCallback)(function Provider({ children }) {
    const history = useAssistantCloudThreadHistoryAdapter({
      get current() {
        return adapterRef.current.cloud ?? autoCloud;
      }
    });
    const cloudInstance = adapterRef.current.cloud ?? autoCloud;
    const attachments = (0, import_react17.useMemo)(() => new CloudFileAttachmentAdapter(cloudInstance), [cloudInstance]);
    const adapters = (0, import_react17.useMemo)(() => ({
      history,
      attachments
    }), [history, attachments]);
    return (0, import_jsx_runtime3.jsx)(RuntimeAdapterProvider, { adapters, children });
  }, []);
  const cloud = adapter.cloud ?? autoCloud;
  if (!cloud)
    return new InMemoryThreadListAdapter();
  return {
    list: async () => {
      const { threads } = await cloud.threads.list();
      return {
        threads: threads.map((t) => ({
          status: t.is_archived ? "archived" : "regular",
          remoteId: t.id,
          title: t.title,
          externalId: t.external_id ?? void 0
        }))
      };
    },
    initialize: async () => {
      var _a3;
      const createTask = ((_a3 = adapter.create) == null ? void 0 : _a3.call(adapter)) ?? Promise.resolve();
      const t = await createTask;
      const external_id = t ? t.externalId : void 0;
      const { thread_id: remoteId } = await cloud.threads.create({
        last_message_at: /* @__PURE__ */ new Date(),
        external_id
      });
      return { externalId: external_id, remoteId };
    },
    rename: async (threadId, newTitle) => {
      return cloud.threads.update(threadId, { title: newTitle });
    },
    archive: async (threadId) => {
      return cloud.threads.update(threadId, { is_archived: true });
    },
    unarchive: async (threadId) => {
      return cloud.threads.update(threadId, { is_archived: false });
    },
    delete: async (threadId) => {
      var _a3;
      await ((_a3 = adapter.delete) == null ? void 0 : _a3.call(adapter, threadId));
      return cloud.threads.delete(threadId);
    },
    generateTitle: async (threadId, messages) => {
      const filteredMessages = messages.map((msg) => ({
        ...msg,
        content: msg.content.filter((part) => part.type === "text" || part.type === "tool-call")
      }));
      return cloud.runs.stream({
        thread_id: threadId,
        assistant_id: "system/thread_title",
        messages: filteredMessages
      });
    },
    fetch: async (threadId) => {
      const thread = await cloud.threads.get(threadId);
      return {
        status: thread.is_archived ? "archived" : "regular",
        remoteId: thread.id,
        title: thread.title,
        externalId: thread.external_id ?? void 0
      };
    },
    unstable_Provider
  };
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/local/useLocalRuntime.js
var useLocalThreadRuntime = (adapter, { initialMessages, ...options }) => {
  const { modelContext, ...threadListAdapters } = useRuntimeAdapters() ?? {};
  const opt = {
    ...options,
    adapters: {
      ...threadListAdapters,
      ...options.adapters,
      chatModel: adapter
    }
  };
  const [runtime] = (0, import_react18.useState)(() => new LocalRuntimeCore(opt, initialMessages));
  const threadIdRef = (0, import_react18.useRef)(void 0);
  threadIdRef.current = useAuiState(({ threadListItem }) => threadListItem.remoteId);
  (0, import_react18.useEffect)(() => {
    runtime.threads.getMainThreadRuntimeCore().__internal_setGetThreadId(() => threadIdRef.current);
  }, [runtime]);
  (0, import_react18.useEffect)(() => {
    return () => {
      runtime.threads.getMainThreadRuntimeCore().detach();
    };
  }, [runtime]);
  (0, import_react18.useEffect)(() => {
    runtime.threads.getMainThreadRuntimeCore().__internal_setOptions(opt);
    runtime.threads.getMainThreadRuntimeCore().__internal_load();
  });
  (0, import_react18.useEffect)(() => {
    if (!modelContext)
      return void 0;
    return runtime.registerModelContextProvider(modelContext);
  }, [modelContext, runtime]);
  return (0, import_react18.useMemo)(() => new AssistantRuntimeImpl(runtime), [runtime]);
};
var useLocalRuntime = (adapter, { cloud, ...options } = {}) => {
  const cloudAdapter = useCloudThreadListAdapter({ cloud });
  return useRemoteThreadListRuntime({
    runtimeHook: function RuntimeHook() {
      return useLocalThreadRuntime(adapter, options);
    },
    adapter: cloudAdapter,
    allowNesting: true
  });
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime/AssistantRuntime.js
var AssistantRuntimeImpl = class {
  constructor(_core) {
    __publicField(this, "_core");
    __publicField(this, "threads");
    __publicField(this, "_thread");
    this._core = _core;
    this.threads = new ThreadListRuntimeImpl(_core.threads);
    this._thread = this.threads.main;
    this.__internal_bindMethods();
  }
  get threadList() {
    return this.threads;
  }
  __internal_bindMethods() {
    this.switchToNewThread = this.switchToNewThread.bind(this);
    this.switchToThread = this.switchToThread.bind(this);
    this.registerModelContextProvider = this.registerModelContextProvider.bind(this);
    this.registerModelConfigProvider = this.registerModelConfigProvider.bind(this);
    this.reset = this.reset.bind(this);
  }
  get thread() {
    return this._thread;
  }
  switchToNewThread() {
    return this._core.threads.switchToNewThread();
  }
  switchToThread(threadId) {
    return this._core.threads.switchToThread(threadId);
  }
  registerModelContextProvider(provider) {
    return this._core.registerModelContextProvider(provider);
  }
  registerModelConfigProvider(provider) {
    return this.registerModelContextProvider(provider);
  }
  reset({ initialMessages } = {}) {
    return this._core.threads.getMainThreadRuntimeCore().import(ExportedMessageRepository.fromArray(initialMessages ?? []));
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/local/LocalRuntimeOptions.js
var splitLocalRuntimeOptions = (options) => {
  const { cloud, initialMessages, maxSteps, adapters, unstable_humanToolNames, ...rest } = options;
  return {
    localRuntimeOptions: {
      cloud,
      initialMessages,
      maxSteps,
      adapters,
      unstable_humanToolNames
    },
    otherOptions: rest
  };
};

// node_modules/@assistant-ui/react/dist/utils/smooth/useSmooth.js
var import_react21 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/utils/smooth/SmoothContext.js
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react20 = __toESM(require_react(), 1);

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState) => {
  let state;
  const listeners = /* @__PURE__ */ new Set();
  const setState = (partial2, replace) => {
    const nextState = typeof partial2 === "function" ? partial2(state) : partial2;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe = (listener) => {
    listeners.add(listener);
    return () => listeners.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe };
  const initialState = state = createState(setState, getState, api);
  return api;
};
var createStore = (createState) => createState ? createStoreImpl(createState) : createStoreImpl;

// node_modules/zustand/esm/react.mjs
var import_react19 = __toESM(require_react(), 1);
var identity = (arg) => arg;
function useStore(api, selector = identity) {
  const slice = import_react19.default.useSyncExternalStore(
    api.subscribe,
    import_react19.default.useCallback(() => selector(api.getState()), [api, selector]),
    import_react19.default.useCallback(() => selector(api.getInitialState()), [api, selector])
  );
  import_react19.default.useDebugValue(slice);
  return slice;
}
var createImpl = (createState) => {
  const api = createStore(createState);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create = (createState) => createState ? createImpl(createState) : createImpl;

// node_modules/@assistant-ui/react/dist/context/react/utils/createContextStoreHook.js
function createContextStoreHook(contextHook, contextKey) {
  function useStoreStoreHook(options) {
    const context2 = contextHook(options);
    if (!context2)
      return null;
    return context2[contextKey];
  }
  function useStoreHook(param) {
    let optional2 = false;
    let selector;
    if (typeof param === "function") {
      selector = param;
    } else if (param && typeof param === "object") {
      optional2 = !!param.optional;
      selector = param.selector;
    }
    const store = useStoreStoreHook({
      optional: optional2
    });
    if (!store)
      return null;
    return selector ? store(selector) : store();
  }
  return {
    [contextKey]: useStoreHook,
    [`${contextKey}Store`]: useStoreStoreHook
  };
}

// node_modules/@assistant-ui/react/dist/utils/smooth/SmoothContext.js
var SmoothContext = (0, import_react20.createContext)(null);
var makeSmoothContext = (initialState) => {
  const useSmoothStatus2 = create(() => initialState);
  return { useSmoothStatus: useSmoothStatus2 };
};
var SmoothContextProvider = ({ children }) => {
  const outer = useSmoothContext({ optional: true });
  const aui = useAui();
  const [context2] = (0, import_react20.useState)(() => makeSmoothContext(aui.part().getState().status));
  if (outer)
    return children;
  return (0, import_jsx_runtime4.jsx)(SmoothContext.Provider, { value: context2, children });
};
var withSmoothContextProvider = (Component) => {
  const Wrapped = (0, import_react20.forwardRef)((props, ref) => {
    return (0, import_jsx_runtime4.jsx)(SmoothContextProvider, { children: (0, import_jsx_runtime4.jsx)(Component, { ...props, ref }) });
  });
  Wrapped.displayName = Component.displayName;
  return Wrapped;
};
function useSmoothContext(options) {
  const context2 = (0, import_react20.useContext)(SmoothContext);
  if (!(options == null ? void 0 : options.optional) && !context2)
    throw new Error("This component must be used within a SmoothContextProvider.");
  return context2;
}
var { useSmoothStatus, useSmoothStatusStore } = createContextStoreHook(useSmoothContext, "useSmoothStatus");

// node_modules/@assistant-ui/react/dist/context/ReadonlyStore.js
var writableStore = (store) => {
  return store;
};

// node_modules/@assistant-ui/react/dist/utils/smooth/useSmooth.js
var TextStreamAnimator = class {
  constructor(currentText, setText) {
    __publicField(this, "currentText");
    __publicField(this, "setText");
    __publicField(this, "animationFrameId", null);
    __publicField(this, "lastUpdateTime", Date.now());
    __publicField(this, "targetText", "");
    __publicField(this, "animate", () => {
      const currentTime = Date.now();
      const deltaTime = currentTime - this.lastUpdateTime;
      let timeToConsume = deltaTime;
      const remainingChars = this.targetText.length - this.currentText.length;
      const baseTimePerChar = Math.min(5, 250 / remainingChars);
      let charsToAdd = 0;
      while (timeToConsume >= baseTimePerChar && charsToAdd < remainingChars) {
        charsToAdd++;
        timeToConsume -= baseTimePerChar;
      }
      if (charsToAdd !== remainingChars) {
        this.animationFrameId = requestAnimationFrame(this.animate);
      } else {
        this.animationFrameId = null;
      }
      if (charsToAdd === 0)
        return;
      this.currentText = this.targetText.slice(0, this.currentText.length + charsToAdd);
      this.lastUpdateTime = currentTime - timeToConsume;
      this.setText(this.currentText);
    });
    this.currentText = currentText;
    this.setText = setText;
  }
  start() {
    if (this.animationFrameId !== null)
      return;
    this.lastUpdateTime = Date.now();
    this.animate();
  }
  stop() {
    if (this.animationFrameId !== null) {
      cancelAnimationFrame(this.animationFrameId);
      this.animationFrameId = null;
    }
  }
};
var SMOOTH_STATUS = Object.freeze({
  type: "running"
});
var useSmooth = (state, smooth = false) => {
  const { text } = state;
  const id = useAuiState(({ message }) => message.id);
  const idRef = (0, import_react21.useRef)(id);
  const [displayedText, setDisplayedText] = (0, import_react21.useState)(text);
  const smoothStatusStore = useSmoothStatusStore({ optional: true });
  const setText = useCallbackRef((text2) => {
    setDisplayedText(text2);
    if (smoothStatusStore) {
      const target = displayedText !== text2 || state.status.type === "running" ? SMOOTH_STATUS : state.status;
      writableStore(smoothStatusStore).setState(target, true);
    }
  });
  (0, import_react21.useEffect)(() => {
    if (smoothStatusStore) {
      const target = smooth && (displayedText !== text || state.status.type === "running") ? SMOOTH_STATUS : state.status;
      writableStore(smoothStatusStore).setState(target, true);
    }
  }, [smoothStatusStore, smooth, text, displayedText, state.status]);
  const [animatorRef] = (0, import_react21.useState)(new TextStreamAnimator(text, setText));
  (0, import_react21.useEffect)(() => {
    if (!smooth) {
      animatorRef.stop();
      return;
    }
    if (idRef.current !== id || !text.startsWith(animatorRef.targetText)) {
      idRef.current = id;
      setText(text);
      animatorRef.currentText = text;
      animatorRef.targetText = text;
      animatorRef.stop();
      return;
    }
    animatorRef.targetText = text;
    animatorRef.start();
  }, [setText, animatorRef, id, smooth, text]);
  (0, import_react21.useEffect)(() => {
    return () => {
      animatorRef.stop();
    };
  }, [animatorRef]);
  return (0, import_react21.useMemo)(() => smooth ? {
    type: "text",
    text: displayedText,
    status: text === displayedText ? state.status : SMOOTH_STATUS
  } : state, [smooth, displayedText, state, text]);
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/RemoteThreadListHookInstanceManager.js
var import_jsx_runtime15 = __toESM(require_jsx_runtime(), 1);
var import_react32 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/legacy-runtime/AssistantRuntimeProvider.js
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_react31 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/legacy-runtime/util-hooks/tapSubscribable.js
var tapSubscribable = (subscribable) => {
  const [, setState] = tapState(subscribable.getState);
  tapEffect(() => {
    setState(subscribable.getState());
    return subscribable.subscribe(() => {
      setState(subscribable.getState());
    });
  }, [subscribable]);
  return subscribable.getState();
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/client/ThreadListItemRuntimeClient.js
var ThreadListItemClient = resource(({ runtime }) => {
  const state = tapSubscribable(runtime);
  const emit = tapAssistantEmit();
  tapEffect(() => {
    const unsubscribers = [];
    const threadListItemEvents = [
      "switchedTo",
      "switchedAway"
    ];
    for (const event of threadListItemEvents) {
      const unsubscribe = runtime.unstable_on(event, () => {
        emit(`threadListItem.${event}`, {
          threadId: runtime.getState().id
        });
      });
      unsubscribers.push(unsubscribe);
    }
    return () => {
      for (const unsub of unsubscribers)
        unsub();
    };
  }, [runtime, emit]);
  return {
    state,
    methods: {
      getState: () => state,
      switchTo: runtime.switchTo,
      rename: runtime.rename,
      archive: runtime.archive,
      unarchive: runtime.unarchive,
      delete: runtime.delete,
      generateTitle: runtime.generateTitle,
      initialize: runtime.initialize,
      detach: runtime.detach,
      __internal_getRuntime: () => runtime
    }
  };
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/client/AttachmentRuntimeClient.js
var AttachmentRuntimeClient = resource(({ runtime }) => {
  const state = tapSubscribable(runtime);
  return {
    state,
    methods: {
      getState: () => state,
      remove: runtime.remove,
      __internal_getRuntime: () => runtime
    }
  };
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/client/ComposerRuntimeClient.js
var ComposerAttachmentClientByIndex = resource(({ runtime, index: index3 }) => {
  const attachmentRuntime = tapMemo(() => runtime.getAttachmentByIndex(index3), [runtime, index3]);
  return tapInlineResource(AttachmentRuntimeClient({
    runtime: attachmentRuntime
  }));
});
var ComposerClient = resource(({ threadIdRef, messageIdRef, runtime }) => {
  const runtimeState = tapSubscribable(runtime);
  const emit = tapAssistantEmit();
  tapEffect(() => {
    const unsubscribers = [];
    const composerEvents = [
      "send",
      "attachmentAdd"
    ];
    for (const event of composerEvents) {
      const unsubscribe = runtime.unstable_on(event, () => {
        emit(`composer.${event}`, {
          threadId: threadIdRef.current,
          ...messageIdRef && { messageId: messageIdRef.current }
        });
      });
      unsubscribers.push(unsubscribe);
    }
    return () => {
      for (const unsub of unsubscribers)
        unsub();
    };
  }, [runtime, emit, threadIdRef, messageIdRef]);
  const attachments = tapClientLookup(() => runtimeState.attachments.map((attachment, idx) => withKey(attachment.id, ComposerAttachmentClientByIndex({
    runtime,
    index: idx
  }))), [runtimeState.attachments, runtime]);
  const state = tapMemo(() => {
    return {
      text: runtimeState.text,
      role: runtimeState.role,
      attachments: attachments.state,
      runConfig: runtimeState.runConfig,
      isEditing: runtimeState.isEditing,
      canCancel: runtimeState.canCancel,
      attachmentAccept: runtimeState.attachmentAccept,
      isEmpty: runtimeState.isEmpty,
      type: runtimeState.type ?? "thread",
      dictation: runtimeState.dictation
    };
  }, [runtimeState, attachments.state]);
  return {
    state,
    methods: {
      getState: () => state,
      setText: runtime.setText,
      setRole: runtime.setRole,
      setRunConfig: runtime.setRunConfig,
      addAttachment: runtime.addAttachment,
      reset: runtime.reset,
      clearAttachments: runtime.clearAttachments,
      send: runtime.send,
      cancel: runtime.cancel,
      beginEdit: runtime.beginEdit ?? (() => {
        throw new Error("beginEdit is not supported in this runtime");
      }),
      startDictation: runtime.startDictation,
      stopDictation: runtime.stopDictation,
      attachment: (selector) => {
        if ("id" in selector) {
          return attachments.get({ key: selector.id });
        } else {
          return attachments.get(selector);
        }
      },
      __internal_getRuntime: () => runtime
    }
  };
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/client/MessagePartRuntimeClient.js
var MessagePartClient = resource(({ runtime }) => {
  const state = tapSubscribable(runtime);
  return {
    state,
    methods: {
      getState: () => state,
      addToolResult: (result) => runtime.addToolResult(result),
      resumeToolCall: (payload) => runtime.resumeToolCall(payload),
      __internal_getRuntime: () => runtime
    }
  };
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/client/MessageRuntimeClient.js
var MessageAttachmentClientByIndex = resource(({ runtime, index: index3 }) => {
  const attachmentRuntime = tapMemo(() => runtime.getAttachmentByIndex(index3), [runtime, index3]);
  return tapInlineResource(AttachmentRuntimeClient({ runtime: attachmentRuntime }));
});
var MessagePartByIndex = resource(({ runtime, index: index3 }) => {
  const partRuntime = tapMemo(() => runtime.getMessagePartByIndex(index3), [runtime, index3]);
  return tapInlineResource(MessagePartClient({ runtime: partRuntime }));
});
var MessageClient = resource(({ runtime, threadIdRef }) => {
  const runtimeState = tapSubscribable(runtime);
  const [isCopiedState, setIsCopied] = tapState(false);
  const [isHoveringState, setIsHovering] = tapState(false);
  const messageIdRef = tapMemo(() => ({
    get current() {
      return runtime.getState().id;
    }
  }), [runtime]);
  const composer = tapClientResource(ComposerClient({
    runtime: runtime.composer,
    threadIdRef,
    messageIdRef
  }));
  const parts = tapClientLookup(() => runtimeState.content.map((part, idx) => withKey("toolCallId" in part && part.toolCallId != null ? `toolCallId-${part.toolCallId}` : `index-${idx}`, MessagePartByIndex({ runtime, index: idx }))), [runtimeState.content, runtime]);
  const attachments = tapClientLookup(() => (runtimeState.attachments ?? []).map((attachment, idx) => withKey(attachment.id, MessageAttachmentClientByIndex({ runtime, index: idx }))), [runtimeState.attachments, runtime]);
  const state = tapMemo(() => {
    return {
      ...runtimeState,
      parts: parts.state,
      composer: composer.state,
      isCopied: isCopiedState,
      isHovering: isHoveringState
    };
  }, [
    runtimeState,
    parts.state,
    composer.state,
    isCopiedState,
    isHoveringState
  ]);
  return {
    state,
    methods: {
      getState: () => state,
      composer: composer.methods,
      reload: (config2) => runtime.reload(config2),
      speak: () => runtime.speak(),
      stopSpeaking: () => runtime.stopSpeaking(),
      submitFeedback: (feedback) => runtime.submitFeedback(feedback),
      switchToBranch: (options) => runtime.switchToBranch(options),
      getCopyText: () => runtime.unstable_getCopyText(),
      part: (selector) => {
        if ("index" in selector) {
          return parts.get({ index: selector.index });
        } else {
          return parts.get({ key: `toolCallId-${selector.toolCallId}` });
        }
      },
      attachment: (selector) => {
        if ("id" in selector) {
          return attachments.get({ key: selector.id });
        } else {
          return attachments.get(selector);
        }
      },
      setIsCopied,
      setIsHovering,
      __internal_getRuntime: () => runtime
    }
  };
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/client/ThreadRuntimeClient.js
var MessageClientById = resource(({ runtime, id, threadIdRef }) => {
  const messageRuntime = tapMemo(() => runtime.getMessageById(id), [runtime, id]);
  return tapInlineResource(MessageClient({ runtime: messageRuntime, threadIdRef }));
});
var ThreadClient = resource(({ runtime }) => {
  const runtimeState = tapSubscribable(runtime);
  const emit = tapAssistantEmit();
  tapEffect(() => {
    const unsubscribers = [];
    const threadEvents = [
      "runStart",
      "runEnd",
      "initialize",
      "modelContextUpdate"
    ];
    for (const event of threadEvents) {
      const unsubscribe = runtime.unstable_on(event, () => {
        var _a3;
        const threadId = ((_a3 = runtime.getState()) == null ? void 0 : _a3.threadId) || "unknown";
        emit(`thread.${event}`, {
          threadId
        });
      });
      unsubscribers.push(unsubscribe);
    }
    return () => {
      for (const unsub of unsubscribers)
        unsub();
    };
  }, [runtime, emit]);
  const threadIdRef = tapMemo(() => ({
    get current() {
      return runtime.getState().threadId;
    }
  }), [runtime]);
  const composer = tapClientResource(ComposerClient({
    runtime: runtime.composer,
    threadIdRef
  }));
  const messages = tapClientLookup(() => runtimeState.messages.map((m) => withKey(m.id, MessageClientById({ runtime, id: m.id, threadIdRef }))), [runtimeState.messages, runtime, threadIdRef]);
  const state = tapMemo(() => {
    return {
      isEmpty: messages.state.length === 0 && !runtimeState.isLoading,
      isDisabled: runtimeState.isDisabled,
      isLoading: runtimeState.isLoading,
      isRunning: runtimeState.isRunning,
      capabilities: runtimeState.capabilities,
      state: runtimeState.state,
      suggestions: runtimeState.suggestions,
      extras: runtimeState.extras,
      speech: runtimeState.speech,
      composer: composer.state,
      messages: messages.state
    };
  }, [runtimeState, messages, composer.state]);
  return {
    state,
    methods: {
      getState: () => state,
      composer: composer.methods,
      append: runtime.append,
      startRun: runtime.startRun,
      unstable_resumeRun: runtime.unstable_resumeRun,
      cancelRun: runtime.cancelRun,
      getModelContext: runtime.getModelContext,
      export: runtime.export,
      import: runtime.import,
      reset: runtime.reset,
      stopSpeaking: runtime.stopSpeaking,
      startVoice: async () => {
        throw new Error("startVoice is not supported in this runtime");
      },
      stopVoice: async () => {
        throw new Error("stopVoice is not supported in this runtime");
      },
      message: (selector) => {
        if ("id" in selector) {
          return messages.get({ key: selector.id });
        } else {
          return messages.get(selector);
        }
      },
      __internal_getRuntime: () => runtime
    }
  };
});

// node_modules/@assistant-ui/react/dist/legacy-runtime/client/ThreadListRuntimeClient.js
var ThreadListItemClientById = resource(({ runtime, id }) => {
  const threadListItemRuntime = tapMemo(() => runtime.getItemById(id), [runtime, id]);
  return tapInlineResource(ThreadListItemClient({
    runtime: threadListItemRuntime
  }));
});
var ThreadListClient = resource(({ runtime, __internal_assistantRuntime }) => {
  const runtimeState = tapSubscribable(runtime);
  const main = tapClientResource(ThreadClient({
    runtime: runtime.main
  }));
  const threadItems = tapClientLookup(() => Object.keys(runtimeState.threadItems).map((id) => withKey(id, ThreadListItemClientById({ runtime, id }))), [runtimeState.threadItems, runtime]);
  const state = tapMemo(() => {
    return {
      mainThreadId: runtimeState.mainThreadId,
      newThreadId: runtimeState.newThreadId ?? null,
      isLoading: runtimeState.isLoading,
      threadIds: runtimeState.threadIds,
      archivedThreadIds: runtimeState.archivedThreadIds,
      threadItems: threadItems.state,
      main: main.state
    };
  }, [runtimeState, threadItems.state, main.state]);
  return {
    state,
    methods: {
      getState: () => state,
      thread: () => main.methods,
      item: (threadIdOrOptions) => {
        if (threadIdOrOptions === "main") {
          return threadItems.get({ key: state.mainThreadId });
        }
        if ("id" in threadIdOrOptions) {
          return threadItems.get({ key: threadIdOrOptions.id });
        }
        const { index: index3, archived = false } = threadIdOrOptions;
        const id = archived ? state.archivedThreadIds[index3] : state.threadIds[index3];
        return threadItems.get({ key: id });
      },
      switchToThread: async (threadId) => {
        await runtime.switchToThread(threadId);
      },
      switchToNewThread: async () => {
        await runtime.switchToNewThread();
      },
      __internal_getAssistantRuntime: () => __internal_assistantRuntime
    }
  };
});

// node_modules/@assistant-ui/react/dist/client/ModelContextClient.js
var version = 1;
var ModelContext = resource(() => {
  const [state] = tapState(() => ({ version: version + 1 }));
  const composite = tapMemo(() => new CompositeContextProvider(), []);
  return {
    state,
    methods: {
      getState: () => state,
      getModelContext: () => composite.getModelContext(),
      subscribe: (callback) => composite.subscribe(callback),
      register: (provider) => composite.registerModelContextProvider(provider)
    }
  };
});

// node_modules/@assistant-ui/react/dist/model-context/useAssistantTool.js
var import_react22 = __toESM(require_react(), 1);
var useAssistantTool = (tool2) => {
  const aui = useAui();
  (0, import_react22.useEffect)(() => {
    if (!tool2.render)
      return void 0;
    return aui.tools().setToolUI(tool2.toolName, tool2.render);
  }, [aui, tool2.toolName, tool2.render]);
  (0, import_react22.useEffect)(() => {
    const { toolName, render, ...rest } = tool2;
    const context2 = {
      tools: {
        [toolName]: rest
      }
    };
    return aui.modelContext().register({
      getModelContext: () => context2
    });
  }, [aui, tool2]);
};

// node_modules/@assistant-ui/react/dist/model-context/makeAssistantTool.js
var makeAssistantTool = (tool2) => {
  const Tool = () => {
    useAssistantTool(tool2);
    return null;
  };
  Tool.unstable_tool = tool2;
  return Tool;
};

// node_modules/@assistant-ui/react/dist/model-context/useAssistantToolUI.js
var import_react23 = __toESM(require_react(), 1);
var useAssistantToolUI = (tool2) => {
  const aui = useAui();
  (0, import_react23.useEffect)(() => {
    if (!(tool2 == null ? void 0 : tool2.toolName) || !(tool2 == null ? void 0 : tool2.render))
      return void 0;
    return aui.tools().setToolUI(tool2.toolName, tool2.render);
  }, [aui, tool2 == null ? void 0 : tool2.toolName, tool2 == null ? void 0 : tool2.render]);
};

// node_modules/@assistant-ui/react/dist/model-context/makeAssistantToolUI.js
var makeAssistantToolUI = (tool2) => {
  const ToolUI = () => {
    useAssistantToolUI(tool2);
    return null;
  };
  ToolUI.unstable_tool = tool2;
  return ToolUI;
};

// node_modules/@assistant-ui/react/dist/model-context/useAssistantInstructions.js
var import_react24 = __toESM(require_react(), 1);
var getInstructions = (instruction) => {
  if (typeof instruction === "string")
    return { instruction };
  return instruction;
};
var useAssistantInstructions = (config2) => {
  const { instruction, disabled = false } = getInstructions(config2);
  const aui = useAui();
  (0, import_react24.useEffect)(() => {
    if (disabled)
      return;
    const config3 = {
      system: instruction
    };
    return aui.modelContext().register({
      getModelContext: () => config3
    });
  }, [aui, instruction, disabled]);
};

// node_modules/@assistant-ui/react/dist/model-context/useInlineRender.js
var import_react25 = __toESM(require_react(), 1);
var useInlineRender = (toolUI) => {
  const [useToolUIStore] = (0, import_react25.useState)(() => create(() => ({
    toolUI
  })));
  (0, import_react25.useEffect)(() => {
    useToolUIStore.setState({ toolUI });
  }, [toolUI, useToolUIStore]);
  return (0, import_react25.useCallback)(function ToolUI(args) {
    const store = useToolUIStore();
    return store.toolUI(args);
  }, [useToolUIStore]);
};

// node_modules/@assistant-ui/react/dist/model-context/tool.js
function tool(tool2) {
  return tool2;
}

// node_modules/@assistant-ui/react/dist/model-context/makeAssistantVisible.js
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_react26 = __toESM(require_react(), 1);
var click = tool({
  parameters: {
    type: "object",
    properties: {
      clickId: {
        type: "string"
      }
    },
    required: ["clickId"]
  },
  execute: async ({ clickId }) => {
    const escapedClickId = CSS.escape(clickId);
    const el = document.querySelector(`[data-click-id='${escapedClickId}']`);
    if (el instanceof HTMLElement) {
      el.click();
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      return {};
    } else {
      return "Element not found";
    }
  }
});
var edit = tool({
  parameters: {
    type: "object",
    properties: {
      editId: {
        type: "string"
      },
      value: {
        type: "string"
      }
    },
    required: ["editId", "value"]
  },
  execute: async ({ editId, value }) => {
    const escapedEditId = CSS.escape(editId);
    const el = document.querySelector(`[data-edit-id='${escapedEditId}']`);
    if (el instanceof HTMLInputElement || el instanceof HTMLTextAreaElement) {
      el.value = value;
      el.dispatchEvent(new Event("input", { bubbles: true }));
      el.dispatchEvent(new Event("change", { bubbles: true }));
      await new Promise((resolve) => setTimeout(resolve, 2e3));
      return {};
    } else {
      return "Element not found";
    }
  }
});
var ReadableContext = (0, import_react26.createContext)(false);
var makeAssistantVisible = (Component, config2) => {
  const ReadableComponent = (0, import_react26.forwardRef)((props, outerRef) => {
    const isNestedReadable = (0, import_react26.useContext)(ReadableContext);
    const clickId = (0, import_react26.useId)();
    const componentRef = (0, import_react26.useRef)(null);
    const aui = useAui();
    const { clickable, editable } = config2 ?? {};
    (0, import_react26.useEffect)(() => {
      return aui.modelContext().register({
        getModelContext: () => {
          var _a3;
          return {
            tools: {
              ...clickable ? { click } : {},
              ...editable ? { edit } : {}
            },
            system: !isNestedReadable ? (_a3 = componentRef.current) == null ? void 0 : _a3.outerHTML : void 0
          };
        }
      });
    }, [isNestedReadable, aui, clickable, editable]);
    const ref = useComposedRefs(componentRef, outerRef);
    return (0, import_jsx_runtime5.jsx)(ReadableContext.Provider, { value: true, children: (0, import_jsx_runtime5.jsx)(Component, { ...props, ...(config2 == null ? void 0 : config2.clickable) ? { "data-click-id": clickId } : {}, ...(config2 == null ? void 0 : config2.editable) ? { "data-edit-id": clickId } : {}, ref }) });
  });
  ReadableComponent.displayName = Component.displayName;
  return ReadableComponent;
};

// node_modules/@assistant-ui/react/dist/client/Tools.js
var Tools = resource(({ toolkit }) => {
  const [state, setState] = tapState(() => ({
    tools: {}
  }));
  const clientRef = tapAssistantClientRef();
  const setToolUI = tapCallback((toolName, render) => {
    setState((prev) => {
      return {
        ...prev,
        tools: {
          ...prev.tools,
          [toolName]: [...prev.tools[toolName] ?? [], render]
        }
      };
    });
    return () => {
      setState((prev) => {
        var _a3;
        return {
          ...prev,
          tools: {
            ...prev.tools,
            [toolName]: ((_a3 = prev.tools[toolName]) == null ? void 0 : _a3.filter((r) => r !== render)) ?? []
          }
        };
      });
    };
  }, []);
  tapEffect(() => {
    if (!toolkit)
      return;
    const unsubscribes = [];
    for (const [toolName, tool2] of Object.entries(toolkit)) {
      if (tool2.render) {
        unsubscribes.push(setToolUI(toolName, tool2.render));
      }
    }
    const toolsWithoutRender = Object.entries(toolkit).reduce((acc, [name, tool2]) => {
      const { render, ...rest } = tool2;
      acc[name] = rest;
      return acc;
    }, {});
    const modelContextProvider = {
      getModelContext: () => ({
        tools: toolsWithoutRender
      })
    };
    unsubscribes.push(clientRef.current.modelContext().register(modelContextProvider));
    return () => {
      unsubscribes.forEach((fn) => fn());
    };
  }, [toolkit, setToolUI, clientRef]);
  return {
    state,
    methods: {
      getState: () => state,
      setToolUI
    }
  };
});
attachDefaultPeers(Tools, {
  modelContext: ModelContext()
});

// node_modules/@assistant-ui/react/dist/client/Suggestions.js
var SuggestionClient = resource((state) => {
  return {
    state,
    methods: {
      getState: () => state
    }
  };
});
var SuggestionsResource = resource((suggestions) => {
  const [state] = tapState(() => {
    const normalizedSuggestions = (suggestions ?? []).map((s) => {
      if (typeof s === "string") {
        return {
          title: s,
          label: "",
          prompt: s
        };
      }
      return {
        title: s.title,
        label: s.label,
        prompt: s.prompt
      };
    });
    return {
      suggestions: normalizedSuggestions
    };
  });
  const suggestionClients = tapClientLookup(() => state.suggestions.map((suggestion, index3) => withKey(index3, SuggestionClient(suggestion))), [state.suggestions]);
  return {
    state,
    methods: {
      getState: () => state,
      suggestion: ({ index: index3 }) => {
        return suggestionClients.get({ index: index3 });
      }
    }
  };
});
var Suggestions = SuggestionsResource;

// node_modules/@assistant-ui/react/dist/model-context/registry/ModelContextRegistry.js
var ModelContextRegistry = class {
  constructor() {
    __publicField(this, "_tools", /* @__PURE__ */ new Map());
    __publicField(this, "_instructions", /* @__PURE__ */ new Map());
    __publicField(this, "_providers", /* @__PURE__ */ new Map());
    __publicField(this, "_subscribers", /* @__PURE__ */ new Set());
    __publicField(this, "_providerUnsubscribes", /* @__PURE__ */ new Map());
  }
  getModelContext() {
    const instructions = Array.from(this._instructions.values()).filter(Boolean);
    const system = instructions.length > 0 ? instructions.join("\n\n") : void 0;
    const tools = {};
    for (const toolProps of this._tools.values()) {
      const { toolName, render, ...tool2 } = toolProps;
      tools[toolName] = tool2;
    }
    const providerContexts = mergeModelContexts(new Set(this._providers.values()));
    const context2 = {
      system,
      tools: Object.keys(tools).length > 0 ? tools : void 0
    };
    if (providerContexts.system) {
      context2.system = context2.system ? `${context2.system}

${providerContexts.system}` : providerContexts.system;
    }
    if (providerContexts.tools) {
      context2.tools = { ...context2.tools || {}, ...providerContexts.tools };
    }
    if (providerContexts.callSettings) {
      context2.callSettings = providerContexts.callSettings;
    }
    if (providerContexts.config) {
      context2.config = providerContexts.config;
    }
    return context2;
  }
  subscribe(callback) {
    this._subscribers.add(callback);
    return () => this._subscribers.delete(callback);
  }
  notifySubscribers() {
    for (const callback of this._subscribers) {
      callback();
    }
  }
  addTool(tool2) {
    const id = Symbol();
    this._tools.set(id, tool2);
    this.notifySubscribers();
    return {
      update: (newTool) => {
        if (this._tools.has(id)) {
          this._tools.set(id, newTool);
          this.notifySubscribers();
        }
      },
      remove: () => {
        this._tools.delete(id);
        this.notifySubscribers();
      }
    };
  }
  addInstruction(config2) {
    const id = Symbol();
    const instruction = typeof config2 === "string" ? config2 : config2.instruction;
    const disabled = typeof config2 === "object" ? config2.disabled : false;
    if (!disabled) {
      this._instructions.set(id, instruction);
      this.notifySubscribers();
    }
    return {
      update: (newConfig) => {
        const newInstruction = typeof newConfig === "string" ? newConfig : newConfig.instruction;
        const newDisabled = typeof newConfig === "object" ? newConfig.disabled : false;
        if (newDisabled) {
          this._instructions.delete(id);
        } else {
          this._instructions.set(id, newInstruction);
        }
        this.notifySubscribers();
      },
      remove: () => {
        this._instructions.delete(id);
        this.notifySubscribers();
      }
    };
  }
  addProvider(provider) {
    var _a3;
    const id = Symbol();
    this._providers.set(id, provider);
    const unsubscribe = (_a3 = provider.subscribe) == null ? void 0 : _a3.call(provider, () => {
      this.notifySubscribers();
    });
    this._providerUnsubscribes.set(id, unsubscribe);
    this.notifySubscribers();
    return {
      remove: () => {
        this._providers.delete(id);
        const unsubscribe2 = this._providerUnsubscribes.get(id);
        unsubscribe2 == null ? void 0 : unsubscribe2();
        this._providerUnsubscribes.delete(id);
        this.notifySubscribers();
      }
    };
  }
};

// node_modules/@assistant-ui/react/dist/model-context/frame/AssistantFrameTypes.js
var FRAME_MESSAGE_CHANNEL = "assistant-ui-frame";

// node_modules/@assistant-ui/react/dist/model-context/frame/AssistantFrameHost.js
var deserializeTool = (serializedTool) => ({
  parameters: serializedTool.parameters,
  ...serializedTool.description && {
    description: serializedTool.description
  },
  ...serializedTool.disabled !== void 0 && {
    disabled: serializedTool.disabled
  },
  ...serializedTool.type && { type: serializedTool.type }
});
var deserializeModelContext = (serialized) => ({
  ...serialized.system !== void 0 && { system: serialized.system },
  ...serialized.tools && {
    tools: Object.fromEntries(Object.entries(serialized.tools).map(([name, tool2]) => [
      name,
      deserializeTool(tool2)
    ]))
  }
});
var AssistantFrameHost = class {
  constructor(iframeWindow, targetOrigin = "*") {
    __publicField(this, "_context", {});
    __publicField(this, "_subscribers", /* @__PURE__ */ new Set());
    __publicField(this, "_pendingRequests", /* @__PURE__ */ new Map());
    __publicField(this, "_requestCounter", 0);
    __publicField(this, "_iframeWindow");
    __publicField(this, "_targetOrigin");
    this._iframeWindow = iframeWindow;
    this._targetOrigin = targetOrigin;
    this.handleMessage = this.handleMessage.bind(this);
    window.addEventListener("message", this.handleMessage);
    this.requestContext();
  }
  handleMessage(event) {
    var _a3;
    if (this._targetOrigin !== "*" && event.origin !== this._targetOrigin)
      return;
    if (event.source !== this._iframeWindow)
      return;
    if (((_a3 = event.data) == null ? void 0 : _a3.channel) !== FRAME_MESSAGE_CHANNEL)
      return;
    const message = event.data.message;
    switch (message.type) {
      case "model-context-update": {
        this.updateContext(message.context);
        break;
      }
      case "tool-result": {
        const pending = this._pendingRequests.get(message.id);
        if (pending) {
          if (message.error) {
            pending.reject(new Error(message.error));
          } else {
            pending.resolve(message.result);
          }
          this._pendingRequests.delete(message.id);
        }
        break;
      }
    }
  }
  updateContext(serializedContext) {
    const context2 = deserializeModelContext(serializedContext);
    this._context = {
      ...context2,
      tools: context2.tools && Object.fromEntries(Object.entries(context2.tools).map(([name, tool2]) => [
        name,
        {
          ...tool2,
          execute: (args) => this.callTool(name, args)
        }
      ]))
    };
    this.notifySubscribers();
  }
  callTool(toolName, args) {
    return this.sendRequest({
      type: "tool-call",
      id: `tool-${this._requestCounter++}`,
      toolName,
      args
    }, 3e4, `Tool call "${toolName}" timed out`);
  }
  sendRequest(message, timeout = 3e4, timeoutMessage = "Request timed out") {
    return new Promise((resolve, reject) => {
      this._pendingRequests.set(message.id, { resolve, reject });
      this._iframeWindow.postMessage({ channel: FRAME_MESSAGE_CHANNEL, message }, this._targetOrigin);
      const timeoutId = setTimeout(() => {
        const pending = this._pendingRequests.get(message.id);
        if (pending) {
          pending.reject(new Error(timeoutMessage));
          this._pendingRequests.delete(message.id);
        }
      }, timeout);
      const originalResolve = this._pendingRequests.get(message.id).resolve;
      const originalReject = this._pendingRequests.get(message.id).reject;
      this._pendingRequests.set(message.id, {
        resolve: (value) => {
          clearTimeout(timeoutId);
          originalResolve(value);
        },
        reject: (error48) => {
          clearTimeout(timeoutId);
          originalReject(error48);
        }
      });
    });
  }
  requestContext() {
    this._iframeWindow.postMessage({
      channel: FRAME_MESSAGE_CHANNEL,
      message: {
        type: "model-context-request"
      }
    }, this._targetOrigin);
  }
  notifySubscribers() {
    this._subscribers.forEach((callback) => callback());
  }
  getModelContext() {
    return this._context;
  }
  subscribe(callback) {
    this._subscribers.add(callback);
    return () => this._subscribers.delete(callback);
  }
  dispose() {
    window.removeEventListener("message", this.handleMessage);
    this._subscribers.clear();
    this._pendingRequests.clear();
  }
};

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/external.js
var external_exports = {};
__export(external_exports, {
  $brand: () => $brand,
  $input: () => $input,
  $output: () => $output,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodError: () => ZodError,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFirstPartyTypeKind: () => ZodFirstPartyTypeKind,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  ZodIntersection: () => ZodIntersection,
  ZodIssueCode: () => ZodIssueCode,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRealError: () => ZodRealError,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  clone: () => clone,
  codec: () => codec,
  coerce: () => coerce_exports,
  config: () => config,
  core: () => core_exports2,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  decode: () => decode2,
  decodeAsync: () => decodeAsync2,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  encode: () => encode2,
  encodeAsync: () => encodeAsync2,
  endsWith: () => _endsWith,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  flattenError: () => flattenError,
  float32: () => float32,
  float64: () => float64,
  formatError: () => formatError,
  fromJSONSchema: () => fromJSONSchema,
  function: () => _function,
  getErrorMap: () => getErrorMap,
  globalRegistry: () => globalRegistry,
  gt: () => _gt,
  gte: () => _gte,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  includes: () => _includes,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  iso: () => iso_exports,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  length: () => _length,
  literal: () => literal,
  locales: () => locales_exports,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  mac: () => mac2,
  map: () => map,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  meta: () => meta2,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  negative: () => _negative,
  never: () => never,
  nonnegative: () => _nonnegative,
  nonoptional: () => nonoptional,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  overwrite: () => _overwrite,
  parse: () => parse2,
  parseAsync: () => parseAsync2,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  positive: () => _positive,
  prefault: () => prefault,
  preprocess: () => preprocess,
  prettifyError: () => prettifyError,
  promise: () => promise,
  property: () => _property,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  regex: () => _regex,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode2,
  safeDecodeAsync: () => safeDecodeAsync2,
  safeEncode: () => safeEncode2,
  safeEncodeAsync: () => safeEncodeAsync2,
  safeParse: () => safeParse2,
  safeParseAsync: () => safeParseAsync2,
  set: () => set,
  setErrorMap: () => setErrorMap,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  toJSONSchema: () => toJSONSchema2,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  transform: () => transform,
  treeifyError: () => treeifyError,
  trim: () => _trim,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  uppercase: () => _uppercase,
  url: () => url,
  util: () => util_exports,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/index.js
var core_exports2 = {};
__export(core_exports2, {
  $ZodAny: () => $ZodAny,
  $ZodArray: () => $ZodArray,
  $ZodAsyncError: () => $ZodAsyncError,
  $ZodBase64: () => $ZodBase64,
  $ZodBase64URL: () => $ZodBase64URL,
  $ZodBigInt: () => $ZodBigInt,
  $ZodBigIntFormat: () => $ZodBigIntFormat,
  $ZodBoolean: () => $ZodBoolean,
  $ZodCIDRv4: () => $ZodCIDRv4,
  $ZodCIDRv6: () => $ZodCIDRv6,
  $ZodCUID: () => $ZodCUID,
  $ZodCUID2: () => $ZodCUID2,
  $ZodCatch: () => $ZodCatch,
  $ZodCheck: () => $ZodCheck,
  $ZodCheckBigIntFormat: () => $ZodCheckBigIntFormat,
  $ZodCheckEndsWith: () => $ZodCheckEndsWith,
  $ZodCheckGreaterThan: () => $ZodCheckGreaterThan,
  $ZodCheckIncludes: () => $ZodCheckIncludes,
  $ZodCheckLengthEquals: () => $ZodCheckLengthEquals,
  $ZodCheckLessThan: () => $ZodCheckLessThan,
  $ZodCheckLowerCase: () => $ZodCheckLowerCase,
  $ZodCheckMaxLength: () => $ZodCheckMaxLength,
  $ZodCheckMaxSize: () => $ZodCheckMaxSize,
  $ZodCheckMimeType: () => $ZodCheckMimeType,
  $ZodCheckMinLength: () => $ZodCheckMinLength,
  $ZodCheckMinSize: () => $ZodCheckMinSize,
  $ZodCheckMultipleOf: () => $ZodCheckMultipleOf,
  $ZodCheckNumberFormat: () => $ZodCheckNumberFormat,
  $ZodCheckOverwrite: () => $ZodCheckOverwrite,
  $ZodCheckProperty: () => $ZodCheckProperty,
  $ZodCheckRegex: () => $ZodCheckRegex,
  $ZodCheckSizeEquals: () => $ZodCheckSizeEquals,
  $ZodCheckStartsWith: () => $ZodCheckStartsWith,
  $ZodCheckStringFormat: () => $ZodCheckStringFormat,
  $ZodCheckUpperCase: () => $ZodCheckUpperCase,
  $ZodCodec: () => $ZodCodec,
  $ZodCustom: () => $ZodCustom,
  $ZodCustomStringFormat: () => $ZodCustomStringFormat,
  $ZodDate: () => $ZodDate,
  $ZodDefault: () => $ZodDefault,
  $ZodDiscriminatedUnion: () => $ZodDiscriminatedUnion,
  $ZodE164: () => $ZodE164,
  $ZodEmail: () => $ZodEmail,
  $ZodEmoji: () => $ZodEmoji,
  $ZodEncodeError: () => $ZodEncodeError,
  $ZodEnum: () => $ZodEnum,
  $ZodError: () => $ZodError,
  $ZodExactOptional: () => $ZodExactOptional,
  $ZodFile: () => $ZodFile,
  $ZodFunction: () => $ZodFunction,
  $ZodGUID: () => $ZodGUID,
  $ZodIPv4: () => $ZodIPv4,
  $ZodIPv6: () => $ZodIPv6,
  $ZodISODate: () => $ZodISODate,
  $ZodISODateTime: () => $ZodISODateTime,
  $ZodISODuration: () => $ZodISODuration,
  $ZodISOTime: () => $ZodISOTime,
  $ZodIntersection: () => $ZodIntersection,
  $ZodJWT: () => $ZodJWT,
  $ZodKSUID: () => $ZodKSUID,
  $ZodLazy: () => $ZodLazy,
  $ZodLiteral: () => $ZodLiteral,
  $ZodMAC: () => $ZodMAC,
  $ZodMap: () => $ZodMap,
  $ZodNaN: () => $ZodNaN,
  $ZodNanoID: () => $ZodNanoID,
  $ZodNever: () => $ZodNever,
  $ZodNonOptional: () => $ZodNonOptional,
  $ZodNull: () => $ZodNull,
  $ZodNullable: () => $ZodNullable,
  $ZodNumber: () => $ZodNumber,
  $ZodNumberFormat: () => $ZodNumberFormat,
  $ZodObject: () => $ZodObject,
  $ZodObjectJIT: () => $ZodObjectJIT,
  $ZodOptional: () => $ZodOptional,
  $ZodPipe: () => $ZodPipe,
  $ZodPrefault: () => $ZodPrefault,
  $ZodPromise: () => $ZodPromise,
  $ZodReadonly: () => $ZodReadonly,
  $ZodRealError: () => $ZodRealError,
  $ZodRecord: () => $ZodRecord,
  $ZodRegistry: () => $ZodRegistry,
  $ZodSet: () => $ZodSet,
  $ZodString: () => $ZodString,
  $ZodStringFormat: () => $ZodStringFormat,
  $ZodSuccess: () => $ZodSuccess,
  $ZodSymbol: () => $ZodSymbol,
  $ZodTemplateLiteral: () => $ZodTemplateLiteral,
  $ZodTransform: () => $ZodTransform,
  $ZodTuple: () => $ZodTuple,
  $ZodType: () => $ZodType,
  $ZodULID: () => $ZodULID,
  $ZodURL: () => $ZodURL,
  $ZodUUID: () => $ZodUUID,
  $ZodUndefined: () => $ZodUndefined,
  $ZodUnion: () => $ZodUnion,
  $ZodUnknown: () => $ZodUnknown,
  $ZodVoid: () => $ZodVoid,
  $ZodXID: () => $ZodXID,
  $ZodXor: () => $ZodXor,
  $brand: () => $brand,
  $constructor: () => $constructor,
  $input: () => $input,
  $output: () => $output,
  Doc: () => Doc,
  JSONSchema: () => json_schema_exports,
  JSONSchemaGenerator: () => JSONSchemaGenerator,
  NEVER: () => NEVER,
  TimePrecision: () => TimePrecision,
  _any: () => _any,
  _array: () => _array,
  _base64: () => _base64,
  _base64url: () => _base64url,
  _bigint: () => _bigint,
  _boolean: () => _boolean,
  _catch: () => _catch,
  _check: () => _check,
  _cidrv4: () => _cidrv4,
  _cidrv6: () => _cidrv6,
  _coercedBigint: () => _coercedBigint,
  _coercedBoolean: () => _coercedBoolean,
  _coercedDate: () => _coercedDate,
  _coercedNumber: () => _coercedNumber,
  _coercedString: () => _coercedString,
  _cuid: () => _cuid,
  _cuid2: () => _cuid2,
  _custom: () => _custom,
  _date: () => _date,
  _decode: () => _decode,
  _decodeAsync: () => _decodeAsync,
  _default: () => _default,
  _discriminatedUnion: () => _discriminatedUnion,
  _e164: () => _e164,
  _email: () => _email,
  _emoji: () => _emoji2,
  _encode: () => _encode,
  _encodeAsync: () => _encodeAsync,
  _endsWith: () => _endsWith,
  _enum: () => _enum,
  _file: () => _file,
  _float32: () => _float32,
  _float64: () => _float64,
  _gt: () => _gt,
  _gte: () => _gte,
  _guid: () => _guid,
  _includes: () => _includes,
  _int: () => _int,
  _int32: () => _int32,
  _int64: () => _int64,
  _intersection: () => _intersection,
  _ipv4: () => _ipv4,
  _ipv6: () => _ipv6,
  _isoDate: () => _isoDate,
  _isoDateTime: () => _isoDateTime,
  _isoDuration: () => _isoDuration,
  _isoTime: () => _isoTime,
  _jwt: () => _jwt,
  _ksuid: () => _ksuid,
  _lazy: () => _lazy,
  _length: () => _length,
  _literal: () => _literal,
  _lowercase: () => _lowercase,
  _lt: () => _lt,
  _lte: () => _lte,
  _mac: () => _mac,
  _map: () => _map,
  _max: () => _lte,
  _maxLength: () => _maxLength,
  _maxSize: () => _maxSize,
  _mime: () => _mime,
  _min: () => _gte,
  _minLength: () => _minLength,
  _minSize: () => _minSize,
  _multipleOf: () => _multipleOf,
  _nan: () => _nan,
  _nanoid: () => _nanoid,
  _nativeEnum: () => _nativeEnum,
  _negative: () => _negative,
  _never: () => _never,
  _nonnegative: () => _nonnegative,
  _nonoptional: () => _nonoptional,
  _nonpositive: () => _nonpositive,
  _normalize: () => _normalize,
  _null: () => _null2,
  _nullable: () => _nullable,
  _number: () => _number,
  _optional: () => _optional,
  _overwrite: () => _overwrite,
  _parse: () => _parse,
  _parseAsync: () => _parseAsync,
  _pipe: () => _pipe,
  _positive: () => _positive,
  _promise: () => _promise,
  _property: () => _property,
  _readonly: () => _readonly,
  _record: () => _record,
  _refine: () => _refine,
  _regex: () => _regex,
  _safeDecode: () => _safeDecode,
  _safeDecodeAsync: () => _safeDecodeAsync,
  _safeEncode: () => _safeEncode,
  _safeEncodeAsync: () => _safeEncodeAsync,
  _safeParse: () => _safeParse,
  _safeParseAsync: () => _safeParseAsync,
  _set: () => _set,
  _size: () => _size,
  _slugify: () => _slugify,
  _startsWith: () => _startsWith,
  _string: () => _string,
  _stringFormat: () => _stringFormat,
  _stringbool: () => _stringbool,
  _success: () => _success,
  _superRefine: () => _superRefine,
  _symbol: () => _symbol,
  _templateLiteral: () => _templateLiteral,
  _toLowerCase: () => _toLowerCase,
  _toUpperCase: () => _toUpperCase,
  _transform: () => _transform,
  _trim: () => _trim,
  _tuple: () => _tuple,
  _uint32: () => _uint32,
  _uint64: () => _uint64,
  _ulid: () => _ulid,
  _undefined: () => _undefined2,
  _union: () => _union,
  _unknown: () => _unknown,
  _uppercase: () => _uppercase,
  _url: () => _url,
  _uuid: () => _uuid,
  _uuidv4: () => _uuidv4,
  _uuidv6: () => _uuidv6,
  _uuidv7: () => _uuidv7,
  _void: () => _void,
  _xid: () => _xid,
  _xor: () => _xor,
  clone: () => clone,
  config: () => config,
  createStandardJSONSchemaMethod: () => createStandardJSONSchemaMethod,
  createToJSONSchemaMethod: () => createToJSONSchemaMethod,
  decode: () => decode,
  decodeAsync: () => decodeAsync,
  describe: () => describe,
  encode: () => encode,
  encodeAsync: () => encodeAsync,
  extractDefs: () => extractDefs,
  finalize: () => finalize,
  flattenError: () => flattenError,
  formatError: () => formatError,
  globalConfig: () => globalConfig,
  globalRegistry: () => globalRegistry,
  initializeContext: () => initializeContext,
  isValidBase64: () => isValidBase64,
  isValidBase64URL: () => isValidBase64URL,
  isValidJWT: () => isValidJWT,
  locales: () => locales_exports,
  meta: () => meta,
  parse: () => parse,
  parseAsync: () => parseAsync,
  prettifyError: () => prettifyError,
  process: () => process2,
  regexes: () => regexes_exports,
  registry: () => registry,
  safeDecode: () => safeDecode,
  safeDecodeAsync: () => safeDecodeAsync,
  safeEncode: () => safeEncode,
  safeEncodeAsync: () => safeEncodeAsync,
  safeParse: () => safeParse,
  safeParseAsync: () => safeParseAsync,
  toDotPath: () => toDotPath,
  toJSONSchema: () => toJSONSchema2,
  treeifyError: () => treeifyError,
  util: () => util_exports,
  version: () => version2
});

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/core.js
var NEVER = Object.freeze({
  status: "aborted"
});
function $constructor(name, initializer3, params) {
  function init(inst, def) {
    if (!inst._zod) {
      Object.defineProperty(inst, "_zod", {
        value: {
          def,
          constr: _,
          traits: /* @__PURE__ */ new Set()
        },
        enumerable: false
      });
    }
    if (inst._zod.traits.has(name)) {
      return;
    }
    inst._zod.traits.add(name);
    initializer3(inst, def);
    const proto = _.prototype;
    const keys = Object.keys(proto);
    for (let i = 0; i < keys.length; i++) {
      const k = keys[i];
      if (!(k in inst)) {
        inst[k] = proto[k].bind(inst);
      }
    }
  }
  const Parent = (params == null ? void 0 : params.Parent) ?? Object;
  class Definition extends Parent {
  }
  Object.defineProperty(Definition, "name", { value: name });
  function _(def) {
    var _a3;
    const inst = (params == null ? void 0 : params.Parent) ? new Definition() : this;
    init(inst, def);
    (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
    for (const fn of inst._zod.deferred) {
      fn();
    }
    return inst;
  }
  Object.defineProperty(_, "init", { value: init });
  Object.defineProperty(_, Symbol.hasInstance, {
    value: (inst) => {
      var _a3, _b;
      if ((params == null ? void 0 : params.Parent) && inst instanceof params.Parent)
        return true;
      return (_b = (_a3 = inst == null ? void 0 : inst._zod) == null ? void 0 : _a3.traits) == null ? void 0 : _b.has(name);
    }
  });
  Object.defineProperty(_, "name", { value: name });
  return _;
}
var $brand = Symbol("zod_brand");
var $ZodAsyncError = class extends Error {
  constructor() {
    super(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);
  }
};
var $ZodEncodeError = class extends Error {
  constructor(name) {
    super(`Encountered unidirectional transform during encode: ${name}`);
    this.name = "ZodEncodeError";
  }
};
var globalConfig = {};
function config(newConfig) {
  if (newConfig)
    Object.assign(globalConfig, newConfig);
  return globalConfig;
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/util.js
var util_exports = {};
__export(util_exports, {
  BIGINT_FORMAT_RANGES: () => BIGINT_FORMAT_RANGES,
  Class: () => Class,
  NUMBER_FORMAT_RANGES: () => NUMBER_FORMAT_RANGES,
  aborted: () => aborted,
  allowsEval: () => allowsEval,
  assert: () => assert,
  assertEqual: () => assertEqual,
  assertIs: () => assertIs,
  assertNever: () => assertNever,
  assertNotEqual: () => assertNotEqual,
  assignProp: () => assignProp,
  base64ToUint8Array: () => base64ToUint8Array,
  base64urlToUint8Array: () => base64urlToUint8Array,
  cached: () => cached,
  captureStackTrace: () => captureStackTrace,
  cleanEnum: () => cleanEnum,
  cleanRegex: () => cleanRegex,
  clone: () => clone,
  cloneDef: () => cloneDef,
  createTransparentProxy: () => createTransparentProxy,
  defineLazy: () => defineLazy,
  esc: () => esc,
  escapeRegex: () => escapeRegex,
  extend: () => extend,
  finalizeIssue: () => finalizeIssue,
  floatSafeRemainder: () => floatSafeRemainder,
  getElementAtPath: () => getElementAtPath,
  getEnumValues: () => getEnumValues,
  getLengthableOrigin: () => getLengthableOrigin,
  getParsedType: () => getParsedType,
  getSizableOrigin: () => getSizableOrigin,
  hexToUint8Array: () => hexToUint8Array,
  isObject: () => isObject,
  isPlainObject: () => isPlainObject,
  issue: () => issue,
  joinValues: () => joinValues,
  jsonStringifyReplacer: () => jsonStringifyReplacer,
  merge: () => merge,
  mergeDefs: () => mergeDefs,
  normalizeParams: () => normalizeParams,
  nullish: () => nullish,
  numKeys: () => numKeys,
  objectClone: () => objectClone,
  omit: () => omit,
  optionalKeys: () => optionalKeys,
  parsedType: () => parsedType,
  partial: () => partial,
  pick: () => pick,
  prefixIssues: () => prefixIssues,
  primitiveTypes: () => primitiveTypes,
  promiseAllObject: () => promiseAllObject,
  propertyKeyTypes: () => propertyKeyTypes,
  randomString: () => randomString,
  required: () => required,
  safeExtend: () => safeExtend,
  shallowClone: () => shallowClone,
  slugify: () => slugify,
  stringifyPrimitive: () => stringifyPrimitive,
  uint8ArrayToBase64: () => uint8ArrayToBase64,
  uint8ArrayToBase64url: () => uint8ArrayToBase64url,
  uint8ArrayToHex: () => uint8ArrayToHex,
  unwrapMessage: () => unwrapMessage
});
function assertEqual(val) {
  return val;
}
function assertNotEqual(val) {
  return val;
}
function assertIs(_arg) {
}
function assertNever(_x) {
  throw new Error("Unexpected value in exhaustive check");
}
function assert(_) {
}
function getEnumValues(entries) {
  const numericValues = Object.values(entries).filter((v) => typeof v === "number");
  const values = Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);
  return values;
}
function joinValues(array2, separator = "|") {
  return array2.map((val) => stringifyPrimitive(val)).join(separator);
}
function jsonStringifyReplacer(_, value) {
  if (typeof value === "bigint")
    return value.toString();
  return value;
}
function cached(getter) {
  const set2 = false;
  return {
    get value() {
      if (!set2) {
        const value = getter();
        Object.defineProperty(this, "value", { value });
        return value;
      }
      throw new Error("cached value already set");
    }
  };
}
function nullish(input) {
  return input === null || input === void 0;
}
function cleanRegex(source) {
  const start = source.startsWith("^") ? 1 : 0;
  const end = source.endsWith("$") ? source.length - 1 : source.length;
  return source.slice(start, end);
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepString = step.toString();
  let stepDecCount = (stepString.split(".")[1] || "").length;
  if (stepDecCount === 0 && /\d?e-\d?/.test(stepString)) {
    const match = stepString.match(/\d?e-(\d?)/);
    if (match == null ? void 0 : match[1]) {
      stepDecCount = Number.parseInt(match[1]);
    }
  }
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = Number.parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = Number.parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / 10 ** decCount;
}
var EVALUATING = Symbol("evaluating");
function defineLazy(object2, key, getter) {
  let value = void 0;
  Object.defineProperty(object2, key, {
    get() {
      if (value === EVALUATING) {
        return void 0;
      }
      if (value === void 0) {
        value = EVALUATING;
        value = getter();
      }
      return value;
    },
    set(v) {
      Object.defineProperty(object2, key, {
        value: v
        // configurable: true,
      });
    },
    configurable: true
  });
}
function objectClone(obj) {
  return Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));
}
function assignProp(target, prop, value) {
  Object.defineProperty(target, prop, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
}
function mergeDefs(...defs) {
  const mergedDescriptors = {};
  for (const def of defs) {
    const descriptors = Object.getOwnPropertyDescriptors(def);
    Object.assign(mergedDescriptors, descriptors);
  }
  return Object.defineProperties({}, mergedDescriptors);
}
function cloneDef(schema) {
  return mergeDefs(schema._zod.def);
}
function getElementAtPath(obj, path) {
  if (!path)
    return obj;
  return path.reduce((acc, key) => acc == null ? void 0 : acc[key], obj);
}
function promiseAllObject(promisesObj) {
  const keys = Object.keys(promisesObj);
  const promises = keys.map((key) => promisesObj[key]);
  return Promise.all(promises).then((results) => {
    const resolvedObj = {};
    for (let i = 0; i < keys.length; i++) {
      resolvedObj[keys[i]] = results[i];
    }
    return resolvedObj;
  });
}
function randomString(length = 10) {
  const chars = "abcdefghijklmnopqrstuvwxyz";
  let str = "";
  for (let i = 0; i < length; i++) {
    str += chars[Math.floor(Math.random() * chars.length)];
  }
  return str;
}
function esc(str) {
  return JSON.stringify(str);
}
function slugify(input) {
  return input.toLowerCase().trim().replace(/[^\w\s-]/g, "").replace(/[\s_-]+/g, "-").replace(/^-+|-+$/g, "");
}
var captureStackTrace = "captureStackTrace" in Error ? Error.captureStackTrace : (..._args) => {
};
function isObject(data) {
  return typeof data === "object" && data !== null && !Array.isArray(data);
}
var allowsEval = cached(() => {
  var _a3;
  if (typeof navigator !== "undefined" && ((_a3 = navigator == null ? void 0 : navigator.userAgent) == null ? void 0 : _a3.includes("Cloudflare"))) {
    return false;
  }
  try {
    const F = Function;
    new F("");
    return true;
  } catch (_) {
    return false;
  }
});
function isPlainObject(o) {
  if (isObject(o) === false)
    return false;
  const ctor = o.constructor;
  if (ctor === void 0)
    return true;
  if (typeof ctor !== "function")
    return true;
  const prot = ctor.prototype;
  if (isObject(prot) === false)
    return false;
  if (Object.prototype.hasOwnProperty.call(prot, "isPrototypeOf") === false) {
    return false;
  }
  return true;
}
function shallowClone(o) {
  if (isPlainObject(o))
    return { ...o };
  if (Array.isArray(o))
    return [...o];
  return o;
}
function numKeys(data) {
  let keyCount = 0;
  for (const key in data) {
    if (Object.prototype.hasOwnProperty.call(data, key)) {
      keyCount++;
    }
  }
  return keyCount;
}
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return "undefined";
    case "string":
      return "string";
    case "number":
      return Number.isNaN(data) ? "nan" : "number";
    case "boolean":
      return "boolean";
    case "function":
      return "function";
    case "bigint":
      return "bigint";
    case "symbol":
      return "symbol";
    case "object":
      if (Array.isArray(data)) {
        return "array";
      }
      if (data === null) {
        return "null";
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return "promise";
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return "map";
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return "set";
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return "date";
      }
      if (typeof File !== "undefined" && data instanceof File) {
        return "file";
      }
      return "object";
    default:
      throw new Error(`Unknown data type: ${t}`);
  }
};
var propertyKeyTypes = /* @__PURE__ */ new Set(["string", "number", "symbol"]);
var primitiveTypes = /* @__PURE__ */ new Set(["string", "number", "bigint", "boolean", "symbol", "undefined"]);
function escapeRegex(str) {
  return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function clone(inst, def, params) {
  const cl = new inst._zod.constr(def ?? inst._zod.def);
  if (!def || (params == null ? void 0 : params.parent))
    cl._zod.parent = inst;
  return cl;
}
function normalizeParams(_params) {
  const params = _params;
  if (!params)
    return {};
  if (typeof params === "string")
    return { error: () => params };
  if ((params == null ? void 0 : params.message) !== void 0) {
    if ((params == null ? void 0 : params.error) !== void 0)
      throw new Error("Cannot specify both `message` and `error` params");
    params.error = params.message;
  }
  delete params.message;
  if (typeof params.error === "string")
    return { ...params, error: () => params.error };
  return params;
}
function createTransparentProxy(getter) {
  let target;
  return new Proxy({}, {
    get(_, prop, receiver) {
      target ?? (target = getter());
      return Reflect.get(target, prop, receiver);
    },
    set(_, prop, value, receiver) {
      target ?? (target = getter());
      return Reflect.set(target, prop, value, receiver);
    },
    has(_, prop) {
      target ?? (target = getter());
      return Reflect.has(target, prop);
    },
    deleteProperty(_, prop) {
      target ?? (target = getter());
      return Reflect.deleteProperty(target, prop);
    },
    ownKeys(_) {
      target ?? (target = getter());
      return Reflect.ownKeys(target);
    },
    getOwnPropertyDescriptor(_, prop) {
      target ?? (target = getter());
      return Reflect.getOwnPropertyDescriptor(target, prop);
    },
    defineProperty(_, prop, descriptor) {
      target ?? (target = getter());
      return Reflect.defineProperty(target, prop, descriptor);
    }
  });
}
function stringifyPrimitive(value) {
  if (typeof value === "bigint")
    return value.toString() + "n";
  if (typeof value === "string")
    return `"${value}"`;
  return `${value}`;
}
function optionalKeys(shape) {
  return Object.keys(shape).filter((k) => {
    return shape[k]._zod.optin === "optional" && shape[k]._zod.optout === "optional";
  });
}
var NUMBER_FORMAT_RANGES = {
  safeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],
  int32: [-2147483648, 2147483647],
  uint32: [0, 4294967295],
  float32: [-34028234663852886e22, 34028234663852886e22],
  float64: [-Number.MAX_VALUE, Number.MAX_VALUE]
};
var BIGINT_FORMAT_RANGES = {
  int64: [BigInt("-9223372036854775808"), BigInt("9223372036854775807")],
  uint64: [BigInt(0), BigInt("18446744073709551615")]
};
function pick(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".pick() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = {};
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        newShape[key] = currDef.shape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function omit(schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".omit() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const newShape = { ...schema._zod.def.shape };
      for (const key in mask) {
        if (!(key in currDef.shape)) {
          throw new Error(`Unrecognized key: "${key}"`);
        }
        if (!mask[key])
          continue;
        delete newShape[key];
      }
      assignProp(this, "shape", newShape);
      return newShape;
    },
    checks: []
  });
  return clone(schema, def);
}
function extend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to extend: expected a plain object");
  }
  const checks = schema._zod.def.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    const existingShape = schema._zod.def.shape;
    for (const key in shape) {
      if (Object.getOwnPropertyDescriptor(existingShape, key) !== void 0) {
        throw new Error("Cannot overwrite keys on object schemas containing refinements. Use `.safeExtend()` instead.");
      }
    }
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function safeExtend(schema, shape) {
  if (!isPlainObject(shape)) {
    throw new Error("Invalid input to safeExtend: expected a plain object");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const _shape = { ...schema._zod.def.shape, ...shape };
      assignProp(this, "shape", _shape);
      return _shape;
    }
  });
  return clone(schema, def);
}
function merge(a, b) {
  const def = mergeDefs(a._zod.def, {
    get shape() {
      const _shape = { ...a._zod.def.shape, ...b._zod.def.shape };
      assignProp(this, "shape", _shape);
      return _shape;
    },
    get catchall() {
      return b._zod.def.catchall;
    },
    checks: []
    // delete existing checks
  });
  return clone(a, def);
}
function partial(Class2, schema, mask) {
  const currDef = schema._zod.def;
  const checks = currDef.checks;
  const hasChecks = checks && checks.length > 0;
  if (hasChecks) {
    throw new Error(".partial() cannot be used on object schemas containing refinements");
  }
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in oldShape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      } else {
        for (const key in oldShape) {
          shape[key] = Class2 ? new Class2({
            type: "optional",
            innerType: oldShape[key]
          }) : oldShape[key];
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    },
    checks: []
  });
  return clone(schema, def);
}
function required(Class2, schema, mask) {
  const def = mergeDefs(schema._zod.def, {
    get shape() {
      const oldShape = schema._zod.def.shape;
      const shape = { ...oldShape };
      if (mask) {
        for (const key in mask) {
          if (!(key in shape)) {
            throw new Error(`Unrecognized key: "${key}"`);
          }
          if (!mask[key])
            continue;
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      } else {
        for (const key in oldShape) {
          shape[key] = new Class2({
            type: "nonoptional",
            innerType: oldShape[key]
          });
        }
      }
      assignProp(this, "shape", shape);
      return shape;
    }
  });
  return clone(schema, def);
}
function aborted(x, startIndex = 0) {
  var _a3;
  if (x.aborted === true)
    return true;
  for (let i = startIndex; i < x.issues.length; i++) {
    if (((_a3 = x.issues[i]) == null ? void 0 : _a3.continue) !== true) {
      return true;
    }
  }
  return false;
}
function prefixIssues(path, issues) {
  return issues.map((iss) => {
    var _a3;
    (_a3 = iss).path ?? (_a3.path = []);
    iss.path.unshift(path);
    return iss;
  });
}
function unwrapMessage(message) {
  return typeof message === "string" ? message : message == null ? void 0 : message.message;
}
function finalizeIssue(iss, ctx, config2) {
  var _a3, _b, _c, _d, _e, _f;
  const full = { ...iss, path: iss.path ?? [] };
  if (!iss.message) {
    const message = unwrapMessage((_c = (_b = (_a3 = iss.inst) == null ? void 0 : _a3._zod.def) == null ? void 0 : _b.error) == null ? void 0 : _c.call(_b, iss)) ?? unwrapMessage((_d = ctx == null ? void 0 : ctx.error) == null ? void 0 : _d.call(ctx, iss)) ?? unwrapMessage((_e = config2.customError) == null ? void 0 : _e.call(config2, iss)) ?? unwrapMessage((_f = config2.localeError) == null ? void 0 : _f.call(config2, iss)) ?? "Invalid input";
    full.message = message;
  }
  delete full.inst;
  delete full.continue;
  if (!(ctx == null ? void 0 : ctx.reportInput)) {
    delete full.input;
  }
  return full;
}
function getSizableOrigin(input) {
  if (input instanceof Set)
    return "set";
  if (input instanceof Map)
    return "map";
  if (input instanceof File)
    return "file";
  return "unknown";
}
function getLengthableOrigin(input) {
  if (Array.isArray(input))
    return "array";
  if (typeof input === "string")
    return "string";
  return "unknown";
}
function parsedType(data) {
  const t = typeof data;
  switch (t) {
    case "number": {
      return Number.isNaN(data) ? "nan" : "number";
    }
    case "object": {
      if (data === null) {
        return "null";
      }
      if (Array.isArray(data)) {
        return "array";
      }
      const obj = data;
      if (obj && Object.getPrototypeOf(obj) !== Object.prototype && "constructor" in obj && obj.constructor) {
        return obj.constructor.name;
      }
    }
  }
  return t;
}
function issue(...args) {
  const [iss, input, inst] = args;
  if (typeof iss === "string") {
    return {
      message: iss,
      code: "custom",
      input,
      inst
    };
  }
  return { ...iss };
}
function cleanEnum(obj) {
  return Object.entries(obj).filter(([k, _]) => {
    return Number.isNaN(Number.parseInt(k, 10));
  }).map((el) => el[1]);
}
function base64ToUint8Array(base643) {
  const binaryString = atob(base643);
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes;
}
function uint8ArrayToBase64(bytes) {
  let binaryString = "";
  for (let i = 0; i < bytes.length; i++) {
    binaryString += String.fromCharCode(bytes[i]);
  }
  return btoa(binaryString);
}
function base64urlToUint8Array(base64url3) {
  const base643 = base64url3.replace(/-/g, "+").replace(/_/g, "/");
  const padding = "=".repeat((4 - base643.length % 4) % 4);
  return base64ToUint8Array(base643 + padding);
}
function uint8ArrayToBase64url(bytes) {
  return uint8ArrayToBase64(bytes).replace(/\+/g, "-").replace(/\//g, "_").replace(/=/g, "");
}
function hexToUint8Array(hex3) {
  const cleanHex = hex3.replace(/^0x/, "");
  if (cleanHex.length % 2 !== 0) {
    throw new Error("Invalid hex string length");
  }
  const bytes = new Uint8Array(cleanHex.length / 2);
  for (let i = 0; i < cleanHex.length; i += 2) {
    bytes[i / 2] = Number.parseInt(cleanHex.slice(i, i + 2), 16);
  }
  return bytes;
}
function uint8ArrayToHex(bytes) {
  return Array.from(bytes).map((b) => b.toString(16).padStart(2, "0")).join("");
}
var Class = class {
  constructor(..._args) {
  }
};

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/errors.js
var initializer = (inst, def) => {
  inst.name = "$ZodError";
  Object.defineProperty(inst, "_zod", {
    value: inst._zod,
    enumerable: false
  });
  Object.defineProperty(inst, "issues", {
    value: def,
    enumerable: false
  });
  inst.message = JSON.stringify(def, jsonStringifyReplacer, 2);
  Object.defineProperty(inst, "toString", {
    value: () => inst.message,
    enumerable: false
  });
};
var $ZodError = $constructor("$ZodError", initializer);
var $ZodRealError = $constructor("$ZodError", initializer, { Parent: Error });
function flattenError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = {};
  const formErrors = [];
  for (const sub of error48.issues) {
    if (sub.path.length > 0) {
      fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
      fieldErrors[sub.path[0]].push(mapper(sub));
    } else {
      formErrors.push(mapper(sub));
    }
  }
  return { formErrors, fieldErrors };
}
function formatError(error48, mapper = (issue2) => issue2.message) {
  const fieldErrors = { _errors: [] };
  const processError = (error49) => {
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues });
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues });
      } else if (issue2.path.length === 0) {
        fieldErrors._errors.push(mapper(issue2));
      } else {
        let curr = fieldErrors;
        let i = 0;
        while (i < issue2.path.length) {
          const el = issue2.path[i];
          const terminal = i === issue2.path.length - 1;
          if (!terminal) {
            curr[el] = curr[el] || { _errors: [] };
          } else {
            curr[el] = curr[el] || { _errors: [] };
            curr[el]._errors.push(mapper(issue2));
          }
          curr = curr[el];
          i++;
        }
      }
    }
  };
  processError(error48);
  return fieldErrors;
}
function treeifyError(error48, mapper = (issue2) => issue2.message) {
  const result = { errors: [] };
  const processError = (error49, path = []) => {
    var _a3, _b;
    for (const issue2 of error49.issues) {
      if (issue2.code === "invalid_union" && issue2.errors.length) {
        issue2.errors.map((issues) => processError({ issues }, issue2.path));
      } else if (issue2.code === "invalid_key") {
        processError({ issues: issue2.issues }, issue2.path);
      } else if (issue2.code === "invalid_element") {
        processError({ issues: issue2.issues }, issue2.path);
      } else {
        const fullpath = [...path, ...issue2.path];
        if (fullpath.length === 0) {
          result.errors.push(mapper(issue2));
          continue;
        }
        let curr = result;
        let i = 0;
        while (i < fullpath.length) {
          const el = fullpath[i];
          const terminal = i === fullpath.length - 1;
          if (typeof el === "string") {
            curr.properties ?? (curr.properties = {});
            (_a3 = curr.properties)[el] ?? (_a3[el] = { errors: [] });
            curr = curr.properties[el];
          } else {
            curr.items ?? (curr.items = []);
            (_b = curr.items)[el] ?? (_b[el] = { errors: [] });
            curr = curr.items[el];
          }
          if (terminal) {
            curr.errors.push(mapper(issue2));
          }
          i++;
        }
      }
    }
  };
  processError(error48);
  return result;
}
function toDotPath(_path) {
  const segs = [];
  const path = _path.map((seg) => typeof seg === "object" ? seg.key : seg);
  for (const seg of path) {
    if (typeof seg === "number")
      segs.push(`[${seg}]`);
    else if (typeof seg === "symbol")
      segs.push(`[${JSON.stringify(String(seg))}]`);
    else if (/[^\w$]/.test(seg))
      segs.push(`[${JSON.stringify(seg)}]`);
    else {
      if (segs.length)
        segs.push(".");
      segs.push(seg);
    }
  }
  return segs.join("");
}
function prettifyError(error48) {
  var _a3;
  const lines = [];
  const issues = [...error48.issues].sort((a, b) => (a.path ?? []).length - (b.path ?? []).length);
  for (const issue2 of issues) {
    lines.push(` ${issue2.message}`);
    if ((_a3 = issue2.path) == null ? void 0 : _a3.length)
      lines.push(`   at ${toDotPath(issue2.path)}`);
  }
  return lines.join("\n");
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/parse.js
var _parse = (_Err) => (schema, value, _ctx, _params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  if (result.issues.length) {
    const e = new ((_params == null ? void 0 : _params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, _params == null ? void 0 : _params.callee);
    throw e;
  }
  return result.value;
};
var parse = _parse($ZodRealError);
var _parseAsync = (_Err) => async (schema, value, _ctx, params) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  if (result.issues.length) {
    const e = new ((params == null ? void 0 : params.Err) ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));
    captureStackTrace(e, params == null ? void 0 : params.callee);
    throw e;
  }
  return result.value;
};
var parseAsync = _parseAsync($ZodRealError);
var _safeParse = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? { ..._ctx, async: false } : { async: false };
  const result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise) {
    throw new $ZodAsyncError();
  }
  return result.issues.length ? {
    success: false,
    error: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParse = _safeParse($ZodRealError);
var _safeParseAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };
  let result = schema._zod.run({ value, issues: [] }, ctx);
  if (result instanceof Promise)
    result = await result;
  return result.issues.length ? {
    success: false,
    error: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  } : { success: true, data: result.value };
};
var safeParseAsync = _safeParseAsync($ZodRealError);
var _encode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parse(_Err)(schema, value, ctx);
};
var encode = _encode($ZodRealError);
var _decode = (_Err) => (schema, value, _ctx) => {
  return _parse(_Err)(schema, value, _ctx);
};
var decode = _decode($ZodRealError);
var _encodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _parseAsync(_Err)(schema, value, ctx);
};
var encodeAsync = _encodeAsync($ZodRealError);
var _decodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _parseAsync(_Err)(schema, value, _ctx);
};
var decodeAsync = _decodeAsync($ZodRealError);
var _safeEncode = (_Err) => (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParse(_Err)(schema, value, ctx);
};
var safeEncode = _safeEncode($ZodRealError);
var _safeDecode = (_Err) => (schema, value, _ctx) => {
  return _safeParse(_Err)(schema, value, _ctx);
};
var safeDecode = _safeDecode($ZodRealError);
var _safeEncodeAsync = (_Err) => async (schema, value, _ctx) => {
  const ctx = _ctx ? Object.assign(_ctx, { direction: "backward" }) : { direction: "backward" };
  return _safeParseAsync(_Err)(schema, value, ctx);
};
var safeEncodeAsync = _safeEncodeAsync($ZodRealError);
var _safeDecodeAsync = (_Err) => async (schema, value, _ctx) => {
  return _safeParseAsync(_Err)(schema, value, _ctx);
};
var safeDecodeAsync = _safeDecodeAsync($ZodRealError);

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/regexes.js
var regexes_exports = {};
__export(regexes_exports, {
  base64: () => base64,
  base64url: () => base64url,
  bigint: () => bigint,
  boolean: () => boolean,
  browserEmail: () => browserEmail,
  cidrv4: () => cidrv4,
  cidrv6: () => cidrv6,
  cuid: () => cuid,
  cuid2: () => cuid2,
  date: () => date,
  datetime: () => datetime,
  domain: () => domain,
  duration: () => duration,
  e164: () => e164,
  email: () => email,
  emoji: () => emoji,
  extendedDuration: () => extendedDuration,
  guid: () => guid,
  hex: () => hex,
  hostname: () => hostname,
  html5Email: () => html5Email,
  idnEmail: () => idnEmail,
  integer: () => integer,
  ipv4: () => ipv4,
  ipv6: () => ipv6,
  ksuid: () => ksuid,
  lowercase: () => lowercase,
  mac: () => mac,
  md5_base64: () => md5_base64,
  md5_base64url: () => md5_base64url,
  md5_hex: () => md5_hex,
  nanoid: () => nanoid,
  null: () => _null,
  number: () => number,
  rfc5322Email: () => rfc5322Email,
  sha1_base64: () => sha1_base64,
  sha1_base64url: () => sha1_base64url,
  sha1_hex: () => sha1_hex,
  sha256_base64: () => sha256_base64,
  sha256_base64url: () => sha256_base64url,
  sha256_hex: () => sha256_hex,
  sha384_base64: () => sha384_base64,
  sha384_base64url: () => sha384_base64url,
  sha384_hex: () => sha384_hex,
  sha512_base64: () => sha512_base64,
  sha512_base64url: () => sha512_base64url,
  sha512_hex: () => sha512_hex,
  string: () => string,
  time: () => time,
  ulid: () => ulid,
  undefined: () => _undefined,
  unicodeEmail: () => unicodeEmail,
  uppercase: () => uppercase,
  uuid: () => uuid,
  uuid4: () => uuid4,
  uuid6: () => uuid6,
  uuid7: () => uuid7,
  xid: () => xid
});
var cuid = /^[cC][^\s-]{8,}$/;
var cuid2 = /^[0-9a-z]+$/;
var ulid = /^[0-9A-HJKMNP-TV-Za-hjkmnp-tv-z]{26}$/;
var xid = /^[0-9a-vA-V]{20}$/;
var ksuid = /^[A-Za-z0-9]{27}$/;
var nanoid = /^[a-zA-Z0-9_-]{21}$/;
var duration = /^P(?:(\d+W)|(?!.*W)(?=\d|T\d)(\d+Y)?(\d+M)?(\d+D)?(T(?=\d)(\d+H)?(\d+M)?(\d+([.,]\d+)?S)?)?)$/;
var extendedDuration = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var guid = /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12})$/;
var uuid = (version3) => {
  if (!version3)
    return /^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-8][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/;
  return new RegExp(`^([0-9a-fA-F]{8}-[0-9a-fA-F]{4}-${version3}[0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12})$`);
};
var uuid4 = uuid(4);
var uuid6 = uuid(6);
var uuid7 = uuid(7);
var email = /^(?!\.)(?!.*\.\.)([A-Za-z0-9_'+\-\.]*)[A-Za-z0-9_+-]@([A-Za-z0-9][A-Za-z0-9\-]*\.)+[A-Za-z]{2,}$/;
var html5Email = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var rfc5322Email = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var unicodeEmail = /^[^\s@"]{1,64}@[^\s@]{1,255}$/u;
var idnEmail = unicodeEmail;
var browserEmail = /^[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;
var _emoji = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
function emoji() {
  return new RegExp(_emoji, "u");
}
var ipv4 = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:))$/;
var mac = (delimiter) => {
  const escapedDelim = escapeRegex(delimiter ?? ":");
  return new RegExp(`^(?:[0-9A-F]{2}${escapedDelim}){5}[0-9A-F]{2}$|^(?:[0-9a-f]{2}${escapedDelim}){5}[0-9a-f]{2}$`);
};
var cidrv4 = /^((25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/([0-9]|[1-2][0-9]|3[0-2])$/;
var cidrv6 = /^(([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|::|([0-9a-fA-F]{1,4})?::([0-9a-fA-F]{1,4}:?){0,6})\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
var base64 = /^$|^(?:[0-9a-zA-Z+/]{4})*(?:(?:[0-9a-zA-Z+/]{2}==)|(?:[0-9a-zA-Z+/]{3}=))?$/;
var base64url = /^[A-Za-z0-9_-]*$/;
var hostname = /^(?=.{1,253}\.?$)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[-0-9a-zA-Z]{0,61}[0-9a-zA-Z])?)*\.?$/;
var domain = /^([a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}$/;
var e164 = /^\+[1-9]\d{6,14}$/;
var dateSource = `(?:(?:\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-(?:(?:0[13578]|1[02])-(?:0[1-9]|[12]\\d|3[01])|(?:0[469]|11)-(?:0[1-9]|[12]\\d|30)|(?:02)-(?:0[1-9]|1\\d|2[0-8])))`;
var date = new RegExp(`^${dateSource}$`);
function timeSource(args) {
  const hhmm = `(?:[01]\\d|2[0-3]):[0-5]\\d`;
  const regex = typeof args.precision === "number" ? args.precision === -1 ? `${hhmm}` : args.precision === 0 ? `${hhmm}:[0-5]\\d` : `${hhmm}:[0-5]\\d\\.\\d{${args.precision}}` : `${hhmm}(?::[0-5]\\d(?:\\.\\d+)?)?`;
  return regex;
}
function time(args) {
  return new RegExp(`^${timeSource(args)}$`);
}
function datetime(args) {
  const time3 = timeSource({ precision: args.precision });
  const opts = ["Z"];
  if (args.local)
    opts.push("");
  if (args.offset)
    opts.push(`([+-](?:[01]\\d|2[0-3]):[0-5]\\d)`);
  const timeRegex = `${time3}(?:${opts.join("|")})`;
  return new RegExp(`^${dateSource}T(?:${timeRegex})$`);
}
var string = (params) => {
  const regex = params ? `[\\s\\S]{${(params == null ? void 0 : params.minimum) ?? 0},${(params == null ? void 0 : params.maximum) ?? ""}}` : `[\\s\\S]*`;
  return new RegExp(`^${regex}$`);
};
var bigint = /^-?\d+n?$/;
var integer = /^-?\d+$/;
var number = /^-?\d+(?:\.\d+)?$/;
var boolean = /^(?:true|false)$/i;
var _null = /^null$/i;
var _undefined = /^undefined$/i;
var lowercase = /^[^A-Z]*$/;
var uppercase = /^[^a-z]*$/;
var hex = /^[0-9a-fA-F]*$/;
function fixedBase64(bodyLength, padding) {
  return new RegExp(`^[A-Za-z0-9+/]{${bodyLength}}${padding}$`);
}
function fixedBase64url(length) {
  return new RegExp(`^[A-Za-z0-9_-]{${length}}$`);
}
var md5_hex = /^[0-9a-fA-F]{32}$/;
var md5_base64 = fixedBase64(22, "==");
var md5_base64url = fixedBase64url(22);
var sha1_hex = /^[0-9a-fA-F]{40}$/;
var sha1_base64 = fixedBase64(27, "=");
var sha1_base64url = fixedBase64url(27);
var sha256_hex = /^[0-9a-fA-F]{64}$/;
var sha256_base64 = fixedBase64(43, "=");
var sha256_base64url = fixedBase64url(43);
var sha384_hex = /^[0-9a-fA-F]{96}$/;
var sha384_base64 = fixedBase64(64, "");
var sha384_base64url = fixedBase64url(64);
var sha512_hex = /^[0-9a-fA-F]{128}$/;
var sha512_base64 = fixedBase64(86, "==");
var sha512_base64url = fixedBase64url(86);

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/checks.js
var $ZodCheck = $constructor("$ZodCheck", (inst, def) => {
  var _a3;
  inst._zod ?? (inst._zod = {});
  inst._zod.def = def;
  (_a3 = inst._zod).onattach ?? (_a3.onattach = []);
});
var numericOriginMap = {
  number: "number",
  bigint: "bigint",
  object: "date"
};
var $ZodCheckLessThan = $constructor("$ZodCheckLessThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.maximum : bag.exclusiveMaximum) ?? Number.POSITIVE_INFINITY;
    if (def.value < curr) {
      if (def.inclusive)
        bag.maximum = def.value;
      else
        bag.exclusiveMaximum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value <= def.value : payload.value < def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckGreaterThan = $constructor("$ZodCheckGreaterThan", (inst, def) => {
  $ZodCheck.init(inst, def);
  const origin = numericOriginMap[typeof def.value];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    const curr = (def.inclusive ? bag.minimum : bag.exclusiveMinimum) ?? Number.NEGATIVE_INFINITY;
    if (def.value > curr) {
      if (def.inclusive)
        bag.minimum = def.value;
      else
        bag.exclusiveMinimum = def.value;
    }
  });
  inst._zod.check = (payload) => {
    if (def.inclusive ? payload.value >= def.value : payload.value > def.value) {
      return;
    }
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: typeof def.value === "object" ? def.value.getTime() : def.value,
      input: payload.value,
      inclusive: def.inclusive,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMultipleOf = $constructor("$ZodCheckMultipleOf", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    var _a3;
    (_a3 = inst2._zod.bag).multipleOf ?? (_a3.multipleOf = def.value);
  });
  inst._zod.check = (payload) => {
    if (typeof payload.value !== typeof def.value)
      throw new Error("Cannot mix number and bigint in multiple_of check.");
    const isMultiple = typeof payload.value === "bigint" ? payload.value % def.value === BigInt(0) : floatSafeRemainder(payload.value, def.value) === 0;
    if (isMultiple)
      return;
    payload.issues.push({
      origin: typeof payload.value,
      code: "not_multiple_of",
      divisor: def.value,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckNumberFormat = $constructor("$ZodCheckNumberFormat", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  def.format = def.format || "float64";
  const isInt = (_a3 = def.format) == null ? void 0 : _a3.includes("int");
  const origin = isInt ? "int" : "number";
  const [minimum, maximum] = NUMBER_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
    if (isInt)
      bag.pattern = integer;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (isInt) {
      if (!Number.isInteger(input)) {
        payload.issues.push({
          expected: origin,
          format: def.format,
          code: "invalid_type",
          continue: false,
          input,
          inst
        });
        return;
      }
      if (!Number.isSafeInteger(input)) {
        if (input > 0) {
          payload.issues.push({
            input,
            code: "too_big",
            maximum: Number.MAX_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        } else {
          payload.issues.push({
            input,
            code: "too_small",
            minimum: Number.MIN_SAFE_INTEGER,
            note: "Integers must be within the safe integer range.",
            inst,
            origin,
            inclusive: true,
            continue: !def.abort
          });
        }
        return;
      }
    }
    if (input < minimum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "number",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckBigIntFormat = $constructor("$ZodCheckBigIntFormat", (inst, def) => {
  $ZodCheck.init(inst, def);
  const [minimum, maximum] = BIGINT_FORMAT_RANGES[def.format];
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    bag.minimum = minimum;
    bag.maximum = maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    if (input < minimum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_small",
        minimum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
    if (input > maximum) {
      payload.issues.push({
        origin: "bigint",
        input,
        code: "too_big",
        maximum,
        inclusive: true,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodCheckMaxSize = $constructor("$ZodCheckMaxSize", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size <= def.maximum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinSize = $constructor("$ZodCheckMinSize", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size >= def.minimum)
      return;
    payload.issues.push({
      origin: getSizableOrigin(input),
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckSizeEquals = $constructor("$ZodCheckSizeEquals", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.size !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.size;
    bag.maximum = def.size;
    bag.size = def.size;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const size = input.size;
    if (size === def.size)
      return;
    const tooBig = size > def.size;
    payload.issues.push({
      origin: getSizableOrigin(input),
      ...tooBig ? { code: "too_big", maximum: def.size } : { code: "too_small", minimum: def.size },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMaxLength = $constructor("$ZodCheckMaxLength", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.maximum ?? Number.POSITIVE_INFINITY;
    if (def.maximum < curr)
      inst2._zod.bag.maximum = def.maximum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length <= def.maximum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_big",
      maximum: def.maximum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckMinLength = $constructor("$ZodCheckMinLength", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const curr = inst2._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;
    if (def.minimum > curr)
      inst2._zod.bag.minimum = def.minimum;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length >= def.minimum)
      return;
    const origin = getLengthableOrigin(input);
    payload.issues.push({
      origin,
      code: "too_small",
      minimum: def.minimum,
      inclusive: true,
      input,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLengthEquals = $constructor("$ZodCheckLengthEquals", (inst, def) => {
  var _a3;
  $ZodCheck.init(inst, def);
  (_a3 = inst._zod.def).when ?? (_a3.when = (payload) => {
    const val = payload.value;
    return !nullish(val) && val.length !== void 0;
  });
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.minimum = def.length;
    bag.maximum = def.length;
    bag.length = def.length;
  });
  inst._zod.check = (payload) => {
    const input = payload.value;
    const length = input.length;
    if (length === def.length)
      return;
    const origin = getLengthableOrigin(input);
    const tooBig = length > def.length;
    payload.issues.push({
      origin,
      ...tooBig ? { code: "too_big", maximum: def.length } : { code: "too_small", minimum: def.length },
      inclusive: true,
      exact: true,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStringFormat = $constructor("$ZodCheckStringFormat", (inst, def) => {
  var _a3, _b;
  $ZodCheck.init(inst, def);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.format = def.format;
    if (def.pattern) {
      bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
      bag.patterns.add(def.pattern);
    }
  });
  if (def.pattern)
    (_a3 = inst._zod).check ?? (_a3.check = (payload) => {
      def.pattern.lastIndex = 0;
      if (def.pattern.test(payload.value))
        return;
      payload.issues.push({
        origin: "string",
        code: "invalid_format",
        format: def.format,
        input: payload.value,
        ...def.pattern ? { pattern: def.pattern.toString() } : {},
        inst,
        continue: !def.abort
      });
    });
  else
    (_b = inst._zod).check ?? (_b.check = () => {
    });
});
var $ZodCheckRegex = $constructor("$ZodCheckRegex", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    def.pattern.lastIndex = 0;
    if (def.pattern.test(payload.value))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "regex",
      input: payload.value,
      pattern: def.pattern.toString(),
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckLowerCase = $constructor("$ZodCheckLowerCase", (inst, def) => {
  def.pattern ?? (def.pattern = lowercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckUpperCase = $constructor("$ZodCheckUpperCase", (inst, def) => {
  def.pattern ?? (def.pattern = uppercase);
  $ZodCheckStringFormat.init(inst, def);
});
var $ZodCheckIncludes = $constructor("$ZodCheckIncludes", (inst, def) => {
  $ZodCheck.init(inst, def);
  const escapedRegex = escapeRegex(def.includes);
  const pattern = new RegExp(typeof def.position === "number" ? `^.{${def.position}}${escapedRegex}` : escapedRegex);
  def.pattern = pattern;
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.includes(def.includes, def.position))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "includes",
      includes: def.includes,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckStartsWith = $constructor("$ZodCheckStartsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`^${escapeRegex(def.prefix)}.*`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.startsWith(def.prefix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "starts_with",
      prefix: def.prefix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckEndsWith = $constructor("$ZodCheckEndsWith", (inst, def) => {
  $ZodCheck.init(inst, def);
  const pattern = new RegExp(`.*${escapeRegex(def.suffix)}$`);
  def.pattern ?? (def.pattern = pattern);
  inst._zod.onattach.push((inst2) => {
    const bag = inst2._zod.bag;
    bag.patterns ?? (bag.patterns = /* @__PURE__ */ new Set());
    bag.patterns.add(pattern);
  });
  inst._zod.check = (payload) => {
    if (payload.value.endsWith(def.suffix))
      return;
    payload.issues.push({
      origin: "string",
      code: "invalid_format",
      format: "ends_with",
      suffix: def.suffix,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function handleCheckPropertyResult(result, payload, property) {
  if (result.issues.length) {
    payload.issues.push(...prefixIssues(property, result.issues));
  }
}
var $ZodCheckProperty = $constructor("$ZodCheckProperty", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    const result = def.schema._zod.run({
      value: payload.value[def.property],
      issues: []
    }, {});
    if (result instanceof Promise) {
      return result.then((result2) => handleCheckPropertyResult(result2, payload, def.property));
    }
    handleCheckPropertyResult(result, payload, def.property);
    return;
  };
});
var $ZodCheckMimeType = $constructor("$ZodCheckMimeType", (inst, def) => {
  $ZodCheck.init(inst, def);
  const mimeSet = new Set(def.mime);
  inst._zod.onattach.push((inst2) => {
    inst2._zod.bag.mime = def.mime;
  });
  inst._zod.check = (payload) => {
    if (mimeSet.has(payload.value.type))
      return;
    payload.issues.push({
      code: "invalid_value",
      values: def.mime,
      input: payload.value.type,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCheckOverwrite = $constructor("$ZodCheckOverwrite", (inst, def) => {
  $ZodCheck.init(inst, def);
  inst._zod.check = (payload) => {
    payload.value = def.tx(payload.value);
  };
});

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/doc.js
var Doc = class {
  constructor(args = []) {
    this.content = [];
    this.indent = 0;
    if (this)
      this.args = args;
  }
  indented(fn) {
    this.indent += 1;
    fn(this);
    this.indent -= 1;
  }
  write(arg) {
    if (typeof arg === "function") {
      arg(this, { execution: "sync" });
      arg(this, { execution: "async" });
      return;
    }
    const content = arg;
    const lines = content.split("\n").filter((x) => x);
    const minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));
    const dedented = lines.map((x) => x.slice(minIndent)).map((x) => " ".repeat(this.indent * 2) + x);
    for (const line of dedented) {
      this.content.push(line);
    }
  }
  compile() {
    const F = Function;
    const args = this == null ? void 0 : this.args;
    const content = (this == null ? void 0 : this.content) ?? [``];
    const lines = [...content.map((x) => `  ${x}`)];
    return new F(...args, lines.join("\n"));
  }
};

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/versions.js
var version2 = {
  major: 4,
  minor: 3,
  patch: 6
};

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/schemas.js
var $ZodType = $constructor("$ZodType", (inst, def) => {
  var _a4;
  var _a3;
  inst ?? (inst = {});
  inst._zod.def = def;
  inst._zod.bag = inst._zod.bag || {};
  inst._zod.version = version2;
  const checks = [...inst._zod.def.checks ?? []];
  if (inst._zod.traits.has("$ZodCheck")) {
    checks.unshift(inst);
  }
  for (const ch of checks) {
    for (const fn of ch._zod.onattach) {
      fn(inst);
    }
  }
  if (checks.length === 0) {
    (_a3 = inst._zod).deferred ?? (_a3.deferred = []);
    (_a4 = inst._zod.deferred) == null ? void 0 : _a4.push(() => {
      inst._zod.run = inst._zod.parse;
    });
  } else {
    const runChecks = (payload, checks2, ctx) => {
      let isAborted = aborted(payload);
      let asyncResult;
      for (const ch of checks2) {
        if (ch._zod.def.when) {
          const shouldRun = ch._zod.def.when(payload);
          if (!shouldRun)
            continue;
        } else if (isAborted) {
          continue;
        }
        const currLen = payload.issues.length;
        const _ = ch._zod.check(payload);
        if (_ instanceof Promise && (ctx == null ? void 0 : ctx.async) === false) {
          throw new $ZodAsyncError();
        }
        if (asyncResult || _ instanceof Promise) {
          asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {
            await _;
            const nextLen = payload.issues.length;
            if (nextLen === currLen)
              return;
            if (!isAborted)
              isAborted = aborted(payload, currLen);
          });
        } else {
          const nextLen = payload.issues.length;
          if (nextLen === currLen)
            continue;
          if (!isAborted)
            isAborted = aborted(payload, currLen);
        }
      }
      if (asyncResult) {
        return asyncResult.then(() => {
          return payload;
        });
      }
      return payload;
    };
    const handleCanaryResult = (canary, payload, ctx) => {
      if (aborted(canary)) {
        canary.aborted = true;
        return canary;
      }
      const checkResult = runChecks(payload, checks, ctx);
      if (checkResult instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return checkResult.then((checkResult2) => inst._zod.parse(checkResult2, ctx));
      }
      return inst._zod.parse(checkResult, ctx);
    };
    inst._zod.run = (payload, ctx) => {
      if (ctx.skipChecks) {
        return inst._zod.parse(payload, ctx);
      }
      if (ctx.direction === "backward") {
        const canary = inst._zod.parse({ value: payload.value, issues: [] }, { ...ctx, skipChecks: true });
        if (canary instanceof Promise) {
          return canary.then((canary2) => {
            return handleCanaryResult(canary2, payload, ctx);
          });
        }
        return handleCanaryResult(canary, payload, ctx);
      }
      const result = inst._zod.parse(payload, ctx);
      if (result instanceof Promise) {
        if (ctx.async === false)
          throw new $ZodAsyncError();
        return result.then((result2) => runChecks(result2, checks, ctx));
      }
      return runChecks(result, checks, ctx);
    };
  }
  defineLazy(inst, "~standard", () => ({
    validate: (value) => {
      var _a5;
      try {
        const r = safeParse(inst, value);
        return r.success ? { value: r.data } : { issues: (_a5 = r.error) == null ? void 0 : _a5.issues };
      } catch (_) {
        return safeParseAsync(inst, value).then((r) => {
          var _a6;
          return r.success ? { value: r.data } : { issues: (_a6 = r.error) == null ? void 0 : _a6.issues };
        });
      }
    },
    vendor: "zod",
    version: 1
  }));
});
var $ZodString = $constructor("$ZodString", (inst, def) => {
  var _a3;
  $ZodType.init(inst, def);
  inst._zod.pattern = [...((_a3 = inst == null ? void 0 : inst._zod.bag) == null ? void 0 : _a3.patterns) ?? []].pop() ?? string(inst._zod.bag);
  inst._zod.parse = (payload, _) => {
    if (def.coerce)
      try {
        payload.value = String(payload.value);
      } catch (_2) {
      }
    if (typeof payload.value === "string")
      return payload;
    payload.issues.push({
      expected: "string",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodStringFormat = $constructor("$ZodStringFormat", (inst, def) => {
  $ZodCheckStringFormat.init(inst, def);
  $ZodString.init(inst, def);
});
var $ZodGUID = $constructor("$ZodGUID", (inst, def) => {
  def.pattern ?? (def.pattern = guid);
  $ZodStringFormat.init(inst, def);
});
var $ZodUUID = $constructor("$ZodUUID", (inst, def) => {
  if (def.version) {
    const versionMap = {
      v1: 1,
      v2: 2,
      v3: 3,
      v4: 4,
      v5: 5,
      v6: 6,
      v7: 7,
      v8: 8
    };
    const v = versionMap[def.version];
    if (v === void 0)
      throw new Error(`Invalid UUID version: "${def.version}"`);
    def.pattern ?? (def.pattern = uuid(v));
  } else
    def.pattern ?? (def.pattern = uuid());
  $ZodStringFormat.init(inst, def);
});
var $ZodEmail = $constructor("$ZodEmail", (inst, def) => {
  def.pattern ?? (def.pattern = email);
  $ZodStringFormat.init(inst, def);
});
var $ZodURL = $constructor("$ZodURL", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    try {
      const trimmed = payload.value.trim();
      const url2 = new URL(trimmed);
      if (def.hostname) {
        def.hostname.lastIndex = 0;
        if (!def.hostname.test(url2.hostname)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid hostname",
            pattern: def.hostname.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.protocol) {
        def.protocol.lastIndex = 0;
        if (!def.protocol.test(url2.protocol.endsWith(":") ? url2.protocol.slice(0, -1) : url2.protocol)) {
          payload.issues.push({
            code: "invalid_format",
            format: "url",
            note: "Invalid protocol",
            pattern: def.protocol.source,
            input: payload.value,
            inst,
            continue: !def.abort
          });
        }
      }
      if (def.normalize) {
        payload.value = url2.href;
      } else {
        payload.value = trimmed;
      }
      return;
    } catch (_) {
      payload.issues.push({
        code: "invalid_format",
        format: "url",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodEmoji = $constructor("$ZodEmoji", (inst, def) => {
  def.pattern ?? (def.pattern = emoji());
  $ZodStringFormat.init(inst, def);
});
var $ZodNanoID = $constructor("$ZodNanoID", (inst, def) => {
  def.pattern ?? (def.pattern = nanoid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID = $constructor("$ZodCUID", (inst, def) => {
  def.pattern ?? (def.pattern = cuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodCUID2 = $constructor("$ZodCUID2", (inst, def) => {
  def.pattern ?? (def.pattern = cuid2);
  $ZodStringFormat.init(inst, def);
});
var $ZodULID = $constructor("$ZodULID", (inst, def) => {
  def.pattern ?? (def.pattern = ulid);
  $ZodStringFormat.init(inst, def);
});
var $ZodXID = $constructor("$ZodXID", (inst, def) => {
  def.pattern ?? (def.pattern = xid);
  $ZodStringFormat.init(inst, def);
});
var $ZodKSUID = $constructor("$ZodKSUID", (inst, def) => {
  def.pattern ?? (def.pattern = ksuid);
  $ZodStringFormat.init(inst, def);
});
var $ZodISODateTime = $constructor("$ZodISODateTime", (inst, def) => {
  def.pattern ?? (def.pattern = datetime(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODate = $constructor("$ZodISODate", (inst, def) => {
  def.pattern ?? (def.pattern = date);
  $ZodStringFormat.init(inst, def);
});
var $ZodISOTime = $constructor("$ZodISOTime", (inst, def) => {
  def.pattern ?? (def.pattern = time(def));
  $ZodStringFormat.init(inst, def);
});
var $ZodISODuration = $constructor("$ZodISODuration", (inst, def) => {
  def.pattern ?? (def.pattern = duration);
  $ZodStringFormat.init(inst, def);
});
var $ZodIPv4 = $constructor("$ZodIPv4", (inst, def) => {
  def.pattern ?? (def.pattern = ipv4);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv4`;
});
var $ZodIPv6 = $constructor("$ZodIPv6", (inst, def) => {
  def.pattern ?? (def.pattern = ipv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `ipv6`;
  inst._zod.check = (payload) => {
    try {
      new URL(`http://[${payload.value}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "ipv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
var $ZodMAC = $constructor("$ZodMAC", (inst, def) => {
  def.pattern ?? (def.pattern = mac(def.delimiter));
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.format = `mac`;
});
var $ZodCIDRv4 = $constructor("$ZodCIDRv4", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv4);
  $ZodStringFormat.init(inst, def);
});
var $ZodCIDRv6 = $constructor("$ZodCIDRv6", (inst, def) => {
  def.pattern ?? (def.pattern = cidrv6);
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    const parts = payload.value.split("/");
    try {
      if (parts.length !== 2)
        throw new Error();
      const [address, prefix] = parts;
      if (!prefix)
        throw new Error();
      const prefixNum = Number(prefix);
      if (`${prefixNum}` !== prefix)
        throw new Error();
      if (prefixNum < 0 || prefixNum > 128)
        throw new Error();
      new URL(`http://[${address}]`);
    } catch {
      payload.issues.push({
        code: "invalid_format",
        format: "cidrv6",
        input: payload.value,
        inst,
        continue: !def.abort
      });
    }
  };
});
function isValidBase64(data) {
  if (data === "")
    return true;
  if (data.length % 4 !== 0)
    return false;
  try {
    atob(data);
    return true;
  } catch {
    return false;
  }
}
var $ZodBase64 = $constructor("$ZodBase64", (inst, def) => {
  def.pattern ?? (def.pattern = base64);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64";
  inst._zod.check = (payload) => {
    if (isValidBase64(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
function isValidBase64URL(data) {
  if (!base64url.test(data))
    return false;
  const base643 = data.replace(/[-_]/g, (c) => c === "-" ? "+" : "/");
  const padded = base643.padEnd(Math.ceil(base643.length / 4) * 4, "=");
  return isValidBase64(padded);
}
var $ZodBase64URL = $constructor("$ZodBase64URL", (inst, def) => {
  def.pattern ?? (def.pattern = base64url);
  $ZodStringFormat.init(inst, def);
  inst._zod.bag.contentEncoding = "base64url";
  inst._zod.check = (payload) => {
    if (isValidBase64URL(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "base64url",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodE164 = $constructor("$ZodE164", (inst, def) => {
  def.pattern ?? (def.pattern = e164);
  $ZodStringFormat.init(inst, def);
});
function isValidJWT(token, algorithm = null) {
  try {
    const tokensParts = token.split(".");
    if (tokensParts.length !== 3)
      return false;
    const [header] = tokensParts;
    if (!header)
      return false;
    const parsedHeader = JSON.parse(atob(header));
    if ("typ" in parsedHeader && (parsedHeader == null ? void 0 : parsedHeader.typ) !== "JWT")
      return false;
    if (!parsedHeader.alg)
      return false;
    if (algorithm && (!("alg" in parsedHeader) || parsedHeader.alg !== algorithm))
      return false;
    return true;
  } catch {
    return false;
  }
}
var $ZodJWT = $constructor("$ZodJWT", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (isValidJWT(payload.value, def.alg))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: "jwt",
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodCustomStringFormat = $constructor("$ZodCustomStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  inst._zod.check = (payload) => {
    if (def.fn(payload.value))
      return;
    payload.issues.push({
      code: "invalid_format",
      format: def.format,
      input: payload.value,
      inst,
      continue: !def.abort
    });
  };
});
var $ZodNumber = $constructor("$ZodNumber", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = inst._zod.bag.pattern ?? number;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Number(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "number" && !Number.isNaN(input) && Number.isFinite(input)) {
      return payload;
    }
    const received = typeof input === "number" ? Number.isNaN(input) ? "NaN" : !Number.isFinite(input) ? "Infinity" : void 0 : void 0;
    payload.issues.push({
      expected: "number",
      code: "invalid_type",
      input,
      inst,
      ...received ? { received } : {}
    });
    return payload;
  };
});
var $ZodNumberFormat = $constructor("$ZodNumberFormat", (inst, def) => {
  $ZodCheckNumberFormat.init(inst, def);
  $ZodNumber.init(inst, def);
});
var $ZodBoolean = $constructor("$ZodBoolean", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = boolean;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = Boolean(payload.value);
      } catch (_) {
      }
    const input = payload.value;
    if (typeof input === "boolean")
      return payload;
    payload.issues.push({
      expected: "boolean",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodBigInt = $constructor("$ZodBigInt", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = bigint;
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce)
      try {
        payload.value = BigInt(payload.value);
      } catch (_) {
      }
    if (typeof payload.value === "bigint")
      return payload;
    payload.issues.push({
      expected: "bigint",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodBigIntFormat = $constructor("$ZodBigIntFormat", (inst, def) => {
  $ZodCheckBigIntFormat.init(inst, def);
  $ZodBigInt.init(inst, def);
});
var $ZodSymbol = $constructor("$ZodSymbol", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "symbol")
      return payload;
    payload.issues.push({
      expected: "symbol",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodUndefined = $constructor("$ZodUndefined", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _undefined;
  inst._zod.values = /* @__PURE__ */ new Set([void 0]);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "undefined",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodNull = $constructor("$ZodNull", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.pattern = _null;
  inst._zod.values = /* @__PURE__ */ new Set([null]);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input === null)
      return payload;
    payload.issues.push({
      expected: "null",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodAny = $constructor("$ZodAny", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodUnknown = $constructor("$ZodUnknown", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload) => payload;
});
var $ZodNever = $constructor("$ZodNever", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    payload.issues.push({
      expected: "never",
      code: "invalid_type",
      input: payload.value,
      inst
    });
    return payload;
  };
});
var $ZodVoid = $constructor("$ZodVoid", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (typeof input === "undefined")
      return payload;
    payload.issues.push({
      expected: "void",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodDate = $constructor("$ZodDate", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (def.coerce) {
      try {
        payload.value = new Date(payload.value);
      } catch (_err) {
      }
    }
    const input = payload.value;
    const isDate = input instanceof Date;
    const isValidDate = isDate && !Number.isNaN(input.getTime());
    if (isValidDate)
      return payload;
    payload.issues.push({
      expected: "date",
      code: "invalid_type",
      input,
      ...isDate ? { received: "Invalid Date" } : {},
      inst
    });
    return payload;
  };
});
function handleArrayResult(result, final, index3) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index3, result.issues));
  }
  final.value[index3] = result.value;
}
var $ZodArray = $constructor("$ZodArray", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        expected: "array",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = Array(input.length);
    const proms = [];
    for (let i = 0; i < input.length; i++) {
      const item = input[i];
      const result = def.element._zod.run({
        value: item,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleArrayResult(result2, payload, i)));
      } else {
        handleArrayResult(result, payload, i);
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
function handlePropertyResult(result, final, key, input, isOptionalOut) {
  if (result.issues.length) {
    if (isOptionalOut && !(key in input)) {
      return;
    }
    final.issues.push(...prefixIssues(key, result.issues));
  }
  if (result.value === void 0) {
    if (key in input) {
      final.value[key] = void 0;
    }
  } else {
    final.value[key] = result.value;
  }
}
function normalizeDef(def) {
  var _a3, _b, _c, _d;
  const keys = Object.keys(def.shape);
  for (const k of keys) {
    if (!((_d = (_c = (_b = (_a3 = def.shape) == null ? void 0 : _a3[k]) == null ? void 0 : _b._zod) == null ? void 0 : _c.traits) == null ? void 0 : _d.has("$ZodType"))) {
      throw new Error(`Invalid element at key "${k}": expected a Zod schema`);
    }
  }
  const okeys = optionalKeys(def.shape);
  return {
    ...def,
    keys,
    keySet: new Set(keys),
    numKeys: keys.length,
    optionalKeys: new Set(okeys)
  };
}
function handleCatchall(proms, input, payload, ctx, def, inst) {
  const unrecognized = [];
  const keySet = def.keySet;
  const _catchall = def.catchall._zod;
  const t = _catchall.def.type;
  const isOptionalOut = _catchall.optout === "optional";
  for (const key in input) {
    if (keySet.has(key))
      continue;
    if (t === "never") {
      unrecognized.push(key);
      continue;
    }
    const r = _catchall.run({ value: input[key], issues: [] }, ctx);
    if (r instanceof Promise) {
      proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
    } else {
      handlePropertyResult(r, payload, key, input, isOptionalOut);
    }
  }
  if (unrecognized.length) {
    payload.issues.push({
      code: "unrecognized_keys",
      keys: unrecognized,
      input,
      inst
    });
  }
  if (!proms.length)
    return payload;
  return Promise.all(proms).then(() => {
    return payload;
  });
}
var $ZodObject = $constructor("$ZodObject", (inst, def) => {
  $ZodType.init(inst, def);
  const desc = Object.getOwnPropertyDescriptor(def, "shape");
  if (!(desc == null ? void 0 : desc.get)) {
    const sh = def.shape;
    Object.defineProperty(def, "shape", {
      get: () => {
        const newSh = { ...sh };
        Object.defineProperty(def, "shape", {
          value: newSh
        });
        return newSh;
      }
    });
  }
  const _normalized = cached(() => normalizeDef(def));
  defineLazy(inst._zod, "propValues", () => {
    const shape = def.shape;
    const propValues = {};
    for (const key in shape) {
      const field = shape[key]._zod;
      if (field.values) {
        propValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());
        for (const v of field.values)
          propValues[key].add(v);
      }
    }
    return propValues;
  });
  const isObject2 = isObject;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    payload.value = {};
    const proms = [];
    const shape = value.shape;
    for (const key of value.keys) {
      const el = shape[key];
      const isOptionalOut = el._zod.optout === "optional";
      const r = el._zod.run({ value: input[key], issues: [] }, ctx);
      if (r instanceof Promise) {
        proms.push(r.then((r2) => handlePropertyResult(r2, payload, key, input, isOptionalOut)));
      } else {
        handlePropertyResult(r, payload, key, input, isOptionalOut);
      }
    }
    if (!catchall) {
      return proms.length ? Promise.all(proms).then(() => payload) : payload;
    }
    return handleCatchall(proms, input, payload, ctx, _normalized.value, inst);
  };
});
var $ZodObjectJIT = $constructor("$ZodObjectJIT", (inst, def) => {
  $ZodObject.init(inst, def);
  const superParse = inst._zod.parse;
  const _normalized = cached(() => normalizeDef(def));
  const generateFastpass = (shape) => {
    var _a3;
    const doc = new Doc(["shape", "payload", "ctx"]);
    const normalized = _normalized.value;
    const parseStr = (key) => {
      const k = esc(key);
      return `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;
    };
    doc.write(`const input = payload.value;`);
    const ids = /* @__PURE__ */ Object.create(null);
    let counter = 0;
    for (const key of normalized.keys) {
      ids[key] = `key_${counter++}`;
    }
    doc.write(`const newResult = {};`);
    for (const key of normalized.keys) {
      const id = ids[key];
      const k = esc(key);
      const schema = shape[key];
      const isOptionalOut = ((_a3 = schema == null ? void 0 : schema._zod) == null ? void 0 : _a3.optout) === "optional";
      doc.write(`const ${id} = ${parseStr(key)};`);
      if (isOptionalOut) {
        doc.write(`
        if (${id}.issues.length) {
          if (${k} in input) {
            payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
              ...iss,
              path: iss.path ? [${k}, ...iss.path] : [${k}]
            })));
          }
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      } else {
        doc.write(`
        if (${id}.issues.length) {
          payload.issues = payload.issues.concat(${id}.issues.map(iss => ({
            ...iss,
            path: iss.path ? [${k}, ...iss.path] : [${k}]
          })));
        }
        
        if (${id}.value === undefined) {
          if (${k} in input) {
            newResult[${k}] = undefined;
          }
        } else {
          newResult[${k}] = ${id}.value;
        }
        
      `);
      }
    }
    doc.write(`payload.value = newResult;`);
    doc.write(`return payload;`);
    const fn = doc.compile();
    return (payload, ctx) => fn(shape, payload, ctx);
  };
  let fastpass;
  const isObject2 = isObject;
  const jit = !globalConfig.jitless;
  const allowsEval2 = allowsEval;
  const fastEnabled = jit && allowsEval2.value;
  const catchall = def.catchall;
  let value;
  inst._zod.parse = (payload, ctx) => {
    value ?? (value = _normalized.value);
    const input = payload.value;
    if (!isObject2(input)) {
      payload.issues.push({
        expected: "object",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    if (jit && fastEnabled && (ctx == null ? void 0 : ctx.async) === false && ctx.jitless !== true) {
      if (!fastpass)
        fastpass = generateFastpass(def.shape);
      payload = fastpass(payload, ctx);
      if (!catchall)
        return payload;
      return handleCatchall([], input, payload, ctx, value, inst);
    }
    return superParse(payload, ctx);
  };
});
function handleUnionResults(results, final, inst, ctx) {
  for (const result of results) {
    if (result.issues.length === 0) {
      final.value = result.value;
      return final;
    }
  }
  const nonaborted = results.filter((r) => !aborted(r));
  if (nonaborted.length === 1) {
    final.value = nonaborted[0].value;
    return nonaborted[0];
  }
  final.issues.push({
    code: "invalid_union",
    input: final.value,
    inst,
    errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
  });
  return final;
}
var $ZodUnion = $constructor("$ZodUnion", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.options.some((o) => o._zod.optin === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "optout", () => def.options.some((o) => o._zod.optout === "optional") ? "optional" : void 0);
  defineLazy(inst._zod, "values", () => {
    if (def.options.every((o) => o._zod.values)) {
      return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));
    }
    return void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    if (def.options.every((o) => o._zod.pattern)) {
      const patterns = def.options.map((o) => o._zod.pattern);
      return new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join("|")})$`);
    }
    return void 0;
  });
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        if (result.issues.length === 0)
          return result;
        results.push(result);
      }
    }
    if (!async)
      return handleUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleUnionResults(results2, payload, inst, ctx);
    });
  };
});
function handleExclusiveUnionResults(results, final, inst, ctx) {
  const successes = results.filter((r) => r.issues.length === 0);
  if (successes.length === 1) {
    final.value = successes[0].value;
    return final;
  }
  if (successes.length === 0) {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))
    });
  } else {
    final.issues.push({
      code: "invalid_union",
      input: final.value,
      inst,
      errors: [],
      inclusive: false
    });
  }
  return final;
}
var $ZodXor = $constructor("$ZodXor", (inst, def) => {
  $ZodUnion.init(inst, def);
  def.inclusive = false;
  const single = def.options.length === 1;
  const first = def.options[0]._zod.run;
  inst._zod.parse = (payload, ctx) => {
    if (single) {
      return first(payload, ctx);
    }
    let async = false;
    const results = [];
    for (const option of def.options) {
      const result = option._zod.run({
        value: payload.value,
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        results.push(result);
        async = true;
      } else {
        results.push(result);
      }
    }
    if (!async)
      return handleExclusiveUnionResults(results, payload, inst, ctx);
    return Promise.all(results).then((results2) => {
      return handleExclusiveUnionResults(results2, payload, inst, ctx);
    });
  };
});
var $ZodDiscriminatedUnion = $constructor("$ZodDiscriminatedUnion", (inst, def) => {
  def.inclusive = false;
  $ZodUnion.init(inst, def);
  const _super = inst._zod.parse;
  defineLazy(inst._zod, "propValues", () => {
    const propValues = {};
    for (const option of def.options) {
      const pv = option._zod.propValues;
      if (!pv || Object.keys(pv).length === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(option)}"`);
      for (const [k, v] of Object.entries(pv)) {
        if (!propValues[k])
          propValues[k] = /* @__PURE__ */ new Set();
        for (const val of v) {
          propValues[k].add(val);
        }
      }
    }
    return propValues;
  });
  const disc = cached(() => {
    var _a3;
    const opts = def.options;
    const map2 = /* @__PURE__ */ new Map();
    for (const o of opts) {
      const values = (_a3 = o._zod.propValues) == null ? void 0 : _a3[def.discriminator];
      if (!values || values.size === 0)
        throw new Error(`Invalid discriminated union option at index "${def.options.indexOf(o)}"`);
      for (const v of values) {
        if (map2.has(v)) {
          throw new Error(`Duplicate discriminator value "${String(v)}"`);
        }
        map2.set(v, o);
      }
    }
    return map2;
  });
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isObject(input)) {
      payload.issues.push({
        code: "invalid_type",
        expected: "object",
        input,
        inst
      });
      return payload;
    }
    const opt = disc.value.get(input == null ? void 0 : input[def.discriminator]);
    if (opt) {
      return opt._zod.run(payload, ctx);
    }
    if (def.unionFallback) {
      return _super(payload, ctx);
    }
    payload.issues.push({
      code: "invalid_union",
      errors: [],
      note: "No matching discriminator",
      discriminator: def.discriminator,
      input,
      path: [def.discriminator],
      inst
    });
    return payload;
  };
});
var $ZodIntersection = $constructor("$ZodIntersection", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    const left = def.left._zod.run({ value: input, issues: [] }, ctx);
    const right = def.right._zod.run({ value: input, issues: [] }, ctx);
    const async = left instanceof Promise || right instanceof Promise;
    if (async) {
      return Promise.all([left, right]).then(([left2, right2]) => {
        return handleIntersectionResults(payload, left2, right2);
      });
    }
    return handleIntersectionResults(payload, left, right);
  };
});
function mergeValues(a, b) {
  if (a === b) {
    return { valid: true, data: a };
  }
  if (a instanceof Date && b instanceof Date && +a === +b) {
    return { valid: true, data: a };
  }
  if (isPlainObject(a) && isPlainObject(b)) {
    const bKeys = Object.keys(b);
    const sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [key, ...sharedValue.mergeErrorPath]
        };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  }
  if (Array.isArray(a) && Array.isArray(b)) {
    if (a.length !== b.length) {
      return { valid: false, mergeErrorPath: [] };
    }
    const newArray = [];
    for (let index3 = 0; index3 < a.length; index3++) {
      const itemA = a[index3];
      const itemB = b[index3];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return {
          valid: false,
          mergeErrorPath: [index3, ...sharedValue.mergeErrorPath]
        };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  }
  return { valid: false, mergeErrorPath: [] };
}
function handleIntersectionResults(result, left, right) {
  const unrecKeys = /* @__PURE__ */ new Map();
  let unrecIssue;
  for (const iss of left.issues) {
    if (iss.code === "unrecognized_keys") {
      unrecIssue ?? (unrecIssue = iss);
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).l = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  for (const iss of right.issues) {
    if (iss.code === "unrecognized_keys") {
      for (const k of iss.keys) {
        if (!unrecKeys.has(k))
          unrecKeys.set(k, {});
        unrecKeys.get(k).r = true;
      }
    } else {
      result.issues.push(iss);
    }
  }
  const bothKeys = [...unrecKeys].filter(([, f]) => f.l && f.r).map(([k]) => k);
  if (bothKeys.length && unrecIssue) {
    result.issues.push({ ...unrecIssue, keys: bothKeys });
  }
  if (aborted(result))
    return result;
  const merged = mergeValues(left.value, right.value);
  if (!merged.valid) {
    throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);
  }
  result.value = merged.data;
  return result;
}
var $ZodTuple = $constructor("$ZodTuple", (inst, def) => {
  $ZodType.init(inst, def);
  const items = def.items;
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!Array.isArray(input)) {
      payload.issues.push({
        input,
        inst,
        expected: "tuple",
        code: "invalid_type"
      });
      return payload;
    }
    payload.value = [];
    const proms = [];
    const reversedIndex = [...items].reverse().findIndex((item) => item._zod.optin !== "optional");
    const optStart = reversedIndex === -1 ? 0 : items.length - reversedIndex;
    if (!def.rest) {
      const tooBig = input.length > items.length;
      const tooSmall = input.length < optStart - 1;
      if (tooBig || tooSmall) {
        payload.issues.push({
          ...tooBig ? { code: "too_big", maximum: items.length, inclusive: true } : { code: "too_small", minimum: items.length },
          input,
          inst,
          origin: "array"
        });
        return payload;
      }
    }
    let i = -1;
    for (const item of items) {
      i++;
      if (i >= input.length) {
        if (i >= optStart)
          continue;
      }
      const result = item._zod.run({
        value: input[i],
        issues: []
      }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
      } else {
        handleTupleResult(result, payload, i);
      }
    }
    if (def.rest) {
      const rest = input.slice(items.length);
      for (const el of rest) {
        i++;
        const result = def.rest._zod.run({
          value: el,
          issues: []
        }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => handleTupleResult(result2, payload, i)));
        } else {
          handleTupleResult(result, payload, i);
        }
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleTupleResult(result, final, index3) {
  if (result.issues.length) {
    final.issues.push(...prefixIssues(index3, result.issues));
  }
  final.value[index3] = result.value;
}
var $ZodRecord = $constructor("$ZodRecord", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!isPlainObject(input)) {
      payload.issues.push({
        expected: "record",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    const values = def.keyType._zod.values;
    if (values) {
      payload.value = {};
      const recordKeys = /* @__PURE__ */ new Set();
      for (const key of values) {
        if (typeof key === "string" || typeof key === "number" || typeof key === "symbol") {
          recordKeys.add(typeof key === "number" ? key.toString() : key);
          const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
          if (result instanceof Promise) {
            proms.push(result.then((result2) => {
              if (result2.issues.length) {
                payload.issues.push(...prefixIssues(key, result2.issues));
              }
              payload.value[key] = result2.value;
            }));
          } else {
            if (result.issues.length) {
              payload.issues.push(...prefixIssues(key, result.issues));
            }
            payload.value[key] = result.value;
          }
        }
      }
      let unrecognized;
      for (const key in input) {
        if (!recordKeys.has(key)) {
          unrecognized = unrecognized ?? [];
          unrecognized.push(key);
        }
      }
      if (unrecognized && unrecognized.length > 0) {
        payload.issues.push({
          code: "unrecognized_keys",
          input,
          inst,
          keys: unrecognized
        });
      }
    } else {
      payload.value = {};
      for (const key of Reflect.ownKeys(input)) {
        if (key === "__proto__")
          continue;
        let keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
        if (keyResult instanceof Promise) {
          throw new Error("Async schemas not supported in object keys currently");
        }
        const checkNumericKey = typeof key === "string" && number.test(key) && keyResult.issues.length;
        if (checkNumericKey) {
          const retryResult = def.keyType._zod.run({ value: Number(key), issues: [] }, ctx);
          if (retryResult instanceof Promise) {
            throw new Error("Async schemas not supported in object keys currently");
          }
          if (retryResult.issues.length === 0) {
            keyResult = retryResult;
          }
        }
        if (keyResult.issues.length) {
          if (def.mode === "loose") {
            payload.value[key] = input[key];
          } else {
            payload.issues.push({
              code: "invalid_key",
              origin: "record",
              issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config())),
              input: key,
              path: [key],
              inst
            });
          }
          continue;
        }
        const result = def.valueType._zod.run({ value: input[key], issues: [] }, ctx);
        if (result instanceof Promise) {
          proms.push(result.then((result2) => {
            if (result2.issues.length) {
              payload.issues.push(...prefixIssues(key, result2.issues));
            }
            payload.value[keyResult.value] = result2.value;
          }));
        } else {
          if (result.issues.length) {
            payload.issues.push(...prefixIssues(key, result.issues));
          }
          payload.value[keyResult.value] = result.value;
        }
      }
    }
    if (proms.length) {
      return Promise.all(proms).then(() => payload);
    }
    return payload;
  };
});
var $ZodMap = $constructor("$ZodMap", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Map)) {
      payload.issues.push({
        expected: "map",
        code: "invalid_type",
        input,
        inst
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Map();
    for (const [key, value] of input) {
      const keyResult = def.keyType._zod.run({ value: key, issues: [] }, ctx);
      const valueResult = def.valueType._zod.run({ value, issues: [] }, ctx);
      if (keyResult instanceof Promise || valueResult instanceof Promise) {
        proms.push(Promise.all([keyResult, valueResult]).then(([keyResult2, valueResult2]) => {
          handleMapResult(keyResult2, valueResult2, payload, key, input, inst, ctx);
        }));
      } else {
        handleMapResult(keyResult, valueResult, payload, key, input, inst, ctx);
      }
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleMapResult(keyResult, valueResult, final, key, input, inst, ctx) {
  if (keyResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, keyResult.issues));
    } else {
      final.issues.push({
        code: "invalid_key",
        origin: "map",
        input,
        inst,
        issues: keyResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  if (valueResult.issues.length) {
    if (propertyKeyTypes.has(typeof key)) {
      final.issues.push(...prefixIssues(key, valueResult.issues));
    } else {
      final.issues.push({
        origin: "map",
        code: "invalid_element",
        input,
        inst,
        key,
        issues: valueResult.issues.map((iss) => finalizeIssue(iss, ctx, config()))
      });
    }
  }
  final.value.set(keyResult.value, valueResult.value);
}
var $ZodSet = $constructor("$ZodSet", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    const input = payload.value;
    if (!(input instanceof Set)) {
      payload.issues.push({
        input,
        inst,
        expected: "set",
        code: "invalid_type"
      });
      return payload;
    }
    const proms = [];
    payload.value = /* @__PURE__ */ new Set();
    for (const item of input) {
      const result = def.valueType._zod.run({ value: item, issues: [] }, ctx);
      if (result instanceof Promise) {
        proms.push(result.then((result2) => handleSetResult(result2, payload)));
      } else
        handleSetResult(result, payload);
    }
    if (proms.length)
      return Promise.all(proms).then(() => payload);
    return payload;
  };
});
function handleSetResult(result, final) {
  if (result.issues.length) {
    final.issues.push(...result.issues);
  }
  final.value.add(result.value);
}
var $ZodEnum = $constructor("$ZodEnum", (inst, def) => {
  $ZodType.init(inst, def);
  const values = getEnumValues(def.entries);
  const valuesSet = new Set(values);
  inst._zod.values = valuesSet;
  inst._zod.pattern = new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === "string" ? escapeRegex(o) : o.toString()).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (valuesSet.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodLiteral = $constructor("$ZodLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  if (def.values.length === 0) {
    throw new Error("Cannot create literal schema with no valid values");
  }
  const values = new Set(def.values);
  inst._zod.values = values;
  inst._zod.pattern = new RegExp(`^(${def.values.map((o) => typeof o === "string" ? escapeRegex(o) : o ? escapeRegex(o.toString()) : String(o)).join("|")})$`);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (values.has(input)) {
      return payload;
    }
    payload.issues.push({
      code: "invalid_value",
      values: def.values,
      input,
      inst
    });
    return payload;
  };
});
var $ZodFile = $constructor("$ZodFile", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    const input = payload.value;
    if (input instanceof File)
      return payload;
    payload.issues.push({
      expected: "file",
      code: "invalid_type",
      input,
      inst
    });
    return payload;
  };
});
var $ZodTransform = $constructor("$ZodTransform", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    const _out = def.transform(payload.value, payload);
    if (ctx.async) {
      const output = _out instanceof Promise ? _out : Promise.resolve(_out);
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    if (_out instanceof Promise) {
      throw new $ZodAsyncError();
    }
    payload.value = _out;
    return payload;
  };
});
function handleOptionalResult(result, input) {
  if (result.issues.length && input === void 0) {
    return { issues: [], value: void 0 };
  }
  return result;
}
var $ZodOptional = $constructor("$ZodOptional", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  inst._zod.optout = "optional";
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, void 0]) : void 0;
  });
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (def.innerType._zod.optin === "optional") {
      const result = def.innerType._zod.run(payload, ctx);
      if (result instanceof Promise)
        return result.then((r) => handleOptionalResult(r, payload.value));
      return handleOptionalResult(result, payload.value);
    }
    if (payload.value === void 0) {
      return payload;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodExactOptional = $constructor("$ZodExactOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "pattern", () => def.innerType._zod.pattern);
  inst._zod.parse = (payload, ctx) => {
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNullable = $constructor("$ZodNullable", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "pattern", () => {
    const pattern = def.innerType._zod.pattern;
    return pattern ? new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;
  });
  defineLazy(inst._zod, "values", () => {
    return def.innerType._zod.values ? /* @__PURE__ */ new Set([...def.innerType._zod.values, null]) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    if (payload.value === null)
      return payload;
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodDefault = $constructor("$ZodDefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
      return payload;
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleDefaultResult(result2, def));
    }
    return handleDefaultResult(result, def);
  };
});
function handleDefaultResult(payload, def) {
  if (payload.value === void 0) {
    payload.value = def.defaultValue;
  }
  return payload;
}
var $ZodPrefault = $constructor("$ZodPrefault", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.optin = "optional";
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    if (payload.value === void 0) {
      payload.value = def.defaultValue;
    }
    return def.innerType._zod.run(payload, ctx);
  };
});
var $ZodNonOptional = $constructor("$ZodNonOptional", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => {
    const v = def.innerType._zod.values;
    return v ? new Set([...v].filter((x) => x !== void 0)) : void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => handleNonOptionalResult(result2, inst));
    }
    return handleNonOptionalResult(result, inst);
  };
});
function handleNonOptionalResult(payload, inst) {
  if (!payload.issues.length && payload.value === void 0) {
    payload.issues.push({
      code: "invalid_type",
      expected: "nonoptional",
      input: payload.value,
      inst
    });
  }
  return payload;
}
var $ZodSuccess = $constructor("$ZodSuccess", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      throw new $ZodEncodeError("ZodSuccess");
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.issues.length === 0;
        return payload;
      });
    }
    payload.value = result.issues.length === 0;
    return payload;
  };
});
var $ZodCatch = $constructor("$ZodCatch", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "optin", () => def.innerType._zod.optin);
  defineLazy(inst._zod, "optout", () => def.innerType._zod.optout);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then((result2) => {
        payload.value = result2.value;
        if (result2.issues.length) {
          payload.value = def.catchValue({
            ...payload,
            error: {
              issues: result2.issues.map((iss) => finalizeIssue(iss, ctx, config()))
            },
            input: payload.value
          });
          payload.issues = [];
        }
        return payload;
      });
    }
    payload.value = result.value;
    if (result.issues.length) {
      payload.value = def.catchValue({
        ...payload,
        error: {
          issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config()))
        },
        input: payload.value
      });
      payload.issues = [];
    }
    return payload;
  };
});
var $ZodNaN = $constructor("$ZodNaN", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "number" || !Number.isNaN(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "nan",
        code: "invalid_type"
      });
      return payload;
    }
    return payload;
  };
});
var $ZodPipe = $constructor("$ZodPipe", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handlePipeResult(right2, def.in, ctx));
      }
      return handlePipeResult(right, def.in, ctx);
    }
    const left = def.in._zod.run(payload, ctx);
    if (left instanceof Promise) {
      return left.then((left2) => handlePipeResult(left2, def.out, ctx));
    }
    return handlePipeResult(left, def.out, ctx);
  };
});
function handlePipeResult(left, next, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return next._zod.run({ value: left.value, issues: left.issues }, ctx);
}
var $ZodCodec = $constructor("$ZodCodec", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "values", () => def.in._zod.values);
  defineLazy(inst._zod, "optin", () => def.in._zod.optin);
  defineLazy(inst._zod, "optout", () => def.out._zod.optout);
  defineLazy(inst._zod, "propValues", () => def.in._zod.propValues);
  inst._zod.parse = (payload, ctx) => {
    const direction = ctx.direction || "forward";
    if (direction === "forward") {
      const left = def.in._zod.run(payload, ctx);
      if (left instanceof Promise) {
        return left.then((left2) => handleCodecAResult(left2, def, ctx));
      }
      return handleCodecAResult(left, def, ctx);
    } else {
      const right = def.out._zod.run(payload, ctx);
      if (right instanceof Promise) {
        return right.then((right2) => handleCodecAResult(right2, def, ctx));
      }
      return handleCodecAResult(right, def, ctx);
    }
  };
});
function handleCodecAResult(result, def, ctx) {
  if (result.issues.length) {
    result.aborted = true;
    return result;
  }
  const direction = ctx.direction || "forward";
  if (direction === "forward") {
    const transformed = def.transform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.out, ctx));
    }
    return handleCodecTxResult(result, transformed, def.out, ctx);
  } else {
    const transformed = def.reverseTransform(result.value, result);
    if (transformed instanceof Promise) {
      return transformed.then((value) => handleCodecTxResult(result, value, def.in, ctx));
    }
    return handleCodecTxResult(result, transformed, def.in, ctx);
  }
}
function handleCodecTxResult(left, value, nextSchema, ctx) {
  if (left.issues.length) {
    left.aborted = true;
    return left;
  }
  return nextSchema._zod.run({ value, issues: left.issues }, ctx);
}
var $ZodReadonly = $constructor("$ZodReadonly", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "propValues", () => def.innerType._zod.propValues);
  defineLazy(inst._zod, "values", () => def.innerType._zod.values);
  defineLazy(inst._zod, "optin", () => {
    var _a3, _b;
    return (_b = (_a3 = def.innerType) == null ? void 0 : _a3._zod) == null ? void 0 : _b.optin;
  });
  defineLazy(inst._zod, "optout", () => {
    var _a3, _b;
    return (_b = (_a3 = def.innerType) == null ? void 0 : _a3._zod) == null ? void 0 : _b.optout;
  });
  inst._zod.parse = (payload, ctx) => {
    if (ctx.direction === "backward") {
      return def.innerType._zod.run(payload, ctx);
    }
    const result = def.innerType._zod.run(payload, ctx);
    if (result instanceof Promise) {
      return result.then(handleReadonlyResult);
    }
    return handleReadonlyResult(result);
  };
});
function handleReadonlyResult(payload) {
  payload.value = Object.freeze(payload.value);
  return payload;
}
var $ZodTemplateLiteral = $constructor("$ZodTemplateLiteral", (inst, def) => {
  $ZodType.init(inst, def);
  const regexParts = [];
  for (const part of def.parts) {
    if (typeof part === "object" && part !== null) {
      if (!part._zod.pattern) {
        throw new Error(`Invalid template literal part, no pattern found: ${[...part._zod.traits].shift()}`);
      }
      const source = part._zod.pattern instanceof RegExp ? part._zod.pattern.source : part._zod.pattern;
      if (!source)
        throw new Error(`Invalid template literal part: ${part._zod.traits}`);
      const start = source.startsWith("^") ? 1 : 0;
      const end = source.endsWith("$") ? source.length - 1 : source.length;
      regexParts.push(source.slice(start, end));
    } else if (part === null || primitiveTypes.has(typeof part)) {
      regexParts.push(escapeRegex(`${part}`));
    } else {
      throw new Error(`Invalid template literal part: ${part}`);
    }
  }
  inst._zod.pattern = new RegExp(`^${regexParts.join("")}$`);
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "string") {
      payload.issues.push({
        input: payload.value,
        inst,
        expected: "string",
        code: "invalid_type"
      });
      return payload;
    }
    inst._zod.pattern.lastIndex = 0;
    if (!inst._zod.pattern.test(payload.value)) {
      payload.issues.push({
        input: payload.value,
        inst,
        code: "invalid_format",
        format: def.format ?? "template_literal",
        pattern: inst._zod.pattern.source
      });
      return payload;
    }
    return payload;
  };
});
var $ZodFunction = $constructor("$ZodFunction", (inst, def) => {
  $ZodType.init(inst, def);
  inst._def = def;
  inst._zod.def = def;
  inst.implement = (func) => {
    if (typeof func !== "function") {
      throw new Error("implement() must be called with a function");
    }
    return function(...args) {
      const parsedArgs = inst._def.input ? parse(inst._def.input, args) : args;
      const result = Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return parse(inst._def.output, result);
      }
      return result;
    };
  };
  inst.implementAsync = (func) => {
    if (typeof func !== "function") {
      throw new Error("implementAsync() must be called with a function");
    }
    return async function(...args) {
      const parsedArgs = inst._def.input ? await parseAsync(inst._def.input, args) : args;
      const result = await Reflect.apply(func, this, parsedArgs);
      if (inst._def.output) {
        return await parseAsync(inst._def.output, result);
      }
      return result;
    };
  };
  inst._zod.parse = (payload, _ctx) => {
    if (typeof payload.value !== "function") {
      payload.issues.push({
        code: "invalid_type",
        expected: "function",
        input: payload.value,
        inst
      });
      return payload;
    }
    const hasPromiseOutput = inst._def.output && inst._def.output._zod.def.type === "promise";
    if (hasPromiseOutput) {
      payload.value = inst.implementAsync(payload.value);
    } else {
      payload.value = inst.implement(payload.value);
    }
    return payload;
  };
  inst.input = (...args) => {
    const F = inst.constructor;
    if (Array.isArray(args[0])) {
      return new F({
        type: "function",
        input: new $ZodTuple({
          type: "tuple",
          items: args[0],
          rest: args[1]
        }),
        output: inst._def.output
      });
    }
    return new F({
      type: "function",
      input: args[0],
      output: inst._def.output
    });
  };
  inst.output = (output) => {
    const F = inst.constructor;
    return new F({
      type: "function",
      input: inst._def.input,
      output
    });
  };
  return inst;
});
var $ZodPromise = $constructor("$ZodPromise", (inst, def) => {
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, ctx) => {
    return Promise.resolve(payload.value).then((inner) => def.innerType._zod.run({ value: inner, issues: [] }, ctx));
  };
});
var $ZodLazy = $constructor("$ZodLazy", (inst, def) => {
  $ZodType.init(inst, def);
  defineLazy(inst._zod, "innerType", () => def.getter());
  defineLazy(inst._zod, "pattern", () => {
    var _a3, _b;
    return (_b = (_a3 = inst._zod.innerType) == null ? void 0 : _a3._zod) == null ? void 0 : _b.pattern;
  });
  defineLazy(inst._zod, "propValues", () => {
    var _a3, _b;
    return (_b = (_a3 = inst._zod.innerType) == null ? void 0 : _a3._zod) == null ? void 0 : _b.propValues;
  });
  defineLazy(inst._zod, "optin", () => {
    var _a3, _b;
    return ((_b = (_a3 = inst._zod.innerType) == null ? void 0 : _a3._zod) == null ? void 0 : _b.optin) ?? void 0;
  });
  defineLazy(inst._zod, "optout", () => {
    var _a3, _b;
    return ((_b = (_a3 = inst._zod.innerType) == null ? void 0 : _a3._zod) == null ? void 0 : _b.optout) ?? void 0;
  });
  inst._zod.parse = (payload, ctx) => {
    const inner = inst._zod.innerType;
    return inner._zod.run(payload, ctx);
  };
});
var $ZodCustom = $constructor("$ZodCustom", (inst, def) => {
  $ZodCheck.init(inst, def);
  $ZodType.init(inst, def);
  inst._zod.parse = (payload, _) => {
    return payload;
  };
  inst._zod.check = (payload) => {
    const input = payload.value;
    const r = def.fn(input);
    if (r instanceof Promise) {
      return r.then((r2) => handleRefineResult(r2, payload, input, inst));
    }
    handleRefineResult(r, payload, input, inst);
    return;
  };
});
function handleRefineResult(result, payload, input, inst) {
  if (!result) {
    const _iss = {
      code: "custom",
      input,
      inst,
      // incorporates params.error into issue reporting
      path: [...inst._zod.def.path ?? []],
      // incorporates params.error into issue reporting
      continue: !inst._zod.def.abort
      // params: inst._zod.def.params,
    };
    if (inst._zod.def.params)
      _iss.params = inst._zod.def.params;
    payload.issues.push(issue(_iss));
  }
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/index.js
var locales_exports = {};
__export(locales_exports, {
  ar: () => ar_default,
  az: () => az_default,
  be: () => be_default,
  bg: () => bg_default,
  ca: () => ca_default,
  cs: () => cs_default,
  da: () => da_default,
  de: () => de_default,
  en: () => en_default,
  eo: () => eo_default,
  es: () => es_default,
  fa: () => fa_default,
  fi: () => fi_default,
  fr: () => fr_default,
  frCA: () => fr_CA_default,
  he: () => he_default,
  hu: () => hu_default,
  hy: () => hy_default,
  id: () => id_default,
  is: () => is_default,
  it: () => it_default,
  ja: () => ja_default,
  ka: () => ka_default,
  kh: () => kh_default,
  km: () => km_default,
  ko: () => ko_default,
  lt: () => lt_default,
  mk: () => mk_default,
  ms: () => ms_default,
  nl: () => nl_default,
  no: () => no_default,
  ota: () => ota_default,
  pl: () => pl_default,
  ps: () => ps_default,
  pt: () => pt_default,
  ru: () => ru_default,
  sl: () => sl_default,
  sv: () => sv_default,
  ta: () => ta_default,
  th: () => th_default,
  tr: () => tr_default,
  ua: () => ua_default,
  uk: () => uk_default,
  ur: () => ur_default,
  uz: () => uz_default,
  vi: () => vi_default,
  yo: () => yo_default,
  zhCN: () => zh_CN_default,
  zhTW: () => zh_TW_default
});

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ar.js
var error = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: "  ISO",
    time: "  ISO",
    duration: "  ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: "   IPv4",
    cidrv6: "   IPv6",
    base64: "  base64-encoded",
    base64url: "  base64url-encoded",
    json_string: "   JSON",
    e164: "   E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  :   instanceof ${issue2.expected}    ${received}`;
        }
        return `  :   ${expected}    ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :   ${stringifyPrimitive(issue2.values[0])}`;
        return `  :     : ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `   :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  :    ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  :   ${issue2.origin}   ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `  :     "${issue2.prefix}"`;
        if (_issue.format === "ends_with")
          return `  :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  :     ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return `  :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `    ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `    ${issue2.origin}`;
      default:
        return "  ";
    }
  };
};
function ar_default() {
  return {
    localeError: error()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/az.js
var error2 = () => {
  const Sizable = {
    string: { unit: "simvol", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "element", verb: "olmaldr" },
    set: { unit: "element", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Yanl dyr: gzlniln instanceof ${issue2.expected}, daxil olan ${received}`;
        }
        return `Yanl dyr: gzlniln ${expected}, daxil olan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Yanl dyr: gzlniln ${stringifyPrimitive(issue2.values[0])}`;
        return `Yanl seim: aadaklardan biri olmaldr: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        return `ox byk: gzlniln ${issue2.origin ?? "dyr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ox kiik: gzlniln ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Yanl mtn: "${_issue.prefix}" il balamaldr`;
        if (_issue.format === "ends_with")
          return `Yanl mtn: "${_issue.suffix}" il bitmlidir`;
        if (_issue.format === "includes")
          return `Yanl mtn: "${_issue.includes}" daxil olmaldr`;
        if (_issue.format === "regex")
          return `Yanl mtn: ${_issue.pattern} ablonuna uyun olmaldr`;
        return `Yanl ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Yanl dd: ${issue2.divisor} il bln biln olmaldr`;
      case "unrecognized_keys":
        return `Tannmayan aar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} daxilind yanl aar`;
      case "invalid_union":
        return "Yanl dyr";
      case "invalid_element":
        return `${issue2.origin} daxilind yanl dyr`;
      default:
        return `Yanl dyr`;
    }
  };
};
function az_default() {
  return {
    localeError: error2()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/be.js
function getBelarusianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error3 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getBelarusianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin ?? ""}  ${sizing.verb} ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getBelarusianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return ` : ,  ${issue2.origin}  ${sizing.verb} ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return ` : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function be_default() {
  return {
    localeError: error3()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/bg.js
var error4 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :     ${_issue.pattern}`;
        let invalid_adj = "";
        if (_issue.format === "emoji")
          invalid_adj = "";
        if (_issue.format === "datetime")
          invalid_adj = "";
        if (_issue.format === "date")
          invalid_adj = "";
        if (_issue.format === "time")
          invalid_adj = "";
        if (_issue.format === "duration")
          invalid_adj = "";
        return `${invalid_adj} ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function bg_default() {
  return {
    localeError: error4()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ca.js
var error5 = () => {
  const Sizable = {
    string: { unit: "carcters", verb: "contenir" },
    file: { unit: "bytes", verb: "contenir" },
    array: { unit: "elements", verb: "contenir" },
    set: { unit: "elements", verb: "contenir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "adrea electrnica",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durada ISO",
    ipv4: "adrea IPv4",
    ipv6: "adrea IPv6",
    cidrv4: "rang IPv4",
    cidrv6: "rang IPv6",
    base64: "cadena codificada en base64",
    base64url: "cadena codificada en base64url",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipus invlid: s'esperava instanceof ${issue2.expected}, s'ha rebut ${received}`;
        }
        return `Tipus invlid: s'esperava ${expected}, s'ha rebut ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Valor invlid: s'esperava ${stringifyPrimitive(issue2.values[0])}`;
        return `Opci invlida: s'esperava una de ${joinValues(issue2.values, " o ")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "com a mxim" : "menys de";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} contingus ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Massa gran: s'esperava que ${issue2.origin ?? "el valor"} fos ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "com a mnim" : "ms de";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Massa petit: s'esperava que ${issue2.origin} contingus ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Massa petit: s'esperava que ${issue2.origin} fos ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Format invlid: ha de comenar amb "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Format invlid: ha d'acabar amb "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Format invlid: ha d'incloure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Format invlid: ha de coincidir amb el patr ${_issue.pattern}`;
        return `Format invlid per a ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlid: ha de ser mltiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Clau${issue2.keys.length > 1 ? "s" : ""} no reconeguda${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Clau invlida a ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Element invlid a ${issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function ca_default() {
  return {
    localeError: error5()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/cs.js
var error6 = () => {
  const Sizable = {
    string: { unit: "znak", verb: "mt" },
    file: { unit: "bajt", verb: "mt" },
    array: { unit: "prvk", verb: "mt" },
    set: { unit: "prvk", verb: "mt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "regulrn vraz",
    email: "e-mailov adresa",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "datum a as ve formtu ISO",
    date: "datum ve formtu ISO",
    time: "as ve formtu ISO",
    duration: "doba trvn ISO",
    ipv4: "IPv4 adresa",
    ipv6: "IPv6 adresa",
    cidrv4: "rozsah IPv4",
    cidrv6: "rozsah IPv6",
    base64: "etzec zakdovan ve formtu base64",
    base64url: "etzec zakdovan ve formtu base64url",
    json_string: "etzec ve formtu JSON",
    e164: "slo E.164",
    jwt: "JWT",
    template_literal: "vstup"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "slo",
    string: "etzec",
    function: "funkce",
    array: "pole"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neplatn vstup: oekvno instanceof ${issue2.expected}, obdreno ${received}`;
        }
        return `Neplatn vstup: oekvno ${expected}, obdreno ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neplatn vstup: oekvno ${stringifyPrimitive(issue2.values[0])}`;
        return `Neplatn monost: oekvna jedna z hodnot ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli velk: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus mt ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "prvk"}`;
        }
        return `Hodnota je pli mal: ${issue2.origin ?? "hodnota"} mus bt ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Neplatn etzec: mus zanat na "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Neplatn etzec: mus konit na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neplatn etzec: mus obsahovat "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neplatn etzec: mus odpovdat vzoru ${_issue.pattern}`;
        return `Neplatn formt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neplatn slo: mus bt nsobkem ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neznm kle: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neplatn kl v ${issue2.origin}`;
      case "invalid_union":
        return "Neplatn vstup";
      case "invalid_element":
        return `Neplatn hodnota v ${issue2.origin}`;
      default:
        return `Neplatn vstup`;
    }
  };
};
function cs_default() {
  return {
    localeError: error6()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/da.js
var error7 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: "havde" },
    file: { unit: "bytes", verb: "havde" },
    array: { unit: "elementer", verb: "indeholdt" },
    set: { unit: "elementer", verb: "indeholdt" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-mailadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslt",
    date: "ISO-dato",
    time: "ISO-klokkeslt",
    duration: "ISO-varighed",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodet streng",
    base64url: "base64url-kodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "streng",
    number: "tal",
    boolean: "boolean",
    array: "liste",
    object: "objekt",
    set: "st",
    file: "fil"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldigt input: forventede instanceof ${issue2.expected}, fik ${received}`;
        }
        return `Ugyldigt input: forventede ${expected}, fik ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig vrdi: forventede ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldigt valg: forventede en af flgende ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `For stor: forventede ${origin ?? "value"} ${sizing.verb} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor: forventede ${origin ?? "value"} havde ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `For lille: forventede ${origin} ${sizing.verb} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lille: forventede ${origin} havde ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: skal starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: skal ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: skal indeholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: skal matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldigt tal: skal vre deleligt med ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukendte ngler" : "Ukendt ngle"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig ngle i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldigt input: matcher ingen af de tilladte typer";
      case "invalid_element":
        return `Ugyldig vrdi i ${issue2.origin}`;
      default:
        return `Ugyldigt input`;
    }
  };
};
function da_default() {
  return {
    localeError: error7()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/de.js
var error8 = () => {
  const Sizable = {
    string: { unit: "Zeichen", verb: "zu haben" },
    file: { unit: "Bytes", verb: "zu haben" },
    array: { unit: "Elemente", verb: "zu haben" },
    set: { unit: "Elemente", verb: "zu haben" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "Eingabe",
    email: "E-Mail-Adresse",
    url: "URL",
    emoji: "Emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-Datum und -Uhrzeit",
    date: "ISO-Datum",
    time: "ISO-Uhrzeit",
    duration: "ISO-Dauer",
    ipv4: "IPv4-Adresse",
    ipv6: "IPv6-Adresse",
    cidrv4: "IPv4-Bereich",
    cidrv6: "IPv6-Bereich",
    base64: "Base64-codierter String",
    base64url: "Base64-URL-codierter String",
    json_string: "JSON-String",
    e164: "E.164-Nummer",
    jwt: "JWT",
    template_literal: "Eingabe"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "Zahl",
    array: "Array"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ungltige Eingabe: erwartet instanceof ${issue2.expected}, erhalten ${received}`;
        }
        return `Ungltige Eingabe: erwartet ${expected}, erhalten ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ungltige Eingabe: erwartet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ungltige Option: erwartet eine von ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "Elemente"} hat`;
        return `Zu gro: erwartet, dass ${issue2.origin ?? "Wert"} ${adj}${issue2.maximum.toString()} ist`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} hat`;
        }
        return `Zu klein: erwartet, dass ${issue2.origin} ${adj}${issue2.minimum.toString()} ist`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ungltiger String: muss mit "${_issue.prefix}" beginnen`;
        if (_issue.format === "ends_with")
          return `Ungltiger String: muss mit "${_issue.suffix}" enden`;
        if (_issue.format === "includes")
          return `Ungltiger String: muss "${_issue.includes}" enthalten`;
        if (_issue.format === "regex")
          return `Ungltiger String: muss dem Muster ${_issue.pattern} entsprechen`;
        return `Ungltig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ungltige Zahl: muss ein Vielfaches von ${issue2.divisor} sein`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Unbekannte Schlssel" : "Unbekannter Schlssel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ungltiger Schlssel in ${issue2.origin}`;
      case "invalid_union":
        return "Ungltige Eingabe";
      case "invalid_element":
        return `Ungltiger Wert in ${issue2.origin}`;
      default:
        return `Ungltige Eingabe`;
    }
  };
};
function de_default() {
  return {
    localeError: error8()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/en.js
var error9 = () => {
  const Sizable = {
    string: { unit: "characters", verb: "to have" },
    file: { unit: "bytes", verb: "to have" },
    array: { unit: "items", verb: "to have" },
    set: { unit: "items", verb: "to have" },
    map: { unit: "entries", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "email address",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datetime",
    date: "ISO date",
    time: "ISO time",
    duration: "ISO duration",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    mac: "MAC address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded string",
    base64url: "base64url-encoded string",
    json_string: "JSON string",
    e164: "E.164 number",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    // Compatibility: "nan" -> "NaN" for display
    nan: "NaN"
    // All other type names omitted - they fall back to raw values via ?? operator
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        return `Invalid input: expected ${expected}, received ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return `Invalid option: expected one of ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Too big: expected ${issue2.origin ?? "value"} to have ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"}`;
        return `Too big: expected ${issue2.origin ?? "value"} to be ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Too small: expected ${issue2.origin} to have ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Too small: expected ${issue2.origin} to be ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Invalid string: must start with "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Invalid string: must end with "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Invalid string: must include "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Invalid string: must match pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Invalid number: must be a multiple of ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Unrecognized key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Invalid key in ${issue2.origin}`;
      case "invalid_union":
        return "Invalid input";
      case "invalid_element":
        return `Invalid value in ${issue2.origin}`;
      default:
        return `Invalid input`;
    }
  };
};
function en_default() {
  return {
    localeError: error9()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/eo.js
var error10 = () => {
  const Sizable = {
    string: { unit: "karaktrojn", verb: "havi" },
    file: { unit: "bajtojn", verb: "havi" },
    array: { unit: "elementojn", verb: "havi" },
    set: { unit: "elementojn", verb: "havi" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "enigo",
    email: "retadreso",
    url: "URL",
    emoji: "emoio",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datotempo",
    date: "ISO-dato",
    time: "ISO-tempo",
    duration: "ISO-daro",
    ipv4: "IPv4-adreso",
    ipv6: "IPv6-adreso",
    cidrv4: "IPv4-rango",
    cidrv6: "IPv6-rango",
    base64: "64-ume kodita karaktraro",
    base64url: "URL-64-ume kodita karaktraro",
    json_string: "JSON-karaktraro",
    e164: "E.164-nombro",
    jwt: "JWT",
    template_literal: "enigo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombro",
    array: "tabelo",
    null: "senvalora"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nevalida enigo: atendiis instanceof ${issue2.expected}, riceviis ${received}`;
        }
        return `Nevalida enigo: atendiis ${expected}, riceviis ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nevalida enigo: atendiis ${stringifyPrimitive(issue2.values[0])}`;
        return `Nevalida opcio: atendiis unu el ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementojn"}`;
        return `Tro granda: atendiis ke ${issue2.origin ?? "valoro"} havu ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tro malgranda: atendiis ke ${issue2.origin} havu ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tro malgranda: atendiis ke ${issue2.origin} estu ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nevalida karaktraro: devas komencii per "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nevalida karaktraro: devas finii per "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nevalida karaktraro: devas inkluzivi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nevalida karaktraro: devas kongrui kun la modelo ${_issue.pattern}`;
        return `Nevalida ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nevalida nombro: devas esti oblo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nekonata${issue2.keys.length > 1 ? "j" : ""} losilo${issue2.keys.length > 1 ? "j" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nevalida losilo en ${issue2.origin}`;
      case "invalid_union":
        return "Nevalida enigo";
      case "invalid_element":
        return `Nevalida valoro en ${issue2.origin}`;
      default:
        return `Nevalida enigo`;
    }
  };
};
function eo_default() {
  return {
    localeError: error10()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/es.js
var error11 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "tener" },
    file: { unit: "bytes", verb: "tener" },
    array: { unit: "elementos", verb: "tener" },
    set: { unit: "elementos", verb: "tener" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entrada",
    email: "direccin de correo electrnico",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "fecha y hora ISO",
    date: "fecha ISO",
    time: "hora ISO",
    duration: "duracin ISO",
    ipv4: "direccin IPv4",
    ipv6: "direccin IPv6",
    cidrv4: "rango IPv4",
    cidrv6: "rango IPv6",
    base64: "cadena codificada en base64",
    base64url: "URL codificada en base64",
    json_string: "cadena JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    string: "texto",
    number: "nmero",
    boolean: "booleano",
    array: "arreglo",
    object: "objeto",
    set: "conjunto",
    file: "archivo",
    date: "fecha",
    bigint: "nmero grande",
    symbol: "smbolo",
    undefined: "indefinido",
    null: "nulo",
    function: "funcin",
    map: "mapa",
    record: "registro",
    tuple: "tupla",
    enum: "enumeracin",
    union: "unin",
    literal: "literal",
    promise: "promesa",
    void: "vaco",
    never: "nunca",
    unknown: "desconocido",
    any: "cualquiera"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entrada invlida: se esperaba instanceof ${issue2.expected}, recibido ${received}`;
        }
        return `Entrada invlida: se esperaba ${expected}, recibido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: se esperaba ${stringifyPrimitive(issue2.values[0])}`;
        return `Opcin invlida: se esperaba una de ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing)
          return `Demasiado grande: se esperaba que ${origin ?? "valor"} tuviera ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Demasiado grande: se esperaba que ${origin ?? "valor"} fuera ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        if (sizing) {
          return `Demasiado pequeo: se esperaba que ${origin} tuviera ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Demasiado pequeo: se esperaba que ${origin} fuera ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Cadena invlida: debe comenzar con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Cadena invlida: debe terminar en "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Cadena invlida: debe incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Cadena invlida: debe coincidir con el patrn ${_issue.pattern}`;
        return `Invlido ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmero invlido: debe ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Llave${issue2.keys.length > 1 ? "s" : ""} desconocida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Llave invlida en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido en ${TypeDictionary[issue2.origin] ?? issue2.origin}`;
      default:
        return `Entrada invlida`;
    }
  };
};
function es_default() {
  return {
    localeError: error11()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/fa.js
var error12 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ",
    date: " ",
    time: " ",
    duration: "  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected}  ${received}  `;
        }
        return ` :  ${expected}  ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")} `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"  `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"  `;
        }
        if (_issue.format === "includes") {
          return ` :   "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :    ${_issue.pattern}   `;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format} `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function fa_default() {
  return {
    localeError: error12()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/fi.js
var error13 = () => {
  const Sizable = {
    string: { unit: "merkki", subject: "merkkijonon" },
    file: { unit: "tavua", subject: "tiedoston" },
    array: { unit: "alkiota", subject: "listan" },
    set: { unit: "alkiota", subject: "joukon" },
    number: { unit: "", subject: "luvun" },
    bigint: { unit: "", subject: "suuren kokonaisluvun" },
    int: { unit: "", subject: "kokonaisluvun" },
    date: { unit: "", subject: "pivmrn" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "snnllinen lauseke",
    email: "shkpostiosoite",
    url: "URL-osoite",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-aikaleima",
    date: "ISO-pivmr",
    time: "ISO-aika",
    duration: "ISO-kesto",
    ipv4: "IPv4-osoite",
    ipv6: "IPv6-osoite",
    cidrv4: "IPv4-alue",
    cidrv6: "IPv6-alue",
    base64: "base64-koodattu merkkijono",
    base64url: "base64url-koodattu merkkijono",
    json_string: "JSON-merkkijono",
    e164: "E.164-luku",
    jwt: "JWT",
    template_literal: "templaattimerkkijono"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Virheellinen tyyppi: odotettiin instanceof ${issue2.expected}, oli ${received}`;
        }
        return `Virheellinen tyyppi: odotettiin ${expected}, oli ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Virheellinen syte: tytyy olla ${stringifyPrimitive(issue2.values[0])}`;
        return `Virheellinen valinta: tytyy olla yksi seuraavista: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian suuri: ${sizing.subject} tytyy olla ${adj}${issue2.maximum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian suuri: arvon tytyy olla ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Liian pieni: ${sizing.subject} tytyy olla ${adj}${issue2.minimum.toString()} ${sizing.unit}`.trim();
        }
        return `Liian pieni: arvon tytyy olla ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Virheellinen syte: tytyy alkaa "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Virheellinen syte: tytyy loppua "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Virheellinen syte: tytyy sislt "${_issue.includes}"`;
        if (_issue.format === "regex") {
          return `Virheellinen syte: tytyy vastata snnllist lauseketta ${_issue.pattern}`;
        }
        return `Virheellinen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Virheellinen luku: tytyy olla luvun ${issue2.divisor} monikerta`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Tuntemattomat avaimet" : "Tuntematon avain"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Virheellinen avain tietueessa";
      case "invalid_union":
        return "Virheellinen unioni";
      case "invalid_element":
        return "Virheellinen arvo joukossa";
      default:
        return `Virheellinen syte`;
    }
  };
};
function fi_default() {
  return {
    localeError: error13()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/fr.js
var error14 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entre",
    email: "adresse e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date et heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombre",
    array: "tableau"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entre invalide : instanceof ${issue2.expected} attendu, ${received} reu`;
        }
        return `Entre invalide : ${expected} attendu, ${received} reu`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : ${stringifyPrimitive(issue2.values[0])} attendu`;
        return `Option invalide : une valeur parmi ${joinValues(issue2.values, "|")} attendue`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : ${issue2.origin ?? "valeur"} doit ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "lment(s)"}`;
        return `Trop grand : ${issue2.origin ?? "valeur"} doit tre ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : ${issue2.origin} doit ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : ${issue2.origin} doit tre ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au modle ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_default() {
  return {
    localeError: error14()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/fr-CA.js
var error15 = () => {
  const Sizable = {
    string: { unit: "caractres", verb: "avoir" },
    file: { unit: "octets", verb: "avoir" },
    array: { unit: "lments", verb: "avoir" },
    set: { unit: "lments", verb: "avoir" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "entre",
    email: "adresse courriel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "date-heure ISO",
    date: "date ISO",
    time: "heure ISO",
    duration: "dure ISO",
    ipv4: "adresse IPv4",
    ipv6: "adresse IPv6",
    cidrv4: "plage IPv4",
    cidrv6: "plage IPv6",
    base64: "chane encode en base64",
    base64url: "chane encode en base64url",
    json_string: "chane JSON",
    e164: "numro E.164",
    jwt: "JWT",
    template_literal: "entre"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Entre invalide : attendu instanceof ${issue2.expected}, reu ${received}`;
        }
        return `Entre invalide : attendu ${expected}, reu ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entre invalide : attendu ${stringifyPrimitive(issue2.values[0])}`;
        return `Option invalide : attendu l'une des valeurs suivantes ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} ait ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return `Trop grand : attendu que ${issue2.origin ?? "la valeur"} soit ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Trop petit : attendu que ${issue2.origin} ait ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Trop petit : attendu que ${issue2.origin} soit ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Chane invalide : doit commencer par "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Chane invalide : doit se terminer par "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chane invalide : doit inclure "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chane invalide : doit correspondre au motif ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invalide`;
      }
      case "not_multiple_of":
        return `Nombre invalide : doit tre un multiple de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Cl${issue2.keys.length > 1 ? "s" : ""} non reconnue${issue2.keys.length > 1 ? "s" : ""} : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Cl invalide dans ${issue2.origin}`;
      case "invalid_union":
        return "Entre invalide";
      case "invalid_element":
        return `Valeur invalide dans ${issue2.origin}`;
      default:
        return `Entre invalide`;
    }
  };
};
function fr_CA_default() {
  return {
    localeError: error15()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/he.js
var error16 = () => {
  const TypeNames = {
    string: { label: "", gender: "f" },
    number: { label: "", gender: "m" },
    boolean: { label: " ", gender: "m" },
    bigint: { label: "BigInt", gender: "m" },
    date: { label: "", gender: "m" },
    array: { label: "", gender: "m" },
    object: { label: "", gender: "m" },
    null: { label: "  (null)", gender: "m" },
    undefined: { label: "   (undefined)", gender: "m" },
    symbol: { label: " (Symbol)", gender: "m" },
    function: { label: "", gender: "f" },
    map: { label: " (Map)", gender: "f" },
    set: { label: " (Set)", gender: "f" },
    file: { label: "", gender: "m" },
    promise: { label: "Promise", gender: "m" },
    NaN: { label: "NaN", gender: "m" },
    unknown: { label: "  ", gender: "m" },
    value: { label: "", gender: "m" }
  };
  const Sizable = {
    string: { unit: "", shortLabel: "", longLabel: "" },
    file: { unit: "", shortLabel: "", longLabel: "" },
    array: { unit: "", shortLabel: "", longLabel: "" },
    set: { unit: "", shortLabel: "", longLabel: "" },
    number: { unit: "", shortLabel: "", longLabel: "" }
    // no unit
  };
  const typeEntry = (t) => t ? TypeNames[t] : void 0;
  const typeLabel = (t) => {
    const e = typeEntry(t);
    if (e)
      return e.label;
    return t ?? TypeNames.unknown.label;
  };
  const withDefinite = (t) => `${typeLabel(t)}`;
  const verbFor = (t) => {
    const e = typeEntry(t);
    const gender = (e == null ? void 0 : e.gender) ?? "m";
    return gender === "f" ? " " : " ";
  };
  const getSizing = (origin) => {
    if (!origin)
      return null;
    return Sizable[origin] ?? null;
  };
  const FormatDictionary = {
    regex: { label: "", gender: "m" },
    email: { label: " ", gender: "f" },
    url: { label: " ", gender: "f" },
    emoji: { label: "'", gender: "m" },
    uuid: { label: "UUID", gender: "m" },
    nanoid: { label: "nanoid", gender: "m" },
    guid: { label: "GUID", gender: "m" },
    cuid: { label: "cuid", gender: "m" },
    cuid2: { label: "cuid2", gender: "m" },
    ulid: { label: "ULID", gender: "m" },
    xid: { label: "XID", gender: "m" },
    ksuid: { label: "KSUID", gender: "m" },
    datetime: { label: "  ISO", gender: "m" },
    date: { label: " ISO", gender: "m" },
    time: { label: " ISO", gender: "m" },
    duration: { label: "  ISO", gender: "m" },
    ipv4: { label: " IPv4", gender: "f" },
    ipv6: { label: " IPv6", gender: "f" },
    cidrv4: { label: " IPv4", gender: "m" },
    cidrv6: { label: " IPv6", gender: "m" },
    base64: { label: "  64", gender: "f" },
    base64url: { label: "  64  ", gender: "f" },
    json_string: { label: " JSON", gender: "f" },
    e164: { label: " E.164", gender: "m" },
    jwt: { label: "JWT", gender: "m" },
    ends_with: { label: "", gender: "m" },
    includes: { label: "", gender: "m" },
    lowercase: { label: "", gender: "m" },
    starts_with: { label: "", gender: "m" },
    uppercase: { label: "", gender: "m" }
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    var _a3;
    switch (issue2.code) {
      case "invalid_type": {
        const expectedKey = issue2.expected;
        const expected = TypeDictionary[expectedKey ?? ""] ?? typeLabel(expectedKey);
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? ((_a3 = TypeNames[receivedType]) == null ? void 0 : _a3.label) ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  :   instanceof ${issue2.expected},  ${received}`;
        }
        return `  :   ${expected},  ${received}`;
      }
      case "invalid_value": {
        if (issue2.values.length === 1) {
          return `  :    ${stringifyPrimitive(issue2.values[0])}`;
        }
        const stringified = issue2.values.map((v) => stringifyPrimitive(v));
        if (issue2.values.length === 2) {
          return `  :    ${stringified[0]}  ${stringified[1]}`;
        }
        const lastValue = stringified[stringified.length - 1];
        const restValues = stringified.slice(0, -1).join(", ");
        return `  :    ${restValues}  ${lastValue}`;
      }
      case "too_big": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${(sizing == null ? void 0 : sizing.longLabel) ?? ""} : ${subject}   ${issue2.maximum.toString()} ${(sizing == null ? void 0 : sizing.unit) ?? ""} ${issue2.inclusive ? " " : " "}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `   -${issue2.maximum}` : ` -${issue2.maximum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "" : "";
          const comparison = issue2.inclusive ? `${issue2.maximum} ${(sizing == null ? void 0 : sizing.unit) ?? ""}  ` : ` -${issue2.maximum} ${(sizing == null ? void 0 : sizing.unit) ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? "<=" : "<";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing == null ? void 0 : sizing.unit) {
          return `${sizing.longLabel} : ${subject} ${be} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        }
        return `${(sizing == null ? void 0 : sizing.longLabel) ?? ""} : ${subject} ${be} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const sizing = getSizing(issue2.origin);
        const subject = withDefinite(issue2.origin ?? "value");
        if (issue2.origin === "string") {
          return `${(sizing == null ? void 0 : sizing.shortLabel) ?? ""} : ${subject}   ${issue2.minimum.toString()} ${(sizing == null ? void 0 : sizing.unit) ?? ""} ${issue2.inclusive ? " " : ""}`.trim();
        }
        if (issue2.origin === "number") {
          const comparison = issue2.inclusive ? `   -${issue2.minimum}` : ` -${issue2.minimum}`;
          return ` : ${subject}   ${comparison}`;
        }
        if (issue2.origin === "array" || issue2.origin === "set") {
          const verb = issue2.origin === "set" ? "" : "";
          if (issue2.minimum === 1 && issue2.inclusive) {
            const singularPhrase = issue2.origin === "set" ? "  " : "  ";
            return ` : ${subject} ${verb}  ${singularPhrase}`;
          }
          const comparison = issue2.inclusive ? `${issue2.minimum} ${(sizing == null ? void 0 : sizing.unit) ?? ""}  ` : ` -${issue2.minimum} ${(sizing == null ? void 0 : sizing.unit) ?? ""}`;
          return ` : ${subject} ${verb}  ${comparison}`.trim();
        }
        const adj = issue2.inclusive ? ">=" : ">";
        const be = verbFor(issue2.origin ?? "value");
        if (sizing == null ? void 0 : sizing.unit) {
          return `${sizing.shortLabel} : ${subject} ${be} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `${(sizing == null ? void 0 : sizing.shortLabel) ?? ""} : ${subject} ${be} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `    ${_issue.pattern}`;
        const nounEntry = FormatDictionary[_issue.format];
        const noun = (nounEntry == null ? void 0 : nounEntry.label) ?? _issue.format;
        const gender = (nounEntry == null ? void 0 : nounEntry.gender) ?? "m";
        const adjective = gender === "f" ? "" : "";
        return `${noun}  ${adjective}`;
      }
      case "not_multiple_of":
        return `  :     ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key": {
        return `   `;
      }
      case "invalid_union":
        return "  ";
      case "invalid_element": {
        const place = withDefinite(issue2.origin ?? "array");
        return `   ${place}`;
      }
      default:
        return `  `;
    }
  };
};
function he_default() {
  return {
    localeError: error16()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/hu.js
var error17 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "legyen" },
    file: { unit: "byte", verb: "legyen" },
    array: { unit: "elem", verb: "legyen" },
    set: { unit: "elem", verb: "legyen" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "bemenet",
    email: "email cm",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO idblyeg",
    date: "ISO dtum",
    time: "ISO id",
    duration: "ISO idintervallum",
    ipv4: "IPv4 cm",
    ipv6: "IPv6 cm",
    cidrv4: "IPv4 tartomny",
    cidrv6: "IPv6 tartomny",
    base64: "base64-kdolt string",
    base64url: "base64url-kdolt string",
    json_string: "JSON string",
    e164: "E.164 szm",
    jwt: "JWT",
    template_literal: "bemenet"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "szm",
    array: "tmb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `rvnytelen bemenet: a vrt rtk instanceof ${issue2.expected}, a kapott rtk ${received}`;
        }
        return `rvnytelen bemenet: a vrt rtk ${expected}, a kapott rtk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `rvnytelen bemenet: a vrt rtk ${stringifyPrimitive(issue2.values[0])}`;
        return `rvnytelen opci: valamelyik rtk vrt ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Tl nagy: ${issue2.origin ?? "rtk"} mrete tl nagy ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elem"}`;
        return `Tl nagy: a bemeneti rtk ${issue2.origin ?? "rtk"} tl nagy: ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Tl kicsi: a bemeneti rtk ${issue2.origin} mrete tl kicsi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Tl kicsi: a bemeneti rtk ${issue2.origin} tl kicsi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `rvnytelen string: "${_issue.prefix}" rtkkel kell kezddnie`;
        if (_issue.format === "ends_with")
          return `rvnytelen string: "${_issue.suffix}" rtkkel kell vgzdnie`;
        if (_issue.format === "includes")
          return `rvnytelen string: "${_issue.includes}" rtket kell tartalmaznia`;
        if (_issue.format === "regex")
          return `rvnytelen string: ${_issue.pattern} mintnak kell megfelelnie`;
        return `rvnytelen ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `rvnytelen szm: ${issue2.divisor} tbbszrsnek kell lennie`;
      case "unrecognized_keys":
        return `Ismeretlen kulcs${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `rvnytelen kulcs ${issue2.origin}`;
      case "invalid_union":
        return "rvnytelen bemenet";
      case "invalid_element":
        return `rvnytelen rtk: ${issue2.origin}`;
      default:
        return `rvnytelen bemenet`;
    }
  };
};
function hu_default() {
  return {
    localeError: error17()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/hy.js
function getArmenianPlural(count, one, many) {
  return Math.abs(count) === 1 ? one : many;
}
function withDefiniteArticle(word) {
  if (!word)
    return "";
  const vowels = ["", "", "", "", "", "", ""];
  const lastChar = word[word.length - 1];
  return word + (vowels.includes(lastChar) ? "" : "");
}
var error18 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: ". ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `    instanceof ${issue2.expected},   ${received}`;
        }
        return `    ${expected},   ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `    ${stringifyPrimitive(issue2.values[1])}`;
        return `      ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getArmenianPlural(maxValue, sizing.unit.one, sizing.unit.many);
          return `    ,  ${withDefiniteArticle(issue2.origin ?? "")}  ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `    ,  ${withDefiniteArticle(issue2.origin ?? "")}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getArmenianPlural(minValue, sizing.unit.one, sizing.unit.many);
          return `    ,  ${withDefiniteArticle(issue2.origin)}  ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `    ,  ${withDefiniteArticle(issue2.origin)}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `     "${_issue.prefix}"-`;
        if (_issue.format === "ends_with")
          return `     "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return `     "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `     ${_issue.pattern} `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `      ${issue2.divisor}-`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}. ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `  ${withDefiniteArticle(issue2.origin)}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${withDefiniteArticle(issue2.origin)}-`;
      default:
        return ` `;
    }
  };
};
function hy_default() {
  return {
    localeError: error18()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/id.js
var error19 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "memiliki" },
    file: { unit: "byte", verb: "memiliki" },
    array: { unit: "item", verb: "memiliki" },
    set: { unit: "item", verb: "memiliki" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tanggal dan waktu format ISO",
    date: "tanggal format ISO",
    time: "jam format ISO",
    duration: "durasi format ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "rentang alamat IPv4",
    cidrv6: "rentang alamat IPv6",
    base64: "string dengan enkode base64",
    base64url: "string dengan enkode base64url",
    json_string: "string JSON",
    e164: "angka E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak valid: diharapkan instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak valid: diharapkan ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak valid: diharapkan ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak valid: diharapkan salah satu dari ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} memiliki ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: diharapkan ${issue2.origin ?? "value"} menjadi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: diharapkan ${issue2.origin} memiliki ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: diharapkan ${issue2.origin} menjadi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak valid: harus dimulai dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak valid: harus berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak valid: harus menyertakan "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak valid: harus sesuai pola ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak valid`;
      }
      case "not_multiple_of":
        return `Angka tidak valid: harus kelipatan dari ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak valid di ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak valid";
      case "invalid_element":
        return `Nilai tidak valid di ${issue2.origin}`;
      default:
        return `Input tidak valid`;
    }
  };
};
function id_default() {
  return {
    localeError: error19()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/is.js
var error20 = () => {
  const Sizable = {
    string: { unit: "stafi", verb: "a hafa" },
    file: { unit: "bti", verb: "a hafa" },
    array: { unit: "hluti", verb: "a hafa" },
    set: { unit: "hluti", verb: "a hafa" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "gildi",
    email: "netfang",
    url: "vefsl",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dagsetning og tmi",
    date: "ISO dagsetning",
    time: "ISO tmi",
    duration: "ISO tmalengd",
    ipv4: "IPv4 address",
    ipv6: "IPv6 address",
    cidrv4: "IPv4 range",
    cidrv6: "IPv6 range",
    base64: "base64-encoded strengur",
    base64url: "base64url-encoded strengur",
    json_string: "JSON strengur",
    e164: "E.164 tlugildi",
    jwt: "JWT",
    template_literal: "gildi"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmer",
    array: "fylki"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Rangt gildi:  slst inn ${received} ar sem  a vera instanceof ${issue2.expected}`;
        }
        return `Rangt gildi:  slst inn ${received} ar sem  a vera ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Rangt gildi: gert r fyrir ${stringifyPrimitive(issue2.values[0])}`;
        return `gilt val: m vera eitt af eftirfarandi ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} hafi ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "hluti"}`;
        return `Of strt: gert er r fyrir a ${issue2.origin ?? "gildi"} s ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Of lti: gert er r fyrir a ${issue2.origin} hafi ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Of lti: gert er r fyrir a ${issue2.origin} s ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `gildur strengur: verur a byrja  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `gildur strengur: verur a enda  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `gildur strengur: verur a innihalda "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `gildur strengur: verur a fylgja mynstri ${_issue.pattern}`;
        return `Rangt ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Rng tala: verur a vera margfeldi af ${issue2.divisor}`;
      case "unrecognized_keys":
        return `ekkt ${issue2.keys.length > 1 ? "ir lyklar" : "ur lykill"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Rangur lykill  ${issue2.origin}`;
      case "invalid_union":
        return "Rangt gildi";
      case "invalid_element":
        return `Rangt gildi  ${issue2.origin}`;
      default:
        return `Rangt gildi`;
    }
  };
};
function is_default() {
  return {
    localeError: error20()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/it.js
var error21 = () => {
  const Sizable = {
    string: { unit: "caratteri", verb: "avere" },
    file: { unit: "byte", verb: "avere" },
    array: { unit: "elementi", verb: "avere" },
    set: { unit: "elementi", verb: "avere" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "indirizzo email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e ora ISO",
    date: "data ISO",
    time: "ora ISO",
    duration: "durata ISO",
    ipv4: "indirizzo IPv4",
    ipv6: "indirizzo IPv6",
    cidrv4: "intervallo IPv4",
    cidrv6: "intervallo IPv6",
    base64: "stringa codificata in base64",
    base64url: "URL codificata in base64",
    json_string: "stringa JSON",
    e164: "numero E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numero",
    array: "vettore"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input non valido: atteso instanceof ${issue2.expected}, ricevuto ${received}`;
        }
        return `Input non valido: atteso ${expected}, ricevuto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input non valido: atteso ${stringifyPrimitive(issue2.values[0])}`;
        return `Opzione non valida: atteso uno tra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Troppo grande: ${issue2.origin ?? "valore"} deve avere ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementi"}`;
        return `Troppo grande: ${issue2.origin ?? "valore"} deve essere ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Troppo piccolo: ${issue2.origin} deve avere ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Troppo piccolo: ${issue2.origin} deve essere ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Stringa non valida: deve iniziare con "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Stringa non valida: deve terminare con "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Stringa non valida: deve includere "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Stringa non valida: deve corrispondere al pattern ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Numero non valido: deve essere un multiplo di ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chiav${issue2.keys.length > 1 ? "i" : "e"} non riconosciut${issue2.keys.length > 1 ? "e" : "a"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chiave non valida in ${issue2.origin}`;
      case "invalid_union":
        return "Input non valido";
      case "invalid_element":
        return `Valore non valido in ${issue2.origin}`;
      default:
        return `Input non valido`;
    }
  };
};
function it_default() {
  return {
    localeError: error21()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ja.js
var error22 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `: instanceof ${issue2.expected}${received}`;
        }
        return `: ${expected}${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `: ${stringifyPrimitive(issue2.values[0])}`;
        return `: ${joinValues(issue2.values, "")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${sizing.unit ?? ""}${adj}`;
        return `: ${issue2.origin ?? ""}${issue2.maximum.toString()}${adj}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin}${issue2.minimum.toString()}${sizing.unit}${adj}`;
        return `: ${issue2.origin}${issue2.minimum.toString()}${adj}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `: "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `: "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `: "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `: ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `: ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin}`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function ja_default() {
  return {
    localeError: error22()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ka.js
var error23 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "- ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "-",
    date: "",
    time: "",
    duration: "",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    string: "",
    boolean: "",
    function: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  - ${joinValues(issue2.values, "|")}-`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit}`;
        return ` :  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"-`;
        }
        if (_issue.format === "ends_with")
          return ` :   "${_issue.suffix}"-`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"-`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}- `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `  ${issue2.origin}-`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `  ${issue2.origin}-`;
      default:
        return ` `;
    }
  };
};
function ka_default() {
  return {
    localeError: error23()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/km.js
var error24 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: " base64",
    base64url: " base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: " (Array)",
    null: " (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  instanceof ${issue2.expected}  ${received}`;
        }
        return `  ${expected}  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  ${stringifyPrimitive(issue2.values[0])}`;
        return `  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `  ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `  ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `  "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `  ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `  ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ``;
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function km_default() {
  return {
    localeError: error24()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/kh.js
function kh_default() {
  return km_default();
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ko.js
var error25 = () => {
  const Sizable = {
    string: { unit: "", verb: "to have" },
    file: { unit: "", verb: "to have" },
    array: { unit: "", verb: "to have" },
    set: { unit: "", verb: "to have" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64  ",
    base64url: "base64url  ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :   instanceof ${issue2.expected},   ${received}`;
        }
        return ` :   ${expected},   ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, " ")}   `;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "";
        if (sizing)
          return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()}${unit} ${adj}${suffix}`;
        return `${issue2.origin ?? ""}  : ${issue2.maximum.toString()} ${adj}${suffix}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const suffix = adj === "" ? " " : " ";
        const sizing = getSizing(issue2.origin);
        const unit = (sizing == null ? void 0 : sizing.unit) ?? "";
        if (sizing) {
          return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()}${unit} ${adj}${suffix}`;
        }
        return `${issue2.origin ?? ""}  : ${issue2.minimum.toString()} ${adj}${suffix}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"()  `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"()  `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"()  `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}   `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}  `;
      case "unrecognized_keys":
        return `   : ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` : ${issue2.origin}`;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return ` : ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function ko_default() {
  return {
    localeError: error25()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/lt.js
var capitalizeFirstCharacter = (text) => {
  return text.charAt(0).toUpperCase() + text.slice(1);
};
function getUnitTypeFromNumber(number4) {
  const abs = Math.abs(number4);
  const last = abs % 10;
  const last2 = abs % 100;
  if (last2 >= 11 && last2 <= 19 || last === 0)
    return "many";
  if (last === 1)
    return "one";
  return "few";
}
var error26 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "simbolis",
        few: "simboliai",
        many: "simboli"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne ilgesn kaip",
          notInclusive: "turi bti trumpesn kaip"
        },
        bigger: {
          inclusive: "turi bti ne trumpesn kaip",
          notInclusive: "turi bti ilgesn kaip"
        }
      }
    },
    file: {
      unit: {
        one: "baitas",
        few: "baitai",
        many: "bait"
      },
      verb: {
        smaller: {
          inclusive: "turi bti ne didesnis kaip",
          notInclusive: "turi bti maesnis kaip"
        },
        bigger: {
          inclusive: "turi bti ne maesnis kaip",
          notInclusive: "turi bti didesnis kaip"
        }
      }
    },
    array: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    },
    set: {
      unit: {
        one: "element",
        few: "elementus",
        many: "element"
      },
      verb: {
        smaller: {
          inclusive: "turi turti ne daugiau kaip",
          notInclusive: "turi turti maiau kaip"
        },
        bigger: {
          inclusive: "turi turti ne maiau kaip",
          notInclusive: "turi turti daugiau kaip"
        }
      }
    }
  };
  function getSizing(origin, unitType, inclusive, targetShouldBe) {
    const result = Sizable[origin] ?? null;
    if (result === null)
      return result;
    return {
      unit: result.unit[unitType],
      verb: result.verb[targetShouldBe][inclusive ? "inclusive" : "notInclusive"]
    };
  }
  const FormatDictionary = {
    regex: "vestis",
    email: "el. pato adresas",
    url: "URL",
    emoji: "jaustukas",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO data ir laikas",
    date: "ISO data",
    time: "ISO laikas",
    duration: "ISO trukm",
    ipv4: "IPv4 adresas",
    ipv6: "IPv6 adresas",
    cidrv4: "IPv4 tinklo prefiksas (CIDR)",
    cidrv6: "IPv6 tinklo prefiksas (CIDR)",
    base64: "base64 ukoduota eilut",
    base64url: "base64url ukoduota eilut",
    json_string: "JSON eilut",
    e164: "E.164 numeris",
    jwt: "JWT",
    template_literal: "vestis"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "skaiius",
    bigint: "sveikasis skaiius",
    string: "eilut",
    boolean: "login reikm",
    undefined: "neapibrta reikm",
    function: "funkcija",
    symbol: "simbolis",
    array: "masyvas",
    object: "objektas",
    null: "nulin reikm"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Gautas tipas ${received}, o tiktasi - instanceof ${issue2.expected}`;
        }
        return `Gautas tipas ${received}, o tiktasi - ${expected}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Privalo bti ${stringifyPrimitive(issue2.values[0])}`;
        return `Privalo bti vienas i ${joinValues(issue2.values, "|")} pasirinkim`;
      case "too_big": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.maximum)), issue2.inclusive ?? false, "smaller");
        if (sizing == null ? void 0 : sizing.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue2.inclusive ? "ne didesnis kaip" : "maesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.maximum.toString()} ${sizing == null ? void 0 : sizing.unit}`;
      }
      case "too_small": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        const sizing = getSizing(issue2.origin, getUnitTypeFromNumber(Number(issue2.minimum)), issue2.inclusive ?? false, "bigger");
        if (sizing == null ? void 0 : sizing.verb)
          return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} ${sizing.verb} ${issue2.minimum.toString()} ${sizing.unit ?? "element"}`;
        const adj = issue2.inclusive ? "ne maesnis kaip" : "didesnis kaip";
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi bti ${adj} ${issue2.minimum.toString()} ${sizing == null ? void 0 : sizing.unit}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Eilut privalo prasidti "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Eilut privalo pasibaigti "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Eilut privalo traukti "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Eilut privalo atitikti ${_issue.pattern}`;
        return `Neteisingas ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Skaiius privalo bti ${issue2.divisor} kartotinis.`;
      case "unrecognized_keys":
        return `Neatpaint${issue2.keys.length > 1 ? "i" : "as"} rakt${issue2.keys.length > 1 ? "ai" : "as"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return "Rastas klaidingas raktas";
      case "invalid_union":
        return "Klaidinga vestis";
      case "invalid_element": {
        const origin = TypeDictionary[issue2.origin] ?? issue2.origin;
        return `${capitalizeFirstCharacter(origin ?? issue2.origin ?? "reikm")} turi klaiding vest`;
      }
      default:
        return "Klaidinga vestis";
    }
  };
};
function lt_default() {
  return {
    localeError: error26()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/mk.js
var error27 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "  -",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64- ",
    base64url: "base64url- ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :   instanceof ${issue2.expected},  ${received}`;
        }
        return ` :   ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Invalid input: expected ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` :   ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` :   ${issue2.origin}   ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :     "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return ` :     "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :    "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :      ${_issue.pattern}`;
        return `Invalid ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :      ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? " " : " "}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return ` `;
    }
  };
};
function mk_default() {
  return {
    localeError: error27()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ms.js
var error28 = () => {
  const Sizable = {
    string: { unit: "aksara", verb: "mempunyai" },
    file: { unit: "bait", verb: "mempunyai" },
    array: { unit: "elemen", verb: "mempunyai" },
    set: { unit: "elemen", verb: "mempunyai" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "alamat e-mel",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "tarikh masa ISO",
    date: "tarikh ISO",
    time: "masa ISO",
    duration: "tempoh ISO",
    ipv4: "alamat IPv4",
    ipv6: "alamat IPv6",
    cidrv4: "julat IPv4",
    cidrv6: "julat IPv6",
    base64: "string dikodkan base64",
    base64url: "string dikodkan base64url",
    json_string: "string JSON",
    e164: "nombor E.164",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nombor"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Input tidak sah: dijangka instanceof ${issue2.expected}, diterima ${received}`;
        }
        return `Input tidak sah: dijangka ${expected}, diterima ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Input tidak sah: dijangka ${stringifyPrimitive(issue2.values[0])}`;
        return `Pilihan tidak sah: dijangka salah satu daripada ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elemen"}`;
        return `Terlalu besar: dijangka ${issue2.origin ?? "nilai"} adalah ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Terlalu kecil: dijangka ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Terlalu kecil: dijangka ${issue2.origin} adalah ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `String tidak sah: mesti bermula dengan "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `String tidak sah: mesti berakhir dengan "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `String tidak sah: mesti mengandungi "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `String tidak sah: mesti sepadan dengan corak ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} tidak sah`;
      }
      case "not_multiple_of":
        return `Nombor tidak sah: perlu gandaan ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kunci tidak dikenali: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kunci tidak sah dalam ${issue2.origin}`;
      case "invalid_union":
        return "Input tidak sah";
      case "invalid_element":
        return `Nilai tidak sah dalam ${issue2.origin}`;
      default:
        return `Input tidak sah`;
    }
  };
};
function ms_default() {
  return {
    localeError: error28()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/nl.js
var error29 = () => {
  const Sizable = {
    string: { unit: "tekens", verb: "heeft" },
    file: { unit: "bytes", verb: "heeft" },
    array: { unit: "elementen", verb: "heeft" },
    set: { unit: "elementen", verb: "heeft" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "invoer",
    email: "emailadres",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum en tijd",
    date: "ISO datum",
    time: "ISO tijd",
    duration: "ISO duur",
    ipv4: "IPv4-adres",
    ipv6: "IPv6-adres",
    cidrv4: "IPv4-bereik",
    cidrv6: "IPv6-bereik",
    base64: "base64-gecodeerde tekst",
    base64url: "base64 URL-gecodeerde tekst",
    json_string: "JSON string",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "invoer"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "getal"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ongeldige invoer: verwacht instanceof ${issue2.expected}, ontving ${received}`;
        }
        return `Ongeldige invoer: verwacht ${expected}, ontving ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ongeldige invoer: verwacht ${stringifyPrimitive(issue2.values[0])}`;
        return `Ongeldige optie: verwacht n van ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        const longName = issue2.origin === "date" ? "laat" : issue2.origin === "string" ? "lang" : "groot";
        if (sizing)
          return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementen"} ${sizing.verb}`;
        return `Te ${longName}: verwacht dat ${issue2.origin ?? "waarde"} ${adj}${issue2.maximum.toString()} is`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        const shortName = issue2.origin === "date" ? "vroeg" : issue2.origin === "string" ? "kort" : "klein";
        if (sizing) {
          return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Te ${shortName}: verwacht dat ${issue2.origin} ${adj}${issue2.minimum.toString()} is`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ongeldige tekst: moet met "${_issue.prefix}" beginnen`;
        }
        if (_issue.format === "ends_with")
          return `Ongeldige tekst: moet op "${_issue.suffix}" eindigen`;
        if (_issue.format === "includes")
          return `Ongeldige tekst: moet "${_issue.includes}" bevatten`;
        if (_issue.format === "regex")
          return `Ongeldige tekst: moet overeenkomen met patroon ${_issue.pattern}`;
        return `Ongeldig: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ongeldig getal: moet een veelvoud van ${issue2.divisor} zijn`;
      case "unrecognized_keys":
        return `Onbekende key${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ongeldige key in ${issue2.origin}`;
      case "invalid_union":
        return "Ongeldige invoer";
      case "invalid_element":
        return `Ongeldige waarde in ${issue2.origin}`;
      default:
        return `Ongeldige invoer`;
    }
  };
};
function nl_default() {
  return {
    localeError: error29()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/no.js
var error30 = () => {
  const Sizable = {
    string: { unit: "tegn", verb: " ha" },
    file: { unit: "bytes", verb: " ha" },
    array: { unit: "elementer", verb: " inneholde" },
    set: { unit: "elementer", verb: " inneholde" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "input",
    email: "e-postadresse",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO dato- og klokkeslett",
    date: "ISO-dato",
    time: "ISO-klokkeslett",
    duration: "ISO-varighet",
    ipv4: "IPv4-omrde",
    ipv6: "IPv6-omrde",
    cidrv4: "IPv4-spekter",
    cidrv6: "IPv6-spekter",
    base64: "base64-enkodet streng",
    base64url: "base64url-enkodet streng",
    json_string: "JSON-streng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tall",
    array: "liste"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ugyldig input: forventet instanceof ${issue2.expected}, fikk ${received}`;
        }
        return `Ugyldig input: forventet ${expected}, fikk ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ugyldig verdi: forventet ${stringifyPrimitive(issue2.values[0])}`;
        return `Ugyldig valg: forventet en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementer"}`;
        return `For stor(t): forventet ${issue2.origin ?? "value"} til  ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `For lite(n): forventet ${issue2.origin} til  ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Ugyldig streng: m starte med "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Ugyldig streng: m ende med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ugyldig streng: m inneholde "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ugyldig streng: m matche mnsteret ${_issue.pattern}`;
        return `Ugyldig ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ugyldig tall: m vre et multiplum av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Ukjente nkler" : "Ukjent nkkel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ugyldig nkkel i ${issue2.origin}`;
      case "invalid_union":
        return "Ugyldig input";
      case "invalid_element":
        return `Ugyldig verdi i ${issue2.origin}`;
      default:
        return `Ugyldig input`;
    }
  };
};
function no_default() {
  return {
    localeError: error30()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ota.js
var error31 = () => {
  const Sizable = {
    string: { unit: "harf", verb: "olmaldr" },
    file: { unit: "bayt", verb: "olmaldr" },
    array: { unit: "unsur", verb: "olmaldr" },
    set: { unit: "unsur", verb: "olmaldr" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "giren",
    email: "epostagh",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO hengm",
    date: "ISO tarihi",
    time: "ISO zaman",
    duration: "ISO mddeti",
    ipv4: "IPv4 nin",
    ipv6: "IPv6 nin",
    cidrv4: "IPv4 menzili",
    cidrv6: "IPv6 menzili",
    base64: "base64-ifreli metin",
    base64url: "base64url-ifreli metin",
    json_string: "JSON metin",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "giren"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "numara",
    array: "saf",
    null: "gayb"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Fsit giren: umulan instanceof ${issue2.expected}, alnan ${received}`;
        }
        return `Fsit giren: umulan ${expected}, alnan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Fsit giren: umulan ${stringifyPrimitive(issue2.values[0])}`;
        return `Fsit tercih: mteberler ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elements"} sahip olmalyd.`;
        return `Fazla byk: ${issue2.origin ?? "value"}, ${adj}${issue2.maximum.toString()} olmalyd.`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} ${sizing.unit} sahip olmalyd.`;
        }
        return `Fazla kk: ${issue2.origin}, ${adj}${issue2.minimum.toString()} olmalyd.`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Fsit metin: "${_issue.prefix}" ile balamal.`;
        if (_issue.format === "ends_with")
          return `Fsit metin: "${_issue.suffix}" ile bitmeli.`;
        if (_issue.format === "includes")
          return `Fsit metin: "${_issue.includes}" ihtiv etmeli.`;
        if (_issue.format === "regex")
          return `Fsit metin: ${_issue.pattern} nakna uymal.`;
        return `Fsit ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Fsit say: ${issue2.divisor} kat olmalyd.`;
      case "unrecognized_keys":
        return `Tannmayan anahtar ${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iin tannmayan anahtar var.`;
      case "invalid_union":
        return "Giren tannamad.";
      case "invalid_element":
        return `${issue2.origin} iin tannmayan kymet var.`;
      default:
        return `Kymet tannamad.`;
    }
  };
};
function ota_default() {
  return {
    localeError: error31()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ps.js
var error32 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "  ",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "  ",
    date: "",
    time: "",
    duration: "",
    ipv4: " IPv4 ",
    ipv6: " IPv6 ",
    cidrv4: " IPv4 ",
    cidrv6: " IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: " E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected} ,  ${received}  `;
        }
        return ` :  ${expected} ,  ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1) {
          return ` :  ${stringifyPrimitive(issue2.values[0])} `;
        }
        return ` :    ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""} `;
        }
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit} `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` :   "${_issue.prefix}"   `;
        }
        if (_issue.format === "ends_with") {
          return ` :   "${_issue.suffix}"    `;
        }
        if (_issue.format === "includes") {
          return ` :  "${_issue.includes}" `;
        }
        if (_issue.format === "regex") {
          return ` :   ${_issue.pattern}   `;
        }
        return `${FormatDictionary[_issue.format] ?? issue2.format}  `;
      }
      case "not_multiple_of":
        return ` :   ${issue2.divisor}  `;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin} `;
      case "invalid_union":
        return ` `;
      case "invalid_element":
        return `   ${issue2.origin} `;
      default:
        return ` `;
    }
  };
};
function ps_default() {
  return {
    localeError: error32()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/pl.js
var error33 = () => {
  const Sizable = {
    string: { unit: "znakw", verb: "mie" },
    file: { unit: "bajtw", verb: "mie" },
    array: { unit: "elementw", verb: "mie" },
    set: { unit: "elementw", verb: "mie" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "wyraenie",
    email: "adres email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data i godzina w formacie ISO",
    date: "data w formacie ISO",
    time: "godzina w formacie ISO",
    duration: "czas trwania ISO",
    ipv4: "adres IPv4",
    ipv6: "adres IPv6",
    cidrv4: "zakres IPv4",
    cidrv6: "zakres IPv6",
    base64: "cig znakw zakodowany w formacie base64",
    base64url: "cig znakw zakodowany w formacie base64url",
    json_string: "cig znakw w formacie JSON",
    e164: "liczba E.164",
    jwt: "JWT",
    template_literal: "wejcie"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "liczba",
    array: "tablica"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Nieprawidowe dane wejciowe: oczekiwano instanceof ${issue2.expected}, otrzymano ${received}`;
        }
        return `Nieprawidowe dane wejciowe: oczekiwano ${expected}, otrzymano ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Nieprawidowe dane wejciowe: oczekiwano ${stringifyPrimitive(issue2.values[0])}`;
        return `Nieprawidowa opcja: oczekiwano jednej z wartoci ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za dua warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt du(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Za maa warto: oczekiwano, e ${issue2.origin ?? "warto"} bdzie mie ${adj}${issue2.minimum.toString()} ${sizing.unit ?? "elementw"}`;
        }
        return `Zbyt ma(y/a/e): oczekiwano, e ${issue2.origin ?? "warto"} bdzie wynosi ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Nieprawidowy cig znakw: musi zaczyna si od "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Nieprawidowy cig znakw: musi koczy si na "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Nieprawidowy cig znakw: musi zawiera "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Nieprawidowy cig znakw: musi odpowiada wzorcowi ${_issue.pattern}`;
        return `Nieprawidow(y/a/e) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nieprawidowa liczba: musi by wielokrotnoci ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Nierozpoznane klucze${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Nieprawidowy klucz w ${issue2.origin}`;
      case "invalid_union":
        return "Nieprawidowe dane wejciowe";
      case "invalid_element":
        return `Nieprawidowa warto w ${issue2.origin}`;
      default:
        return `Nieprawidowe dane wejciowe`;
    }
  };
};
function pl_default() {
  return {
    localeError: error33()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/pt.js
var error34 = () => {
  const Sizable = {
    string: { unit: "caracteres", verb: "ter" },
    file: { unit: "bytes", verb: "ter" },
    array: { unit: "itens", verb: "ter" },
    set: { unit: "itens", verb: "ter" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "padro",
    email: "endereo de e-mail",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "data e hora ISO",
    date: "data ISO",
    time: "hora ISO",
    duration: "durao ISO",
    ipv4: "endereo IPv4",
    ipv6: "endereo IPv6",
    cidrv4: "faixa de IPv4",
    cidrv6: "faixa de IPv6",
    base64: "texto codificado em base64",
    base64url: "URL codificada em base64",
    json_string: "texto JSON",
    e164: "nmero E.164",
    jwt: "JWT",
    template_literal: "entrada"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmero",
    null: "nulo"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Tipo invlido: esperado instanceof ${issue2.expected}, recebido ${received}`;
        }
        return `Tipo invlido: esperado ${expected}, recebido ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Entrada invlida: esperado ${stringifyPrimitive(issue2.values[0])}`;
        return `Opo invlida: esperada uma das ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Muito grande: esperado que ${issue2.origin ?? "valor"} tivesse ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementos"}`;
        return `Muito grande: esperado que ${issue2.origin ?? "valor"} fosse ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Muito pequeno: esperado que ${issue2.origin} tivesse ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Muito pequeno: esperado que ${issue2.origin} fosse ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Texto invlido: deve comear com "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Texto invlido: deve terminar com "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Texto invlido: deve incluir "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Texto invlido: deve corresponder ao padro ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} invlido`;
      }
      case "not_multiple_of":
        return `Nmero invlido: deve ser mltiplo de ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Chave${issue2.keys.length > 1 ? "s" : ""} desconhecida${issue2.keys.length > 1 ? "s" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Chave invlida em ${issue2.origin}`;
      case "invalid_union":
        return "Entrada invlida";
      case "invalid_element":
        return `Valor invlido em ${issue2.origin}`;
      default:
        return `Campo invlido`;
    }
  };
};
function pt_default() {
  return {
    localeError: error34()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ru.js
function getRussianPlural(count, one, few, many) {
  const absCount = Math.abs(count);
  const lastDigit = absCount % 10;
  const lastTwoDigits = absCount % 100;
  if (lastTwoDigits >= 11 && lastTwoDigits <= 19) {
    return many;
  }
  if (lastDigit === 1) {
    return one;
  }
  if (lastDigit >= 2 && lastDigit <= 4) {
    return few;
  }
  return many;
}
var error35 = () => {
  const Sizable = {
    string: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    file: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    array: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    },
    set: {
      unit: {
        one: "",
        few: "",
        many: ""
      },
      verb: ""
    }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "email ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO   ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "   base64",
    base64url: "   base64url",
    json_string: "JSON ",
    e164: " E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const maxValue = Number(issue2.maximum);
          const unit = getRussianPlural(maxValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin ?? ""}   ${adj}${issue2.maximum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          const minValue = Number(issue2.minimum);
          const unit = getRussianPlural(minValue, sizing.unit.one, sizing.unit.few, sizing.unit.many);
          return `  : ,  ${issue2.origin}   ${adj}${issue2.minimum.toString()} ${unit}`;
        }
        return `  : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""} ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function ru_default() {
  return {
    localeError: error35()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/sl.js
var error36 = () => {
  const Sizable = {
    string: { unit: "znakov", verb: "imeti" },
    file: { unit: "bajtov", verb: "imeti" },
    array: { unit: "elementov", verb: "imeti" },
    set: { unit: "elementov", verb: "imeti" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "vnos",
    email: "e-potni naslov",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO datum in as",
    date: "ISO datum",
    time: "ISO as",
    duration: "ISO trajanje",
    ipv4: "IPv4 naslov",
    ipv6: "IPv6 naslov",
    cidrv4: "obseg IPv4",
    cidrv6: "obseg IPv6",
    base64: "base64 kodiran niz",
    base64url: "base64url kodiran niz",
    json_string: "JSON niz",
    e164: "E.164 tevilka",
    jwt: "JWT",
    template_literal: "vnos"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "tevilo",
    array: "tabela"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Neveljaven vnos: priakovano instanceof ${issue2.expected}, prejeto ${received}`;
        }
        return `Neveljaven vnos: priakovano ${expected}, prejeto ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Neveljaven vnos: priakovano ${stringifyPrimitive(issue2.values[0])}`;
        return `Neveljavna monost: priakovano eno izmed ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} imelo ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "elementov"}`;
        return `Preveliko: priakovano, da bo ${issue2.origin ?? "vrednost"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Premajhno: priakovano, da bo ${issue2.origin} imelo ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Premajhno: priakovano, da bo ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Neveljaven niz: mora se zaeti z "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Neveljaven niz: mora se konati z "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Neveljaven niz: mora vsebovati "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Neveljaven niz: mora ustrezati vzorcu ${_issue.pattern}`;
        return `Neveljaven ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Neveljavno tevilo: mora biti vekratnik ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Neprepoznan${issue2.keys.length > 1 ? "i kljui" : " klju"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Neveljaven klju v ${issue2.origin}`;
      case "invalid_union":
        return "Neveljaven vnos";
      case "invalid_element":
        return `Neveljavna vrednost v ${issue2.origin}`;
      default:
        return "Neveljaven vnos";
    }
  };
};
function sl_default() {
  return {
    localeError: error36()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/sv.js
var error37 = () => {
  const Sizable = {
    string: { unit: "tecken", verb: "att ha" },
    file: { unit: "bytes", verb: "att ha" },
    array: { unit: "objekt", verb: "att innehlla" },
    set: { unit: "objekt", verb: "att innehlla" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "reguljrt uttryck",
    email: "e-postadress",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO-datum och tid",
    date: "ISO-datum",
    time: "ISO-tid",
    duration: "ISO-varaktighet",
    ipv4: "IPv4-intervall",
    ipv6: "IPv6-intervall",
    cidrv4: "IPv4-spektrum",
    cidrv6: "IPv6-spektrum",
    base64: "base64-kodad strng",
    base64url: "base64url-kodad strng",
    json_string: "JSON-strng",
    e164: "E.164-nummer",
    jwt: "JWT",
    template_literal: "mall-literal"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "antal",
    array: "lista"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Ogiltig inmatning: frvntat instanceof ${issue2.expected}, fick ${received}`;
        }
        return `Ogiltig inmatning: frvntat ${expected}, fick ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Ogiltig inmatning: frvntat ${stringifyPrimitive(issue2.values[0])}`;
        return `Ogiltigt val: frvntade en av ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr stor(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "element"}`;
        }
        return `Fr stor(t): frvntat ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Fr lite(t): frvntade ${issue2.origin ?? "vrdet"} att ha ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `Ogiltig strng: mste brja med "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `Ogiltig strng: mste sluta med "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Ogiltig strng: mste innehlla "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Ogiltig strng: mste matcha mnstret "${_issue.pattern}"`;
        return `Ogiltig(t) ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Ogiltigt tal: mste vara en multipel av ${issue2.divisor}`;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "Oknda nycklar" : "Oknd nyckel"}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Ogiltig nyckel i ${issue2.origin ?? "vrdet"}`;
      case "invalid_union":
        return "Ogiltig input";
      case "invalid_element":
        return `Ogiltigt vrde i ${issue2.origin ?? "vrdet"}`;
      default:
        return `Ogiltig input`;
    }
  };
};
function sv_default() {
  return {
    localeError: error37()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ta.js
var error38 = () => {
  const Sizable = {
    string: { unit: "", verb: " " },
    file: { unit: "", verb: " " },
    array: { unit: "", verb: " " },
    set: { unit: "", verb: " " }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: " ",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO  ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO  ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64-encoded ",
    base64url: "base64url-encoded ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: "input"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` :  instanceof ${issue2.expected},  ${received}`;
        }
        return ` :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :  ${joinValues(issue2.values, "|")}  `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        }
        return ` :  ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` :  ${issue2.origin} ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` : "${_issue.prefix}"   `;
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"   `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` : ${_issue.pattern}   `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `  ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return " ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return ` `;
    }
  };
};
function ta_default() {
  return {
    localeError: error38()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/th.js
var error39 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: " ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IP  IPv4",
    cidrv6: " IP  IPv6",
    base64: " Base64",
    base64url: " Base64  URL",
    json_string: " JSON",
    e164: " (E.164)",
    jwt: " JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: " (Array)",
    null: " (null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `:  instanceof ${issue2.expected}  ${received}`;
        }
        return `:  ${expected}  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `:  ${stringifyPrimitive(issue2.values[0])}`;
        return `:  ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return `: ${issue2.origin ?? ""} ${adj} ${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? "" : "";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `: ${issue2.origin} ${adj} ${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return `:  "${_issue.prefix}"`;
        }
        if (_issue.format === "ends_with")
          return `:  "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `:  "${_issue.includes}" `;
        if (_issue.format === "regex")
          return `:  ${_issue.pattern}`;
        return `: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `:  ${issue2.divisor} `;
      case "unrecognized_keys":
        return `: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return ` ${issue2.origin}`;
      case "invalid_union":
        return ": ";
      case "invalid_element":
        return ` ${issue2.origin}`;
      default:
        return ``;
    }
  };
};
function th_default() {
  return {
    localeError: error39()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/tr.js
var error40 = () => {
  const Sizable = {
    string: { unit: "karakter", verb: "olmal" },
    file: { unit: "bayt", verb: "olmal" },
    array: { unit: "e", verb: "olmal" },
    set: { unit: "e", verb: "olmal" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "girdi",
    email: "e-posta adresi",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO tarih ve saat",
    date: "ISO tarih",
    time: "ISO saat",
    duration: "ISO sre",
    ipv4: "IPv4 adresi",
    ipv6: "IPv6 adresi",
    cidrv4: "IPv4 aral",
    cidrv6: "IPv6 aral",
    base64: "base64 ile ifrelenmi metin",
    base64url: "base64url ile ifrelenmi metin",
    json_string: "JSON dizesi",
    e164: "E.164 says",
    jwt: "JWT",
    template_literal: "ablon dizesi"
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Geersiz deer: beklenen instanceof ${issue2.expected}, alnan ${received}`;
        }
        return `Geersiz deer: beklenen ${expected}, alnan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Geersiz deer: beklenen ${stringifyPrimitive(issue2.values[0])}`;
        return `Geersiz seenek: aadakilerden biri olmal: ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "e"}`;
        return `ok byk: beklenen ${issue2.origin ?? "deer"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        return `ok kk: beklenen ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Geersiz metin: "${_issue.prefix}" ile balamal`;
        if (_issue.format === "ends_with")
          return `Geersiz metin: "${_issue.suffix}" ile bitmeli`;
        if (_issue.format === "includes")
          return `Geersiz metin: "${_issue.includes}" iermeli`;
        if (_issue.format === "regex")
          return `Geersiz metin: ${_issue.pattern} desenine uymal`;
        return `Geersiz ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Geersiz say: ${issue2.divisor} ile tam blnebilmeli`;
      case "unrecognized_keys":
        return `Tannmayan anahtar${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} iinde geersiz anahtar`;
      case "invalid_union":
        return "Geersiz deer";
      case "invalid_element":
        return `${issue2.origin} iinde geersiz deer`;
      default:
        return `Geersiz deer`;
    }
  };
};
function tr_default() {
  return {
    localeError: error40()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/uk.js
var error41 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: " ",
    email: "  ",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "   ISO",
    date: " ISO",
    time: " ISO",
    duration: " ISO",
    ipv4: " IPv4",
    ipv6: " IPv6",
    cidrv4: " IPv4",
    cidrv6: " IPv6",
    base64: "   base64",
    base64url: "   base64url",
    json_string: " JSON",
    e164: " E.164",
    jwt: "JWT",
    template_literal: " "
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  :  instanceof ${issue2.expected},  ${received}`;
        }
        return `  :  ${expected},  ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  :  ${stringifyPrimitive(issue2.values[0])}`;
        return ` :    ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ,  ${issue2.origin ?? ""} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` : ,  ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ,  ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` : ,  ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` :    "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return ` :    "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return ` :   "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` :    ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` :    ${issue2.divisor}`;
      case "unrecognized_keys":
        return ` ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `   ${issue2.origin}`;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `   ${issue2.origin}`;
      default:
        return `  `;
    }
  };
};
function uk_default() {
  return {
    localeError: error41()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ua.js
function ua_default() {
  return uk_default();
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/ur.js
var error42 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: " ",
    email: "  ",
    url: "  ",
    emoji: "",
    uuid: "   ",
    uuidv4: "     4",
    uuidv6: "     6",
    nanoid: "  ",
    guid: "   ",
    cuid: "   ",
    cuid2: "    2",
    ulid: "   ",
    xid: "  ",
    ksuid: "    ",
    datetime: "    ",
    date: "   ",
    time: "   ",
    duration: "   ",
    ipv4: "   4 ",
    ipv6: "   6 ",
    cidrv4: "   4 ",
    cidrv6: "   6 ",
    base64: " 64   ",
    base64url: " 64      ",
    json_string: "    ",
    e164: " 164 ",
    jwt: "  ",
    template_literal: " "
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: ""
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `  : instanceof ${issue2.expected}   ${received}  `;
        }
        return `  : ${expected}   ${received}  `;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `  : ${stringifyPrimitive(issue2.values[0])}  `;
        return ` : ${joinValues(issue2.values, "|")}     `;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}   `;
        return ` : ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}   `;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}   `;
        }
        return ` : ${issue2.origin}  ${adj}${issue2.minimum.toString()}   `;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` : "${_issue.prefix}"    `;
        }
        if (_issue.format === "ends_with")
          return ` : "${_issue.suffix}"    `;
        if (_issue.format === "includes")
          return ` : "${_issue.includes}"   `;
        if (_issue.format === "regex")
          return ` :  ${_issue.pattern}    `;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` : ${issue2.divisor}    `;
      case "unrecognized_keys":
        return `   ${issue2.keys.length > 1 ? "" : ""}: ${joinValues(issue2.keys, " ")}`;
      case "invalid_key":
        return `${issue2.origin}   `;
      case "invalid_union":
        return "  ";
      case "invalid_element":
        return `${issue2.origin}   `;
      default:
        return `  `;
    }
  };
};
function ur_default() {
  return {
    localeError: error42()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/uz.js
var error43 = () => {
  const Sizable = {
    string: { unit: "belgi", verb: "bolishi kerak" },
    file: { unit: "bayt", verb: "bolishi kerak" },
    array: { unit: "element", verb: "bolishi kerak" },
    set: { unit: "element", verb: "bolishi kerak" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "kirish",
    email: "elektron pochta manzili",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO sana va vaqti",
    date: "ISO sana",
    time: "ISO vaqt",
    duration: "ISO davomiylik",
    ipv4: "IPv4 manzil",
    ipv6: "IPv6 manzil",
    mac: "MAC manzil",
    cidrv4: "IPv4 diapazon",
    cidrv6: "IPv6 diapazon",
    base64: "base64 kodlangan satr",
    base64url: "base64url kodlangan satr",
    json_string: "JSON satr",
    e164: "E.164 raqam",
    jwt: "JWT",
    template_literal: "kirish"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "raqam",
    array: "massiv"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `Notogri kirish: kutilgan instanceof ${issue2.expected}, qabul qilingan ${received}`;
        }
        return `Notogri kirish: kutilgan ${expected}, qabul qilingan ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `Notogri kirish: kutilgan ${stringifyPrimitive(issue2.values[0])}`;
        return `Notogri variant: quyidagilardan biri kutilgan ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()} ${sizing.unit} ${sizing.verb}`;
        return `Juda katta: kutilgan ${issue2.origin ?? "qiymat"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit} ${sizing.verb}`;
        }
        return `Juda kichik: kutilgan ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Notogri satr: "${_issue.prefix}" bilan boshlanishi kerak`;
        if (_issue.format === "ends_with")
          return `Notogri satr: "${_issue.suffix}" bilan tugashi kerak`;
        if (_issue.format === "includes")
          return `Notogri satr: "${_issue.includes}" ni oz ichiga olishi kerak`;
        if (_issue.format === "regex")
          return `Notogri satr: ${_issue.pattern} shabloniga mos kelishi kerak`;
        return `Notogri ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Notogri raqam: ${issue2.divisor} ning karralisi bolishi kerak`;
      case "unrecognized_keys":
        return `Nomalum kalit${issue2.keys.length > 1 ? "lar" : ""}: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} dagi kalit notogri`;
      case "invalid_union":
        return "Notogri kirish";
      case "invalid_element":
        return `${issue2.origin} da notogri qiymat`;
      default:
        return `Notogri kirish`;
    }
  };
};
function uz_default() {
  return {
    localeError: error43()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/vi.js
var error44 = () => {
  const Sizable = {
    string: { unit: "k t", verb: "c" },
    file: { unit: "byte", verb: "c" },
    array: { unit: "phn t", verb: "c" },
    set: { unit: "phn t", verb: "c" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "u vo",
    email: "a ch email",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ngy gi ISO",
    date: "ngy ISO",
    time: "gi ISO",
    duration: "khong thi gian ISO",
    ipv4: "a ch IPv4",
    ipv6: "a ch IPv6",
    cidrv4: "di IPv4",
    cidrv6: "di IPv6",
    base64: "chui m ha base64",
    base64url: "chui m ha base64url",
    json_string: "chui JSON",
    e164: "s E.164",
    jwt: "JWT",
    template_literal: "u vo"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "s",
    array: "mng"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `u vo khng hp l: mong i instanceof ${issue2.expected}, nhn c ${received}`;
        }
        return `u vo khng hp l: mong i ${expected}, nhn c ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `u vo khng hp l: mong i ${stringifyPrimitive(issue2.values[0])}`;
        return `Ty chn khng hp l: mong i mt trong cc gi tr ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${sizing.verb} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? "phn t"}`;
        return `Qu ln: mong i ${issue2.origin ?? "gi tr"} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return `Qu nh: mong i ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return `Qu nh: mong i ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `Chui khng hp l: phi bt u bng "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `Chui khng hp l: phi kt thc bng "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `Chui khng hp l: phi bao gm "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `Chui khng hp l: phi khp vi mu ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format} khng hp l`;
      }
      case "not_multiple_of":
        return `S khng hp l: phi l bi s ca ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Kha khng c nhn dng: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Kha khng hp l trong ${issue2.origin}`;
      case "invalid_union":
        return "u vo khng hp l";
      case "invalid_element":
        return `Gi tr khng hp l trong ${issue2.origin}`;
      default:
        return `u vo khng hp l`;
    }
  };
};
function vi_default() {
  return {
    localeError: error44()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/zh-CN.js
var error45 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO",
    date: "ISO",
    time: "ISO",
    duration: "ISO",
    ipv4: "IPv4",
    ipv6: "IPv6",
    cidrv4: "IPv4",
    cidrv6: "IPv6",
    base64: "base64",
    base64url: "base64url",
    json_string: "JSON",
    e164: "E.164",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "",
    array: "",
    null: "(null)"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` instanceof ${issue2.expected} ${received}`;
        }
        return ` ${expected} ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""} ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin} ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin} ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return ` "${_issue.prefix}" `;
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return `${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `(key): ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `${issue2.origin} (key)`;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} (value)`;
      default:
        return ``;
    }
  };
};
function zh_CN_default() {
  return {
    localeError: error45()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/zh-TW.js
var error46 = () => {
  const Sizable = {
    string: { unit: "", verb: "" },
    file: { unit: "", verb: "" },
    array: { unit: "", verb: "" },
    set: { unit: "", verb: "" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "",
    email: "",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "ISO ",
    date: "ISO ",
    time: "ISO ",
    duration: "ISO ",
    ipv4: "IPv4 ",
    ipv6: "IPv6 ",
    cidrv4: "IPv4 ",
    cidrv6: "IPv6 ",
    base64: "base64 ",
    base64url: "base64url ",
    json_string: "JSON ",
    e164: "E.164 ",
    jwt: "JWT",
    template_literal: ""
  };
  const TypeDictionary = {
    nan: "NaN"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return ` instanceof ${issue2.expected} ${received}`;
        }
        return ` ${expected} ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return ` ${stringifyPrimitive(issue2.values[0])}`;
        return ` ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()} ${sizing.unit ?? ""}`;
        return ` ${issue2.origin ?? ""}  ${adj}${issue2.maximum.toString()}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing) {
          return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()} ${sizing.unit}`;
        }
        return ` ${issue2.origin}  ${adj}${issue2.minimum.toString()}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with") {
          return ` "${_issue.prefix}" `;
        }
        if (_issue.format === "ends_with")
          return ` "${_issue.suffix}" `;
        if (_issue.format === "includes")
          return ` "${_issue.includes}"`;
        if (_issue.format === "regex")
          return ` ${_issue.pattern}`;
        return ` ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return ` ${issue2.divisor} `;
      case "unrecognized_keys":
        return `${issue2.keys.length > 1 ? "" : ""}${joinValues(issue2.keys, "")}`;
      case "invalid_key":
        return `${issue2.origin} `;
      case "invalid_union":
        return "";
      case "invalid_element":
        return `${issue2.origin} `;
      default:
        return ``;
    }
  };
};
function zh_TW_default() {
  return {
    localeError: error46()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/locales/yo.js
var error47 = () => {
  const Sizable = {
    string: { unit: "mi", verb: "n" },
    file: { unit: "bytes", verb: "n" },
    array: { unit: "nkan", verb: "n" },
    set: { unit: "nkan", verb: "n" }
  };
  function getSizing(origin) {
    return Sizable[origin] ?? null;
  }
  const FormatDictionary = {
    regex: "r bwl",
    email: "drs ml",
    url: "URL",
    emoji: "emoji",
    uuid: "UUID",
    uuidv4: "UUIDv4",
    uuidv6: "UUIDv6",
    nanoid: "nanoid",
    guid: "GUID",
    cuid: "cuid",
    cuid2: "cuid2",
    ulid: "ULID",
    xid: "XID",
    ksuid: "KSUID",
    datetime: "kk ISO",
    date: "j ISO",
    time: "kk ISO",
    duration: "kk t p ISO",
    ipv4: "drs IPv4",
    ipv6: "drs IPv6",
    cidrv4: "gbgb IPv4",
    cidrv6: "gbgb IPv6",
    base64: "r t a k n base64",
    base64url: "r base64url",
    json_string: "r JSON",
    e164: "nmb E.164",
    jwt: "JWT",
    template_literal: "r bwl"
  };
  const TypeDictionary = {
    nan: "NaN",
    number: "nmb",
    array: "akop"
  };
  return (issue2) => {
    switch (issue2.code) {
      case "invalid_type": {
        const expected = TypeDictionary[issue2.expected] ?? issue2.expected;
        const receivedType = parsedType(issue2.input);
        const received = TypeDictionary[receivedType] ?? receivedType;
        if (/^[A-Z]/.test(issue2.expected)) {
          return `bwl ae: a n lti fi instanceof ${issue2.expected}, m a r ${received}`;
        }
        return `bwl ae: a n lti fi ${expected}, m a r ${received}`;
      }
      case "invalid_value":
        if (issue2.values.length === 1)
          return `bwl ae: a n lti fi ${stringifyPrimitive(issue2.values[0])}`;
        return `yn ae: yan kan lra ${joinValues(issue2.values, "|")}`;
      case "too_big": {
        const adj = issue2.inclusive ? "<=" : "<";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `T p j: a n lti j p ${issue2.origin ?? "iye"} ${sizing.verb} ${adj}${issue2.maximum} ${sizing.unit}`;
        return `T p j: a n lti j ${adj}${issue2.maximum}`;
      }
      case "too_small": {
        const adj = issue2.inclusive ? ">=" : ">";
        const sizing = getSizing(issue2.origin);
        if (sizing)
          return `Kr ju: a n lti j p ${issue2.origin} ${sizing.verb} ${adj}${issue2.minimum} ${sizing.unit}`;
        return `Kr ju: a n lti j ${adj}${issue2.minimum}`;
      }
      case "invalid_format": {
        const _issue = issue2;
        if (_issue.format === "starts_with")
          return `r ae: gbd br pl "${_issue.prefix}"`;
        if (_issue.format === "ends_with")
          return `r ae: gbd par pl "${_issue.suffix}"`;
        if (_issue.format === "includes")
          return `r ae: gbd n "${_issue.includes}"`;
        if (_issue.format === "regex")
          return `r ae: gbd b pr mu ${_issue.pattern}`;
        return `Ae: ${FormatDictionary[_issue.format] ?? issue2.format}`;
      }
      case "not_multiple_of":
        return `Nmb ae: gbd j y ppn ti ${issue2.divisor}`;
      case "unrecognized_keys":
        return `Btn m: ${joinValues(issue2.keys, ", ")}`;
      case "invalid_key":
        return `Btn ae nn ${issue2.origin}`;
      case "invalid_union":
        return "bwl ae";
      case "invalid_element":
        return `Iye ae nn ${issue2.origin}`;
      default:
        return "bwl ae";
    }
  };
};
function yo_default() {
  return {
    localeError: error47()
  };
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/registries.js
var _a2;
var $output = Symbol("ZodOutput");
var $input = Symbol("ZodInput");
var $ZodRegistry = class {
  constructor() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
  }
  add(schema, ..._meta) {
    const meta3 = _meta[0];
    this._map.set(schema, meta3);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.set(meta3.id, schema);
    }
    return this;
  }
  clear() {
    this._map = /* @__PURE__ */ new WeakMap();
    this._idmap = /* @__PURE__ */ new Map();
    return this;
  }
  remove(schema) {
    const meta3 = this._map.get(schema);
    if (meta3 && typeof meta3 === "object" && "id" in meta3) {
      this._idmap.delete(meta3.id);
    }
    this._map.delete(schema);
    return this;
  }
  get(schema) {
    const p = schema._zod.parent;
    if (p) {
      const pm = { ...this.get(p) ?? {} };
      delete pm.id;
      const f = { ...pm, ...this._map.get(schema) };
      return Object.keys(f).length ? f : void 0;
    }
    return this._map.get(schema);
  }
  has(schema) {
    return this._map.has(schema);
  }
};
function registry() {
  return new $ZodRegistry();
}
(_a2 = globalThis).__zod_globalRegistry ?? (_a2.__zod_globalRegistry = registry());
var globalRegistry = globalThis.__zod_globalRegistry;

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/api.js
function _string(Class2, params) {
  return new Class2({
    type: "string",
    ...normalizeParams(params)
  });
}
function _coercedString(Class2, params) {
  return new Class2({
    type: "string",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _email(Class2, params) {
  return new Class2({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _guid(Class2, params) {
  return new Class2({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _uuidv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...normalizeParams(params)
  });
}
function _uuidv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...normalizeParams(params)
  });
}
function _uuidv7(Class2, params) {
  return new Class2({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...normalizeParams(params)
  });
}
function _url(Class2, params) {
  return new Class2({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _emoji2(Class2, params) {
  return new Class2({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _nanoid(Class2, params) {
  return new Class2({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cuid2(Class2, params) {
  return new Class2({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ulid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _xid(Class2, params) {
  return new Class2({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ksuid(Class2, params) {
  return new Class2({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _ipv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _mac(Class2, params) {
  return new Class2({
    type: "string",
    format: "mac",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv4(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _cidrv6(Class2, params) {
  return new Class2({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _base64url(Class2, params) {
  return new Class2({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _e164(Class2, params) {
  return new Class2({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
function _jwt(Class2, params) {
  return new Class2({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...normalizeParams(params)
  });
}
var TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6
};
function _isoDateTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDate(Class2, params) {
  return new Class2({
    type: "string",
    format: "date",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _isoTime(Class2, params) {
  return new Class2({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...normalizeParams(params)
  });
}
function _isoDuration(Class2, params) {
  return new Class2({
    type: "string",
    format: "duration",
    check: "string_format",
    ...normalizeParams(params)
  });
}
function _number(Class2, params) {
  return new Class2({
    type: "number",
    checks: [],
    ...normalizeParams(params)
  });
}
function _coercedNumber(Class2, params) {
  return new Class2({
    type: "number",
    coerce: true,
    checks: [],
    ...normalizeParams(params)
  });
}
function _int(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...normalizeParams(params)
  });
}
function _float32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...normalizeParams(params)
  });
}
function _float64(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...normalizeParams(params)
  });
}
function _int32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...normalizeParams(params)
  });
}
function _uint32(Class2, params) {
  return new Class2({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...normalizeParams(params)
  });
}
function _boolean(Class2, params) {
  return new Class2({
    type: "boolean",
    ...normalizeParams(params)
  });
}
function _coercedBoolean(Class2, params) {
  return new Class2({
    type: "boolean",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _bigint(Class2, params) {
  return new Class2({
    type: "bigint",
    ...normalizeParams(params)
  });
}
function _coercedBigint(Class2, params) {
  return new Class2({
    type: "bigint",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _int64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...normalizeParams(params)
  });
}
function _uint64(Class2, params) {
  return new Class2({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...normalizeParams(params)
  });
}
function _symbol(Class2, params) {
  return new Class2({
    type: "symbol",
    ...normalizeParams(params)
  });
}
function _undefined2(Class2, params) {
  return new Class2({
    type: "undefined",
    ...normalizeParams(params)
  });
}
function _null2(Class2, params) {
  return new Class2({
    type: "null",
    ...normalizeParams(params)
  });
}
function _any(Class2) {
  return new Class2({
    type: "any"
  });
}
function _unknown(Class2) {
  return new Class2({
    type: "unknown"
  });
}
function _never(Class2, params) {
  return new Class2({
    type: "never",
    ...normalizeParams(params)
  });
}
function _void(Class2, params) {
  return new Class2({
    type: "void",
    ...normalizeParams(params)
  });
}
function _date(Class2, params) {
  return new Class2({
    type: "date",
    ...normalizeParams(params)
  });
}
function _coercedDate(Class2, params) {
  return new Class2({
    type: "date",
    coerce: true,
    ...normalizeParams(params)
  });
}
function _nan(Class2, params) {
  return new Class2({
    type: "nan",
    ...normalizeParams(params)
  });
}
function _lt(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _lte(value, params) {
  return new $ZodCheckLessThan({
    check: "less_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _gt(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: false
  });
}
function _gte(value, params) {
  return new $ZodCheckGreaterThan({
    check: "greater_than",
    ...normalizeParams(params),
    value,
    inclusive: true
  });
}
function _positive(params) {
  return _gt(0, params);
}
function _negative(params) {
  return _lt(0, params);
}
function _nonpositive(params) {
  return _lte(0, params);
}
function _nonnegative(params) {
  return _gte(0, params);
}
function _multipleOf(value, params) {
  return new $ZodCheckMultipleOf({
    check: "multiple_of",
    ...normalizeParams(params),
    value
  });
}
function _maxSize(maximum, params) {
  return new $ZodCheckMaxSize({
    check: "max_size",
    ...normalizeParams(params),
    maximum
  });
}
function _minSize(minimum, params) {
  return new $ZodCheckMinSize({
    check: "min_size",
    ...normalizeParams(params),
    minimum
  });
}
function _size(size, params) {
  return new $ZodCheckSizeEquals({
    check: "size_equals",
    ...normalizeParams(params),
    size
  });
}
function _maxLength(maximum, params) {
  const ch = new $ZodCheckMaxLength({
    check: "max_length",
    ...normalizeParams(params),
    maximum
  });
  return ch;
}
function _minLength(minimum, params) {
  return new $ZodCheckMinLength({
    check: "min_length",
    ...normalizeParams(params),
    minimum
  });
}
function _length(length, params) {
  return new $ZodCheckLengthEquals({
    check: "length_equals",
    ...normalizeParams(params),
    length
  });
}
function _regex(pattern, params) {
  return new $ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...normalizeParams(params),
    pattern
  });
}
function _lowercase(params) {
  return new $ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...normalizeParams(params)
  });
}
function _uppercase(params) {
  return new $ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...normalizeParams(params)
  });
}
function _includes(includes, params) {
  return new $ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...normalizeParams(params),
    includes
  });
}
function _startsWith(prefix, params) {
  return new $ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...normalizeParams(params),
    prefix
  });
}
function _endsWith(suffix, params) {
  return new $ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...normalizeParams(params),
    suffix
  });
}
function _property(property, schema, params) {
  return new $ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...normalizeParams(params)
  });
}
function _mime(types, params) {
  return new $ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...normalizeParams(params)
  });
}
function _overwrite(tx) {
  return new $ZodCheckOverwrite({
    check: "overwrite",
    tx
  });
}
function _normalize(form) {
  return _overwrite((input) => input.normalize(form));
}
function _trim() {
  return _overwrite((input) => input.trim());
}
function _toLowerCase() {
  return _overwrite((input) => input.toLowerCase());
}
function _toUpperCase() {
  return _overwrite((input) => input.toUpperCase());
}
function _slugify() {
  return _overwrite((input) => slugify(input));
}
function _array(Class2, element, params) {
  return new Class2({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...normalizeParams(params)
  });
}
function _union(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    ...normalizeParams(params)
  });
}
function _xor(Class2, options, params) {
  return new Class2({
    type: "union",
    options,
    inclusive: false,
    ...normalizeParams(params)
  });
}
function _discriminatedUnion(Class2, discriminator, options, params) {
  return new Class2({
    type: "union",
    options,
    discriminator,
    ...normalizeParams(params)
  });
}
function _intersection(Class2, left, right) {
  return new Class2({
    type: "intersection",
    left,
    right
  });
}
function _tuple(Class2, items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class2({
    type: "tuple",
    items,
    rest,
    ...normalizeParams(params)
  });
}
function _record(Class2, keyType, valueType, params) {
  return new Class2({
    type: "record",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _map(Class2, keyType, valueType, params) {
  return new Class2({
    type: "map",
    keyType,
    valueType,
    ...normalizeParams(params)
  });
}
function _set(Class2, valueType, params) {
  return new Class2({
    type: "set",
    valueType,
    ...normalizeParams(params)
  });
}
function _enum(Class2, values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _nativeEnum(Class2, entries, params) {
  return new Class2({
    type: "enum",
    entries,
    ...normalizeParams(params)
  });
}
function _literal(Class2, value, params) {
  return new Class2({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...normalizeParams(params)
  });
}
function _file(Class2, params) {
  return new Class2({
    type: "file",
    ...normalizeParams(params)
  });
}
function _transform(Class2, fn) {
  return new Class2({
    type: "transform",
    transform: fn
  });
}
function _optional(Class2, innerType) {
  return new Class2({
    type: "optional",
    innerType
  });
}
function _nullable(Class2, innerType) {
  return new Class2({
    type: "nullable",
    innerType
  });
}
function _default(Class2, innerType, defaultValue) {
  return new Class2({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : shallowClone(defaultValue);
    }
  });
}
function _nonoptional(Class2, innerType, params) {
  return new Class2({
    type: "nonoptional",
    innerType,
    ...normalizeParams(params)
  });
}
function _success(Class2, innerType) {
  return new Class2({
    type: "success",
    innerType
  });
}
function _catch(Class2, innerType, catchValue) {
  return new Class2({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
function _pipe(Class2, in_, out) {
  return new Class2({
    type: "pipe",
    in: in_,
    out
  });
}
function _readonly(Class2, innerType) {
  return new Class2({
    type: "readonly",
    innerType
  });
}
function _templateLiteral(Class2, parts, params) {
  return new Class2({
    type: "template_literal",
    parts,
    ...normalizeParams(params)
  });
}
function _lazy(Class2, getter) {
  return new Class2({
    type: "lazy",
    getter
  });
}
function _promise(Class2, innerType) {
  return new Class2({
    type: "promise",
    innerType
  });
}
function _custom(Class2, fn, _params) {
  const norm = normalizeParams(_params);
  norm.abort ?? (norm.abort = true);
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...norm
  });
  return schema;
}
function _refine(Class2, fn, _params) {
  const schema = new Class2({
    type: "custom",
    check: "custom",
    fn,
    ...normalizeParams(_params)
  });
  return schema;
}
function _superRefine(fn) {
  const ch = _check((payload) => {
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(issue(issue2, payload.value, ch._zod.def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = ch);
        _issue.continue ?? (_issue.continue = !ch._zod.def.abort);
        payload.issues.push(issue(_issue));
      }
    };
    return fn(payload.value, payload);
  });
  return ch;
}
function _check(fn, params) {
  const ch = new $ZodCheck({
    check: "custom",
    ...normalizeParams(params)
  });
  ch._zod.check = fn;
  return ch;
}
function describe(description) {
  const ch = new $ZodCheck({ check: "describe" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, description });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
function meta(metadata) {
  const ch = new $ZodCheck({ check: "meta" });
  ch._zod.onattach = [
    (inst) => {
      const existing = globalRegistry.get(inst) ?? {};
      globalRegistry.add(inst, { ...existing, ...metadata });
    }
  ];
  ch._zod.check = () => {
  };
  return ch;
}
function _stringbool(Classes, _params) {
  const params = normalizeParams(_params);
  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
    falsyArray = falsyArray.map((v) => typeof v === "string" ? v.toLowerCase() : v);
  }
  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);
  const _Codec = Classes.Codec ?? $ZodCodec;
  const _Boolean = Classes.Boolean ?? $ZodBoolean;
  const _String = Classes.String ?? $ZodString;
  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });
  const codec2 = new _Codec({
    type: "pipe",
    in: stringSchema,
    out: booleanSchema,
    transform: (input, payload) => {
      let data = input;
      if (params.case !== "sensitive")
        data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec2,
          continue: false
        });
        return {};
      }
    },
    reverseTransform: (input, _payload) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    },
    error: params.error
  });
  return codec2;
}
function _stringFormat(Class2, format, fnOrRegex, _params = {}) {
  const params = normalizeParams(_params);
  const def = {
    ...normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }
  const inst = new Class2(def);
  return inst;
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/to-json-schema.js
function initializeContext(params) {
  let target = (params == null ? void 0 : params.target) ?? "draft-2020-12";
  if (target === "draft-4")
    target = "draft-04";
  if (target === "draft-7")
    target = "draft-07";
  return {
    processors: params.processors ?? {},
    metadataRegistry: (params == null ? void 0 : params.metadata) ?? globalRegistry,
    target,
    unrepresentable: (params == null ? void 0 : params.unrepresentable) ?? "throw",
    override: (params == null ? void 0 : params.override) ?? (() => {
    }),
    io: (params == null ? void 0 : params.io) ?? "output",
    counter: 0,
    seen: /* @__PURE__ */ new Map(),
    cycles: (params == null ? void 0 : params.cycles) ?? "ref",
    reused: (params == null ? void 0 : params.reused) ?? "inline",
    external: (params == null ? void 0 : params.external) ?? void 0
  };
}
function process2(schema, ctx, _params = { path: [], schemaPath: [] }) {
  var _a4, _b;
  var _a3;
  const def = schema._zod.def;
  const seen = ctx.seen.get(schema);
  if (seen) {
    seen.count++;
    const isCycle = _params.schemaPath.includes(schema);
    if (isCycle) {
      seen.cycle = _params.path;
    }
    return seen.schema;
  }
  const result = { schema: {}, count: 1, cycle: void 0, path: _params.path };
  ctx.seen.set(schema, result);
  const overrideSchema = (_b = (_a4 = schema._zod).toJSONSchema) == null ? void 0 : _b.call(_a4);
  if (overrideSchema) {
    result.schema = overrideSchema;
  } else {
    const params = {
      ..._params,
      schemaPath: [..._params.schemaPath, schema],
      path: _params.path
    };
    if (schema._zod.processJSONSchema) {
      schema._zod.processJSONSchema(ctx, result.schema, params);
    } else {
      const _json = result.schema;
      const processor = ctx.processors[def.type];
      if (!processor) {
        throw new Error(`[toJSONSchema]: Non-representable type encountered: ${def.type}`);
      }
      processor(schema, ctx, _json, params);
    }
    const parent = schema._zod.parent;
    if (parent) {
      if (!result.ref)
        result.ref = parent;
      process2(parent, ctx, params);
      ctx.seen.get(parent).isParent = true;
    }
  }
  const meta3 = ctx.metadataRegistry.get(schema);
  if (meta3)
    Object.assign(result.schema, meta3);
  if (ctx.io === "input" && isTransforming(schema)) {
    delete result.schema.examples;
    delete result.schema.default;
  }
  if (ctx.io === "input" && result.schema._prefault)
    (_a3 = result.schema).default ?? (_a3.default = result.schema._prefault);
  delete result.schema._prefault;
  const _result = ctx.seen.get(schema);
  return _result.schema;
}
function extractDefs(ctx, schema) {
  var _a3, _b, _c, _d;
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const idToSchema = /* @__PURE__ */ new Map();
  for (const entry of ctx.seen.entries()) {
    const id = (_a3 = ctx.metadataRegistry.get(entry[0])) == null ? void 0 : _a3.id;
    if (id) {
      const existing = idToSchema.get(id);
      if (existing && existing !== entry[0]) {
        throw new Error(`Duplicate schema id "${id}" detected during JSON Schema conversion. Two different schemas cannot share the same id when converted together.`);
      }
      idToSchema.set(id, entry[0]);
    }
  }
  const makeURI = (entry) => {
    var _a4;
    const defsSegment = ctx.target === "draft-2020-12" ? "$defs" : "definitions";
    if (ctx.external) {
      const externalId = (_a4 = ctx.external.registry.get(entry[0])) == null ? void 0 : _a4.id;
      const uriGenerator = ctx.external.uri ?? ((id2) => id2);
      if (externalId) {
        return { ref: uriGenerator(externalId) };
      }
      const id = entry[1].defId ?? entry[1].schema.id ?? `schema${ctx.counter++}`;
      entry[1].defId = id;
      return { defId: id, ref: `${uriGenerator("__shared")}#/${defsSegment}/${id}` };
    }
    if (entry[1] === root) {
      return { ref: "#" };
    }
    const uriPrefix = `#`;
    const defUriPrefix = `${uriPrefix}/${defsSegment}/`;
    const defId = entry[1].schema.id ?? `__schema${ctx.counter++}`;
    return { defId, ref: defUriPrefix + defId };
  };
  const extractToDef = (entry) => {
    if (entry[1].schema.$ref) {
      return;
    }
    const seen = entry[1];
    const { ref, defId } = makeURI(entry);
    seen.def = { ...seen.schema };
    if (defId)
      seen.defId = defId;
    const schema2 = seen.schema;
    for (const key in schema2) {
      delete schema2[key];
    }
    schema2.$ref = ref;
  };
  if (ctx.cycles === "throw") {
    for (const entry of ctx.seen.entries()) {
      const seen = entry[1];
      if (seen.cycle) {
        throw new Error(`Cycle detected: #/${(_b = seen.cycle) == null ? void 0 : _b.join("/")}/<root>

Set the \`cycles\` parameter to \`"ref"\` to resolve cyclical schemas with defs.`);
      }
    }
  }
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (schema === entry[0]) {
      extractToDef(entry);
      continue;
    }
    if (ctx.external) {
      const ext = (_c = ctx.external.registry.get(entry[0])) == null ? void 0 : _c.id;
      if (schema !== entry[0] && ext) {
        extractToDef(entry);
        continue;
      }
    }
    const id = (_d = ctx.metadataRegistry.get(entry[0])) == null ? void 0 : _d.id;
    if (id) {
      extractToDef(entry);
      continue;
    }
    if (seen.cycle) {
      extractToDef(entry);
      continue;
    }
    if (seen.count > 1) {
      if (ctx.reused === "ref") {
        extractToDef(entry);
        continue;
      }
    }
  }
}
function finalize(ctx, schema) {
  var _a3, _b, _c;
  const root = ctx.seen.get(schema);
  if (!root)
    throw new Error("Unprocessed schema. This is a bug in Zod.");
  const flattenRef = (zodSchema) => {
    const seen = ctx.seen.get(zodSchema);
    if (seen.ref === null)
      return;
    const schema2 = seen.def ?? seen.schema;
    const _cached = { ...schema2 };
    const ref = seen.ref;
    seen.ref = null;
    if (ref) {
      flattenRef(ref);
      const refSeen = ctx.seen.get(ref);
      const refSchema = refSeen.schema;
      if (refSchema.$ref && (ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0")) {
        schema2.allOf = schema2.allOf ?? [];
        schema2.allOf.push(refSchema);
      } else {
        Object.assign(schema2, refSchema);
      }
      Object.assign(schema2, _cached);
      const isParentRef = zodSchema._zod.parent === ref;
      if (isParentRef) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (!(key in _cached)) {
            delete schema2[key];
          }
        }
      }
      if (refSchema.$ref && refSeen.def) {
        for (const key in schema2) {
          if (key === "$ref" || key === "allOf")
            continue;
          if (key in refSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(refSeen.def[key])) {
            delete schema2[key];
          }
        }
      }
    }
    const parent = zodSchema._zod.parent;
    if (parent && parent !== ref) {
      flattenRef(parent);
      const parentSeen = ctx.seen.get(parent);
      if (parentSeen == null ? void 0 : parentSeen.schema.$ref) {
        schema2.$ref = parentSeen.schema.$ref;
        if (parentSeen.def) {
          for (const key in schema2) {
            if (key === "$ref" || key === "allOf")
              continue;
            if (key in parentSeen.def && JSON.stringify(schema2[key]) === JSON.stringify(parentSeen.def[key])) {
              delete schema2[key];
            }
          }
        }
      }
    }
    ctx.override({
      zodSchema,
      jsonSchema: schema2,
      path: seen.path ?? []
    });
  };
  for (const entry of [...ctx.seen.entries()].reverse()) {
    flattenRef(entry[0]);
  }
  const result = {};
  if (ctx.target === "draft-2020-12") {
    result.$schema = "https://json-schema.org/draft/2020-12/schema";
  } else if (ctx.target === "draft-07") {
    result.$schema = "http://json-schema.org/draft-07/schema#";
  } else if (ctx.target === "draft-04") {
    result.$schema = "http://json-schema.org/draft-04/schema#";
  } else if (ctx.target === "openapi-3.0") {
  } else {
  }
  if ((_a3 = ctx.external) == null ? void 0 : _a3.uri) {
    const id = (_b = ctx.external.registry.get(schema)) == null ? void 0 : _b.id;
    if (!id)
      throw new Error("Schema is missing an `id` property");
    result.$id = ctx.external.uri(id);
  }
  Object.assign(result, root.def ?? root.schema);
  const defs = ((_c = ctx.external) == null ? void 0 : _c.defs) ?? {};
  for (const entry of ctx.seen.entries()) {
    const seen = entry[1];
    if (seen.def && seen.defId) {
      defs[seen.defId] = seen.def;
    }
  }
  if (ctx.external) {
  } else {
    if (Object.keys(defs).length > 0) {
      if (ctx.target === "draft-2020-12") {
        result.$defs = defs;
      } else {
        result.definitions = defs;
      }
    }
  }
  try {
    const finalized = JSON.parse(JSON.stringify(result));
    Object.defineProperty(finalized, "~standard", {
      value: {
        ...schema["~standard"],
        jsonSchema: {
          input: createStandardJSONSchemaMethod(schema, "input", ctx.processors),
          output: createStandardJSONSchemaMethod(schema, "output", ctx.processors)
        }
      },
      enumerable: false,
      writable: false
    });
    return finalized;
  } catch (_err) {
    throw new Error("Error converting schema to JSON.");
  }
}
function isTransforming(_schema, _ctx) {
  const ctx = _ctx ?? { seen: /* @__PURE__ */ new Set() };
  if (ctx.seen.has(_schema))
    return false;
  ctx.seen.add(_schema);
  const def = _schema._zod.def;
  if (def.type === "transform")
    return true;
  if (def.type === "array")
    return isTransforming(def.element, ctx);
  if (def.type === "set")
    return isTransforming(def.valueType, ctx);
  if (def.type === "lazy")
    return isTransforming(def.getter(), ctx);
  if (def.type === "promise" || def.type === "optional" || def.type === "nonoptional" || def.type === "nullable" || def.type === "readonly" || def.type === "default" || def.type === "prefault") {
    return isTransforming(def.innerType, ctx);
  }
  if (def.type === "intersection") {
    return isTransforming(def.left, ctx) || isTransforming(def.right, ctx);
  }
  if (def.type === "record" || def.type === "map") {
    return isTransforming(def.keyType, ctx) || isTransforming(def.valueType, ctx);
  }
  if (def.type === "pipe") {
    return isTransforming(def.in, ctx) || isTransforming(def.out, ctx);
  }
  if (def.type === "object") {
    for (const key in def.shape) {
      if (isTransforming(def.shape[key], ctx))
        return true;
    }
    return false;
  }
  if (def.type === "union") {
    for (const option of def.options) {
      if (isTransforming(option, ctx))
        return true;
    }
    return false;
  }
  if (def.type === "tuple") {
    for (const item of def.items) {
      if (isTransforming(item, ctx))
        return true;
    }
    if (def.rest && isTransforming(def.rest, ctx))
      return true;
    return false;
  }
  return false;
}
var createToJSONSchemaMethod = (schema, processors = {}) => (params) => {
  const ctx = initializeContext({ ...params, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};
var createStandardJSONSchemaMethod = (schema, io, processors = {}) => (params) => {
  const { libraryOptions, target } = params ?? {};
  const ctx = initializeContext({ ...libraryOptions ?? {}, target, io, processors });
  process2(schema, ctx);
  extractDefs(ctx, schema);
  return finalize(ctx, schema);
};

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/json-schema-processors.js
var formatMap = {
  guid: "uuid",
  url: "uri",
  datetime: "date-time",
  json_string: "json-string",
  regex: ""
  // do not set
};
var stringProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  json2.type = "string";
  const { minimum, maximum, format, patterns, contentEncoding } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minLength = minimum;
  if (typeof maximum === "number")
    json2.maxLength = maximum;
  if (format) {
    json2.format = formatMap[format] ?? format;
    if (json2.format === "")
      delete json2.format;
    if (format === "time") {
      delete json2.format;
    }
  }
  if (contentEncoding)
    json2.contentEncoding = contentEncoding;
  if (patterns && patterns.size > 0) {
    const regexes = [...patterns];
    if (regexes.length === 1)
      json2.pattern = regexes[0].source;
    else if (regexes.length > 1) {
      json2.allOf = [
        ...regexes.map((regex) => ({
          ...ctx.target === "draft-07" || ctx.target === "draft-04" || ctx.target === "openapi-3.0" ? { type: "string" } : {},
          pattern: regex.source
        }))
      ];
    }
  }
};
var numberProcessor = (schema, ctx, _json, _params) => {
  const json2 = _json;
  const { minimum, maximum, format, multipleOf, exclusiveMaximum, exclusiveMinimum } = schema._zod.bag;
  if (typeof format === "string" && format.includes("int"))
    json2.type = "integer";
  else
    json2.type = "number";
  if (typeof exclusiveMinimum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.minimum = exclusiveMinimum;
      json2.exclusiveMinimum = true;
    } else {
      json2.exclusiveMinimum = exclusiveMinimum;
    }
  }
  if (typeof minimum === "number") {
    json2.minimum = minimum;
    if (typeof exclusiveMinimum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMinimum >= minimum)
        delete json2.minimum;
      else
        delete json2.exclusiveMinimum;
    }
  }
  if (typeof exclusiveMaximum === "number") {
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.maximum = exclusiveMaximum;
      json2.exclusiveMaximum = true;
    } else {
      json2.exclusiveMaximum = exclusiveMaximum;
    }
  }
  if (typeof maximum === "number") {
    json2.maximum = maximum;
    if (typeof exclusiveMaximum === "number" && ctx.target !== "draft-04") {
      if (exclusiveMaximum <= maximum)
        delete json2.maximum;
      else
        delete json2.exclusiveMaximum;
    }
  }
  if (typeof multipleOf === "number")
    json2.multipleOf = multipleOf;
};
var booleanProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
var bigintProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("BigInt cannot be represented in JSON Schema");
  }
};
var symbolProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Symbols cannot be represented in JSON Schema");
  }
};
var nullProcessor = (_schema, ctx, json2, _params) => {
  if (ctx.target === "openapi-3.0") {
    json2.type = "string";
    json2.nullable = true;
    json2.enum = [null];
  } else {
    json2.type = "null";
  }
};
var undefinedProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Undefined cannot be represented in JSON Schema");
  }
};
var voidProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Void cannot be represented in JSON Schema");
  }
};
var neverProcessor = (_schema, _ctx, json2, _params) => {
  json2.not = {};
};
var anyProcessor = (_schema, _ctx, _json, _params) => {
};
var unknownProcessor = (_schema, _ctx, _json, _params) => {
};
var dateProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Date cannot be represented in JSON Schema");
  }
};
var enumProcessor = (schema, _ctx, json2, _params) => {
  const def = schema._zod.def;
  const values = getEnumValues(def.entries);
  if (values.every((v) => typeof v === "number"))
    json2.type = "number";
  if (values.every((v) => typeof v === "string"))
    json2.type = "string";
  json2.enum = values;
};
var literalProcessor = (schema, ctx, json2, _params) => {
  const def = schema._zod.def;
  const vals = [];
  for (const val of def.values) {
    if (val === void 0) {
      if (ctx.unrepresentable === "throw") {
        throw new Error("Literal `undefined` cannot be represented in JSON Schema");
      } else {
      }
    } else if (typeof val === "bigint") {
      if (ctx.unrepresentable === "throw") {
        throw new Error("BigInt literals cannot be represented in JSON Schema");
      } else {
        vals.push(Number(val));
      }
    } else {
      vals.push(val);
    }
  }
  if (vals.length === 0) {
  } else if (vals.length === 1) {
    const val = vals[0];
    json2.type = val === null ? "null" : typeof val;
    if (ctx.target === "draft-04" || ctx.target === "openapi-3.0") {
      json2.enum = [val];
    } else {
      json2.const = val;
    }
  } else {
    if (vals.every((v) => typeof v === "number"))
      json2.type = "number";
    if (vals.every((v) => typeof v === "string"))
      json2.type = "string";
    if (vals.every((v) => typeof v === "boolean"))
      json2.type = "boolean";
    if (vals.every((v) => v === null))
      json2.type = "null";
    json2.enum = vals;
  }
};
var nanProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("NaN cannot be represented in JSON Schema");
  }
};
var templateLiteralProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const pattern = schema._zod.pattern;
  if (!pattern)
    throw new Error("Pattern not found in template literal");
  _json.type = "string";
  _json.pattern = pattern.source;
};
var fileProcessor = (schema, _ctx, json2, _params) => {
  const _json = json2;
  const file2 = {
    type: "string",
    format: "binary",
    contentEncoding: "binary"
  };
  const { minimum, maximum, mime } = schema._zod.bag;
  if (minimum !== void 0)
    file2.minLength = minimum;
  if (maximum !== void 0)
    file2.maxLength = maximum;
  if (mime) {
    if (mime.length === 1) {
      file2.contentMediaType = mime[0];
      Object.assign(_json, file2);
    } else {
      Object.assign(_json, file2);
      _json.anyOf = mime.map((m) => ({ contentMediaType: m }));
    }
  } else {
    Object.assign(_json, file2);
  }
};
var successProcessor = (_schema, _ctx, json2, _params) => {
  json2.type = "boolean";
};
var customProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Custom types cannot be represented in JSON Schema");
  }
};
var functionProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Function types cannot be represented in JSON Schema");
  }
};
var transformProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Transforms cannot be represented in JSON Schema");
  }
};
var mapProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Map cannot be represented in JSON Schema");
  }
};
var setProcessor = (_schema, ctx, _json, _params) => {
  if (ctx.unrepresentable === "throw") {
    throw new Error("Set cannot be represented in JSON Schema");
  }
};
var arrayProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
  json2.type = "array";
  json2.items = process2(def.element, ctx, { ...params, path: [...params.path, "items"] });
};
var objectProcessor = (schema, ctx, _json, params) => {
  var _a3;
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  json2.properties = {};
  const shape = def.shape;
  for (const key in shape) {
    json2.properties[key] = process2(shape[key], ctx, {
      ...params,
      path: [...params.path, "properties", key]
    });
  }
  const allKeys = new Set(Object.keys(shape));
  const requiredKeys = new Set([...allKeys].filter((key) => {
    const v = def.shape[key]._zod;
    if (ctx.io === "input") {
      return v.optin === void 0;
    } else {
      return v.optout === void 0;
    }
  }));
  if (requiredKeys.size > 0) {
    json2.required = Array.from(requiredKeys);
  }
  if (((_a3 = def.catchall) == null ? void 0 : _a3._zod.def.type) === "never") {
    json2.additionalProperties = false;
  } else if (!def.catchall) {
    if (ctx.io === "output")
      json2.additionalProperties = false;
  } else if (def.catchall) {
    json2.additionalProperties = process2(def.catchall, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
};
var unionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const isExclusive = def.inclusive === false;
  const options = def.options.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, isExclusive ? "oneOf" : "anyOf", i]
  }));
  if (isExclusive) {
    json2.oneOf = options;
  } else {
    json2.anyOf = options;
  }
};
var intersectionProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const a = process2(def.left, ctx, {
    ...params,
    path: [...params.path, "allOf", 0]
  });
  const b = process2(def.right, ctx, {
    ...params,
    path: [...params.path, "allOf", 1]
  });
  const isSimpleIntersection = (val) => "allOf" in val && Object.keys(val).length === 1;
  const allOf = [
    ...isSimpleIntersection(a) ? a.allOf : [a],
    ...isSimpleIntersection(b) ? b.allOf : [b]
  ];
  json2.allOf = allOf;
};
var tupleProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "array";
  const prefixPath = ctx.target === "draft-2020-12" ? "prefixItems" : "items";
  const restPath = ctx.target === "draft-2020-12" ? "items" : ctx.target === "openapi-3.0" ? "items" : "additionalItems";
  const prefixItems = def.items.map((x, i) => process2(x, ctx, {
    ...params,
    path: [...params.path, prefixPath, i]
  }));
  const rest = def.rest ? process2(def.rest, ctx, {
    ...params,
    path: [...params.path, restPath, ...ctx.target === "openapi-3.0" ? [def.items.length] : []]
  }) : null;
  if (ctx.target === "draft-2020-12") {
    json2.prefixItems = prefixItems;
    if (rest) {
      json2.items = rest;
    }
  } else if (ctx.target === "openapi-3.0") {
    json2.items = {
      anyOf: prefixItems
    };
    if (rest) {
      json2.items.anyOf.push(rest);
    }
    json2.minItems = prefixItems.length;
    if (!rest) {
      json2.maxItems = prefixItems.length;
    }
  } else {
    json2.items = prefixItems;
    if (rest) {
      json2.additionalItems = rest;
    }
  }
  const { minimum, maximum } = schema._zod.bag;
  if (typeof minimum === "number")
    json2.minItems = minimum;
  if (typeof maximum === "number")
    json2.maxItems = maximum;
};
var recordProcessor = (schema, ctx, _json, params) => {
  const json2 = _json;
  const def = schema._zod.def;
  json2.type = "object";
  const keyType = def.keyType;
  const keyBag = keyType._zod.bag;
  const patterns = keyBag == null ? void 0 : keyBag.patterns;
  if (def.mode === "loose" && patterns && patterns.size > 0) {
    const valueSchema = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "patternProperties", "*"]
    });
    json2.patternProperties = {};
    for (const pattern of patterns) {
      json2.patternProperties[pattern.source] = valueSchema;
    }
  } else {
    if (ctx.target === "draft-07" || ctx.target === "draft-2020-12") {
      json2.propertyNames = process2(def.keyType, ctx, {
        ...params,
        path: [...params.path, "propertyNames"]
      });
    }
    json2.additionalProperties = process2(def.valueType, ctx, {
      ...params,
      path: [...params.path, "additionalProperties"]
    });
  }
  const keyValues = keyType._zod.values;
  if (keyValues) {
    const validKeyValues = [...keyValues].filter((v) => typeof v === "string" || typeof v === "number");
    if (validKeyValues.length > 0) {
      json2.required = validKeyValues;
    }
  }
};
var nullableProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  const inner = process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  if (ctx.target === "openapi-3.0") {
    seen.ref = def.innerType;
    json2.nullable = true;
  } else {
    json2.anyOf = [inner, { type: "null" }];
  }
};
var nonoptionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var defaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json2.default = JSON.parse(JSON.stringify(def.defaultValue));
};
var prefaultProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  if (ctx.io === "input")
    json2._prefault = JSON.parse(JSON.stringify(def.defaultValue));
};
var catchProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  let catchValue;
  try {
    catchValue = def.catchValue(void 0);
  } catch {
    throw new Error("Dynamic catch values are not supported in JSON Schema");
  }
  json2.default = catchValue;
};
var pipeProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  const innerType = ctx.io === "input" ? def.in._zod.def.type === "transform" ? def.out : def.in : def.out;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var readonlyProcessor = (schema, ctx, json2, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
  json2.readOnly = true;
};
var promiseProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var optionalProcessor = (schema, ctx, _json, params) => {
  const def = schema._zod.def;
  process2(def.innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = def.innerType;
};
var lazyProcessor = (schema, ctx, _json, params) => {
  const innerType = schema._zod.innerType;
  process2(innerType, ctx, params);
  const seen = ctx.seen.get(schema);
  seen.ref = innerType;
};
var allProcessors = {
  string: stringProcessor,
  number: numberProcessor,
  boolean: booleanProcessor,
  bigint: bigintProcessor,
  symbol: symbolProcessor,
  null: nullProcessor,
  undefined: undefinedProcessor,
  void: voidProcessor,
  never: neverProcessor,
  any: anyProcessor,
  unknown: unknownProcessor,
  date: dateProcessor,
  enum: enumProcessor,
  literal: literalProcessor,
  nan: nanProcessor,
  template_literal: templateLiteralProcessor,
  file: fileProcessor,
  success: successProcessor,
  custom: customProcessor,
  function: functionProcessor,
  transform: transformProcessor,
  map: mapProcessor,
  set: setProcessor,
  array: arrayProcessor,
  object: objectProcessor,
  union: unionProcessor,
  intersection: intersectionProcessor,
  tuple: tupleProcessor,
  record: recordProcessor,
  nullable: nullableProcessor,
  nonoptional: nonoptionalProcessor,
  default: defaultProcessor,
  prefault: prefaultProcessor,
  catch: catchProcessor,
  pipe: pipeProcessor,
  readonly: readonlyProcessor,
  promise: promiseProcessor,
  optional: optionalProcessor,
  lazy: lazyProcessor
};
function toJSONSchema2(input, params) {
  if ("_idmap" in input) {
    const registry2 = input;
    const ctx2 = initializeContext({ ...params, processors: allProcessors });
    const defs = {};
    for (const entry of registry2._idmap.entries()) {
      const [_, schema] = entry;
      process2(schema, ctx2);
    }
    const schemas = {};
    const external = {
      registry: registry2,
      uri: params == null ? void 0 : params.uri,
      defs
    };
    ctx2.external = external;
    for (const entry of registry2._idmap.entries()) {
      const [key, schema] = entry;
      extractDefs(ctx2, schema);
      schemas[key] = finalize(ctx2, schema);
    }
    if (Object.keys(defs).length > 0) {
      const defsSegment = ctx2.target === "draft-2020-12" ? "$defs" : "definitions";
      schemas.__shared = {
        [defsSegment]: defs
      };
    }
    return { schemas };
  }
  const ctx = initializeContext({ ...params, processors: allProcessors });
  process2(input, ctx);
  extractDefs(ctx, input);
  return finalize(ctx, input);
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/json-schema-generator.js
var JSONSchemaGenerator = class {
  /** @deprecated Access via ctx instead */
  get metadataRegistry() {
    return this.ctx.metadataRegistry;
  }
  /** @deprecated Access via ctx instead */
  get target() {
    return this.ctx.target;
  }
  /** @deprecated Access via ctx instead */
  get unrepresentable() {
    return this.ctx.unrepresentable;
  }
  /** @deprecated Access via ctx instead */
  get override() {
    return this.ctx.override;
  }
  /** @deprecated Access via ctx instead */
  get io() {
    return this.ctx.io;
  }
  /** @deprecated Access via ctx instead */
  get counter() {
    return this.ctx.counter;
  }
  set counter(value) {
    this.ctx.counter = value;
  }
  /** @deprecated Access via ctx instead */
  get seen() {
    return this.ctx.seen;
  }
  constructor(params) {
    let normalizedTarget = (params == null ? void 0 : params.target) ?? "draft-2020-12";
    if (normalizedTarget === "draft-4")
      normalizedTarget = "draft-04";
    if (normalizedTarget === "draft-7")
      normalizedTarget = "draft-07";
    this.ctx = initializeContext({
      processors: allProcessors,
      target: normalizedTarget,
      ...(params == null ? void 0 : params.metadata) && { metadata: params.metadata },
      ...(params == null ? void 0 : params.unrepresentable) && { unrepresentable: params.unrepresentable },
      ...(params == null ? void 0 : params.override) && { override: params.override },
      ...(params == null ? void 0 : params.io) && { io: params.io }
    });
  }
  /**
   * Process a schema to prepare it for JSON Schema generation.
   * This must be called before emit().
   */
  process(schema, _params = { path: [], schemaPath: [] }) {
    return process2(schema, this.ctx, _params);
  }
  /**
   * Emit the final JSON Schema after processing.
   * Must call process() first.
   */
  emit(schema, _params) {
    if (_params) {
      if (_params.cycles)
        this.ctx.cycles = _params.cycles;
      if (_params.reused)
        this.ctx.reused = _params.reused;
      if (_params.external)
        this.ctx.external = _params.external;
    }
    extractDefs(this.ctx, schema);
    const result = finalize(this.ctx, schema);
    const { "~standard": _, ...plainResult } = result;
    return plainResult;
  }
};

// node_modules/@assistant-ui/react/node_modules/zod/v4/core/json-schema.js
var json_schema_exports = {};

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/schemas.js
var schemas_exports2 = {};
__export(schemas_exports2, {
  ZodAny: () => ZodAny,
  ZodArray: () => ZodArray,
  ZodBase64: () => ZodBase64,
  ZodBase64URL: () => ZodBase64URL,
  ZodBigInt: () => ZodBigInt,
  ZodBigIntFormat: () => ZodBigIntFormat,
  ZodBoolean: () => ZodBoolean,
  ZodCIDRv4: () => ZodCIDRv4,
  ZodCIDRv6: () => ZodCIDRv6,
  ZodCUID: () => ZodCUID,
  ZodCUID2: () => ZodCUID2,
  ZodCatch: () => ZodCatch,
  ZodCodec: () => ZodCodec,
  ZodCustom: () => ZodCustom,
  ZodCustomStringFormat: () => ZodCustomStringFormat,
  ZodDate: () => ZodDate,
  ZodDefault: () => ZodDefault,
  ZodDiscriminatedUnion: () => ZodDiscriminatedUnion,
  ZodE164: () => ZodE164,
  ZodEmail: () => ZodEmail,
  ZodEmoji: () => ZodEmoji,
  ZodEnum: () => ZodEnum,
  ZodExactOptional: () => ZodExactOptional,
  ZodFile: () => ZodFile,
  ZodFunction: () => ZodFunction,
  ZodGUID: () => ZodGUID,
  ZodIPv4: () => ZodIPv4,
  ZodIPv6: () => ZodIPv6,
  ZodIntersection: () => ZodIntersection,
  ZodJWT: () => ZodJWT,
  ZodKSUID: () => ZodKSUID,
  ZodLazy: () => ZodLazy,
  ZodLiteral: () => ZodLiteral,
  ZodMAC: () => ZodMAC,
  ZodMap: () => ZodMap,
  ZodNaN: () => ZodNaN,
  ZodNanoID: () => ZodNanoID,
  ZodNever: () => ZodNever,
  ZodNonOptional: () => ZodNonOptional,
  ZodNull: () => ZodNull,
  ZodNullable: () => ZodNullable,
  ZodNumber: () => ZodNumber,
  ZodNumberFormat: () => ZodNumberFormat,
  ZodObject: () => ZodObject,
  ZodOptional: () => ZodOptional,
  ZodPipe: () => ZodPipe,
  ZodPrefault: () => ZodPrefault,
  ZodPromise: () => ZodPromise,
  ZodReadonly: () => ZodReadonly,
  ZodRecord: () => ZodRecord,
  ZodSet: () => ZodSet,
  ZodString: () => ZodString,
  ZodStringFormat: () => ZodStringFormat,
  ZodSuccess: () => ZodSuccess,
  ZodSymbol: () => ZodSymbol,
  ZodTemplateLiteral: () => ZodTemplateLiteral,
  ZodTransform: () => ZodTransform,
  ZodTuple: () => ZodTuple,
  ZodType: () => ZodType,
  ZodULID: () => ZodULID,
  ZodURL: () => ZodURL,
  ZodUUID: () => ZodUUID,
  ZodUndefined: () => ZodUndefined,
  ZodUnion: () => ZodUnion,
  ZodUnknown: () => ZodUnknown,
  ZodVoid: () => ZodVoid,
  ZodXID: () => ZodXID,
  ZodXor: () => ZodXor,
  _ZodString: () => _ZodString,
  _default: () => _default2,
  _function: () => _function,
  any: () => any,
  array: () => array,
  base64: () => base642,
  base64url: () => base64url2,
  bigint: () => bigint2,
  boolean: () => boolean2,
  catch: () => _catch2,
  check: () => check,
  cidrv4: () => cidrv42,
  cidrv6: () => cidrv62,
  codec: () => codec,
  cuid: () => cuid3,
  cuid2: () => cuid22,
  custom: () => custom,
  date: () => date3,
  describe: () => describe2,
  discriminatedUnion: () => discriminatedUnion,
  e164: () => e1642,
  email: () => email2,
  emoji: () => emoji2,
  enum: () => _enum2,
  exactOptional: () => exactOptional,
  file: () => file,
  float32: () => float32,
  float64: () => float64,
  function: () => _function,
  guid: () => guid2,
  hash: () => hash,
  hex: () => hex2,
  hostname: () => hostname2,
  httpUrl: () => httpUrl,
  instanceof: () => _instanceof,
  int: () => int,
  int32: () => int32,
  int64: () => int64,
  intersection: () => intersection,
  ipv4: () => ipv42,
  ipv6: () => ipv62,
  json: () => json,
  jwt: () => jwt,
  keyof: () => keyof,
  ksuid: () => ksuid2,
  lazy: () => lazy,
  literal: () => literal,
  looseObject: () => looseObject,
  looseRecord: () => looseRecord,
  mac: () => mac2,
  map: () => map,
  meta: () => meta2,
  nan: () => nan,
  nanoid: () => nanoid2,
  nativeEnum: () => nativeEnum,
  never: () => never,
  nonoptional: () => nonoptional,
  null: () => _null3,
  nullable: () => nullable,
  nullish: () => nullish2,
  number: () => number2,
  object: () => object,
  optional: () => optional,
  partialRecord: () => partialRecord,
  pipe: () => pipe,
  prefault: () => prefault,
  preprocess: () => preprocess,
  promise: () => promise,
  readonly: () => readonly,
  record: () => record,
  refine: () => refine,
  set: () => set,
  strictObject: () => strictObject,
  string: () => string2,
  stringFormat: () => stringFormat,
  stringbool: () => stringbool,
  success: () => success,
  superRefine: () => superRefine,
  symbol: () => symbol,
  templateLiteral: () => templateLiteral,
  transform: () => transform,
  tuple: () => tuple,
  uint32: () => uint32,
  uint64: () => uint64,
  ulid: () => ulid2,
  undefined: () => _undefined3,
  union: () => union,
  unknown: () => unknown,
  url: () => url,
  uuid: () => uuid2,
  uuidv4: () => uuidv4,
  uuidv6: () => uuidv6,
  uuidv7: () => uuidv7,
  void: () => _void2,
  xid: () => xid2,
  xor: () => xor
});

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/checks.js
var checks_exports2 = {};
__export(checks_exports2, {
  endsWith: () => _endsWith,
  gt: () => _gt,
  gte: () => _gte,
  includes: () => _includes,
  length: () => _length,
  lowercase: () => _lowercase,
  lt: () => _lt,
  lte: () => _lte,
  maxLength: () => _maxLength,
  maxSize: () => _maxSize,
  mime: () => _mime,
  minLength: () => _minLength,
  minSize: () => _minSize,
  multipleOf: () => _multipleOf,
  negative: () => _negative,
  nonnegative: () => _nonnegative,
  nonpositive: () => _nonpositive,
  normalize: () => _normalize,
  overwrite: () => _overwrite,
  positive: () => _positive,
  property: () => _property,
  regex: () => _regex,
  size: () => _size,
  slugify: () => _slugify,
  startsWith: () => _startsWith,
  toLowerCase: () => _toLowerCase,
  toUpperCase: () => _toUpperCase,
  trim: () => _trim,
  uppercase: () => _uppercase
});

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/iso.js
var iso_exports = {};
__export(iso_exports, {
  ZodISODate: () => ZodISODate,
  ZodISODateTime: () => ZodISODateTime,
  ZodISODuration: () => ZodISODuration,
  ZodISOTime: () => ZodISOTime,
  date: () => date2,
  datetime: () => datetime2,
  duration: () => duration2,
  time: () => time2
});
var ZodISODateTime = $constructor("ZodISODateTime", (inst, def) => {
  $ZodISODateTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function datetime2(params) {
  return _isoDateTime(ZodISODateTime, params);
}
var ZodISODate = $constructor("ZodISODate", (inst, def) => {
  $ZodISODate.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function date2(params) {
  return _isoDate(ZodISODate, params);
}
var ZodISOTime = $constructor("ZodISOTime", (inst, def) => {
  $ZodISOTime.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function time2(params) {
  return _isoTime(ZodISOTime, params);
}
var ZodISODuration = $constructor("ZodISODuration", (inst, def) => {
  $ZodISODuration.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function duration2(params) {
  return _isoDuration(ZodISODuration, params);
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/errors.js
var initializer2 = (inst, issues) => {
  $ZodError.init(inst, issues);
  inst.name = "ZodError";
  Object.defineProperties(inst, {
    format: {
      value: (mapper) => formatError(inst, mapper)
      // enumerable: false,
    },
    flatten: {
      value: (mapper) => flattenError(inst, mapper)
      // enumerable: false,
    },
    addIssue: {
      value: (issue2) => {
        inst.issues.push(issue2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    addIssues: {
      value: (issues2) => {
        inst.issues.push(...issues2);
        inst.message = JSON.stringify(inst.issues, jsonStringifyReplacer, 2);
      }
      // enumerable: false,
    },
    isEmpty: {
      get() {
        return inst.issues.length === 0;
      }
      // enumerable: false,
    }
  });
};
var ZodError = $constructor("ZodError", initializer2);
var ZodRealError = $constructor("ZodError", initializer2, {
  Parent: Error
});

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/parse.js
var parse2 = _parse(ZodRealError);
var parseAsync2 = _parseAsync(ZodRealError);
var safeParse2 = _safeParse(ZodRealError);
var safeParseAsync2 = _safeParseAsync(ZodRealError);
var encode2 = _encode(ZodRealError);
var decode2 = _decode(ZodRealError);
var encodeAsync2 = _encodeAsync(ZodRealError);
var decodeAsync2 = _decodeAsync(ZodRealError);
var safeEncode2 = _safeEncode(ZodRealError);
var safeDecode2 = _safeDecode(ZodRealError);
var safeEncodeAsync2 = _safeEncodeAsync(ZodRealError);
var safeDecodeAsync2 = _safeDecodeAsync(ZodRealError);

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/schemas.js
var ZodType = $constructor("ZodType", (inst, def) => {
  $ZodType.init(inst, def);
  Object.assign(inst["~standard"], {
    jsonSchema: {
      input: createStandardJSONSchemaMethod(inst, "input"),
      output: createStandardJSONSchemaMethod(inst, "output")
    }
  });
  inst.toJSONSchema = createToJSONSchemaMethod(inst, {});
  inst.def = def;
  inst.type = def.type;
  Object.defineProperty(inst, "_def", { value: def });
  inst.check = (...checks) => {
    return inst.clone(util_exports.mergeDefs(def, {
      checks: [
        ...def.checks ?? [],
        ...checks.map((ch) => typeof ch === "function" ? { _zod: { check: ch, def: { check: "custom" }, onattach: [] } } : ch)
      ]
    }), {
      parent: true
    });
  };
  inst.with = inst.check;
  inst.clone = (def2, params) => clone(inst, def2, params);
  inst.brand = () => inst;
  inst.register = (reg, meta3) => {
    reg.add(inst, meta3);
    return inst;
  };
  inst.parse = (data, params) => parse2(inst, data, params, { callee: inst.parse });
  inst.safeParse = (data, params) => safeParse2(inst, data, params);
  inst.parseAsync = async (data, params) => parseAsync2(inst, data, params, { callee: inst.parseAsync });
  inst.safeParseAsync = async (data, params) => safeParseAsync2(inst, data, params);
  inst.spa = inst.safeParseAsync;
  inst.encode = (data, params) => encode2(inst, data, params);
  inst.decode = (data, params) => decode2(inst, data, params);
  inst.encodeAsync = async (data, params) => encodeAsync2(inst, data, params);
  inst.decodeAsync = async (data, params) => decodeAsync2(inst, data, params);
  inst.safeEncode = (data, params) => safeEncode2(inst, data, params);
  inst.safeDecode = (data, params) => safeDecode2(inst, data, params);
  inst.safeEncodeAsync = async (data, params) => safeEncodeAsync2(inst, data, params);
  inst.safeDecodeAsync = async (data, params) => safeDecodeAsync2(inst, data, params);
  inst.refine = (check2, params) => inst.check(refine(check2, params));
  inst.superRefine = (refinement) => inst.check(superRefine(refinement));
  inst.overwrite = (fn) => inst.check(_overwrite(fn));
  inst.optional = () => optional(inst);
  inst.exactOptional = () => exactOptional(inst);
  inst.nullable = () => nullable(inst);
  inst.nullish = () => optional(nullable(inst));
  inst.nonoptional = (params) => nonoptional(inst, params);
  inst.array = () => array(inst);
  inst.or = (arg) => union([inst, arg]);
  inst.and = (arg) => intersection(inst, arg);
  inst.transform = (tx) => pipe(inst, transform(tx));
  inst.default = (def2) => _default2(inst, def2);
  inst.prefault = (def2) => prefault(inst, def2);
  inst.catch = (params) => _catch2(inst, params);
  inst.pipe = (target) => pipe(inst, target);
  inst.readonly = () => readonly(inst);
  inst.describe = (description) => {
    const cl = inst.clone();
    globalRegistry.add(cl, { description });
    return cl;
  };
  Object.defineProperty(inst, "description", {
    get() {
      var _a3;
      return (_a3 = globalRegistry.get(inst)) == null ? void 0 : _a3.description;
    },
    configurable: true
  });
  inst.meta = (...args) => {
    if (args.length === 0) {
      return globalRegistry.get(inst);
    }
    const cl = inst.clone();
    globalRegistry.add(cl, args[0]);
    return cl;
  };
  inst.isOptional = () => inst.safeParse(void 0).success;
  inst.isNullable = () => inst.safeParse(null).success;
  inst.apply = (fn) => fn(inst);
  return inst;
});
var _ZodString = $constructor("_ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => stringProcessor(inst, ctx, json2, params);
  const bag = inst._zod.bag;
  inst.format = bag.format ?? null;
  inst.minLength = bag.minimum ?? null;
  inst.maxLength = bag.maximum ?? null;
  inst.regex = (...args) => inst.check(_regex(...args));
  inst.includes = (...args) => inst.check(_includes(...args));
  inst.startsWith = (...args) => inst.check(_startsWith(...args));
  inst.endsWith = (...args) => inst.check(_endsWith(...args));
  inst.min = (...args) => inst.check(_minLength(...args));
  inst.max = (...args) => inst.check(_maxLength(...args));
  inst.length = (...args) => inst.check(_length(...args));
  inst.nonempty = (...args) => inst.check(_minLength(1, ...args));
  inst.lowercase = (params) => inst.check(_lowercase(params));
  inst.uppercase = (params) => inst.check(_uppercase(params));
  inst.trim = () => inst.check(_trim());
  inst.normalize = (...args) => inst.check(_normalize(...args));
  inst.toLowerCase = () => inst.check(_toLowerCase());
  inst.toUpperCase = () => inst.check(_toUpperCase());
  inst.slugify = () => inst.check(_slugify());
});
var ZodString = $constructor("ZodString", (inst, def) => {
  $ZodString.init(inst, def);
  _ZodString.init(inst, def);
  inst.email = (params) => inst.check(_email(ZodEmail, params));
  inst.url = (params) => inst.check(_url(ZodURL, params));
  inst.jwt = (params) => inst.check(_jwt(ZodJWT, params));
  inst.emoji = (params) => inst.check(_emoji2(ZodEmoji, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.uuid = (params) => inst.check(_uuid(ZodUUID, params));
  inst.uuidv4 = (params) => inst.check(_uuidv4(ZodUUID, params));
  inst.uuidv6 = (params) => inst.check(_uuidv6(ZodUUID, params));
  inst.uuidv7 = (params) => inst.check(_uuidv7(ZodUUID, params));
  inst.nanoid = (params) => inst.check(_nanoid(ZodNanoID, params));
  inst.guid = (params) => inst.check(_guid(ZodGUID, params));
  inst.cuid = (params) => inst.check(_cuid(ZodCUID, params));
  inst.cuid2 = (params) => inst.check(_cuid2(ZodCUID2, params));
  inst.ulid = (params) => inst.check(_ulid(ZodULID, params));
  inst.base64 = (params) => inst.check(_base64(ZodBase64, params));
  inst.base64url = (params) => inst.check(_base64url(ZodBase64URL, params));
  inst.xid = (params) => inst.check(_xid(ZodXID, params));
  inst.ksuid = (params) => inst.check(_ksuid(ZodKSUID, params));
  inst.ipv4 = (params) => inst.check(_ipv4(ZodIPv4, params));
  inst.ipv6 = (params) => inst.check(_ipv6(ZodIPv6, params));
  inst.cidrv4 = (params) => inst.check(_cidrv4(ZodCIDRv4, params));
  inst.cidrv6 = (params) => inst.check(_cidrv6(ZodCIDRv6, params));
  inst.e164 = (params) => inst.check(_e164(ZodE164, params));
  inst.datetime = (params) => inst.check(datetime2(params));
  inst.date = (params) => inst.check(date2(params));
  inst.time = (params) => inst.check(time2(params));
  inst.duration = (params) => inst.check(duration2(params));
});
function string2(params) {
  return _string(ZodString, params);
}
var ZodStringFormat = $constructor("ZodStringFormat", (inst, def) => {
  $ZodStringFormat.init(inst, def);
  _ZodString.init(inst, def);
});
var ZodEmail = $constructor("ZodEmail", (inst, def) => {
  $ZodEmail.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function email2(params) {
  return _email(ZodEmail, params);
}
var ZodGUID = $constructor("ZodGUID", (inst, def) => {
  $ZodGUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function guid2(params) {
  return _guid(ZodGUID, params);
}
var ZodUUID = $constructor("ZodUUID", (inst, def) => {
  $ZodUUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function uuid2(params) {
  return _uuid(ZodUUID, params);
}
function uuidv4(params) {
  return _uuidv4(ZodUUID, params);
}
function uuidv6(params) {
  return _uuidv6(ZodUUID, params);
}
function uuidv7(params) {
  return _uuidv7(ZodUUID, params);
}
var ZodURL = $constructor("ZodURL", (inst, def) => {
  $ZodURL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function url(params) {
  return _url(ZodURL, params);
}
function httpUrl(params) {
  return _url(ZodURL, {
    protocol: /^https?$/,
    hostname: regexes_exports.domain,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEmoji = $constructor("ZodEmoji", (inst, def) => {
  $ZodEmoji.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function emoji2(params) {
  return _emoji2(ZodEmoji, params);
}
var ZodNanoID = $constructor("ZodNanoID", (inst, def) => {
  $ZodNanoID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function nanoid2(params) {
  return _nanoid(ZodNanoID, params);
}
var ZodCUID = $constructor("ZodCUID", (inst, def) => {
  $ZodCUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid3(params) {
  return _cuid(ZodCUID, params);
}
var ZodCUID2 = $constructor("ZodCUID2", (inst, def) => {
  $ZodCUID2.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cuid22(params) {
  return _cuid2(ZodCUID2, params);
}
var ZodULID = $constructor("ZodULID", (inst, def) => {
  $ZodULID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ulid2(params) {
  return _ulid(ZodULID, params);
}
var ZodXID = $constructor("ZodXID", (inst, def) => {
  $ZodXID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function xid2(params) {
  return _xid(ZodXID, params);
}
var ZodKSUID = $constructor("ZodKSUID", (inst, def) => {
  $ZodKSUID.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ksuid2(params) {
  return _ksuid(ZodKSUID, params);
}
var ZodIPv4 = $constructor("ZodIPv4", (inst, def) => {
  $ZodIPv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv42(params) {
  return _ipv4(ZodIPv4, params);
}
var ZodMAC = $constructor("ZodMAC", (inst, def) => {
  $ZodMAC.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function mac2(params) {
  return _mac(ZodMAC, params);
}
var ZodIPv6 = $constructor("ZodIPv6", (inst, def) => {
  $ZodIPv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function ipv62(params) {
  return _ipv6(ZodIPv6, params);
}
var ZodCIDRv4 = $constructor("ZodCIDRv4", (inst, def) => {
  $ZodCIDRv4.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv42(params) {
  return _cidrv4(ZodCIDRv4, params);
}
var ZodCIDRv6 = $constructor("ZodCIDRv6", (inst, def) => {
  $ZodCIDRv6.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function cidrv62(params) {
  return _cidrv6(ZodCIDRv6, params);
}
var ZodBase64 = $constructor("ZodBase64", (inst, def) => {
  $ZodBase64.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base642(params) {
  return _base64(ZodBase64, params);
}
var ZodBase64URL = $constructor("ZodBase64URL", (inst, def) => {
  $ZodBase64URL.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function base64url2(params) {
  return _base64url(ZodBase64URL, params);
}
var ZodE164 = $constructor("ZodE164", (inst, def) => {
  $ZodE164.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function e1642(params) {
  return _e164(ZodE164, params);
}
var ZodJWT = $constructor("ZodJWT", (inst, def) => {
  $ZodJWT.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function jwt(params) {
  return _jwt(ZodJWT, params);
}
var ZodCustomStringFormat = $constructor("ZodCustomStringFormat", (inst, def) => {
  $ZodCustomStringFormat.init(inst, def);
  ZodStringFormat.init(inst, def);
});
function stringFormat(format, fnOrRegex, _params = {}) {
  return _stringFormat(ZodCustomStringFormat, format, fnOrRegex, _params);
}
function hostname2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hostname", regexes_exports.hostname, _params);
}
function hex2(_params) {
  return _stringFormat(ZodCustomStringFormat, "hex", regexes_exports.hex, _params);
}
function hash(alg, params) {
  const enc = (params == null ? void 0 : params.enc) ?? "hex";
  const format = `${alg}_${enc}`;
  const regex = regexes_exports[format];
  if (!regex)
    throw new Error(`Unrecognized hash format: ${format}`);
  return _stringFormat(ZodCustomStringFormat, format, regex, params);
}
var ZodNumber = $constructor("ZodNumber", (inst, def) => {
  $ZodNumber.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => numberProcessor(inst, ctx, json2, params);
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.int = (params) => inst.check(int(params));
  inst.safe = (params) => inst.check(int(params));
  inst.positive = (params) => inst.check(_gt(0, params));
  inst.nonnegative = (params) => inst.check(_gte(0, params));
  inst.negative = (params) => inst.check(_lt(0, params));
  inst.nonpositive = (params) => inst.check(_lte(0, params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  inst.step = (value, params) => inst.check(_multipleOf(value, params));
  inst.finite = () => inst;
  const bag = inst._zod.bag;
  inst.minValue = Math.max(bag.minimum ?? Number.NEGATIVE_INFINITY, bag.exclusiveMinimum ?? Number.NEGATIVE_INFINITY) ?? null;
  inst.maxValue = Math.min(bag.maximum ?? Number.POSITIVE_INFINITY, bag.exclusiveMaximum ?? Number.POSITIVE_INFINITY) ?? null;
  inst.isInt = (bag.format ?? "").includes("int") || Number.isSafeInteger(bag.multipleOf ?? 0.5);
  inst.isFinite = true;
  inst.format = bag.format ?? null;
});
function number2(params) {
  return _number(ZodNumber, params);
}
var ZodNumberFormat = $constructor("ZodNumberFormat", (inst, def) => {
  $ZodNumberFormat.init(inst, def);
  ZodNumber.init(inst, def);
});
function int(params) {
  return _int(ZodNumberFormat, params);
}
function float32(params) {
  return _float32(ZodNumberFormat, params);
}
function float64(params) {
  return _float64(ZodNumberFormat, params);
}
function int32(params) {
  return _int32(ZodNumberFormat, params);
}
function uint32(params) {
  return _uint32(ZodNumberFormat, params);
}
var ZodBoolean = $constructor("ZodBoolean", (inst, def) => {
  $ZodBoolean.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => booleanProcessor(inst, ctx, json2, params);
});
function boolean2(params) {
  return _boolean(ZodBoolean, params);
}
var ZodBigInt = $constructor("ZodBigInt", (inst, def) => {
  $ZodBigInt.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => bigintProcessor(inst, ctx, json2, params);
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.gt = (value, params) => inst.check(_gt(value, params));
  inst.gte = (value, params) => inst.check(_gte(value, params));
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.lt = (value, params) => inst.check(_lt(value, params));
  inst.lte = (value, params) => inst.check(_lte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  inst.positive = (params) => inst.check(_gt(BigInt(0), params));
  inst.negative = (params) => inst.check(_lt(BigInt(0), params));
  inst.nonpositive = (params) => inst.check(_lte(BigInt(0), params));
  inst.nonnegative = (params) => inst.check(_gte(BigInt(0), params));
  inst.multipleOf = (value, params) => inst.check(_multipleOf(value, params));
  const bag = inst._zod.bag;
  inst.minValue = bag.minimum ?? null;
  inst.maxValue = bag.maximum ?? null;
  inst.format = bag.format ?? null;
});
function bigint2(params) {
  return _bigint(ZodBigInt, params);
}
var ZodBigIntFormat = $constructor("ZodBigIntFormat", (inst, def) => {
  $ZodBigIntFormat.init(inst, def);
  ZodBigInt.init(inst, def);
});
function int64(params) {
  return _int64(ZodBigIntFormat, params);
}
function uint64(params) {
  return _uint64(ZodBigIntFormat, params);
}
var ZodSymbol = $constructor("ZodSymbol", (inst, def) => {
  $ZodSymbol.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => symbolProcessor(inst, ctx, json2, params);
});
function symbol(params) {
  return _symbol(ZodSymbol, params);
}
var ZodUndefined = $constructor("ZodUndefined", (inst, def) => {
  $ZodUndefined.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => undefinedProcessor(inst, ctx, json2, params);
});
function _undefined3(params) {
  return _undefined2(ZodUndefined, params);
}
var ZodNull = $constructor("ZodNull", (inst, def) => {
  $ZodNull.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullProcessor(inst, ctx, json2, params);
});
function _null3(params) {
  return _null2(ZodNull, params);
}
var ZodAny = $constructor("ZodAny", (inst, def) => {
  $ZodAny.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => anyProcessor(inst, ctx, json2, params);
});
function any() {
  return _any(ZodAny);
}
var ZodUnknown = $constructor("ZodUnknown", (inst, def) => {
  $ZodUnknown.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unknownProcessor(inst, ctx, json2, params);
});
function unknown() {
  return _unknown(ZodUnknown);
}
var ZodNever = $constructor("ZodNever", (inst, def) => {
  $ZodNever.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => neverProcessor(inst, ctx, json2, params);
});
function never(params) {
  return _never(ZodNever, params);
}
var ZodVoid = $constructor("ZodVoid", (inst, def) => {
  $ZodVoid.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => voidProcessor(inst, ctx, json2, params);
});
function _void2(params) {
  return _void(ZodVoid, params);
}
var ZodDate = $constructor("ZodDate", (inst, def) => {
  $ZodDate.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => dateProcessor(inst, ctx, json2, params);
  inst.min = (value, params) => inst.check(_gte(value, params));
  inst.max = (value, params) => inst.check(_lte(value, params));
  const c = inst._zod.bag;
  inst.minDate = c.minimum ? new Date(c.minimum) : null;
  inst.maxDate = c.maximum ? new Date(c.maximum) : null;
});
function date3(params) {
  return _date(ZodDate, params);
}
var ZodArray = $constructor("ZodArray", (inst, def) => {
  $ZodArray.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => arrayProcessor(inst, ctx, json2, params);
  inst.element = def.element;
  inst.min = (minLength, params) => inst.check(_minLength(minLength, params));
  inst.nonempty = (params) => inst.check(_minLength(1, params));
  inst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));
  inst.length = (len, params) => inst.check(_length(len, params));
  inst.unwrap = () => inst.element;
});
function array(element, params) {
  return _array(ZodArray, element, params);
}
function keyof(schema) {
  const shape = schema._zod.def.shape;
  return _enum2(Object.keys(shape));
}
var ZodObject = $constructor("ZodObject", (inst, def) => {
  $ZodObjectJIT.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => objectProcessor(inst, ctx, json2, params);
  util_exports.defineLazy(inst, "shape", () => {
    return def.shape;
  });
  inst.keyof = () => _enum2(Object.keys(inst._zod.def.shape));
  inst.catchall = (catchall) => inst.clone({ ...inst._zod.def, catchall });
  inst.passthrough = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.loose = () => inst.clone({ ...inst._zod.def, catchall: unknown() });
  inst.strict = () => inst.clone({ ...inst._zod.def, catchall: never() });
  inst.strip = () => inst.clone({ ...inst._zod.def, catchall: void 0 });
  inst.extend = (incoming) => {
    return util_exports.extend(inst, incoming);
  };
  inst.safeExtend = (incoming) => {
    return util_exports.safeExtend(inst, incoming);
  };
  inst.merge = (other) => util_exports.merge(inst, other);
  inst.pick = (mask) => util_exports.pick(inst, mask);
  inst.omit = (mask) => util_exports.omit(inst, mask);
  inst.partial = (...args) => util_exports.partial(ZodOptional, inst, args[0]);
  inst.required = (...args) => util_exports.required(ZodNonOptional, inst, args[0]);
});
function object(shape, params) {
  const def = {
    type: "object",
    shape: shape ?? {},
    ...util_exports.normalizeParams(params)
  };
  return new ZodObject(def);
}
function strictObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: never(),
    ...util_exports.normalizeParams(params)
  });
}
function looseObject(shape, params) {
  return new ZodObject({
    type: "object",
    shape,
    catchall: unknown(),
    ...util_exports.normalizeParams(params)
  });
}
var ZodUnion = $constructor("ZodUnion", (inst, def) => {
  $ZodUnion.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function union(options, params) {
  return new ZodUnion({
    type: "union",
    options,
    ...util_exports.normalizeParams(params)
  });
}
var ZodXor = $constructor("ZodXor", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodXor.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => unionProcessor(inst, ctx, json2, params);
  inst.options = def.options;
});
function xor(options, params) {
  return new ZodXor({
    type: "union",
    options,
    inclusive: false,
    ...util_exports.normalizeParams(params)
  });
}
var ZodDiscriminatedUnion = $constructor("ZodDiscriminatedUnion", (inst, def) => {
  ZodUnion.init(inst, def);
  $ZodDiscriminatedUnion.init(inst, def);
});
function discriminatedUnion(discriminator, options, params) {
  return new ZodDiscriminatedUnion({
    type: "union",
    options,
    discriminator,
    ...util_exports.normalizeParams(params)
  });
}
var ZodIntersection = $constructor("ZodIntersection", (inst, def) => {
  $ZodIntersection.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => intersectionProcessor(inst, ctx, json2, params);
});
function intersection(left, right) {
  return new ZodIntersection({
    type: "intersection",
    left,
    right
  });
}
var ZodTuple = $constructor("ZodTuple", (inst, def) => {
  $ZodTuple.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => tupleProcessor(inst, ctx, json2, params);
  inst.rest = (rest) => inst.clone({
    ...inst._zod.def,
    rest
  });
});
function tuple(items, _paramsOrRest, _params) {
  const hasRest = _paramsOrRest instanceof $ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new ZodTuple({
    type: "tuple",
    items,
    rest,
    ...util_exports.normalizeParams(params)
  });
}
var ZodRecord = $constructor("ZodRecord", (inst, def) => {
  $ZodRecord.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => recordProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
});
function record(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function partialRecord(keyType, valueType, params) {
  const k = clone(keyType);
  k._zod.values = void 0;
  return new ZodRecord({
    type: "record",
    keyType: k,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
function looseRecord(keyType, valueType, params) {
  return new ZodRecord({
    type: "record",
    keyType,
    valueType,
    mode: "loose",
    ...util_exports.normalizeParams(params)
  });
}
var ZodMap = $constructor("ZodMap", (inst, def) => {
  $ZodMap.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => mapProcessor(inst, ctx, json2, params);
  inst.keyType = def.keyType;
  inst.valueType = def.valueType;
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function map(keyType, valueType, params) {
  return new ZodMap({
    type: "map",
    keyType,
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSet = $constructor("ZodSet", (inst, def) => {
  $ZodSet.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => setProcessor(inst, ctx, json2, params);
  inst.min = (...args) => inst.check(_minSize(...args));
  inst.nonempty = (params) => inst.check(_minSize(1, params));
  inst.max = (...args) => inst.check(_maxSize(...args));
  inst.size = (...args) => inst.check(_size(...args));
});
function set(valueType, params) {
  return new ZodSet({
    type: "set",
    valueType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodEnum = $constructor("ZodEnum", (inst, def) => {
  $ZodEnum.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => enumProcessor(inst, ctx, json2, params);
  inst.enum = def.entries;
  inst.options = Object.values(def.entries);
  const keys = new Set(Object.keys(def.entries));
  inst.extract = (values, params) => {
    const newEntries = {};
    for (const value of values) {
      if (keys.has(value)) {
        newEntries[value] = def.entries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
  inst.exclude = (values, params) => {
    const newEntries = { ...def.entries };
    for (const value of values) {
      if (keys.has(value)) {
        delete newEntries[value];
      } else
        throw new Error(`Key ${value} not found in enum`);
    }
    return new ZodEnum({
      ...def,
      checks: [],
      ...util_exports.normalizeParams(params),
      entries: newEntries
    });
  };
});
function _enum2(values, params) {
  const entries = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
function nativeEnum(entries, params) {
  return new ZodEnum({
    type: "enum",
    entries,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLiteral = $constructor("ZodLiteral", (inst, def) => {
  $ZodLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => literalProcessor(inst, ctx, json2, params);
  inst.values = new Set(def.values);
  Object.defineProperty(inst, "value", {
    get() {
      if (def.values.length > 1) {
        throw new Error("This schema contains multiple valid literal values. Use `.values` instead.");
      }
      return def.values[0];
    }
  });
});
function literal(value, params) {
  return new ZodLiteral({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util_exports.normalizeParams(params)
  });
}
var ZodFile = $constructor("ZodFile", (inst, def) => {
  $ZodFile.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => fileProcessor(inst, ctx, json2, params);
  inst.min = (size, params) => inst.check(_minSize(size, params));
  inst.max = (size, params) => inst.check(_maxSize(size, params));
  inst.mime = (types, params) => inst.check(_mime(Array.isArray(types) ? types : [types], params));
});
function file(params) {
  return _file(ZodFile, params);
}
var ZodTransform = $constructor("ZodTransform", (inst, def) => {
  $ZodTransform.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => transformProcessor(inst, ctx, json2, params);
  inst._zod.parse = (payload, _ctx) => {
    if (_ctx.direction === "backward") {
      throw new $ZodEncodeError(inst.constructor.name);
    }
    payload.addIssue = (issue2) => {
      if (typeof issue2 === "string") {
        payload.issues.push(util_exports.issue(issue2, payload.value, def));
      } else {
        const _issue = issue2;
        if (_issue.fatal)
          _issue.continue = false;
        _issue.code ?? (_issue.code = "custom");
        _issue.input ?? (_issue.input = payload.value);
        _issue.inst ?? (_issue.inst = inst);
        payload.issues.push(util_exports.issue(_issue));
      }
    };
    const output = def.transform(payload.value, payload);
    if (output instanceof Promise) {
      return output.then((output2) => {
        payload.value = output2;
        return payload;
      });
    }
    payload.value = output;
    return payload;
  };
});
function transform(fn) {
  return new ZodTransform({
    type: "transform",
    transform: fn
  });
}
var ZodOptional = $constructor("ZodOptional", (inst, def) => {
  $ZodOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function optional(innerType) {
  return new ZodOptional({
    type: "optional",
    innerType
  });
}
var ZodExactOptional = $constructor("ZodExactOptional", (inst, def) => {
  $ZodExactOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => optionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function exactOptional(innerType) {
  return new ZodExactOptional({
    type: "optional",
    innerType
  });
}
var ZodNullable = $constructor("ZodNullable", (inst, def) => {
  $ZodNullable.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nullableProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nullable(innerType) {
  return new ZodNullable({
    type: "nullable",
    innerType
  });
}
function nullish2(innerType) {
  return optional(nullable(innerType));
}
var ZodDefault = $constructor("ZodDefault", (inst, def) => {
  $ZodDefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => defaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeDefault = inst.unwrap;
});
function _default2(innerType, defaultValue) {
  return new ZodDefault({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodPrefault = $constructor("ZodPrefault", (inst, def) => {
  $ZodPrefault.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => prefaultProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function prefault(innerType, defaultValue) {
  return new ZodPrefault({
    type: "prefault",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? defaultValue() : util_exports.shallowClone(defaultValue);
    }
  });
}
var ZodNonOptional = $constructor("ZodNonOptional", (inst, def) => {
  $ZodNonOptional.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nonoptionalProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function nonoptional(innerType, params) {
  return new ZodNonOptional({
    type: "nonoptional",
    innerType,
    ...util_exports.normalizeParams(params)
  });
}
var ZodSuccess = $constructor("ZodSuccess", (inst, def) => {
  $ZodSuccess.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => successProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function success(innerType) {
  return new ZodSuccess({
    type: "success",
    innerType
  });
}
var ZodCatch = $constructor("ZodCatch", (inst, def) => {
  $ZodCatch.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => catchProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
  inst.removeCatch = inst.unwrap;
});
function _catch2(innerType, catchValue) {
  return new ZodCatch({
    type: "catch",
    innerType,
    catchValue: typeof catchValue === "function" ? catchValue : () => catchValue
  });
}
var ZodNaN = $constructor("ZodNaN", (inst, def) => {
  $ZodNaN.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => nanProcessor(inst, ctx, json2, params);
});
function nan(params) {
  return _nan(ZodNaN, params);
}
var ZodPipe = $constructor("ZodPipe", (inst, def) => {
  $ZodPipe.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => pipeProcessor(inst, ctx, json2, params);
  inst.in = def.in;
  inst.out = def.out;
});
function pipe(in_, out) {
  return new ZodPipe({
    type: "pipe",
    in: in_,
    out
    // ...util.normalizeParams(params),
  });
}
var ZodCodec = $constructor("ZodCodec", (inst, def) => {
  ZodPipe.init(inst, def);
  $ZodCodec.init(inst, def);
});
function codec(in_, out, params) {
  return new ZodCodec({
    type: "pipe",
    in: in_,
    out,
    transform: params.decode,
    reverseTransform: params.encode
  });
}
var ZodReadonly = $constructor("ZodReadonly", (inst, def) => {
  $ZodReadonly.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => readonlyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function readonly(innerType) {
  return new ZodReadonly({
    type: "readonly",
    innerType
  });
}
var ZodTemplateLiteral = $constructor("ZodTemplateLiteral", (inst, def) => {
  $ZodTemplateLiteral.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => templateLiteralProcessor(inst, ctx, json2, params);
});
function templateLiteral(parts, params) {
  return new ZodTemplateLiteral({
    type: "template_literal",
    parts,
    ...util_exports.normalizeParams(params)
  });
}
var ZodLazy = $constructor("ZodLazy", (inst, def) => {
  $ZodLazy.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => lazyProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.getter();
});
function lazy(getter) {
  return new ZodLazy({
    type: "lazy",
    getter
  });
}
var ZodPromise = $constructor("ZodPromise", (inst, def) => {
  $ZodPromise.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => promiseProcessor(inst, ctx, json2, params);
  inst.unwrap = () => inst._zod.def.innerType;
});
function promise(innerType) {
  return new ZodPromise({
    type: "promise",
    innerType
  });
}
var ZodFunction = $constructor("ZodFunction", (inst, def) => {
  $ZodFunction.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => functionProcessor(inst, ctx, json2, params);
});
function _function(params) {
  return new ZodFunction({
    type: "function",
    input: Array.isArray(params == null ? void 0 : params.input) ? tuple(params == null ? void 0 : params.input) : (params == null ? void 0 : params.input) ?? array(unknown()),
    output: (params == null ? void 0 : params.output) ?? unknown()
  });
}
var ZodCustom = $constructor("ZodCustom", (inst, def) => {
  $ZodCustom.init(inst, def);
  ZodType.init(inst, def);
  inst._zod.processJSONSchema = (ctx, json2, params) => customProcessor(inst, ctx, json2, params);
});
function check(fn) {
  const ch = new $ZodCheck({
    check: "custom"
    // ...util.normalizeParams(params),
  });
  ch._zod.check = fn;
  return ch;
}
function custom(fn, _params) {
  return _custom(ZodCustom, fn ?? (() => true), _params);
}
function refine(fn, _params = {}) {
  return _refine(ZodCustom, fn, _params);
}
function superRefine(fn) {
  return _superRefine(fn);
}
var describe2 = describe;
var meta2 = meta;
function _instanceof(cls, params = {}) {
  const inst = new ZodCustom({
    type: "custom",
    check: "custom",
    fn: (data) => data instanceof cls,
    abort: true,
    ...util_exports.normalizeParams(params)
  });
  inst._zod.bag.Class = cls;
  inst._zod.check = (payload) => {
    if (!(payload.value instanceof cls)) {
      payload.issues.push({
        code: "invalid_type",
        expected: cls.name,
        input: payload.value,
        inst,
        path: [...inst._zod.def.path ?? []]
      });
    }
  };
  return inst;
}
var stringbool = (...args) => _stringbool({
  Codec: ZodCodec,
  Boolean: ZodBoolean,
  String: ZodString
}, ...args);
function json(params) {
  const jsonSchema = lazy(() => {
    return union([string2(params), number2(), boolean2(), _null3(), array(jsonSchema), record(string2(), jsonSchema)]);
  });
  return jsonSchema;
}
function preprocess(fn, schema) {
  return pipe(transform(fn), schema);
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/compat.js
var ZodIssueCode = {
  invalid_type: "invalid_type",
  too_big: "too_big",
  too_small: "too_small",
  invalid_format: "invalid_format",
  not_multiple_of: "not_multiple_of",
  unrecognized_keys: "unrecognized_keys",
  invalid_union: "invalid_union",
  invalid_key: "invalid_key",
  invalid_element: "invalid_element",
  invalid_value: "invalid_value",
  custom: "custom"
};
function setErrorMap(map2) {
  config({
    customError: map2
  });
}
function getErrorMap() {
  return config().customError;
}
var ZodFirstPartyTypeKind;
/* @__PURE__ */ (function(ZodFirstPartyTypeKind2) {
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/from-json-schema.js
var z = {
  ...schemas_exports2,
  ...checks_exports2,
  iso: iso_exports
};
var RECOGNIZED_KEYS = /* @__PURE__ */ new Set([
  // Schema identification
  "$schema",
  "$ref",
  "$defs",
  "definitions",
  // Core schema keywords
  "$id",
  "id",
  "$comment",
  "$anchor",
  "$vocabulary",
  "$dynamicRef",
  "$dynamicAnchor",
  // Type
  "type",
  "enum",
  "const",
  // Composition
  "anyOf",
  "oneOf",
  "allOf",
  "not",
  // Object
  "properties",
  "required",
  "additionalProperties",
  "patternProperties",
  "propertyNames",
  "minProperties",
  "maxProperties",
  // Array
  "items",
  "prefixItems",
  "additionalItems",
  "minItems",
  "maxItems",
  "uniqueItems",
  "contains",
  "minContains",
  "maxContains",
  // String
  "minLength",
  "maxLength",
  "pattern",
  "format",
  // Number
  "minimum",
  "maximum",
  "exclusiveMinimum",
  "exclusiveMaximum",
  "multipleOf",
  // Already handled metadata
  "description",
  "default",
  // Content
  "contentEncoding",
  "contentMediaType",
  "contentSchema",
  // Unsupported (error-throwing)
  "unevaluatedItems",
  "unevaluatedProperties",
  "if",
  "then",
  "else",
  "dependentSchemas",
  "dependentRequired",
  // OpenAPI
  "nullable",
  "readOnly"
]);
function detectVersion(schema, defaultTarget) {
  const $schema = schema.$schema;
  if ($schema === "https://json-schema.org/draft/2020-12/schema") {
    return "draft-2020-12";
  }
  if ($schema === "http://json-schema.org/draft-07/schema#") {
    return "draft-7";
  }
  if ($schema === "http://json-schema.org/draft-04/schema#") {
    return "draft-4";
  }
  return defaultTarget ?? "draft-2020-12";
}
function resolveRef(ref, ctx) {
  if (!ref.startsWith("#")) {
    throw new Error("External $ref is not supported, only local refs (#/...) are allowed");
  }
  const path = ref.slice(1).split("/").filter(Boolean);
  if (path.length === 0) {
    return ctx.rootSchema;
  }
  const defsKey = ctx.version === "draft-2020-12" ? "$defs" : "definitions";
  if (path[0] === defsKey) {
    const key = path[1];
    if (!key || !ctx.defs[key]) {
      throw new Error(`Reference not found: ${ref}`);
    }
    return ctx.defs[key];
  }
  throw new Error(`Reference not found: ${ref}`);
}
function convertBaseSchema(schema, ctx) {
  if (schema.not !== void 0) {
    if (typeof schema.not === "object" && Object.keys(schema.not).length === 0) {
      return z.never();
    }
    throw new Error("not is not supported in Zod (except { not: {} } for never)");
  }
  if (schema.unevaluatedItems !== void 0) {
    throw new Error("unevaluatedItems is not supported");
  }
  if (schema.unevaluatedProperties !== void 0) {
    throw new Error("unevaluatedProperties is not supported");
  }
  if (schema.if !== void 0 || schema.then !== void 0 || schema.else !== void 0) {
    throw new Error("Conditional schemas (if/then/else) are not supported");
  }
  if (schema.dependentSchemas !== void 0 || schema.dependentRequired !== void 0) {
    throw new Error("dependentSchemas and dependentRequired are not supported");
  }
  if (schema.$ref) {
    const refPath = schema.$ref;
    if (ctx.refs.has(refPath)) {
      return ctx.refs.get(refPath);
    }
    if (ctx.processing.has(refPath)) {
      return z.lazy(() => {
        if (!ctx.refs.has(refPath)) {
          throw new Error(`Circular reference not resolved: ${refPath}`);
        }
        return ctx.refs.get(refPath);
      });
    }
    ctx.processing.add(refPath);
    const resolved = resolveRef(refPath, ctx);
    const zodSchema2 = convertSchema(resolved, ctx);
    ctx.refs.set(refPath, zodSchema2);
    ctx.processing.delete(refPath);
    return zodSchema2;
  }
  if (schema.enum !== void 0) {
    const enumValues = schema.enum;
    if (ctx.version === "openapi-3.0" && schema.nullable === true && enumValues.length === 1 && enumValues[0] === null) {
      return z.null();
    }
    if (enumValues.length === 0) {
      return z.never();
    }
    if (enumValues.length === 1) {
      return z.literal(enumValues[0]);
    }
    if (enumValues.every((v) => typeof v === "string")) {
      return z.enum(enumValues);
    }
    const literalSchemas = enumValues.map((v) => z.literal(v));
    if (literalSchemas.length < 2) {
      return literalSchemas[0];
    }
    return z.union([literalSchemas[0], literalSchemas[1], ...literalSchemas.slice(2)]);
  }
  if (schema.const !== void 0) {
    return z.literal(schema.const);
  }
  const type = schema.type;
  if (Array.isArray(type)) {
    const typeSchemas = type.map((t) => {
      const typeSchema = { ...schema, type: t };
      return convertBaseSchema(typeSchema, ctx);
    });
    if (typeSchemas.length === 0) {
      return z.never();
    }
    if (typeSchemas.length === 1) {
      return typeSchemas[0];
    }
    return z.union(typeSchemas);
  }
  if (!type) {
    return z.any();
  }
  let zodSchema;
  switch (type) {
    case "string": {
      let stringSchema = z.string();
      if (schema.format) {
        const format = schema.format;
        if (format === "email") {
          stringSchema = stringSchema.check(z.email());
        } else if (format === "uri" || format === "uri-reference") {
          stringSchema = stringSchema.check(z.url());
        } else if (format === "uuid" || format === "guid") {
          stringSchema = stringSchema.check(z.uuid());
        } else if (format === "date-time") {
          stringSchema = stringSchema.check(z.iso.datetime());
        } else if (format === "date") {
          stringSchema = stringSchema.check(z.iso.date());
        } else if (format === "time") {
          stringSchema = stringSchema.check(z.iso.time());
        } else if (format === "duration") {
          stringSchema = stringSchema.check(z.iso.duration());
        } else if (format === "ipv4") {
          stringSchema = stringSchema.check(z.ipv4());
        } else if (format === "ipv6") {
          stringSchema = stringSchema.check(z.ipv6());
        } else if (format === "mac") {
          stringSchema = stringSchema.check(z.mac());
        } else if (format === "cidr") {
          stringSchema = stringSchema.check(z.cidrv4());
        } else if (format === "cidr-v6") {
          stringSchema = stringSchema.check(z.cidrv6());
        } else if (format === "base64") {
          stringSchema = stringSchema.check(z.base64());
        } else if (format === "base64url") {
          stringSchema = stringSchema.check(z.base64url());
        } else if (format === "e164") {
          stringSchema = stringSchema.check(z.e164());
        } else if (format === "jwt") {
          stringSchema = stringSchema.check(z.jwt());
        } else if (format === "emoji") {
          stringSchema = stringSchema.check(z.emoji());
        } else if (format === "nanoid") {
          stringSchema = stringSchema.check(z.nanoid());
        } else if (format === "cuid") {
          stringSchema = stringSchema.check(z.cuid());
        } else if (format === "cuid2") {
          stringSchema = stringSchema.check(z.cuid2());
        } else if (format === "ulid") {
          stringSchema = stringSchema.check(z.ulid());
        } else if (format === "xid") {
          stringSchema = stringSchema.check(z.xid());
        } else if (format === "ksuid") {
          stringSchema = stringSchema.check(z.ksuid());
        }
      }
      if (typeof schema.minLength === "number") {
        stringSchema = stringSchema.min(schema.minLength);
      }
      if (typeof schema.maxLength === "number") {
        stringSchema = stringSchema.max(schema.maxLength);
      }
      if (schema.pattern) {
        stringSchema = stringSchema.regex(new RegExp(schema.pattern));
      }
      zodSchema = stringSchema;
      break;
    }
    case "number":
    case "integer": {
      let numberSchema = type === "integer" ? z.number().int() : z.number();
      if (typeof schema.minimum === "number") {
        numberSchema = numberSchema.min(schema.minimum);
      }
      if (typeof schema.maximum === "number") {
        numberSchema = numberSchema.max(schema.maximum);
      }
      if (typeof schema.exclusiveMinimum === "number") {
        numberSchema = numberSchema.gt(schema.exclusiveMinimum);
      } else if (schema.exclusiveMinimum === true && typeof schema.minimum === "number") {
        numberSchema = numberSchema.gt(schema.minimum);
      }
      if (typeof schema.exclusiveMaximum === "number") {
        numberSchema = numberSchema.lt(schema.exclusiveMaximum);
      } else if (schema.exclusiveMaximum === true && typeof schema.maximum === "number") {
        numberSchema = numberSchema.lt(schema.maximum);
      }
      if (typeof schema.multipleOf === "number") {
        numberSchema = numberSchema.multipleOf(schema.multipleOf);
      }
      zodSchema = numberSchema;
      break;
    }
    case "boolean": {
      zodSchema = z.boolean();
      break;
    }
    case "null": {
      zodSchema = z.null();
      break;
    }
    case "object": {
      const shape = {};
      const properties = schema.properties || {};
      const requiredSet = new Set(schema.required || []);
      for (const [key, propSchema] of Object.entries(properties)) {
        const propZodSchema = convertSchema(propSchema, ctx);
        shape[key] = requiredSet.has(key) ? propZodSchema : propZodSchema.optional();
      }
      if (schema.propertyNames) {
        const keySchema = convertSchema(schema.propertyNames, ctx);
        const valueSchema = schema.additionalProperties && typeof schema.additionalProperties === "object" ? convertSchema(schema.additionalProperties, ctx) : z.any();
        if (Object.keys(shape).length === 0) {
          zodSchema = z.record(keySchema, valueSchema);
          break;
        }
        const objectSchema2 = z.object(shape).passthrough();
        const recordSchema = z.looseRecord(keySchema, valueSchema);
        zodSchema = z.intersection(objectSchema2, recordSchema);
        break;
      }
      if (schema.patternProperties) {
        const patternProps = schema.patternProperties;
        const patternKeys = Object.keys(patternProps);
        const looseRecords = [];
        for (const pattern of patternKeys) {
          const patternValue = convertSchema(patternProps[pattern], ctx);
          const keySchema = z.string().regex(new RegExp(pattern));
          looseRecords.push(z.looseRecord(keySchema, patternValue));
        }
        const schemasToIntersect = [];
        if (Object.keys(shape).length > 0) {
          schemasToIntersect.push(z.object(shape).passthrough());
        }
        schemasToIntersect.push(...looseRecords);
        if (schemasToIntersect.length === 0) {
          zodSchema = z.object({}).passthrough();
        } else if (schemasToIntersect.length === 1) {
          zodSchema = schemasToIntersect[0];
        } else {
          let result = z.intersection(schemasToIntersect[0], schemasToIntersect[1]);
          for (let i = 2; i < schemasToIntersect.length; i++) {
            result = z.intersection(result, schemasToIntersect[i]);
          }
          zodSchema = result;
        }
        break;
      }
      const objectSchema = z.object(shape);
      if (schema.additionalProperties === false) {
        zodSchema = objectSchema.strict();
      } else if (typeof schema.additionalProperties === "object") {
        zodSchema = objectSchema.catchall(convertSchema(schema.additionalProperties, ctx));
      } else {
        zodSchema = objectSchema.passthrough();
      }
      break;
    }
    case "array": {
      const prefixItems = schema.prefixItems;
      const items = schema.items;
      if (prefixItems && Array.isArray(prefixItems)) {
        const tupleItems = prefixItems.map((item) => convertSchema(item, ctx));
        const rest = items && typeof items === "object" && !Array.isArray(items) ? convertSchema(items, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (Array.isArray(items)) {
        const tupleItems = items.map((item) => convertSchema(item, ctx));
        const rest = schema.additionalItems && typeof schema.additionalItems === "object" ? convertSchema(schema.additionalItems, ctx) : void 0;
        if (rest) {
          zodSchema = z.tuple(tupleItems).rest(rest);
        } else {
          zodSchema = z.tuple(tupleItems);
        }
        if (typeof schema.minItems === "number") {
          zodSchema = zodSchema.check(z.minLength(schema.minItems));
        }
        if (typeof schema.maxItems === "number") {
          zodSchema = zodSchema.check(z.maxLength(schema.maxItems));
        }
      } else if (items !== void 0) {
        const element = convertSchema(items, ctx);
        let arraySchema = z.array(element);
        if (typeof schema.minItems === "number") {
          arraySchema = arraySchema.min(schema.minItems);
        }
        if (typeof schema.maxItems === "number") {
          arraySchema = arraySchema.max(schema.maxItems);
        }
        zodSchema = arraySchema;
      } else {
        zodSchema = z.array(z.any());
      }
      break;
    }
    default:
      throw new Error(`Unsupported type: ${type}`);
  }
  if (schema.description) {
    zodSchema = zodSchema.describe(schema.description);
  }
  if (schema.default !== void 0) {
    zodSchema = zodSchema.default(schema.default);
  }
  return zodSchema;
}
function convertSchema(schema, ctx) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  let baseSchema = convertBaseSchema(schema, ctx);
  const hasExplicitType = schema.type || schema.enum !== void 0 || schema.const !== void 0;
  if (schema.anyOf && Array.isArray(schema.anyOf)) {
    const options = schema.anyOf.map((s) => convertSchema(s, ctx));
    const anyOfUnion = z.union(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, anyOfUnion) : anyOfUnion;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    const options = schema.oneOf.map((s) => convertSchema(s, ctx));
    const oneOfUnion = z.xor(options);
    baseSchema = hasExplicitType ? z.intersection(baseSchema, oneOfUnion) : oneOfUnion;
  }
  if (schema.allOf && Array.isArray(schema.allOf)) {
    if (schema.allOf.length === 0) {
      baseSchema = hasExplicitType ? baseSchema : z.any();
    } else {
      let result = hasExplicitType ? baseSchema : convertSchema(schema.allOf[0], ctx);
      const startIdx = hasExplicitType ? 0 : 1;
      for (let i = startIdx; i < schema.allOf.length; i++) {
        result = z.intersection(result, convertSchema(schema.allOf[i], ctx));
      }
      baseSchema = result;
    }
  }
  if (schema.nullable === true && ctx.version === "openapi-3.0") {
    baseSchema = z.nullable(baseSchema);
  }
  if (schema.readOnly === true) {
    baseSchema = z.readonly(baseSchema);
  }
  const extraMeta = {};
  const coreMetadataKeys = ["$id", "id", "$comment", "$anchor", "$vocabulary", "$dynamicRef", "$dynamicAnchor"];
  for (const key of coreMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  const contentMetadataKeys = ["contentEncoding", "contentMediaType", "contentSchema"];
  for (const key of contentMetadataKeys) {
    if (key in schema) {
      extraMeta[key] = schema[key];
    }
  }
  for (const key of Object.keys(schema)) {
    if (!RECOGNIZED_KEYS.has(key)) {
      extraMeta[key] = schema[key];
    }
  }
  if (Object.keys(extraMeta).length > 0) {
    ctx.registry.add(baseSchema, extraMeta);
  }
  return baseSchema;
}
function fromJSONSchema(schema, params) {
  if (typeof schema === "boolean") {
    return schema ? z.any() : z.never();
  }
  const version3 = detectVersion(schema, params == null ? void 0 : params.defaultTarget);
  const defs = schema.$defs || schema.definitions || {};
  const ctx = {
    version: version3,
    defs,
    refs: /* @__PURE__ */ new Map(),
    processing: /* @__PURE__ */ new Set(),
    rootSchema: schema,
    registry: (params == null ? void 0 : params.registry) ?? globalRegistry
  };
  return convertSchema(schema, ctx);
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/coerce.js
var coerce_exports = {};
__export(coerce_exports, {
  bigint: () => bigint3,
  boolean: () => boolean3,
  date: () => date4,
  number: () => number3,
  string: () => string3
});
function string3(params) {
  return _coercedString(ZodString, params);
}
function number3(params) {
  return _coercedNumber(ZodNumber, params);
}
function boolean3(params) {
  return _coercedBoolean(ZodBoolean, params);
}
function bigint3(params) {
  return _coercedBigint(ZodBigInt, params);
}
function date4(params) {
  return _coercedDate(ZodDate, params);
}

// node_modules/@assistant-ui/react/node_modules/zod/v4/classic/external.js
config(en_default());

// node_modules/@assistant-ui/react/dist/model-context/frame/AssistantFrameProvider.js
var serializeTool = (tool2) => {
  var _a3, _b;
  return {
    ...tool2.description && { description: tool2.description },
    parameters: tool2.parameters instanceof external_exports.ZodType ? ((_b = (_a3 = external_exports).toJSONSchema) == null ? void 0 : _b.call(_a3, tool2.parameters)) ?? tool2.parameters : tool2.parameters,
    ...tool2.disabled !== void 0 && { disabled: tool2.disabled },
    ...tool2.type && { type: tool2.type }
  };
};
var serializeModelContext = (context2) => ({
  ...context2.system !== void 0 && { system: context2.system },
  ...context2.tools && {
    tools: Object.fromEntries(Object.entries(context2.tools).map(([name, tool2]) => [
      name,
      serializeTool(tool2)
    ]))
  }
});
var _AssistantFrameProvider = class _AssistantFrameProvider {
  constructor(targetOrigin = "*") {
    __publicField(this, "_providers", /* @__PURE__ */ new Set());
    __publicField(this, "_providerUnsubscribes", /* @__PURE__ */ new Map());
    __publicField(this, "_targetOrigin");
    this._targetOrigin = targetOrigin;
    this.handleMessage = this.handleMessage.bind(this);
    window.addEventListener("message", this.handleMessage);
    setTimeout(() => this.broadcastUpdate(), 0);
  }
  static getInstance(targetOrigin) {
    if (!_AssistantFrameProvider._instance) {
      _AssistantFrameProvider._instance = new _AssistantFrameProvider(targetOrigin);
    }
    return _AssistantFrameProvider._instance;
  }
  handleMessage(event) {
    var _a3;
    if (this._targetOrigin !== "*" && event.origin !== this._targetOrigin)
      return;
    if (((_a3 = event.data) == null ? void 0 : _a3.channel) !== FRAME_MESSAGE_CHANNEL)
      return;
    const message = event.data.message;
    switch (message.type) {
      case "model-context-request":
        this.sendMessage(event, {
          type: "model-context-update",
          context: serializeModelContext(this.getModelContext())
        });
        break;
      case "tool-call":
        this.handleToolCall(message, event);
        break;
    }
  }
  async handleToolCall(message, event) {
    var _a3;
    const tool2 = (_a3 = this.getModelContext().tools) == null ? void 0 : _a3[message.toolName];
    let result;
    let error48;
    if (!tool2) {
      error48 = `Tool "${message.toolName}" not found`;
    } else {
      try {
        result = tool2.execute ? await tool2.execute(message.args, {
          toolCallId: message.id,
          abortSignal: new AbortController().signal,
          human: async () => {
            throw new Error("Tool human input is not supported in frame context");
          }
        }) : void 0;
      } catch (e) {
        error48 = e instanceof Error ? e.message : String(e);
      }
    }
    this.sendMessage(event, {
      type: "tool-result",
      id: message.id,
      ...error48 ? { error: error48 } : { result }
    });
  }
  sendMessage(event, message) {
    var _a3;
    (_a3 = event.source) == null ? void 0 : _a3.postMessage({ channel: FRAME_MESSAGE_CHANNEL, message }, { targetOrigin: event.origin });
  }
  getModelContext() {
    const contexts = Array.from(this._providers).map((p) => p.getModelContext());
    return contexts.reduce((merged, context2) => ({
      system: context2.system ? merged.system ? `${merged.system}

${context2.system}` : context2.system : merged.system,
      tools: { ...merged.tools || {}, ...context2.tools || {} }
    }), {});
  }
  broadcastUpdate() {
    if (window.parent && window.parent !== window) {
      const updateMessage = {
        type: "model-context-update",
        context: serializeModelContext(this.getModelContext())
      };
      window.parent.postMessage({ channel: FRAME_MESSAGE_CHANNEL, message: updateMessage }, this._targetOrigin);
    }
  }
  static addModelContextProvider(provider, targetOrigin) {
    var _a3;
    const instance = _AssistantFrameProvider.getInstance(targetOrigin);
    instance._providers.add(provider);
    const unsubscribe = (_a3 = provider.subscribe) == null ? void 0 : _a3.call(provider, () => instance.broadcastUpdate());
    if (unsubscribe) {
      instance._providerUnsubscribes.set(provider, unsubscribe);
    }
    instance.broadcastUpdate();
    return () => {
      var _a4;
      instance._providers.delete(provider);
      (_a4 = instance._providerUnsubscribes.get(provider)) == null ? void 0 : _a4();
      instance._providerUnsubscribes.delete(provider);
      instance.broadcastUpdate();
    };
  }
  static dispose() {
    if (_AssistantFrameProvider._instance) {
      const instance = _AssistantFrameProvider._instance;
      window.removeEventListener("message", instance.handleMessage);
      instance._providerUnsubscribes.forEach((unsubscribe) => unsubscribe == null ? void 0 : unsubscribe());
      instance._providerUnsubscribes.clear();
      instance._providers.clear();
      _AssistantFrameProvider._instance = null;
    }
  }
};
__publicField(_AssistantFrameProvider, "_instance", null);
var AssistantFrameProvider = _AssistantFrameProvider;

// node_modules/@assistant-ui/react/dist/model-context/frame/useAssistantFrameHost.js
var import_react27 = __toESM(require_react(), 1);
var useAssistantFrameHost = ({ iframeRef, targetOrigin = "*", register }) => {
  (0, import_react27.useEffect)(() => {
    var _a3;
    const iframeWindow = (_a3 = iframeRef.current) == null ? void 0 : _a3.contentWindow;
    if (!iframeWindow)
      return;
    const frameHost = new AssistantFrameHost(iframeWindow, targetOrigin);
    const unsubscribe = register(frameHost);
    return () => {
      frameHost.dispose();
      unsubscribe();
    };
  }, [iframeRef, targetOrigin, register]);
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/RuntimeAdapter.js
var RuntimeAdapter = resource((runtime) => {
  const clientRef = tapAssistantClientRef();
  tapEffect(() => {
    return runtime.registerModelContextProvider(clientRef.current.modelContext());
  }, [runtime, clientRef]);
  return tapInlineResource(ThreadListClient({
    runtime: runtime.threads,
    __internal_assistantRuntime: runtime
  }));
});
attachDefaultPeers(RuntimeAdapter, {
  modelContext: ModelContext(),
  tools: Tools({}),
  suggestions: Suggestions(),
  threadListItem: Derived({
    source: "threads",
    query: { type: "main" },
    get: (aui) => aui.threads().item("main")
  }),
  thread: Derived({
    source: "threads",
    query: { type: "main" },
    get: (aui) => aui.threads().thread("main")
  }),
  composer: Derived({
    source: "thread",
    query: {},
    get: (aui) => aui.threads().thread("main").composer
  })
});

// node_modules/@assistant-ui/react/dist/context/providers/ThreadViewportProvider.js
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react30 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/context/stores/ThreadViewport.js
var createSizeRegistry = (onChange) => {
  const entries = /* @__PURE__ */ new Map();
  const recalculate = () => {
    let total = 0;
    for (const height of entries.values()) {
      total += height;
    }
    onChange(total);
  };
  return {
    register: () => {
      const id = Symbol();
      entries.set(id, 0);
      return {
        setHeight: (height) => {
          if (entries.get(id) !== height) {
            entries.set(id, height);
            recalculate();
          }
        },
        unregister: () => {
          entries.delete(id);
          recalculate();
        }
      };
    }
  };
};
var makeThreadViewportStore = (options = {}) => {
  const scrollToBottomListeners = /* @__PURE__ */ new Set();
  const viewportRegistry = createSizeRegistry((total) => {
    store.setState({
      height: {
        ...store.getState().height,
        viewport: total
      }
    });
  });
  const insetRegistry = createSizeRegistry((total) => {
    store.setState({
      height: {
        ...store.getState().height,
        inset: total
      }
    });
  });
  const userMessageRegistry = createSizeRegistry((total) => {
    store.setState({
      height: {
        ...store.getState().height,
        userMessage: total
      }
    });
  });
  const store = create(() => ({
    isAtBottom: true,
    scrollToBottom: ({ behavior = "auto" } = {}) => {
      for (const listener of scrollToBottomListeners) {
        listener({ behavior });
      }
    },
    onScrollToBottom: (callback) => {
      scrollToBottomListeners.add(callback);
      return () => {
        scrollToBottomListeners.delete(callback);
      };
    },
    turnAnchor: options.turnAnchor ?? "bottom",
    height: {
      viewport: 0,
      inset: 0,
      userMessage: 0
    },
    registerViewport: viewportRegistry.register,
    registerContentInset: insetRegistry.register,
    registerUserMessageHeight: userMessageRegistry.register
  }));
  return store;
};

// node_modules/@assistant-ui/react/dist/context/react/ThreadViewportContext.js
var import_react29 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/context/react/utils/createContextHook.js
var import_react28 = __toESM(require_react(), 1);
function createContextHook(context2, providerName) {
  function useContextHook(options) {
    const contextValue2 = (0, import_react28.useContext)(context2);
    if (!(options == null ? void 0 : options.optional) && !contextValue2) {
      throw new Error(`This component must be used within ${providerName}.`);
    }
    return contextValue2;
  }
  return useContextHook;
}

// node_modules/@assistant-ui/react/dist/context/react/ThreadViewportContext.js
var ThreadViewportContext = (0, import_react29.createContext)(null);
var useThreadViewportContext = createContextHook(ThreadViewportContext, "ThreadPrimitive.Viewport");
var { useThreadViewport, useThreadViewportStore } = createContextStoreHook(useThreadViewportContext, "useThreadViewport");

// node_modules/@assistant-ui/react/dist/context/providers/ThreadViewportProvider.js
var useThreadViewportStoreValue = (options) => {
  const outerViewport = useThreadViewportStore({ optional: true });
  const [store] = (0, import_react30.useState)(() => makeThreadViewportStore(options));
  (0, import_react30.useEffect)(() => {
    return outerViewport == null ? void 0 : outerViewport.getState().onScrollToBottom(() => {
      store.getState().scrollToBottom();
    });
  }, [outerViewport, store]);
  (0, import_react30.useEffect)(() => {
    if (!outerViewport)
      return;
    return store.subscribe((state) => {
      if (outerViewport.getState().isAtBottom !== state.isAtBottom) {
        writableStore(outerViewport).setState({ isAtBottom: state.isAtBottom });
      }
    });
  }, [store, outerViewport]);
  (0, import_react30.useEffect)(() => {
    const nextState = {
      turnAnchor: options.turnAnchor ?? "bottom"
    };
    const currentState = store.getState();
    if (currentState.turnAnchor !== nextState.turnAnchor) {
      writableStore(store).setState(nextState);
    }
  }, [store, options.turnAnchor]);
  return store;
};
var ThreadPrimitiveViewportProvider = ({ children, options = {} }) => {
  const useThreadViewport2 = useThreadViewportStoreValue(options);
  const [context2] = (0, import_react30.useState)(() => {
    return {
      useThreadViewport: useThreadViewport2
    };
  });
  return (0, import_jsx_runtime6.jsx)(ThreadViewportContext.Provider, { value: context2, children });
};

// node_modules/@assistant-ui/react/dist/devtools/DevToolsHooks.js
var cachedHook;
var getHook = () => {
  if (cachedHook) {
    return cachedHook;
  }
  const createHook = () => ({
    apis: /* @__PURE__ */ new Map(),
    nextId: 0,
    listeners: /* @__PURE__ */ new Set()
  });
  if (typeof window === "undefined") {
    cachedHook = createHook();
    return cachedHook;
  }
  const existingHook = window.__ASSISTANT_UI_DEVTOOLS_HOOK__;
  if (existingHook) {
    cachedHook = existingHook;
    return existingHook;
  }
  const newHook = createHook();
  window.__ASSISTANT_UI_DEVTOOLS_HOOK__ = newHook;
  cachedHook = newHook;
  return newHook;
};
var DevToolsHooks = class _DevToolsHooks {
  static subscribe(listener) {
    const hook = getHook();
    hook.listeners.add(listener);
    return () => {
      hook.listeners.delete(listener);
    };
  }
  static clearEventLogs(apiId) {
    const hook = getHook();
    const entry = hook.apis.get(apiId);
    if (!entry)
      return;
    entry.logs = [];
    _DevToolsHooks.notifyListeners(apiId);
  }
  static getApis() {
    return getHook().apis;
  }
  static notifyListeners(apiId) {
    const hook = getHook();
    hook.listeners.forEach((listener) => listener(apiId));
  }
};
var _DevToolsProviderApi = class _DevToolsProviderApi {
  static register(aui) {
    var _a3, _b;
    const hook = getHook();
    for (const entry2 of hook.apis.values()) {
      if (entry2.api === aui) {
        return () => {
        };
      }
    }
    const apiId = hook.nextId++;
    const entry = {
      api: aui,
      logs: []
    };
    const eventUnsubscribe = (_a3 = aui.on) == null ? void 0 : _a3.call(aui, "*", (e) => {
      const entry2 = hook.apis.get(apiId);
      if (!entry2)
        return;
      entry2.logs.push({
        time: /* @__PURE__ */ new Date(),
        event: e.event,
        data: e.payload
      });
      if (entry2.logs.length > _DevToolsProviderApi.MAX_EVENT_LOGS_PER_API) {
        entry2.logs = entry2.logs.slice(-_DevToolsProviderApi.MAX_EVENT_LOGS_PER_API);
      }
      _DevToolsProviderApi.notifyListeners(apiId);
    });
    const stateUnsubscribe = (_b = aui.subscribe) == null ? void 0 : _b.call(aui, () => {
      _DevToolsProviderApi.notifyListeners(apiId);
    });
    hook.apis.set(apiId, entry);
    _DevToolsProviderApi.notifyListeners(apiId);
    return () => {
      const hook2 = getHook();
      const entry2 = hook2.apis.get(apiId);
      if (!entry2)
        return;
      eventUnsubscribe == null ? void 0 : eventUnsubscribe();
      stateUnsubscribe == null ? void 0 : stateUnsubscribe();
      hook2.apis.delete(apiId);
      _DevToolsProviderApi.notifyListeners(apiId);
    };
  }
  static notifyListeners(apiId) {
    const hook = getHook();
    hook.listeners.forEach((listener) => listener(apiId));
  }
};
__publicField(_DevToolsProviderApi, "MAX_EVENT_LOGS_PER_API", 200);
var DevToolsProviderApi = _DevToolsProviderApi;

// node_modules/@assistant-ui/react/dist/legacy-runtime/AssistantRuntimeProvider.js
var getRenderComponent = (runtime) => {
  var _a3;
  return (_a3 = runtime._core) == null ? void 0 : _a3.RenderComponent;
};
var AssistantRuntimeProviderImpl = ({ children, aui: parent = null, runtime }) => {
  const aui = useAui({ threads: RuntimeAdapter(runtime) }, { parent });
  (0, import_react31.useEffect)(() => {
    if (typeof process === "undefined" || false)
      return;
    return DevToolsProviderApi.register(aui);
  }, [aui]);
  const RenderComponent = getRenderComponent(runtime);
  return (0, import_jsx_runtime7.jsxs)(AuiProvider, { value: aui, children: [RenderComponent && (0, import_jsx_runtime7.jsx)(RenderComponent, {}), (0, import_jsx_runtime7.jsx)(ThreadPrimitiveViewportProvider, { children })] });
};
var AssistantRuntimeProvider = (0, import_react31.memo)(AssistantRuntimeProviderImpl);

// node_modules/@assistant-ui/react/dist/context/providers/ThreadListItemProvider.js
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var ThreadListItemByIndexProvider = ({ index: index3, archived, children }) => {
  const aui = useAui({
    threadListItem: Derived({
      source: "threads",
      query: { type: "index", index: index3, archived },
      get: (aui2) => aui2.threads().item({ index: index3, archived })
    })
  });
  return (0, import_jsx_runtime8.jsx)(AuiProvider, { value: aui, children });
};
var ThreadListItemRuntimeProvider = ({ runtime, children }) => {
  const aui = useAui({
    threadListItem: ThreadListItemClient({ runtime })
  });
  return (0, import_jsx_runtime8.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/context/providers/MessageByIndexProvider.js
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var MessageByIndexProvider = ({ index: index3, children }) => {
  const aui = useAui({
    message: Derived({
      source: "thread",
      query: { type: "index", index: index3 },
      get: (aui2) => aui2.thread().message({ index: index3 })
    }),
    composer: Derived({
      source: "message",
      query: {},
      get: (aui2) => aui2.thread().message({ index: index3 }).composer
    })
  });
  return (0, import_jsx_runtime9.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/context/providers/SuggestionByIndexProvider.js
var import_jsx_runtime10 = __toESM(require_jsx_runtime(), 1);
var SuggestionByIndexProvider = ({ index: index3, children }) => {
  const aui = useAui({
    suggestion: Derived({
      source: "suggestions",
      query: { index: index3 },
      get: (aui2) => aui2.suggestions().suggestion({ index: index3 })
    })
  });
  return (0, import_jsx_runtime10.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/context/providers/PartByIndexProvider.js
var import_jsx_runtime11 = __toESM(require_jsx_runtime(), 1);
var PartByIndexProvider = ({ index: index3, children }) => {
  const aui = useAui({
    part: Derived({
      source: "message",
      query: { type: "index", index: index3 },
      get: (aui2) => aui2.message().part({ index: index3 })
    })
  });
  return (0, import_jsx_runtime11.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/context/providers/AttachmentByIndexProvider.js
var import_jsx_runtime12 = __toESM(require_jsx_runtime(), 1);
var MessageAttachmentByIndexProvider = ({ index: index3, children }) => {
  const aui = useAui({
    attachment: Derived({
      source: "message",
      query: { type: "index", index: index3 },
      get: (aui2) => aui2.message().attachment({ index: index3 })
    })
  });
  return (0, import_jsx_runtime12.jsx)(AuiProvider, { value: aui, children });
};
var ComposerAttachmentByIndexProvider = ({ index: index3, children }) => {
  const aui = useAui({
    attachment: Derived({
      source: "composer",
      query: { type: "index", index: index3 },
      get: (aui2) => aui2.composer().attachment({ index: index3 })
    })
  });
  return (0, import_jsx_runtime12.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/context/providers/TextMessagePartProvider.js
var import_jsx_runtime13 = __toESM(require_jsx_runtime(), 1);
var TextMessagePartClient = resource(({ text, isRunning }) => {
  const state = tapMemo(() => ({
    type: "text",
    text,
    status: isRunning ? { type: "running" } : { type: "complete" }
  }), [text, isRunning]);
  return {
    state,
    methods: {
      getState: () => state,
      addToolResult: () => {
        throw new Error("Not supported");
      },
      resumeToolCall: () => {
        throw new Error("Not supported");
      }
    }
  };
});
var TextMessagePartProvider = ({ text, isRunning = false, children }) => {
  const aui = useAui({
    part: TextMessagePartClient({ text, isRunning })
  });
  return (0, import_jsx_runtime13.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/context/providers/MessageProvider.js
var import_jsx_runtime14 = __toESM(require_jsx_runtime(), 1);

// node_modules/@assistant-ui/react/dist/client/NoOpComposerClient.js
var NoOpComposerClient = resource(({ type }) => {
  const state = tapMemo(() => {
    return {
      isEditing: false,
      isEmpty: true,
      text: "",
      attachmentAccept: "*",
      attachments: [],
      role: "user",
      runConfig: {},
      canCancel: false,
      type,
      dictation: void 0
    };
  }, [type]);
  return {
    state,
    methods: {
      getState: () => state,
      setText: () => {
        throw new Error("Not supported");
      },
      setRole: () => {
        throw new Error("Not supported");
      },
      setRunConfig: () => {
        throw new Error("Not supported");
      },
      addAttachment: () => {
        throw new Error("Not supported");
      },
      clearAttachments: () => {
        throw new Error("Not supported");
      },
      attachment: () => {
        throw new Error("Not supported");
      },
      reset: () => {
        throw new Error("Not supported");
      },
      send: () => {
        throw new Error("Not supported");
      },
      cancel: () => {
        throw new Error("Not supported");
      },
      startDictation: () => {
        throw new Error("Not supported");
      },
      stopDictation: () => {
        throw new Error("Not supported");
      },
      beginEdit: () => {
        throw new Error("Not supported");
      }
    }
  };
});

// node_modules/@assistant-ui/react/dist/client/ThreadMessageClient.js
var ThreadMessagePartClient = resource(({ part }) => {
  const state = tapMemo(() => {
    return {
      ...part,
      status: { type: "complete" }
    };
  }, [part]);
  return {
    state,
    methods: {
      getState: () => state,
      addToolResult: () => {
        throw new Error("Not supported");
      },
      resumeToolCall: () => {
        throw new Error("Not supported");
      }
    }
  };
});
var ThreadMessageAttachmentClient = resource(({ attachment }) => {
  return {
    state: attachment,
    methods: {
      getState: () => attachment,
      remove: () => {
        throw new Error("Not supported");
      }
    }
  };
});
var ThreadMessageClient = resource(({ message, index: index3, isLast = true, branchNumber = 1, branchCount = 1 }) => {
  const [isCopiedState, setIsCopied] = tapState(false);
  const [isHoveringState, setIsHovering] = tapState(false);
  const parts = tapClientLookup(() => message.content.map((part, idx) => withKey("toolCallId" in part && part.toolCallId != null ? `toolCallId-${part.toolCallId}` : `index-${idx}`, ThreadMessagePartClient({ part }))), [message.content]);
  const attachments = tapClientLookup(() => (message.attachments ?? []).map((attachment) => withKey(attachment.id, ThreadMessageAttachmentClient({ attachment }))), [message.attachments]);
  const composer = tapInlineResource(NoOpComposerClient({ type: "edit" }));
  const state = tapMemo(() => {
    return {
      ...message,
      parts: parts.state,
      composer: composer.state,
      parentId: null,
      index: index3,
      isLast,
      branchNumber,
      branchCount,
      speech: void 0,
      submittedFeedback: message.metadata.submittedFeedback,
      isCopied: isCopiedState,
      isHovering: isHoveringState
    };
  }, [
    message,
    index3,
    isCopiedState,
    isHoveringState,
    isLast,
    parts.state,
    composer.state,
    branchNumber,
    branchCount
  ]);
  return {
    state,
    methods: {
      getState: () => state,
      composer: composer.methods,
      part: (selector) => {
        if ("index" in selector) {
          return parts.get({ index: selector.index });
        } else {
          return parts.get({ key: `toolCallId-${selector.toolCallId}` });
        }
      },
      attachment: (selector) => {
        if ("id" in selector) {
          return attachments.get({ key: selector.id });
        } else {
          return attachments.get(selector);
        }
      },
      reload: () => {
        throw new Error("Not supported in ThreadMessageProvider");
      },
      speak: () => {
        throw new Error("Not supported in ThreadMessageProvider");
      },
      stopSpeaking: () => {
        throw new Error("Not supported in ThreadMessageProvider");
      },
      submitFeedback: () => {
        throw new Error("Not supported in ThreadMessageProvider");
      },
      switchToBranch: () => {
        throw new Error("Not supported in ThreadMessageProvider");
      },
      getCopyText: () => {
        return message.content.map((part) => {
          if ("text" in part && typeof part.text === "string") {
            return part.text;
          }
          return "";
        }).join("\n");
      },
      setIsCopied,
      setIsHovering
    }
  };
});

// node_modules/@assistant-ui/react/dist/context/providers/MessageProvider.js
var MessageProvider = ({ children, ...props }) => {
  const aui = useAui({
    message: ThreadMessageClient(props)
  });
  return (0, import_jsx_runtime14.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/RemoteThreadListHookInstanceManager.js
var RemoteThreadListHookInstanceManager = class extends BaseSubscribable {
  constructor(runtimeHook, parent) {
    super();
    __publicField(this, "useRuntimeHook");
    __publicField(this, "instances", /* @__PURE__ */ new Map());
    __publicField(this, "useAliveThreadsKeysChanged", create(() => ({})));
    __publicField(this, "parent");
    __publicField(this, "_InnerActiveThreadProvider", ({ threadId }) => {
      const { useRuntime } = this.useRuntimeHook();
      const runtime = useRuntime();
      const threadBinding = runtime.thread.__internal_threadBinding;
      const updateRuntime = (0, import_react32.useCallback)(() => {
        const aliveThread = this.instances.get(threadId);
        if (!aliveThread)
          throw new Error("Thread not found. This is a bug in assistant-ui.");
        aliveThread.runtime = threadBinding.getState();
        this._notifySubscribers();
      }, [threadId, threadBinding]);
      const isMounted = (0, import_react32.useRef)(false);
      if (!isMounted.current) {
        updateRuntime();
      }
      (0, import_react32.useEffect)(() => {
        isMounted.current = true;
        updateRuntime();
        return threadBinding.outerSubscribe(updateRuntime);
      }, [threadBinding, updateRuntime]);
      const aui = useAui();
      const initPromiseRef = (0, import_react32.useRef)(void 0);
      (0, import_react32.useEffect)(() => {
        const runtimeCore = threadBinding.getState();
        const setGetInitializePromise = runtimeCore["__internal_setGetInitializePromise"];
        if (typeof setGetInitializePromise === "function") {
          setGetInitializePromise.call(runtimeCore, () => initPromiseRef.current);
        }
      }, [threadBinding]);
      (0, import_react32.useEffect)(() => {
        return runtime.threads.main.unstable_on("initialize", () => {
          const state = aui.threadListItem().getState();
          if (state.status === "new") {
            initPromiseRef.current = aui.threadListItem().initialize();
            const dispose = runtime.thread.unstable_on("runEnd", () => {
              dispose();
              aui.threadListItem().generateTitle();
            });
          }
        });
      }, [runtime, aui]);
      return null;
    });
    __publicField(this, "_OuterActiveThreadProvider", (0, import_react32.memo)(({ threadId, provider: Provider }) => {
      const runtime = (0, import_react32.useMemo)(() => new ThreadListRuntimeImpl(this.parent).getItemById(threadId), [threadId]);
      return (0, import_jsx_runtime15.jsx)(ThreadListItemRuntimeProvider, { runtime, children: (0, import_jsx_runtime15.jsx)(Provider, { children: (0, import_jsx_runtime15.jsx)(this._InnerActiveThreadProvider, { threadId }) }) });
    }));
    __publicField(this, "__internal_RenderThreadRuntimes", ({ provider }) => {
      this.useAliveThreadsKeysChanged();
      return Array.from(this.instances.keys()).map((threadId) => (0, import_jsx_runtime15.jsx)(this._OuterActiveThreadProvider, { threadId, provider }, threadId));
    });
    this.parent = parent;
    this.useRuntimeHook = create(() => ({ useRuntime: runtimeHook }));
  }
  startThreadRuntime(threadId) {
    if (!this.instances.has(threadId)) {
      this.instances.set(threadId, {});
      this.useAliveThreadsKeysChanged.setState({}, true);
    }
    return new Promise((resolve, reject) => {
      const callback = () => {
        const instance = this.instances.get(threadId);
        if (!instance) {
          dispose();
          reject(new Error("Thread was deleted before runtime was started"));
        } else if (!instance.runtime) {
          return;
        } else {
          dispose();
          resolve(instance.runtime);
        }
      };
      const dispose = this.subscribe(callback);
      callback();
    });
  }
  getThreadRuntimeCore(threadId) {
    const instance = this.instances.get(threadId);
    if (!instance)
      return void 0;
    return instance.runtime;
  }
  stopThreadRuntime(threadId) {
    this.instances.delete(threadId);
    this.useAliveThreadsKeysChanged.setState({}, true);
  }
  setRuntimeHook(newRuntimeHook) {
    const prevRuntimeHook = this.useRuntimeHook.getState().useRuntime;
    if (prevRuntimeHook !== newRuntimeHook) {
      this.useRuntimeHook.setState({ useRuntime: newRuntimeHook }, true);
    }
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/EMPTY_THREAD_CORE.js
var EMPTY_THREAD_ERROR = new Error("This is the empty thread, a placeholder for the main thread. You cannot perform any actions on this thread instance. This error is probably because you tried to call a thread method in your render function. Call the method inside a `useEffect` hook instead.");
var EMPTY_THREAD_CORE = {
  getMessageById() {
    return void 0;
  },
  getBranches() {
    return [];
  },
  switchToBranch() {
    throw EMPTY_THREAD_ERROR;
  },
  append() {
    throw EMPTY_THREAD_ERROR;
  },
  startRun() {
    throw EMPTY_THREAD_ERROR;
  },
  resumeRun() {
    throw EMPTY_THREAD_ERROR;
  },
  cancelRun() {
    throw EMPTY_THREAD_ERROR;
  },
  addToolResult() {
    throw EMPTY_THREAD_ERROR;
  },
  resumeToolCall() {
    throw EMPTY_THREAD_ERROR;
  },
  speak() {
    throw EMPTY_THREAD_ERROR;
  },
  stopSpeaking() {
    throw EMPTY_THREAD_ERROR;
  },
  submitFeedback() {
    throw EMPTY_THREAD_ERROR;
  },
  getModelContext() {
    return {};
  },
  exportExternalState() {
    throw EMPTY_THREAD_ERROR;
  },
  importExternalState() {
    throw EMPTY_THREAD_ERROR;
  },
  unstable_loadExternalState() {
    throw EMPTY_THREAD_ERROR;
  },
  composer: {
    attachments: [],
    attachmentAccept: "*",
    async addAttachment() {
      throw EMPTY_THREAD_ERROR;
    },
    async removeAttachment() {
      throw EMPTY_THREAD_ERROR;
    },
    isEditing: true,
    canCancel: false,
    isEmpty: true,
    text: "",
    setText() {
      throw EMPTY_THREAD_ERROR;
    },
    role: "user",
    setRole() {
      throw EMPTY_THREAD_ERROR;
    },
    runConfig: {},
    setRunConfig() {
      throw EMPTY_THREAD_ERROR;
    },
    async reset() {
    },
    async clearAttachments() {
    },
    send() {
      throw EMPTY_THREAD_ERROR;
    },
    cancel() {
    },
    dictation: void 0,
    startDictation() {
      throw EMPTY_THREAD_ERROR;
    },
    stopDictation() {
    },
    subscribe() {
      return () => {
      };
    },
    unstable_on() {
      return () => {
      };
    }
  },
  getEditComposer() {
    return void 0;
  },
  beginEdit() {
    throw EMPTY_THREAD_ERROR;
  },
  speech: void 0,
  capabilities: {
    switchToBranch: false,
    switchBranchDuringRun: false,
    edit: false,
    reload: false,
    cancel: false,
    unstable_copy: false,
    speech: false,
    dictation: false,
    attachments: false,
    feedback: false
  },
  isDisabled: false,
  isLoading: false,
  messages: [],
  state: null,
  suggestions: [],
  extras: void 0,
  subscribe() {
    return () => {
    };
  },
  import() {
    throw EMPTY_THREAD_ERROR;
  },
  export() {
    return { messages: [] };
  },
  reset() {
    throw EMPTY_THREAD_ERROR;
  },
  unstable_on() {
    return () => {
    };
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/OptimisticState.js
var pipeTransforms = (initialState, extraParam, transforms) => {
  return transforms.reduce((state, transform2) => {
    return (transform2 == null ? void 0 : transform2(state, extraParam)) ?? state;
  }, initialState);
};
var OptimisticState = class extends BaseSubscribable {
  constructor(initialState) {
    super();
    __publicField(this, "_pendingTransforms", []);
    __publicField(this, "_baseValue");
    __publicField(this, "_cachedValue");
    this._baseValue = initialState;
    this._cachedValue = initialState;
  }
  _updateState() {
    this._cachedValue = this._pendingTransforms.reduce((state, transform2) => {
      return pipeTransforms(state, transform2.task, [
        transform2.loading,
        transform2.optimistic
      ]);
    }, this._baseValue);
    this._notifySubscribers();
  }
  get baseValue() {
    return this._baseValue;
  }
  get value() {
    return this._cachedValue;
  }
  update(state) {
    this._baseValue = state;
    this._updateState();
  }
  async optimisticUpdate(transform2) {
    const task = transform2.execute();
    const pendingTransform = { ...transform2, task };
    try {
      this._pendingTransforms.push(pendingTransform);
      this._updateState();
      const result = await task;
      this._baseValue = pipeTransforms(this._baseValue, result, [
        transform2.optimistic,
        transform2.then
      ]);
      return result;
    } finally {
      const index3 = this._pendingTransforms.indexOf(pendingTransform);
      if (index3 > -1) {
        this._pendingTransforms.splice(index3, 1);
      }
      this._updateState();
    }
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/RemoteThreadListThreadListRuntimeCore.js
var import_react33 = __toESM(require_react(), 1);
function createThreadMappingId(id) {
  return id;
}
var getThreadData = (state, threadIdOrRemoteId) => {
  const idx = state.threadIdMap[threadIdOrRemoteId];
  if (idx === void 0)
    return void 0;
  return state.threadData[idx];
};
var updateStatusReducer = (state, threadIdOrRemoteId, newStatus) => {
  const data = getThreadData(state, threadIdOrRemoteId);
  if (!data)
    return state;
  const { id, remoteId, status: lastStatus } = data;
  if (lastStatus === newStatus)
    return state;
  const newState = { ...state };
  switch (lastStatus) {
    case "new":
      newState.newThreadId = void 0;
      break;
    case "regular":
      newState.threadIds = newState.threadIds.filter((t) => t !== id);
      break;
    case "archived":
      newState.archivedThreadIds = newState.archivedThreadIds.filter((t) => t !== id);
      break;
    default: {
      const _exhaustiveCheck = lastStatus;
      throw new Error(`Unsupported state: ${_exhaustiveCheck}`);
    }
  }
  switch (newStatus) {
    case "regular":
      newState.threadIds = [id, ...newState.threadIds];
      break;
    case "archived":
      newState.archivedThreadIds = [id, ...newState.archivedThreadIds];
      break;
    case "deleted":
      newState.threadData = Object.fromEntries(Object.entries(newState.threadData).filter(([key]) => key !== id));
      newState.threadIdMap = Object.fromEntries(Object.entries(newState.threadIdMap).filter(([key]) => key !== id && key !== remoteId));
      break;
    default: {
      const _exhaustiveCheck = newStatus;
      throw new Error(`Unsupported state: ${_exhaustiveCheck}`);
    }
  }
  if (newStatus !== "deleted") {
    newState.threadData = {
      ...newState.threadData,
      [id]: {
        ...data,
        status: newStatus
      }
    };
  }
  return newState;
};
var RemoteThreadListThreadListRuntimeCore = class extends BaseSubscribable {
  constructor(options, contextProvider) {
    super();
    __publicField(this, "contextProvider");
    __publicField(this, "_options");
    __publicField(this, "_hookManager");
    __publicField(this, "_loadThreadsPromise");
    __publicField(this, "_mainThreadId");
    __publicField(this, "_state", new OptimisticState({
      isLoading: false,
      newThreadId: void 0,
      threadIds: [],
      archivedThreadIds: [],
      threadIdMap: {},
      threadData: {}
    }));
    __publicField(this, "useProvider");
    __publicField(this, "initialize", async (threadId) => {
      if (this._state.value.newThreadId !== threadId) {
        const data = this.getItemById(threadId);
        if (!data)
          throw new Error("Thread not found");
        if (data.status === "new")
          throw new Error("Unexpected new state");
        return data.initializeTask;
      }
      return this._state.optimisticUpdate({
        execute: () => {
          return this._options.adapter.initialize(threadId);
        },
        optimistic: (state) => {
          return updateStatusReducer(state, threadId, "regular");
        },
        loading: (state, task) => {
          const mappingId = createThreadMappingId(threadId);
          return {
            ...state,
            threadData: {
              ...state.threadData,
              [mappingId]: {
                ...state.threadData[mappingId],
                initializeTask: task
              }
            }
          };
        },
        then: (state, { remoteId, externalId }) => {
          const data = getThreadData(state, threadId);
          if (!data)
            return state;
          const mappingId = createThreadMappingId(threadId);
          return {
            ...state,
            threadIdMap: {
              ...state.threadIdMap,
              [remoteId]: mappingId
            },
            threadData: {
              ...state.threadData,
              [mappingId]: {
                ...data,
                initializeTask: Promise.resolve({ remoteId, externalId }),
                remoteId,
                externalId
              }
            }
          };
        }
      });
    });
    __publicField(this, "generateTitle", async (threadId) => {
      var _a3;
      const data = this.getItemById(threadId);
      if (!data)
        throw new Error("Thread not found");
      if (data.status === "new")
        throw new Error("Thread is not yet initialized");
      const { remoteId } = await data.initializeTask;
      const runtimeCore = this._hookManager.getThreadRuntimeCore(data.id);
      if (!runtimeCore)
        return;
      const messages = runtimeCore.messages;
      const stream = await this._options.adapter.generateTitle(remoteId, messages);
      const messageStream = AssistantMessageStream.fromAssistantStream(stream);
      for await (const result of messageStream) {
        const newTitle = (_a3 = result.parts.filter((c) => c.type === "text")[0]) == null ? void 0 : _a3.text;
        const state = this._state.baseValue;
        this._state.update({
          ...state,
          threadData: {
            ...state.threadData,
            [data.id]: {
              ...data,
              title: newTitle
            }
          }
        });
      }
    });
    __publicField(this, "useBoundIds", create(() => []));
    __publicField(this, "__internal_RenderComponent", () => {
      const id = (0, import_react33.useId)();
      (0, import_react33.useEffect)(() => {
        this.useBoundIds.setState((s) => [...s, id], true);
        return () => {
          this.useBoundIds.setState((s) => s.filter((i) => i !== id), true);
        };
      }, [id]);
      const boundIds = this.useBoundIds();
      const { Provider } = this.useProvider();
      const adapters = {
        modelContext: this.contextProvider
      };
      return (boundIds.length === 0 || boundIds[0] === id) && // only render if the component is the first one mounted
      (0, import_jsx_runtime16.jsx)(RuntimeAdapterProvider, { adapters, children: (0, import_jsx_runtime16.jsx)(this._hookManager.__internal_RenderThreadRuntimes, { provider: Provider }) });
    });
    this.contextProvider = contextProvider;
    this._state.subscribe(() => this._notifySubscribers());
    this._hookManager = new RemoteThreadListHookInstanceManager(options.runtimeHook, this);
    this.useProvider = create(() => ({
      Provider: options.adapter.unstable_Provider ?? import_react33.Fragment
    }));
    this.__internal_setOptions(options);
    this.switchToNewThread();
  }
  get threadItems() {
    return this._state.value.threadData;
  }
  getLoadThreadsPromise() {
    if (!this._loadThreadsPromise) {
      this._loadThreadsPromise = this._state.optimisticUpdate({
        execute: () => this._options.adapter.list(),
        loading: (state) => {
          return {
            ...state,
            isLoading: true
          };
        },
        then: (state, l) => {
          const newThreadIds = [];
          const newArchivedThreadIds = [];
          const newThreadIdMap = {};
          const newThreadData = {};
          for (const thread of l.threads) {
            switch (thread.status) {
              case "regular":
                newThreadIds.push(thread.remoteId);
                break;
              case "archived":
                newArchivedThreadIds.push(thread.remoteId);
                break;
              default: {
                const _exhaustiveCheck = thread.status;
                throw new Error(`Unsupported state: ${_exhaustiveCheck}`);
              }
            }
            const mappingId = createThreadMappingId(thread.remoteId);
            newThreadIdMap[thread.remoteId] = mappingId;
            newThreadData[mappingId] = {
              id: thread.remoteId,
              remoteId: thread.remoteId,
              externalId: thread.externalId,
              status: thread.status,
              title: thread.title,
              initializeTask: Promise.resolve({
                remoteId: thread.remoteId,
                externalId: thread.externalId
              })
            };
          }
          return {
            ...state,
            threadIds: newThreadIds,
            archivedThreadIds: newArchivedThreadIds,
            threadIdMap: {
              ...state.threadIdMap,
              ...newThreadIdMap
            },
            threadData: {
              ...state.threadData,
              ...newThreadData
            }
          };
        }
      }).then(() => {
      });
    }
    return this._loadThreadsPromise;
  }
  __internal_setOptions(options) {
    if (this._options === options)
      return;
    this._options = options;
    const Provider = options.adapter.unstable_Provider ?? import_react33.Fragment;
    if (Provider !== this.useProvider.getState().Provider) {
      this.useProvider.setState({ Provider }, true);
    }
    this._hookManager.setRuntimeHook(options.runtimeHook);
  }
  __internal_load() {
    this.getLoadThreadsPromise();
  }
  get isLoading() {
    return this._state.value.isLoading;
  }
  get threadIds() {
    return this._state.value.threadIds;
  }
  get archivedThreadIds() {
    return this._state.value.archivedThreadIds;
  }
  get newThreadId() {
    return this._state.value.newThreadId;
  }
  get mainThreadId() {
    return this._mainThreadId;
  }
  getMainThreadRuntimeCore() {
    const result = this._hookManager.getThreadRuntimeCore(this._mainThreadId);
    if (!result)
      return EMPTY_THREAD_CORE;
    return result;
  }
  getThreadRuntimeCore(threadIdOrRemoteId) {
    const data = this.getItemById(threadIdOrRemoteId);
    if (!data)
      throw new Error("Thread not found");
    const result = this._hookManager.getThreadRuntimeCore(data.id);
    if (!result)
      throw new Error("Thread not found");
    return result;
  }
  getItemById(threadIdOrRemoteId) {
    return getThreadData(this._state.value, threadIdOrRemoteId);
  }
  async switchToThread(threadIdOrRemoteId) {
    let data = this.getItemById(threadIdOrRemoteId);
    if (!data) {
      const remoteMetadata = await this._options.adapter.fetch(threadIdOrRemoteId);
      const state = this._state.value;
      const mappingId = createThreadMappingId(remoteMetadata.remoteId);
      const newThreadData = {
        ...state.threadData,
        [mappingId]: {
          id: mappingId,
          initializeTask: Promise.resolve({
            remoteId: remoteMetadata.remoteId,
            externalId: remoteMetadata.externalId
          }),
          remoteId: remoteMetadata.remoteId,
          externalId: remoteMetadata.externalId,
          status: remoteMetadata.status,
          title: remoteMetadata.title
        }
      };
      const newThreadIdMap = {
        ...state.threadIdMap,
        [remoteMetadata.remoteId]: mappingId
      };
      const newThreadIds = remoteMetadata.status === "regular" ? [...state.threadIds, remoteMetadata.remoteId] : state.threadIds;
      const newArchivedThreadIds = remoteMetadata.status === "archived" ? [...state.archivedThreadIds, remoteMetadata.remoteId] : state.archivedThreadIds;
      this._state.update({
        ...state,
        threadIds: newThreadIds,
        archivedThreadIds: newArchivedThreadIds,
        threadIdMap: newThreadIdMap,
        threadData: newThreadData
      });
      data = this.getItemById(threadIdOrRemoteId);
    }
    if (!data)
      throw new Error("Thread not found");
    if (this._mainThreadId === data.id)
      return;
    const task = this._hookManager.startThreadRuntime(data.id);
    if (this.mainThreadId !== void 0) {
      await task;
    } else {
      task.then(() => this._notifySubscribers());
    }
    if (data.status === "archived")
      await this.unarchive(data.id);
    this._mainThreadId = data.id;
    this._notifySubscribers();
  }
  async switchToNewThread() {
    while (this._state.baseValue.newThreadId !== void 0 && this._state.value.newThreadId === void 0) {
      await this._state.waitForUpdate();
    }
    const state = this._state.value;
    let id = this._state.value.newThreadId;
    if (id === void 0) {
      do {
        id = `__LOCALID_${generateId()}`;
      } while (state.threadIdMap[id]);
      const mappingId = createThreadMappingId(id);
      this._state.update({
        ...state,
        newThreadId: id,
        threadIdMap: {
          ...state.threadIdMap,
          [id]: mappingId
        },
        threadData: {
          ...state.threadData,
          [mappingId]: {
            status: "new",
            id,
            remoteId: void 0,
            externalId: void 0,
            title: void 0
          }
        }
      });
    }
    return this.switchToThread(id);
  }
  rename(threadIdOrRemoteId, newTitle) {
    const data = this.getItemById(threadIdOrRemoteId);
    if (!data)
      throw new Error("Thread not found");
    if (data.status === "new")
      throw new Error("Thread is not yet initialized");
    return this._state.optimisticUpdate({
      execute: async () => {
        const { remoteId } = await data.initializeTask;
        return this._options.adapter.rename(remoteId, newTitle);
      },
      optimistic: (state) => {
        const data2 = getThreadData(state, threadIdOrRemoteId);
        if (!data2)
          return state;
        return {
          ...state,
          threadData: {
            ...state.threadData,
            [data2.id]: {
              ...data2,
              title: newTitle
            }
          }
        };
      }
    });
  }
  async _ensureThreadIsNotMain(threadId) {
    if (threadId === this.newThreadId)
      throw new Error("Cannot ensure new thread is not main");
    if (threadId === this._mainThreadId) {
      await this.switchToNewThread();
    }
  }
  async archive(threadIdOrRemoteId) {
    const data = this.getItemById(threadIdOrRemoteId);
    if (!data)
      throw new Error("Thread not found");
    if (data.status !== "regular")
      throw new Error("Thread is not yet initialized or already archived");
    return this._state.optimisticUpdate({
      execute: async () => {
        await this._ensureThreadIsNotMain(data.id);
        const { remoteId } = await data.initializeTask;
        return this._options.adapter.archive(remoteId);
      },
      optimistic: (state) => {
        return updateStatusReducer(state, data.id, "archived");
      }
    });
  }
  unarchive(threadIdOrRemoteId) {
    const data = this.getItemById(threadIdOrRemoteId);
    if (!data)
      throw new Error("Thread not found");
    if (data.status !== "archived")
      throw new Error("Thread is not archived");
    return this._state.optimisticUpdate({
      execute: async () => {
        try {
          const { remoteId } = await data.initializeTask;
          return await this._options.adapter.unarchive(remoteId);
        } catch (error48) {
          await this._ensureThreadIsNotMain(data.id);
          throw error48;
        }
      },
      optimistic: (state) => {
        return updateStatusReducer(state, data.id, "regular");
      }
    });
  }
  async delete(threadIdOrRemoteId) {
    const data = this.getItemById(threadIdOrRemoteId);
    if (!data)
      throw new Error("Thread not found");
    if (data.status !== "regular" && data.status !== "archived")
      throw new Error("Thread is not yet initialized");
    return this._state.optimisticUpdate({
      execute: async () => {
        await this._ensureThreadIsNotMain(data.id);
        const { remoteId } = await data.initializeTask;
        return await this._options.adapter.delete(remoteId);
      },
      optimistic: (state) => {
        return updateStatusReducer(state, data.id, "deleted");
      }
    });
  }
  async detach(threadIdOrRemoteId) {
    const data = this.getItemById(threadIdOrRemoteId);
    if (!data)
      throw new Error("Thread not found");
    if (data.status !== "regular" && data.status !== "archived")
      throw new Error("Thread is not yet initialized");
    await this._ensureThreadIsNotMain(data.id);
    this._hookManager.stopThreadRuntime(data.id);
  }
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/runtime-cores/remote-thread-list/useRemoteThreadListRuntime.js
var RemoteThreadListRuntimeCore = class extends BaseAssistantRuntimeCore {
  constructor(options) {
    super();
    __publicField(this, "threads");
    this.threads = new RemoteThreadListThreadListRuntimeCore(options, this._contextProvider);
  }
  get RenderComponent() {
    return this.threads.__internal_RenderComponent;
  }
};
var useRemoteThreadListRuntimeImpl = (options) => {
  const [runtime] = (0, import_react34.useState)(() => new RemoteThreadListRuntimeCore(options));
  (0, import_react34.useEffect)(() => {
    runtime.threads.__internal_setOptions(options);
    runtime.threads.__internal_load();
  }, [runtime, options]);
  return (0, import_react34.useMemo)(() => new AssistantRuntimeImpl(runtime), [runtime]);
};
var useRemoteThreadListRuntime = (options) => {
  const aui = useAui();
  const isNested = aui.threadListItem.source !== null;
  if (isNested) {
    if (!options.allowNesting) {
      throw new Error("useRemoteThreadListRuntime cannot be nested inside another RemoteThreadListRuntime. Set allowNesting: true to allow nesting (the inner runtime will become a no-op).");
    }
    return options.runtimeHook();
  }
  return useRemoteThreadListRuntimeImpl(options);
};

// node_modules/@assistant-ui/react/dist/legacy-runtime/cloud/useCloudThreadListRuntime.js
var useCloudThreadListRuntime = ({ runtimeHook, ...adapterOptions }) => {
  const adapter = useCloudThreadListAdapter(adapterOptions);
  const runtime = useRemoteThreadListRuntime({
    runtimeHook,
    adapter,
    allowNesting: true
  });
  return runtime;
};

// node_modules/@assistant-ui/react/dist/context/react/utils/useRuntimeState.js
var import_react35 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/context/react/utils/ensureBinding.js
var debugVerifyPrototype = (runtime, prototype) => {
  const unboundMethods = Object.getOwnPropertyNames(prototype).filter((methodStr) => {
    const descriptor = Object.getOwnPropertyDescriptor(prototype, methodStr);
    const isMethod = descriptor && typeof descriptor.value === "function";
    if (!isMethod)
      return false;
    const methodName = methodStr;
    return isMethod && !methodName.startsWith("_") && methodName !== "constructor" && prototype[methodName] === runtime[methodName];
  });
  if (unboundMethods.length > 0) {
    throw new Error(`The following methods are not bound: ${JSON.stringify(unboundMethods)}`);
  }
  const prototypePrototype = Object.getPrototypeOf(prototype);
  if (prototypePrototype && prototypePrototype !== Object.prototype) {
    debugVerifyPrototype(runtime, prototypePrototype);
  }
};
var ensureBinding = (r) => {
  var _a3;
  const runtime = r;
  if (runtime.__isBound)
    return;
  (_a3 = runtime.__internal_bindMethods) == null ? void 0 : _a3.call(runtime);
  runtime.__isBound = true;
  if (true) {
    debugVerifyPrototype(runtime, Object.getPrototypeOf(runtime));
  }
};

// node_modules/@assistant-ui/react/dist/context/react/utils/useRuntimeState.js
function useRuntimeStateInternal(runtime, selector = identity2) {
  ensureBinding(runtime);
  const slice = (0, import_react35.useSyncExternalStore)(runtime.subscribe, () => selector(runtime.getState()), () => selector(runtime.getState()));
  (0, import_react35.useDebugValue)(slice);
  return slice;
}
var identity2 = (arg) => arg;

// node_modules/@assistant-ui/react/dist/context/react/utils/createStateHookForRuntime.js
function createStateHookForRuntime(useRuntime) {
  function useStoreHook(param) {
    let optional2 = false;
    let selector;
    if (typeof param === "function") {
      selector = param;
    } else if (param) {
      optional2 = !!param.optional;
      selector = param.selector;
    }
    const store = useRuntime({ optional: optional2 });
    if (!store)
      return null;
    return useRuntimeStateInternal(store, selector);
  }
  return useStoreHook;
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/hooks/AssistantContext.js
function useAssistantRuntime(options) {
  var _a3, _b;
  const aui = useAui();
  const runtime = ((_b = (_a3 = aui.threads()).__internal_getAssistantRuntime) == null ? void 0 : _b.call(_a3)) ?? null;
  if (!runtime && !(options == null ? void 0 : options.optional)) {
    throw new Error("AssistantRuntime is not available");
  }
  return runtime;
}
var useThreadListRuntime = (opt) => {
  var _a3;
  return ((_a3 = useAssistantRuntime(opt)) == null ? void 0 : _a3.threads) ?? null;
};
var useThreadList = createStateHookForRuntime(useThreadListRuntime);

// node_modules/@assistant-ui/react/dist/legacy-runtime/hooks/AttachmentContext.js
function useAttachmentRuntime(options) {
  const aui = useAui();
  const runtime = useAuiState(() => {
    var _a3, _b;
    return aui.attachment.source ? ((_b = (_a3 = aui.attachment()).__internal_getRuntime) == null ? void 0 : _b.call(_a3)) ?? null : null;
  });
  if (!runtime && !(options == null ? void 0 : options.optional)) {
    throw new Error("AttachmentRuntime is not available");
  }
  return runtime;
}
function useThreadComposerAttachmentRuntime(options) {
  const attachmentRuntime = useAttachmentRuntime(options);
  if (!attachmentRuntime)
    return null;
  if (attachmentRuntime.source !== "thread-composer")
    throw new Error("This component must be used within a thread's ComposerPrimitive.Attachments component.");
  return attachmentRuntime;
}
function useEditComposerAttachmentRuntime(options) {
  const attachmentRuntime = useAttachmentRuntime(options);
  if (!attachmentRuntime)
    return null;
  if (attachmentRuntime.source !== "edit-composer")
    throw new Error("This component must be used within a message's ComposerPrimitive.Attachments component.");
  return attachmentRuntime;
}
function useMessageAttachmentRuntime(options) {
  const attachmentRuntime = useAttachmentRuntime(options);
  if (!attachmentRuntime)
    return null;
  if (attachmentRuntime.source !== "message")
    throw new Error("This component must be used within a MessagePrimitive.Attachments component.");
  return attachmentRuntime;
}
var useAttachment = createStateHookForRuntime(useAttachmentRuntime);
var useThreadComposerAttachment = createStateHookForRuntime(useThreadComposerAttachmentRuntime);
var useEditComposerAttachment = createStateHookForRuntime(useEditComposerAttachmentRuntime);
var useMessageAttachment = createStateHookForRuntime(useMessageAttachmentRuntime);

// node_modules/@assistant-ui/react/dist/legacy-runtime/hooks/ComposerContext.js
function useComposerRuntime(options) {
  const aui = useAui();
  const runtime = useAuiState(() => {
    var _a3, _b;
    return aui.composer.source ? ((_b = (_a3 = aui.composer()).__internal_getRuntime) == null ? void 0 : _b.call(_a3)) ?? null : null;
  });
  if (!runtime && !(options == null ? void 0 : options.optional)) {
    throw new Error("ComposerRuntime is not available");
  }
  return runtime;
}
var useComposer = createStateHookForRuntime(useComposerRuntime);

// node_modules/@assistant-ui/react/dist/legacy-runtime/hooks/MessageContext.js
function useMessageRuntime(options) {
  const aui = useAui();
  const runtime = useAuiState(() => {
    var _a3, _b;
    return aui.message.source ? ((_b = (_a3 = aui.message()).__internal_getRuntime) == null ? void 0 : _b.call(_a3)) ?? null : null;
  });
  if (!runtime && !(options == null ? void 0 : options.optional)) {
    throw new Error("MessageRuntime is not available");
  }
  return runtime;
}
var useMessage = createStateHookForRuntime(useMessageRuntime);
var useEditComposerRuntime = (opt) => {
  var _a3;
  return ((_a3 = useMessageRuntime(opt)) == null ? void 0 : _a3.composer) ?? null;
};
var useEditComposer = createStateHookForRuntime(useEditComposerRuntime);

// node_modules/@assistant-ui/react/dist/legacy-runtime/hooks/MessagePartContext.js
function useMessagePartRuntime(options) {
  const aui = useAui();
  const runtime = useAuiState(() => {
    var _a3, _b;
    return aui.part.source ? ((_b = (_a3 = aui.part()).__internal_getRuntime) == null ? void 0 : _b.call(_a3)) ?? null : null;
  });
  if (!runtime && !(options == null ? void 0 : options.optional)) {
    throw new Error("MessagePartRuntime is not available");
  }
  return runtime;
}
var useMessagePart = createStateHookForRuntime(useMessagePartRuntime);

// node_modules/@assistant-ui/react/dist/legacy-runtime/hooks/ThreadContext.js
var import_react36 = __toESM(require_react(), 1);
function useThreadRuntime(options) {
  const aui = useAui();
  const runtime = useAuiState(() => {
    var _a3, _b;
    return aui.thread.source ? ((_b = (_a3 = aui.thread()).__internal_getRuntime) == null ? void 0 : _b.call(_a3)) ?? null : null;
  });
  if (!runtime && !(options == null ? void 0 : options.optional)) {
    throw new Error("ThreadRuntime is not available");
  }
  return runtime;
}
var useThread = createStateHookForRuntime(useThreadRuntime);
var useThreadComposerRuntime = (opt) => {
  var _a3;
  return ((_a3 = useThreadRuntime(opt)) == null ? void 0 : _a3.composer) ?? null;
};
var useThreadComposer = createStateHookForRuntime(useThreadComposerRuntime);
function useThreadModelContext(options) {
  const [, rerender] = (0, import_react36.useState)({});
  const runtime = useThreadRuntime(options);
  useAuiEvent("thread.modelContextUpdate", () => rerender({}));
  if (!runtime)
    return null;
  return runtime == null ? void 0 : runtime.getModelContext();
}

// node_modules/@assistant-ui/react/dist/legacy-runtime/hooks/ThreadListItemContext.js
function useThreadListItemRuntime(options) {
  const aui = useAui();
  const runtime = useAuiState(() => {
    var _a3, _b;
    return aui.threadListItem.source ? ((_b = (_a3 = aui.threadListItem()).__internal_getRuntime) == null ? void 0 : _b.call(_a3)) ?? null : null;
  });
  if (!runtime && !(options == null ? void 0 : options.optional)) {
    throw new Error("ThreadListItemRuntime is not available");
  }
  return runtime;
}
var useThreadListItem = createStateHookForRuntime(useThreadListItemRuntime);

// node_modules/@assistant-ui/react/dist/primitives/actionBar/index.js
var actionBar_exports = {};
__export(actionBar_exports, {
  Copy: () => ActionBarPrimitiveCopy,
  Edit: () => ActionBarPrimitiveEdit,
  ExportMarkdown: () => ActionBarPrimitiveExportMarkdown,
  FeedbackNegative: () => ActionBarPrimitiveFeedbackNegative,
  FeedbackPositive: () => ActionBarPrimitiveFeedbackPositive,
  Reload: () => ActionBarPrimitiveReload,
  Root: () => ActionBarPrimitiveRoot,
  Speak: () => ActionBarPrimitiveSpeak,
  StopSpeaking: () => ActionBarPrimitiveStopSpeaking
});

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarRoot.js
var import_jsx_runtime19 = __toESM(require_jsx_runtime(), 1);

// node_modules/@assistant-ui/react/node_modules/@radix-ui/react-primitive/dist/index.mjs
var React4 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);

// node_modules/@assistant-ui/react/node_modules/@radix-ui/react-slot/dist/index.mjs
var React3 = __toESM(require_react(), 1);
var import_jsx_runtime17 = __toESM(require_jsx_runtime(), 1);
var REACT_LAZY_TYPE = Symbol.for("react.lazy");
var use = React3[" use ".trim().toString()];
function isPromiseLike(value) {
  return typeof value === "object" && value !== null && "then" in value;
}
function isLazyComponent(element) {
  return element != null && typeof element === "object" && "$$typeof" in element && element.$$typeof === REACT_LAZY_TYPE && "_payload" in element && isPromiseLike(element._payload);
}
function createSlot(ownerName) {
  const SlotClone = createSlotClone(ownerName);
  const Slot2 = React3.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    const childrenArray = React3.Children.toArray(children);
    const slottable = childrenArray.find(isSlottable);
    if (slottable) {
      const newElement = slottable.props.children;
      const newChildren = childrenArray.map((child) => {
        if (child === slottable) {
          if (React3.Children.count(newElement) > 1) return React3.Children.only(null);
          return React3.isValidElement(newElement) ? newElement.props.children : null;
        } else {
          return child;
        }
      });
      return (0, import_jsx_runtime17.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children: React3.isValidElement(newElement) ? React3.cloneElement(newElement, void 0, newChildren) : null });
    }
    return (0, import_jsx_runtime17.jsx)(SlotClone, { ...slotProps, ref: forwardedRef, children });
  });
  Slot2.displayName = `${ownerName}.Slot`;
  return Slot2;
}
var Slot = createSlot("Slot");
function createSlotClone(ownerName) {
  const SlotClone = React3.forwardRef((props, forwardedRef) => {
    let { children, ...slotProps } = props;
    if (isLazyComponent(children) && typeof use === "function") {
      children = use(children._payload);
    }
    if (React3.isValidElement(children)) {
      const childrenRef = getElementRef(children);
      const props2 = mergeProps(slotProps, children.props);
      if (children.type !== React3.Fragment) {
        props2.ref = forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef;
      }
      return React3.cloneElement(children, props2);
    }
    return React3.Children.count(children) > 1 ? React3.Children.only(null) : null;
  });
  SlotClone.displayName = `${ownerName}.SlotClone`;
  return SlotClone;
}
var SLOTTABLE_IDENTIFIER = Symbol("radix.slottable");
function createSlottable(ownerName) {
  const Slottable2 = ({ children }) => {
    return (0, import_jsx_runtime17.jsx)(import_jsx_runtime17.Fragment, { children });
  };
  Slottable2.displayName = `${ownerName}.Slottable`;
  Slottable2.__radixId = SLOTTABLE_IDENTIFIER;
  return Slottable2;
}
var Slottable = createSlottable("Slottable");
function isSlottable(child) {
  return React3.isValidElement(child) && typeof child.type === "function" && "__radixId" in child.type && child.type.__radixId === SLOTTABLE_IDENTIFIER;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          const result = childPropValue(...args);
          slotPropValue(...args);
          return result;
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef(element) {
  var _a3, _b;
  let getter = (_a3 = Object.getOwnPropertyDescriptor(element.props, "ref")) == null ? void 0 : _a3.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = (_b = Object.getOwnPropertyDescriptor(element, "ref")) == null ? void 0 : _b.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}

// node_modules/@assistant-ui/react/node_modules/@radix-ui/react-primitive/dist/index.mjs
var import_jsx_runtime18 = __toESM(require_jsx_runtime(), 1);
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "select",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Slot2 = createSlot(`Primitive.${node}`);
  const Node = React4.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot2 : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return (0, import_jsx_runtime18.jsx)(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node };
}, {});

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarRoot.js
var import_react37 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/primitives/actionBar/useActionBarFloatStatus.js
var HideAndFloatStatus;
(function(HideAndFloatStatus2) {
  HideAndFloatStatus2["Hidden"] = "hidden";
  HideAndFloatStatus2["Floating"] = "floating";
  HideAndFloatStatus2["Normal"] = "normal";
})(HideAndFloatStatus || (HideAndFloatStatus = {}));
var useActionBarFloatStatus = ({ hideWhenRunning, autohide, autohideFloat }) => {
  return useAuiState(({ thread, message }) => {
    if (hideWhenRunning && thread.isRunning)
      return HideAndFloatStatus.Hidden;
    const autohideEnabled = autohide === "always" || autohide === "not-last" && !message.isLast;
    if (!autohideEnabled)
      return HideAndFloatStatus.Normal;
    if (!message.isHovering)
      return HideAndFloatStatus.Hidden;
    if (autohideFloat === "always" || autohideFloat === "single-branch" && message.branchCount <= 1)
      return HideAndFloatStatus.Floating;
    return HideAndFloatStatus.Normal;
  });
};

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarRoot.js
var ActionBarPrimitiveRoot = (0, import_react37.forwardRef)(({ hideWhenRunning, autohide, autohideFloat, ...rest }, ref) => {
  const hideAndfloatStatus = useActionBarFloatStatus({
    hideWhenRunning,
    autohide,
    autohideFloat
  });
  if (hideAndfloatStatus === HideAndFloatStatus.Hidden)
    return null;
  return (0, import_jsx_runtime19.jsx)(Primitive.div, { ...hideAndfloatStatus === HideAndFloatStatus.Floating ? { "data-floating": "true" } : null, ...rest, ref });
});
ActionBarPrimitiveRoot.displayName = "ActionBarPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarCopy.js
var import_jsx_runtime20 = __toESM(require_jsx_runtime(), 1);
var import_react38 = __toESM(require_react(), 1);
var import_react39 = __toESM(require_react(), 1);
var useActionBarPrimitiveCopy = ({ copiedDuration = 3e3 } = {}) => {
  const aui = useAui();
  const hasCopyableContent = useAuiState(({ message }) => {
    var _a3;
    return (message.role !== "assistant" || ((_a3 = message.status) == null ? void 0 : _a3.type) !== "running") && message.parts.some((c) => c.type === "text" && c.text.length > 0);
  });
  const isEditing = useAuiState(({ composer }) => composer.isEditing);
  const composerValue = useAuiState(({ composer }) => composer.text);
  const callback = (0, import_react39.useCallback)(() => {
    const valueToCopy = isEditing ? composerValue : aui.message().getCopyText();
    if (!valueToCopy)
      return;
    navigator.clipboard.writeText(valueToCopy).then(() => {
      aui.message().setIsCopied(true);
      setTimeout(() => aui.message().setIsCopied(false), copiedDuration);
    });
  }, [aui, isEditing, composerValue, copiedDuration]);
  if (!hasCopyableContent)
    return null;
  return callback;
};
var ActionBarPrimitiveCopy = (0, import_react38.forwardRef)(({ copiedDuration, onClick, disabled, ...props }, forwardedRef) => {
  const isCopied = useAuiState(({ message }) => message.isCopied);
  const callback = useActionBarPrimitiveCopy({ copiedDuration });
  return (0, import_jsx_runtime20.jsx)(Primitive.button, { type: "button", ...isCopied ? { "data-copied": "true" } : {}, ...props, ref: forwardedRef, disabled: disabled || !callback, onClick: composeEventHandlers(onClick, () => {
    callback == null ? void 0 : callback();
  }) });
});
ActionBarPrimitiveCopy.displayName = "ActionBarPrimitive.Copy";

// node_modules/@assistant-ui/react/dist/utils/createActionButton.js
var import_jsx_runtime21 = __toESM(require_jsx_runtime(), 1);
var import_react40 = __toESM(require_react(), 1);
var createActionButton = (displayName, useActionButton, forwardProps = []) => {
  const ActionButton = (0, import_react40.forwardRef)((props, forwardedRef) => {
    const forwardedProps = {};
    const primitiveProps = {};
    Object.keys(props).forEach((key) => {
      if (forwardProps.includes(key)) {
        forwardedProps[key] = props[key];
      } else {
        primitiveProps[key] = props[key];
      }
    });
    const callback = useActionButton(forwardedProps) ?? void 0;
    return (0, import_jsx_runtime21.jsx)(Primitive.button, { type: "button", ...primitiveProps, ref: forwardedRef, disabled: primitiveProps.disabled || !callback, onClick: composeEventHandlers(primitiveProps.onClick, callback) });
  });
  ActionButton.displayName = displayName;
  return ActionButton;
};

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarReload.js
var import_react41 = __toESM(require_react(), 1);
var useActionBarReload = () => {
  const aui = useAui();
  const disabled = useAuiState((s) => s.thread.isRunning || s.thread.isDisabled || s.message.role !== "assistant");
  const callback = (0, import_react41.useCallback)(() => {
    aui.message().reload();
  }, [aui]);
  if (disabled)
    return null;
  return callback;
};
var ActionBarPrimitiveReload = createActionButton("ActionBarPrimitive.Reload", useActionBarReload);

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarEdit.js
var import_react42 = __toESM(require_react(), 1);
var useActionBarEdit = () => {
  const aui = useAui();
  const disabled = useAuiState(({ composer }) => composer.isEditing);
  const callback = (0, import_react42.useCallback)(() => {
    aui.composer().beginEdit();
  }, [aui]);
  if (disabled)
    return null;
  return callback;
};
var ActionBarPrimitiveEdit = createActionButton("ActionBarPrimitive.Edit", useActionBarEdit);

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarSpeak.js
var import_react43 = __toESM(require_react(), 1);
var useActionBarSpeak = () => {
  const aui = useAui();
  const callback = (0, import_react43.useCallback)(async () => {
    aui.message().speak();
  }, [aui]);
  const hasSpeakableContent = useAuiState(({ message }) => {
    var _a3;
    return (message.role !== "assistant" || ((_a3 = message.status) == null ? void 0 : _a3.type) !== "running") && message.parts.some((c) => c.type === "text" && c.text.length > 0);
  });
  if (!hasSpeakableContent)
    return null;
  return callback;
};
var ActionBarPrimitiveSpeak = createActionButton("ActionBarPrimitive.Speak", useActionBarSpeak);

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarStopSpeaking.js
var import_jsx_runtime22 = __toESM(require_jsx_runtime(), 1);
var import_react44 = __toESM(require_react(), 1);
var import_react45 = __toESM(require_react(), 1);
var useActionBarStopSpeaking = () => {
  const aui = useAui();
  const isSpeaking = useAuiState(({ message }) => message.speech != null);
  const callback = (0, import_react45.useCallback)(() => {
    aui.message().stopSpeaking();
  }, [aui]);
  if (!isSpeaking)
    return null;
  return callback;
};
var ActionBarPrimitiveStopSpeaking = (0, import_react44.forwardRef)((props, ref) => {
  const callback = useActionBarStopSpeaking();
  useEscapeKeydown((e) => {
    if (callback) {
      e.preventDefault();
      callback();
    }
  });
  return (0, import_jsx_runtime22.jsx)(Primitive.button, { type: "button", disabled: !callback, ...props, ref, onClick: composeEventHandlers(props.onClick, () => {
    callback == null ? void 0 : callback();
  }) });
});
ActionBarPrimitiveStopSpeaking.displayName = "ActionBarPrimitive.StopSpeaking";

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarFeedbackPositive.js
var import_jsx_runtime23 = __toESM(require_jsx_runtime(), 1);
var import_react46 = __toESM(require_react(), 1);
var useActionBarFeedbackPositive = () => {
  const aui = useAui();
  const callback = (0, import_react46.useCallback)(() => {
    aui.message().submitFeedback({ type: "positive" });
  }, [aui]);
  return callback;
};
var ActionBarPrimitiveFeedbackPositive = (0, import_react46.forwardRef)(({ onClick, disabled, ...props }, forwardedRef) => {
  const isSubmitted = useAuiState((s) => {
    var _a3;
    return ((_a3 = s.message.metadata.submittedFeedback) == null ? void 0 : _a3.type) === "positive";
  });
  const callback = useActionBarFeedbackPositive();
  return (0, import_jsx_runtime23.jsx)(Primitive.button, { type: "button", ...isSubmitted ? { "data-submitted": "true" } : {}, ...props, ref: forwardedRef, disabled: disabled || !callback, onClick: composeEventHandlers(onClick, () => {
    callback == null ? void 0 : callback();
  }) });
});
ActionBarPrimitiveFeedbackPositive.displayName = "ActionBarPrimitive.FeedbackPositive";

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarFeedbackNegative.js
var import_jsx_runtime24 = __toESM(require_jsx_runtime(), 1);
var import_react47 = __toESM(require_react(), 1);
var import_react48 = __toESM(require_react(), 1);
var useActionBarFeedbackNegative = () => {
  const aui = useAui();
  const callback = (0, import_react48.useCallback)(() => {
    aui.message().submitFeedback({ type: "negative" });
  }, [aui]);
  return callback;
};
var ActionBarPrimitiveFeedbackNegative = (0, import_react47.forwardRef)(({ onClick, disabled, ...props }, forwardedRef) => {
  const isSubmitted = useAuiState((s) => {
    var _a3;
    return ((_a3 = s.message.metadata.submittedFeedback) == null ? void 0 : _a3.type) === "negative";
  });
  const callback = useActionBarFeedbackNegative();
  return (0, import_jsx_runtime24.jsx)(Primitive.button, { type: "button", ...isSubmitted ? { "data-submitted": "true" } : {}, ...props, ref: forwardedRef, disabled: disabled || !callback, onClick: composeEventHandlers(onClick, () => {
    callback == null ? void 0 : callback();
  }) });
});
ActionBarPrimitiveFeedbackNegative.displayName = "ActionBarPrimitive.FeedbackNegative";

// node_modules/@assistant-ui/react/dist/primitives/actionBar/ActionBarExportMarkdown.js
var import_jsx_runtime25 = __toESM(require_jsx_runtime(), 1);
var import_react49 = __toESM(require_react(), 1);
var useActionBarExportMarkdown = ({ filename, onExport } = {}) => {
  const aui = useAui();
  const hasExportableContent = useAuiState(({ message }) => {
    var _a3;
    return (message.role !== "assistant" || ((_a3 = message.status) == null ? void 0 : _a3.type) !== "running") && message.parts.some((c) => c.type === "text" && c.text.length > 0);
  });
  const callback = (0, import_react49.useCallback)(async () => {
    const content = aui.message().getCopyText();
    if (!content)
      return;
    if (onExport) {
      await onExport(content);
      return;
    }
    const blob = new Blob([content], { type: "text/markdown" });
    const url2 = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url2;
    a.download = filename ?? `message-${Date.now()}.md`;
    a.click();
    URL.revokeObjectURL(url2);
  }, [aui, filename, onExport]);
  if (!hasExportableContent)
    return null;
  return callback;
};
var ActionBarPrimitiveExportMarkdown = (0, import_react49.forwardRef)(({ filename, onExport, onClick, disabled, ...props }, forwardedRef) => {
  const callback = useActionBarExportMarkdown({ filename, onExport });
  return (0, import_jsx_runtime25.jsx)(Primitive.button, { type: "button", ...props, ref: forwardedRef, disabled: disabled || !callback, onClick: composeEventHandlers(onClick, () => {
    callback == null ? void 0 : callback();
  }) });
});
ActionBarPrimitiveExportMarkdown.displayName = "ActionBarPrimitive.ExportMarkdown";

// node_modules/@assistant-ui/react/dist/primitives/actionBarMore/index.js
var actionBarMore_exports = {};
__export(actionBarMore_exports, {
  Content: () => ActionBarMorePrimitiveContent,
  Item: () => ActionBarMorePrimitiveItem,
  Root: () => ActionBarMorePrimitiveRoot,
  Separator: () => ActionBarMorePrimitiveSeparator,
  Trigger: () => ActionBarMorePrimitiveTrigger
});

// node_modules/@assistant-ui/react/dist/primitives/actionBarMore/ActionBarMoreRoot.js
var import_jsx_runtime26 = __toESM(require_jsx_runtime(), 1);

// node_modules/@assistant-ui/react/dist/primitives/actionBarMore/scope.js
var useDropdownMenuScope = createDropdownMenuScope();

// node_modules/@assistant-ui/react/dist/primitives/actionBarMore/ActionBarMoreRoot.js
var ActionBarMorePrimitiveRoot = ({ __scopeActionBarMore, ...rest }) => {
  const scope = useDropdownMenuScope(__scopeActionBarMore);
  return (0, import_jsx_runtime26.jsx)(Root2, { ...scope, ...rest });
};
ActionBarMorePrimitiveRoot.displayName = "ActionBarMorePrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/actionBarMore/ActionBarMoreTrigger.js
var import_jsx_runtime27 = __toESM(require_jsx_runtime(), 1);
var import_react50 = __toESM(require_react(), 1);
var ActionBarMorePrimitiveTrigger = (0, import_react50.forwardRef)(({ __scopeActionBarMore, ...rest }, ref) => {
  const scope = useDropdownMenuScope(__scopeActionBarMore);
  return (0, import_jsx_runtime27.jsx)(Trigger, { ...scope, ...rest, ref });
});
ActionBarMorePrimitiveTrigger.displayName = "ActionBarMorePrimitive.Trigger";

// node_modules/@assistant-ui/react/dist/primitives/actionBarMore/ActionBarMoreContent.js
var import_jsx_runtime28 = __toESM(require_jsx_runtime(), 1);
var import_react51 = __toESM(require_react(), 1);
var ActionBarMorePrimitiveContent = (0, import_react51.forwardRef)(({ __scopeActionBarMore, portalProps, sideOffset = 4, ...props }, forwardedRef) => {
  const scope = useDropdownMenuScope(__scopeActionBarMore);
  return (0, import_jsx_runtime28.jsx)(Portal2, { ...scope, ...portalProps, children: (0, import_jsx_runtime28.jsx)(Content2, { ...scope, ...props, ref: forwardedRef, sideOffset }) });
});
ActionBarMorePrimitiveContent.displayName = "ActionBarMorePrimitive.Content";

// node_modules/@assistant-ui/react/dist/primitives/actionBarMore/ActionBarMoreItem.js
var import_jsx_runtime29 = __toESM(require_jsx_runtime(), 1);
var import_react52 = __toESM(require_react(), 1);
var ActionBarMorePrimitiveItem = (0, import_react52.forwardRef)(({ __scopeActionBarMore, ...rest }, ref) => {
  const scope = useDropdownMenuScope(__scopeActionBarMore);
  return (0, import_jsx_runtime29.jsx)(Item2, { ...scope, ...rest, ref });
});
ActionBarMorePrimitiveItem.displayName = "ActionBarMorePrimitive.Item";

// node_modules/@assistant-ui/react/dist/primitives/actionBarMore/ActionBarMoreSeparator.js
var import_jsx_runtime30 = __toESM(require_jsx_runtime(), 1);
var import_react53 = __toESM(require_react(), 1);
var ActionBarMorePrimitiveSeparator = (0, import_react53.forwardRef)(({ __scopeActionBarMore, ...rest }, ref) => {
  const scope = useDropdownMenuScope(__scopeActionBarMore);
  return (0, import_jsx_runtime30.jsx)(Separator2, { ...scope, ...rest, ref });
});
ActionBarMorePrimitiveSeparator.displayName = "ActionBarMorePrimitive.Separator";

// node_modules/@assistant-ui/react/dist/primitives/assistantModal/index.js
var assistantModal_exports = {};
__export(assistantModal_exports, {
  Anchor: () => AssistantModalPrimitiveAnchor,
  Content: () => AssistantModalPrimitiveContent,
  Root: () => AssistantModalPrimitiveRoot,
  Trigger: () => AssistantModalPrimitiveTrigger
});

// node_modules/@assistant-ui/react/dist/primitives/assistantModal/AssistantModalRoot.js
var import_jsx_runtime31 = __toESM(require_jsx_runtime(), 1);
var import_react54 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/primitives/assistantModal/scope.js
var usePopoverScope = createPopoverScope();

// node_modules/@assistant-ui/react/dist/primitives/assistantModal/AssistantModalRoot.js
var useAssistantModalOpenState = ({ defaultOpen = false, unstable_openOnRunStart = true }) => {
  const state = (0, import_react54.useState)(defaultOpen);
  const [, setOpen] = state;
  const aui = useAui();
  (0, import_react54.useEffect)(() => {
    if (!unstable_openOnRunStart)
      return void 0;
    return aui.on("thread.runStart", () => {
      setOpen(true);
    });
  }, [unstable_openOnRunStart, aui]);
  return state;
};
var AssistantModalPrimitiveRoot = ({ __scopeAssistantModal, defaultOpen, unstable_openOnRunStart, open, onOpenChange, ...rest }) => {
  const scope = usePopoverScope(__scopeAssistantModal);
  const [modalOpen, setOpen] = useAssistantModalOpenState({
    defaultOpen,
    unstable_openOnRunStart
  });
  const openChangeHandler = (open2) => {
    onOpenChange == null ? void 0 : onOpenChange(open2);
    setOpen(open2);
  };
  return (0, import_jsx_runtime31.jsx)(Root22, { ...scope, open: open === void 0 ? modalOpen : open, onOpenChange: openChangeHandler, ...rest });
};
AssistantModalPrimitiveRoot.displayName = "AssistantModalPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/assistantModal/AssistantModalTrigger.js
var import_jsx_runtime32 = __toESM(require_jsx_runtime(), 1);
var import_react55 = __toESM(require_react(), 1);
var AssistantModalPrimitiveTrigger = (0, import_react55.forwardRef)(({ __scopeAssistantModal, ...rest }, ref) => {
  const scope = usePopoverScope(__scopeAssistantModal);
  return (0, import_jsx_runtime32.jsx)(Trigger2, { ...scope, ...rest, ref });
});
AssistantModalPrimitiveTrigger.displayName = "AssistantModalPrimitive.Trigger";

// node_modules/@assistant-ui/react/dist/primitives/assistantModal/AssistantModalContent.js
var import_jsx_runtime33 = __toESM(require_jsx_runtime(), 1);
var import_react56 = __toESM(require_react(), 1);
var AssistantModalPrimitiveContent = (0, import_react56.forwardRef)(({ __scopeAssistantModal, side, align, onInteractOutside, dissmissOnInteractOutside = false, portalProps, ...props }, forwardedRef) => {
  const scope = usePopoverScope(__scopeAssistantModal);
  return (0, import_jsx_runtime33.jsx)(Portal, { ...scope, ...portalProps, children: (0, import_jsx_runtime33.jsx)(Content22, { ...scope, ...props, ref: forwardedRef, side: side ?? "top", align: align ?? "end", onInteractOutside: composeEventHandlers(onInteractOutside, dissmissOnInteractOutside ? void 0 : (e) => e.preventDefault()) }) });
});
AssistantModalPrimitiveContent.displayName = "AssistantModalPrimitive.Content";

// node_modules/@assistant-ui/react/dist/primitives/assistantModal/AssistantModalAnchor.js
var import_jsx_runtime34 = __toESM(require_jsx_runtime(), 1);
var import_react57 = __toESM(require_react(), 1);
var AssistantModalPrimitiveAnchor = (0, import_react57.forwardRef)(({ __scopeAssistantModal, ...rest }, ref) => {
  const scope = usePopoverScope(__scopeAssistantModal);
  return (0, import_jsx_runtime34.jsx)(Anchor2, { ...scope, ...rest, ref });
});
AssistantModalPrimitiveAnchor.displayName = "AssistantModalPrimitive.Anchor";

// node_modules/@assistant-ui/react/dist/primitives/attachment/index.js
var attachment_exports = {};
__export(attachment_exports, {
  Name: () => AttachmentPrimitiveName,
  Remove: () => AttachmentPrimitiveRemove,
  Root: () => AttachmentPrimitiveRoot,
  unstable_Thumb: () => AttachmentPrimitiveThumb
});

// node_modules/@assistant-ui/react/dist/primitives/attachment/AttachmentRoot.js
var import_jsx_runtime35 = __toESM(require_jsx_runtime(), 1);
var import_react58 = __toESM(require_react(), 1);
var AttachmentPrimitiveRoot = (0, import_react58.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime35.jsx)(Primitive.div, { ...props, ref });
});
AttachmentPrimitiveRoot.displayName = "AttachmentPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/attachment/AttachmentThumb.js
var import_jsx_runtime36 = __toESM(require_jsx_runtime(), 1);
var import_react59 = __toESM(require_react(), 1);
var AttachmentPrimitiveThumb = (0, import_react59.forwardRef)((props, ref) => {
  const ext = useAuiState(({ attachment }) => {
    const parts = attachment.name.split(".");
    return parts.length > 1 ? parts.pop() : "";
  });
  return (0, import_jsx_runtime36.jsxs)(Primitive.div, { ...props, ref, children: [".", ext] });
});
AttachmentPrimitiveThumb.displayName = "AttachmentPrimitive.Thumb";

// node_modules/@assistant-ui/react/dist/primitives/attachment/AttachmentName.js
var import_jsx_runtime37 = __toESM(require_jsx_runtime(), 1);
var AttachmentPrimitiveName = () => {
  const name = useAuiState(({ attachment }) => attachment.name);
  return (0, import_jsx_runtime37.jsx)(import_jsx_runtime37.Fragment, { children: name });
};
AttachmentPrimitiveName.displayName = "AttachmentPrimitive.Name";

// node_modules/@assistant-ui/react/dist/primitives/attachment/AttachmentRemove.js
var import_react60 = __toESM(require_react(), 1);
var useAttachmentRemove = () => {
  const aui = useAui();
  const handleRemoveAttachment = (0, import_react60.useCallback)(() => {
    aui.attachment().remove();
  }, [aui]);
  return handleRemoveAttachment;
};
var AttachmentPrimitiveRemove = createActionButton("AttachmentPrimitive.Remove", useAttachmentRemove);

// node_modules/@assistant-ui/react/dist/primitives/branchPicker/index.js
var branchPicker_exports = {};
__export(branchPicker_exports, {
  Count: () => BranchPickerPrimitiveCount,
  Next: () => BranchPickerPrimitiveNext,
  Number: () => BranchPickerPrimitiveNumber,
  Previous: () => BranchPickerPrimitivePrevious,
  Root: () => BranchPickerPrimitiveRoot
});

// node_modules/@assistant-ui/react/dist/primitives/branchPicker/BranchPickerNext.js
var import_react61 = __toESM(require_react(), 1);
var useBranchPickerNext = () => {
  const aui = useAui();
  const disabled = useAuiState(({ thread, message }) => {
    if (message.branchNumber >= message.branchCount)
      return true;
    if (thread.isRunning && !thread.capabilities.switchBranchDuringRun) {
      return true;
    }
    return false;
  });
  const callback = (0, import_react61.useCallback)(() => {
    aui.message().switchToBranch({ position: "next" });
  }, [aui]);
  if (disabled)
    return null;
  return callback;
};
var BranchPickerPrimitiveNext = createActionButton("BranchPickerPrimitive.Next", useBranchPickerNext);

// node_modules/@assistant-ui/react/dist/primitives/branchPicker/BranchPickerPrevious.js
var import_react62 = __toESM(require_react(), 1);
var useBranchPickerPrevious = () => {
  const aui = useAui();
  const disabled = useAuiState(({ thread, message }) => {
    if (message.branchNumber <= 1)
      return true;
    if (thread.isRunning && !thread.capabilities.switchBranchDuringRun) {
      return true;
    }
    return false;
  });
  const callback = (0, import_react62.useCallback)(() => {
    aui.message().switchToBranch({ position: "previous" });
  }, [aui]);
  if (disabled)
    return null;
  return callback;
};
var BranchPickerPrimitivePrevious = createActionButton("BranchPickerPrimitive.Previous", useBranchPickerPrevious);

// node_modules/@assistant-ui/react/dist/primitives/branchPicker/BranchPickerCount.js
var import_jsx_runtime38 = __toESM(require_jsx_runtime(), 1);
var useBranchPickerCount = () => {
  const branchCount = useAuiState(({ message }) => message.branchCount);
  return branchCount;
};
var BranchPickerPrimitiveCount = () => {
  const branchCount = useBranchPickerCount();
  return (0, import_jsx_runtime38.jsx)(import_jsx_runtime38.Fragment, { children: branchCount });
};
BranchPickerPrimitiveCount.displayName = "BranchPickerPrimitive.Count";

// node_modules/@assistant-ui/react/dist/primitives/branchPicker/BranchPickerNumber.js
var import_jsx_runtime39 = __toESM(require_jsx_runtime(), 1);
var useBranchPickerNumber = () => {
  const branchNumber = useAuiState(({ message }) => message.branchNumber);
  return branchNumber;
};
var BranchPickerPrimitiveNumber = () => {
  const branchNumber = useBranchPickerNumber();
  return (0, import_jsx_runtime39.jsx)(import_jsx_runtime39.Fragment, { children: branchNumber });
};
BranchPickerPrimitiveNumber.displayName = "BranchPickerPrimitive.Number";

// node_modules/@assistant-ui/react/dist/primitives/branchPicker/BranchPickerRoot.js
var import_jsx_runtime48 = __toESM(require_jsx_runtime(), 1);
var import_react72 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/primitives/message/index.js
var message_exports = {};
__export(message_exports, {
  AttachmentByIndex: () => MessagePrimitiveAttachmentByIndex,
  Attachments: () => MessagePrimitiveAttachments,
  Content: () => MessagePrimitiveParts,
  Error: () => MessagePrimitiveError,
  If: () => MessagePrimitiveIf,
  PartByIndex: () => MessagePrimitivePartByIndex,
  Parts: () => MessagePrimitiveParts,
  Root: () => MessagePrimitiveRoot,
  Unstable_PartsGrouped: () => MessagePrimitiveUnstable_PartsGrouped,
  Unstable_PartsGroupedByParentId: () => MessagePrimitiveUnstable_PartsGroupedByParentId
});

// node_modules/@assistant-ui/react/dist/primitives/message/MessageRoot.js
var import_jsx_runtime41 = __toESM(require_jsx_runtime(), 1);
var import_react66 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/utils/hooks/useManagedRef.js
var import_react63 = __toESM(require_react(), 1);
var useManagedRef = (callback) => {
  const cleanupRef = (0, import_react63.useRef)(void 0);
  const ref = (0, import_react63.useCallback)((el) => {
    if (cleanupRef.current) {
      cleanupRef.current();
    }
    if (el) {
      cleanupRef.current = callback(el);
    }
  }, [callback]);
  return ref;
};

// node_modules/@assistant-ui/react/dist/utils/hooks/useSizeHandle.js
var import_react64 = __toESM(require_react(), 1);
var useSizeHandle = (register, getHeight3) => {
  const callbackRef = (0, import_react64.useCallback)((el) => {
    if (!register)
      return;
    const sizeHandle = register();
    const updateHeight = () => {
      const height = getHeight3 ? getHeight3(el) : el.offsetHeight;
      sizeHandle.setHeight(height);
    };
    const ro = new ResizeObserver(updateHeight);
    ro.observe(el);
    updateHeight();
    return () => {
      ro.disconnect();
      sizeHandle.unregister();
    };
  }, [register, getHeight3]);
  return useManagedRef(callbackRef);
};

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadViewportSlack.js
var import_jsx_runtime40 = __toESM(require_jsx_runtime(), 1);
var import_react65 = __toESM(require_react(), 1);
var SlackNestingContext = (0, import_react65.createContext)(false);
var parseCssLength = (value, element) => {
  const match = value.match(/^([\d.]+)(em|px|rem)$/);
  if (!match)
    return 0;
  const num = parseFloat(match[1]);
  const unit = match[2];
  if (unit === "px")
    return num;
  if (unit === "em") {
    const fontSize = parseFloat(getComputedStyle(element).fontSize) || 16;
    return num * fontSize;
  }
  if (unit === "rem") {
    const rootFontSize = parseFloat(getComputedStyle(document.documentElement).fontSize) || 16;
    return num * rootFontSize;
  }
  return 0;
};
var ThreadPrimitiveViewportSlack = ({ children, fillClampThreshold = "10em", fillClampOffset = "6em" }) => {
  const shouldApplySlack = useAuiState(
    // only add slack to the last assistant message following a user message (valid turn)
    ({ thread, message }) => {
      var _a3;
      return message.isLast && message.role === "assistant" && message.index >= 1 && ((_a3 = thread.messages.at(message.index - 1)) == null ? void 0 : _a3.role) === "user";
    }
  );
  const threadViewportStore = useThreadViewportStore({ optional: true });
  const isNested = (0, import_react65.useContext)(SlackNestingContext);
  const callback = (0, import_react65.useCallback)((el) => {
    if (!threadViewportStore || isNested)
      return;
    const updateMinHeight = () => {
      const state = threadViewportStore.getState();
      if (state.turnAnchor === "top" && shouldApplySlack) {
        const { viewport, inset, userMessage } = state.height;
        const threshold = parseCssLength(fillClampThreshold, el);
        const offset = parseCssLength(fillClampOffset, el);
        const clampAdjustment = userMessage <= threshold ? userMessage : offset;
        const minHeight = Math.max(0, viewport - inset - clampAdjustment);
        el.style.minHeight = `${minHeight}px`;
        el.style.flexShrink = "0";
        el.style.transition = "min-height 0s";
      } else {
        el.style.minHeight = "";
        el.style.flexShrink = "";
        el.style.transition = "";
      }
    };
    updateMinHeight();
    return threadViewportStore.subscribe(updateMinHeight);
  }, [
    threadViewportStore,
    shouldApplySlack,
    isNested,
    fillClampThreshold,
    fillClampOffset
  ]);
  const ref = useManagedRef(callback);
  return (0, import_jsx_runtime40.jsx)(SlackNestingContext.Provider, { value: true, children: (0, import_jsx_runtime40.jsx)(Slot, { ref, children }) });
};
ThreadPrimitiveViewportSlack.displayName = "ThreadPrimitive.ViewportSlack";

// node_modules/@assistant-ui/react/dist/primitives/message/MessageRoot.js
var useIsHoveringRef = () => {
  const aui = useAui();
  const message = useAuiState(() => aui.message());
  const callbackRef = (0, import_react66.useCallback)((el) => {
    const handleMouseEnter = () => {
      message.setIsHovering(true);
    };
    const handleMouseLeave = () => {
      message.setIsHovering(false);
    };
    el.addEventListener("mouseenter", handleMouseEnter);
    el.addEventListener("mouseleave", handleMouseLeave);
    if (el.matches(":hover")) {
      queueMicrotask(() => message.setIsHovering(true));
    }
    return () => {
      el.removeEventListener("mouseenter", handleMouseEnter);
      el.removeEventListener("mouseleave", handleMouseLeave);
      message.setIsHovering(false);
    };
  }, [message]);
  return useManagedRef(callbackRef);
};
var useMessageViewportRef = () => {
  const turnAnchor = useThreadViewport((s) => s.turnAnchor);
  const registerUserHeight = useThreadViewport((s) => s.registerUserMessageHeight);
  const shouldRegisterAsInset = useAuiState(({ thread, message }) => {
    var _a3;
    return turnAnchor === "top" && message.role === "user" && message.index === thread.messages.length - 2 && ((_a3 = thread.messages.at(-1)) == null ? void 0 : _a3.role) === "assistant";
  });
  const getHeight3 = (0, import_react66.useCallback)((el) => el.offsetHeight, []);
  return useSizeHandle(shouldRegisterAsInset ? registerUserHeight : null, getHeight3);
};
var MessagePrimitiveRoot = (0, import_react66.forwardRef)((props, forwardRef45) => {
  const isHoveringRef = useIsHoveringRef();
  const anchorUserMessageRef = useMessageViewportRef();
  const ref = useComposedRefs(forwardRef45, isHoveringRef, anchorUserMessageRef);
  return (0, import_jsx_runtime41.jsx)(ThreadPrimitiveViewportSlack, { children: (0, import_jsx_runtime41.jsx)(Primitive.div, { ...props, ref }) });
});
MessagePrimitiveRoot.displayName = "MessagePrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/message/MessageParts.js
var import_jsx_runtime45 = __toESM(require_jsx_runtime(), 1);
var import_react69 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/context/providers/ChainOfThoughtByIndicesProvider.js
var import_jsx_runtime42 = __toESM(require_jsx_runtime(), 1);

// node_modules/@assistant-ui/react/dist/client/ChainOfThoughtClient.js
var COMPLETE_STATUS2 = Object.freeze({
  type: "complete"
});
var ChainOfThoughtClient = resource(({ parts, getMessagePart }) => {
  const [collapsed, setCollapsed] = tapState(true);
  const status = tapMemo(() => {
    const lastPart = parts[parts.length - 1];
    return (lastPart == null ? void 0 : lastPart.status) ?? COMPLETE_STATUS2;
  }, [parts]);
  const state = tapMemo(() => ({ parts, collapsed, status }), [parts, collapsed, status]);
  return {
    state,
    methods: {
      getState: () => state,
      setCollapsed,
      part: getMessagePart
    }
  };
});

// node_modules/@assistant-ui/react/dist/context/providers/ChainOfThoughtByIndicesProvider.js
var ChainOfThoughtByIndicesProvider = ({ startIndex, endIndex, children }) => {
  const parts = useAuiState(({ message }) => message.parts).slice(startIndex, endIndex + 1);
  const parentAui = useAui();
  const aui = useAui({
    chainOfThought: ChainOfThoughtClient({
      parts,
      getMessagePart: ({ index: index3 }) => {
        if (index3 < 0 || index3 >= parts.length) {
          throw new Error(`ChainOfThought part index ${index3} is out of bounds (0..${parts.length - 1})`);
        }
        return parentAui.message().part({ index: startIndex + index3 });
      }
    })
  });
  return (0, import_jsx_runtime42.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/primitives/messagePart/MessagePartText.js
var import_jsx_runtime43 = __toESM(require_jsx_runtime(), 1);
var import_react67 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/primitives/messagePart/useMessagePartText.js
var useMessagePartText = () => {
  const text = useAuiState(({ part }) => {
    if (part.type !== "text" && part.type !== "reasoning")
      throw new Error("MessagePartText can only be used inside text or reasoning message parts.");
    return part;
  });
  return text;
};

// node_modules/@assistant-ui/react/dist/primitives/messagePart/MessagePartText.js
var MessagePartPrimitiveText = (0, import_react67.forwardRef)(({ smooth = true, component: Component = "span", ...rest }, forwardedRef) => {
  const { text, status } = useSmooth(useMessagePartText(), smooth);
  return (0, import_jsx_runtime43.jsx)(Component, { "data-status": status.type, ...rest, ref: forwardedRef, children: text });
});
MessagePartPrimitiveText.displayName = "MessagePartPrimitive.Text";

// node_modules/@assistant-ui/react/dist/primitives/messagePart/MessagePartImage.js
var import_jsx_runtime44 = __toESM(require_jsx_runtime(), 1);
var import_react68 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/primitives/messagePart/useMessagePartImage.js
var useMessagePartImage = () => {
  const image = useAuiState(({ part }) => {
    if (part.type !== "image")
      throw new Error("MessagePartImage can only be used inside image message parts.");
    return part;
  });
  return image;
};

// node_modules/@assistant-ui/react/dist/primitives/messagePart/MessagePartImage.js
var MessagePartPrimitiveImage = (0, import_react68.forwardRef)((props, forwardedRef) => {
  const { image } = useMessagePartImage();
  return (0, import_jsx_runtime44.jsx)(Primitive.img, { src: image, ...props, ref: forwardedRef });
});
MessagePartPrimitiveImage.displayName = "MessagePartPrimitive.Image";

// node_modules/@assistant-ui/react/dist/primitives/messagePart/MessagePartInProgress.js
var MessagePartPrimitiveInProgress = ({ children }) => {
  const isInProgress = useAuiState(({ part }) => part.status.type === "running");
  return isInProgress ? children : null;
};
MessagePartPrimitiveInProgress.displayName = "MessagePartPrimitive.InProgress";

// node_modules/@assistant-ui/react/dist/primitives/message/MessageParts.js
var createGroupState = (groupType) => {
  let start = -1;
  return {
    startGroup: (index3) => {
      if (start === -1) {
        start = index3;
      }
    },
    endGroup: (endIndex, ranges) => {
      if (start !== -1) {
        ranges.push({
          type: groupType,
          startIndex: start,
          endIndex
        });
        start = -1;
      }
    },
    finalize: (endIndex, ranges) => {
      if (start !== -1) {
        ranges.push({
          type: groupType,
          startIndex: start,
          endIndex
        });
      }
    }
  };
};
var groupMessageParts = (messageTypes, useChainOfThought) => {
  const ranges = [];
  if (useChainOfThought) {
    const chainOfThoughtGroup = createGroupState("chainOfThoughtGroup");
    for (let i = 0; i < messageTypes.length; i++) {
      const type = messageTypes[i];
      if (type === "tool-call" || type === "reasoning") {
        chainOfThoughtGroup.startGroup(i);
      } else {
        chainOfThoughtGroup.endGroup(i - 1, ranges);
        ranges.push({ type: "single", index: i });
      }
    }
    chainOfThoughtGroup.finalize(messageTypes.length - 1, ranges);
  } else {
    const toolGroup = createGroupState("toolGroup");
    const reasoningGroup = createGroupState("reasoningGroup");
    for (let i = 0; i < messageTypes.length; i++) {
      const type = messageTypes[i];
      if (type === "tool-call") {
        reasoningGroup.endGroup(i - 1, ranges);
        toolGroup.startGroup(i);
      } else if (type === "reasoning") {
        toolGroup.endGroup(i - 1, ranges);
        reasoningGroup.startGroup(i);
      } else {
        toolGroup.endGroup(i - 1, ranges);
        reasoningGroup.endGroup(i - 1, ranges);
        ranges.push({ type: "single", index: i });
      }
    }
    toolGroup.finalize(messageTypes.length - 1, ranges);
    reasoningGroup.finalize(messageTypes.length - 1, ranges);
  }
  return ranges;
};
var useMessagePartsGroups = (useChainOfThought) => {
  const messageTypes = useAuiState(useShallow((s) => s.message.parts.map((c) => c.type)));
  return (0, import_react69.useMemo)(() => {
    if (messageTypes.length === 0) {
      return [];
    }
    return groupMessageParts(messageTypes, useChainOfThought);
  }, [messageTypes, useChainOfThought]);
};
var ToolUIDisplay = ({ Fallback, ...props }) => {
  const Render = useAuiState(({ tools }) => {
    const Render2 = tools.tools[props.toolName] ?? Fallback;
    if (Array.isArray(Render2))
      return Render2[0] ?? Fallback;
    return Render2;
  });
  if (!Render)
    return null;
  return (0, import_jsx_runtime45.jsx)(Render, { ...props });
};
var defaultComponents = {
  Text: () => (0, import_jsx_runtime45.jsxs)("p", { style: { whiteSpace: "pre-line" }, children: [(0, import_jsx_runtime45.jsx)(MessagePartPrimitiveText, {}), (0, import_jsx_runtime45.jsx)(MessagePartPrimitiveInProgress, { children: (0, import_jsx_runtime45.jsx)("span", { style: { fontFamily: "revert" }, children: " " }) })] }),
  Reasoning: () => null,
  Source: () => null,
  Image: () => (0, import_jsx_runtime45.jsx)(MessagePartPrimitiveImage, {}),
  File: () => null,
  Unstable_Audio: () => null,
  ToolGroup: ({ children }) => children,
  ReasoningGroup: ({ children }) => children
};
var MessagePartComponent = ({ components: { Text = defaultComponents.Text, Reasoning = defaultComponents.Reasoning, Image = defaultComponents.Image, Source = defaultComponents.Source, File: File2 = defaultComponents.File, Unstable_Audio: Audio = defaultComponents.Unstable_Audio, tools = {} } = {} }) => {
  var _a3, _b;
  const aui = useAui();
  const part = useAuiState(({ part: part2 }) => part2);
  const type = part.type;
  if (type === "tool-call") {
    const addResult = aui.part().addToolResult;
    const resume = aui.part().resumeToolCall;
    if ("Override" in tools)
      return (0, import_jsx_runtime45.jsx)(tools.Override, { ...part, addResult, resume });
    const Tool = ((_a3 = tools.by_name) == null ? void 0 : _a3[part.toolName]) ?? tools.Fallback;
    return (0, import_jsx_runtime45.jsx)(ToolUIDisplay, { ...part, Fallback: Tool, addResult, resume });
  }
  if (((_b = part.status) == null ? void 0 : _b.type) === "requires-action")
    throw new Error("Encountered unexpected requires-action status");
  switch (type) {
    case "text":
      return (0, import_jsx_runtime45.jsx)(Text, { ...part });
    case "reasoning":
      return (0, import_jsx_runtime45.jsx)(Reasoning, { ...part });
    case "source":
      return (0, import_jsx_runtime45.jsx)(Source, { ...part });
    case "image":
      return (0, import_jsx_runtime45.jsx)(Image, { ...part });
    case "file":
      return (0, import_jsx_runtime45.jsx)(File2, { ...part });
    case "audio":
      return (0, import_jsx_runtime45.jsx)(Audio, { ...part });
    case "data":
      return null;
    default:
      const unhandledType = type;
      throw new Error(`Unknown message part type: ${unhandledType}`);
  }
};
var MessagePrimitivePartByIndex = (0, import_react69.memo)(({ index: index3, components }) => {
  return (0, import_jsx_runtime45.jsx)(PartByIndexProvider, { index: index3, children: (0, import_jsx_runtime45.jsx)(MessagePartComponent, { components }) });
}, (prev, next) => {
  var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;
  return prev.index === next.index && ((_a3 = prev.components) == null ? void 0 : _a3.Text) === ((_b = next.components) == null ? void 0 : _b.Text) && ((_c = prev.components) == null ? void 0 : _c.Reasoning) === ((_d = next.components) == null ? void 0 : _d.Reasoning) && ((_e = prev.components) == null ? void 0 : _e.Source) === ((_f = next.components) == null ? void 0 : _f.Source) && ((_g = prev.components) == null ? void 0 : _g.Image) === ((_h = next.components) == null ? void 0 : _h.Image) && ((_i = prev.components) == null ? void 0 : _i.File) === ((_j = next.components) == null ? void 0 : _j.File) && ((_k = prev.components) == null ? void 0 : _k.Unstable_Audio) === ((_l = next.components) == null ? void 0 : _l.Unstable_Audio) && ((_m = prev.components) == null ? void 0 : _m.tools) === ((_n = next.components) == null ? void 0 : _n.tools) && ((_o = prev.components) == null ? void 0 : _o.ToolGroup) === ((_p = next.components) == null ? void 0 : _p.ToolGroup) && ((_q = prev.components) == null ? void 0 : _q.ReasoningGroup) === ((_r = next.components) == null ? void 0 : _r.ReasoningGroup);
});
MessagePrimitivePartByIndex.displayName = "MessagePrimitive.PartByIndex";
var EmptyPartFallback = ({ status, component: Component }) => {
  return (0, import_jsx_runtime45.jsx)(TextMessagePartProvider, { text: "", isRunning: status.type === "running", children: (0, import_jsx_runtime45.jsx)(Component, { type: "text", text: "", status }) });
};
var COMPLETE_STATUS3 = Object.freeze({
  type: "complete"
});
var EmptyPartsImpl = ({ components }) => {
  const status = useAuiState((s) => s.message.status ?? COMPLETE_STATUS3);
  if (components == null ? void 0 : components.Empty)
    return (0, import_jsx_runtime45.jsx)(components.Empty, { status });
  return (0, import_jsx_runtime45.jsx)(EmptyPartFallback, { status, component: (components == null ? void 0 : components.Text) ?? defaultComponents.Text });
};
var EmptyParts = (0, import_react69.memo)(EmptyPartsImpl, (prev, next) => {
  var _a3, _b, _c, _d;
  return ((_a3 = prev.components) == null ? void 0 : _a3.Empty) === ((_b = next.components) == null ? void 0 : _b.Empty) && ((_c = prev.components) == null ? void 0 : _c.Text) === ((_d = next.components) == null ? void 0 : _d.Text);
});
var ConditionalEmptyImpl = ({ components, enabled }) => {
  const shouldShowEmpty = useAuiState(({ message }) => {
    if (!enabled)
      return false;
    if (message.parts.length === 0)
      return false;
    const lastPart = message.parts[message.parts.length - 1];
    return (lastPart == null ? void 0 : lastPart.type) !== "text" && (lastPart == null ? void 0 : lastPart.type) !== "reasoning";
  });
  if (!shouldShowEmpty)
    return null;
  return (0, import_jsx_runtime45.jsx)(EmptyParts, { components });
};
var ConditionalEmpty = (0, import_react69.memo)(ConditionalEmptyImpl, (prev, next) => {
  var _a3, _b, _c, _d;
  return prev.enabled === next.enabled && ((_a3 = prev.components) == null ? void 0 : _a3.Empty) === ((_b = next.components) == null ? void 0 : _b.Empty) && ((_c = prev.components) == null ? void 0 : _c.Text) === ((_d = next.components) == null ? void 0 : _d.Text);
});
var MessagePrimitiveParts = ({ components, unstable_showEmptyOnNonTextEnd = true }) => {
  const contentLength = useAuiState(({ message }) => message.parts.length);
  const useChainOfThought = !!(components == null ? void 0 : components.ChainOfThought);
  const messageRanges = useMessagePartsGroups(useChainOfThought);
  const partsElements = (0, import_react69.useMemo)(() => {
    if (contentLength === 0) {
      return (0, import_jsx_runtime45.jsx)(EmptyParts, { components });
    }
    return messageRanges.map((range) => {
      if (range.type === "single") {
        return (0, import_jsx_runtime45.jsx)(MessagePrimitivePartByIndex, { index: range.index, components }, range.index);
      } else if (range.type === "chainOfThoughtGroup") {
        const ChainOfThoughtComponent = components == null ? void 0 : components.ChainOfThought;
        if (!ChainOfThoughtComponent)
          return null;
        return (0, import_jsx_runtime45.jsx)(ChainOfThoughtByIndicesProvider, { startIndex: range.startIndex, endIndex: range.endIndex, children: (0, import_jsx_runtime45.jsx)(ChainOfThoughtComponent, {}) }, `chainOfThought-${range.startIndex}`);
      } else if (range.type === "toolGroup") {
        const ToolGroupComponent = (components == null ? void 0 : components.ToolGroup) ?? defaultComponents.ToolGroup;
        return (0, import_jsx_runtime45.jsx)(ToolGroupComponent, { startIndex: range.startIndex, endIndex: range.endIndex, children: Array.from({ length: range.endIndex - range.startIndex + 1 }, (_, i) => (0, import_jsx_runtime45.jsx)(MessagePrimitivePartByIndex, { index: range.startIndex + i, components }, i)) }, `tool-${range.startIndex}`);
      } else {
        const ReasoningGroupComponent = (components == null ? void 0 : components.ReasoningGroup) ?? defaultComponents.ReasoningGroup;
        return (0, import_jsx_runtime45.jsx)(ReasoningGroupComponent, { startIndex: range.startIndex, endIndex: range.endIndex, children: Array.from({ length: range.endIndex - range.startIndex + 1 }, (_, i) => (0, import_jsx_runtime45.jsx)(MessagePrimitivePartByIndex, { index: range.startIndex + i, components }, i)) }, `reasoning-${range.startIndex}`);
      }
    });
  }, [messageRanges, components, contentLength]);
  return (0, import_jsx_runtime45.jsxs)(import_jsx_runtime45.Fragment, { children: [partsElements, (0, import_jsx_runtime45.jsx)(ConditionalEmpty, { components, enabled: unstable_showEmptyOnNonTextEnd })] });
};
MessagePrimitiveParts.displayName = "MessagePrimitive.Parts";

// node_modules/@assistant-ui/react/dist/primitives/message/MessageIf.js
var useMessageIf = (props) => {
  return useAuiState(({ message }) => {
    var _a3;
    const { role, attachments, parts, branchCount, isLast, speech, isCopied, isHovering } = message;
    if (props.hasBranches === true && branchCount < 2)
      return false;
    if (props.user && role !== "user")
      return false;
    if (props.assistant && role !== "assistant")
      return false;
    if (props.system && role !== "system")
      return false;
    if (props.lastOrHover === true && !isHovering && !isLast)
      return false;
    if (props.last !== void 0 && props.last !== isLast)
      return false;
    if (props.copied === true && !isCopied)
      return false;
    if (props.copied === false && isCopied)
      return false;
    if (props.speaking === true && speech == null)
      return false;
    if (props.speaking === false && speech != null)
      return false;
    if (props.hasAttachments === true && (role !== "user" || !(attachments == null ? void 0 : attachments.length)))
      return false;
    if (props.hasAttachments === false && role === "user" && !!(attachments == null ? void 0 : attachments.length))
      return false;
    if (props.hasContent === true && parts.length === 0)
      return false;
    if (props.hasContent === false && parts.length > 0)
      return false;
    if (props.submittedFeedback !== void 0 && (((_a3 = message.metadata.submittedFeedback) == null ? void 0 : _a3.type) ?? null) !== props.submittedFeedback)
      return false;
    return true;
  });
};
var MessagePrimitiveIf = ({ children, ...query }) => {
  const result = useMessageIf(query);
  return result ? children : null;
};
MessagePrimitiveIf.displayName = "MessagePrimitive.If";

// node_modules/@assistant-ui/react/dist/primitives/message/MessageAttachments.js
var import_jsx_runtime46 = __toESM(require_jsx_runtime(), 1);
var import_react70 = __toESM(require_react(), 1);
var getComponent = (components, attachment) => {
  const type = attachment.type;
  switch (type) {
    case "image":
      return (components == null ? void 0 : components.Image) ?? (components == null ? void 0 : components.Attachment);
    case "document":
      return (components == null ? void 0 : components.Document) ?? (components == null ? void 0 : components.Attachment);
    case "file":
      return (components == null ? void 0 : components.File) ?? (components == null ? void 0 : components.Attachment);
    default:
      const _exhaustiveCheck = type;
      throw new Error(`Unknown attachment type: ${_exhaustiveCheck}`);
  }
};
var AttachmentComponent = ({ components }) => {
  const attachment = useAuiState(({ attachment: attachment2 }) => attachment2);
  if (!attachment)
    return null;
  const Component = getComponent(components, attachment);
  if (!Component)
    return null;
  return (0, import_jsx_runtime46.jsx)(Component, {});
};
var MessagePrimitiveAttachmentByIndex = (0, import_react70.memo)(({ index: index3, components }) => {
  return (0, import_jsx_runtime46.jsx)(MessageAttachmentByIndexProvider, { index: index3, children: (0, import_jsx_runtime46.jsx)(AttachmentComponent, { components }) });
}, (prev, next) => {
  var _a3, _b, _c, _d, _e, _f, _g, _h;
  return prev.index === next.index && ((_a3 = prev.components) == null ? void 0 : _a3.Image) === ((_b = next.components) == null ? void 0 : _b.Image) && ((_c = prev.components) == null ? void 0 : _c.Document) === ((_d = next.components) == null ? void 0 : _d.Document) && ((_e = prev.components) == null ? void 0 : _e.File) === ((_f = next.components) == null ? void 0 : _f.File) && ((_g = prev.components) == null ? void 0 : _g.Attachment) === ((_h = next.components) == null ? void 0 : _h.Attachment);
});
MessagePrimitiveAttachmentByIndex.displayName = "MessagePrimitive.AttachmentByIndex";
var MessagePrimitiveAttachments = ({ components }) => {
  const attachmentsCount = useAuiState(({ message }) => {
    if (message.role !== "user")
      return 0;
    return message.attachments.length;
  });
  const attachmentElements = (0, import_react70.useMemo)(() => {
    return Array.from({ length: attachmentsCount }, (_, index3) => (0, import_jsx_runtime46.jsx)(MessagePrimitiveAttachmentByIndex, { index: index3, components }, index3));
  }, [attachmentsCount, components]);
  return attachmentElements;
};
MessagePrimitiveAttachments.displayName = "MessagePrimitive.Attachments";

// node_modules/@assistant-ui/react/dist/primitives/message/MessageError.js
var MessagePrimitiveError = ({ children }) => {
  const hasError = useAuiState(({ message }) => {
    var _a3;
    return ((_a3 = message.status) == null ? void 0 : _a3.type) === "incomplete" && message.status.reason === "error";
  });
  return hasError ? children : null;
};
MessagePrimitiveError.displayName = "MessagePrimitive.Error";

// node_modules/@assistant-ui/react/dist/primitives/message/MessagePartsGrouped.js
var import_jsx_runtime47 = __toESM(require_jsx_runtime(), 1);
var import_react71 = __toESM(require_react(), 1);
var groupMessagePartsByParentId = (parts) => {
  const groupMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < parts.length; i++) {
    const part = parts[i];
    const parentId = part == null ? void 0 : part.parentId;
    const groupId = parentId ?? `__ungrouped_${i}`;
    const indices = groupMap.get(groupId) ?? [];
    indices.push(i);
    groupMap.set(groupId, indices);
  }
  const groups = [];
  for (const [groupId, indices] of groupMap) {
    const groupKey = groupId.startsWith("__ungrouped_") ? void 0 : groupId;
    groups.push({ groupKey, indices });
  }
  return groups;
};
var useMessagePartsGrouped = (groupingFunction) => {
  const parts = useAuiState(({ message }) => message.parts);
  return (0, import_react71.useMemo)(() => {
    if (parts.length === 0) {
      return [];
    }
    return groupingFunction(parts);
  }, [parts, groupingFunction]);
};
var ToolUIDisplay2 = ({ Fallback, ...props }) => {
  const Render = useAuiState(({ tools }) => {
    const Render2 = tools.tools[props.toolName] ?? Fallback;
    if (Array.isArray(Render2))
      return Render2[0] ?? Fallback;
    return Render2;
  });
  if (!Render)
    return null;
  return (0, import_jsx_runtime47.jsx)(Render, { ...props });
};
var defaultComponents2 = {
  Text: () => (0, import_jsx_runtime47.jsxs)("p", { style: { whiteSpace: "pre-line" }, children: [(0, import_jsx_runtime47.jsx)(MessagePartPrimitiveText, {}), (0, import_jsx_runtime47.jsx)(MessagePartPrimitiveInProgress, { children: (0, import_jsx_runtime47.jsx)("span", { style: { fontFamily: "revert" }, children: " " }) })] }),
  Reasoning: () => null,
  Source: () => null,
  Image: () => (0, import_jsx_runtime47.jsx)(MessagePartPrimitiveImage, {}),
  File: () => null,
  Unstable_Audio: () => null,
  Group: ({ children }) => children
};
var MessagePartComponent2 = ({ components: { Text = defaultComponents2.Text, Reasoning = defaultComponents2.Reasoning, Image = defaultComponents2.Image, Source = defaultComponents2.Source, File: File2 = defaultComponents2.File, Unstable_Audio: Audio = defaultComponents2.Unstable_Audio, tools = {} } = {} }) => {
  var _a3, _b;
  const aui = useAui();
  const part = useAuiState(({ part: part2 }) => part2);
  const type = part.type;
  if (type === "tool-call") {
    const addResult = aui.part().addToolResult;
    const resume = aui.part().resumeToolCall;
    if ("Override" in tools)
      return (0, import_jsx_runtime47.jsx)(tools.Override, { ...part, addResult, resume });
    const Tool = ((_a3 = tools.by_name) == null ? void 0 : _a3[part.toolName]) ?? tools.Fallback;
    return (0, import_jsx_runtime47.jsx)(ToolUIDisplay2, { ...part, Fallback: Tool, addResult, resume });
  }
  if (((_b = part.status) == null ? void 0 : _b.type) === "requires-action")
    throw new Error("Encountered unexpected requires-action status");
  switch (type) {
    case "text":
      return (0, import_jsx_runtime47.jsx)(Text, { ...part });
    case "reasoning":
      return (0, import_jsx_runtime47.jsx)(Reasoning, { ...part });
    case "source":
      return (0, import_jsx_runtime47.jsx)(Source, { ...part });
    case "image":
      return (0, import_jsx_runtime47.jsx)(Image, { ...part });
    case "file":
      return (0, import_jsx_runtime47.jsx)(File2, { ...part });
    case "audio":
      return (0, import_jsx_runtime47.jsx)(Audio, { ...part });
    case "data":
      return null;
    default:
      const unhandledType = type;
      throw new Error(`Unknown message part type: ${unhandledType}`);
  }
};
var MessagePartImpl = ({ partIndex, components }) => {
  return (0, import_jsx_runtime47.jsx)(PartByIndexProvider, { index: partIndex, children: (0, import_jsx_runtime47.jsx)(MessagePartComponent2, { components }) });
};
var MessagePart = (0, import_react71.memo)(MessagePartImpl, (prev, next) => {
  var _a3, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p;
  return prev.partIndex === next.partIndex && ((_a3 = prev.components) == null ? void 0 : _a3.Text) === ((_b = next.components) == null ? void 0 : _b.Text) && ((_c = prev.components) == null ? void 0 : _c.Reasoning) === ((_d = next.components) == null ? void 0 : _d.Reasoning) && ((_e = prev.components) == null ? void 0 : _e.Source) === ((_f = next.components) == null ? void 0 : _f.Source) && ((_g = prev.components) == null ? void 0 : _g.Image) === ((_h = next.components) == null ? void 0 : _h.Image) && ((_i = prev.components) == null ? void 0 : _i.File) === ((_j = next.components) == null ? void 0 : _j.File) && ((_k = prev.components) == null ? void 0 : _k.Unstable_Audio) === ((_l = next.components) == null ? void 0 : _l.Unstable_Audio) && ((_m = prev.components) == null ? void 0 : _m.tools) === ((_n = next.components) == null ? void 0 : _n.tools) && ((_o = prev.components) == null ? void 0 : _o.Group) === ((_p = next.components) == null ? void 0 : _p.Group);
});
var EmptyPartFallback2 = ({ status, component: Component }) => {
  return (0, import_jsx_runtime47.jsx)(TextMessagePartProvider, { text: "", isRunning: status.type === "running", children: (0, import_jsx_runtime47.jsx)(Component, { type: "text", text: "", status }) });
};
var COMPLETE_STATUS4 = Object.freeze({
  type: "complete"
});
var EmptyPartsImpl2 = ({ components }) => {
  const status = useAuiState((s) => s.message.status ?? COMPLETE_STATUS4);
  if (components == null ? void 0 : components.Empty)
    return (0, import_jsx_runtime47.jsx)(components.Empty, { status });
  return (0, import_jsx_runtime47.jsx)(EmptyPartFallback2, { status, component: (components == null ? void 0 : components.Text) ?? defaultComponents2.Text });
};
var EmptyParts2 = (0, import_react71.memo)(EmptyPartsImpl2, (prev, next) => {
  var _a3, _b, _c, _d;
  return ((_a3 = prev.components) == null ? void 0 : _a3.Empty) === ((_b = next.components) == null ? void 0 : _b.Empty) && ((_c = prev.components) == null ? void 0 : _c.Text) === ((_d = next.components) == null ? void 0 : _d.Text);
});
var MessagePrimitiveUnstable_PartsGrouped = ({ groupingFunction, components }) => {
  const contentLength = useAuiState(({ message }) => message.parts.length);
  const messageGroups = useMessagePartsGrouped(groupingFunction);
  const partsElements = (0, import_react71.useMemo)(() => {
    if (contentLength === 0) {
      return (0, import_jsx_runtime47.jsx)(EmptyParts2, { components });
    }
    return messageGroups.map((group, groupIndex) => {
      const GroupComponent = (components == null ? void 0 : components.Group) ?? defaultComponents2.Group;
      return (0, import_jsx_runtime47.jsx)(GroupComponent, { groupKey: group.groupKey, indices: group.indices, children: group.indices.map((partIndex) => (0, import_jsx_runtime47.jsx)(MessagePart, { partIndex, components }, partIndex)) }, `group-${groupIndex}-${group.groupKey ?? "ungrouped"}`);
    });
  }, [messageGroups, components, contentLength]);
  return (0, import_jsx_runtime47.jsx)(import_jsx_runtime47.Fragment, { children: partsElements });
};
MessagePrimitiveUnstable_PartsGrouped.displayName = "MessagePrimitive.Unstable_PartsGrouped";
var MessagePrimitiveUnstable_PartsGroupedByParentId = ({ components, ...props }) => {
  return (0, import_jsx_runtime47.jsx)(MessagePrimitiveUnstable_PartsGrouped, { ...props, components, groupingFunction: groupMessagePartsByParentId });
};
MessagePrimitiveUnstable_PartsGroupedByParentId.displayName = "MessagePrimitive.Unstable_PartsGroupedByParentId";

// node_modules/@assistant-ui/react/dist/primitives/branchPicker/BranchPickerRoot.js
var BranchPickerPrimitiveRoot = (0, import_react72.forwardRef)(({ hideWhenSingleBranch, ...rest }, ref) => {
  return (0, import_jsx_runtime48.jsx)(MessagePrimitiveIf, { hasBranches: hideWhenSingleBranch ? true : void 0, children: (0, import_jsx_runtime48.jsx)(Primitive.div, { ...rest, ref }) });
});
BranchPickerPrimitiveRoot.displayName = "BranchPickerPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/chainOfThought/index.js
var chainOfThought_exports = {};
__export(chainOfThought_exports, {
  AccordionTrigger: () => ChainOfThoughtPrimitiveAccordionTrigger,
  Parts: () => ChainOfThoughtPrimitiveParts,
  Root: () => ChainOfThoughtPrimitiveRoot
});

// node_modules/@assistant-ui/react/dist/primitives/chainOfThought/ChainOfThoughtRoot.js
var import_jsx_runtime49 = __toESM(require_jsx_runtime(), 1);
var import_react73 = __toESM(require_react(), 1);
var ChainOfThoughtPrimitiveRoot = (0, import_react73.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime49.jsx)(Primitive.div, { ...props, ref });
});
ChainOfThoughtPrimitiveRoot.displayName = "ChainOfThoughtPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/chainOfThought/ChainOfThoughtAccordionTrigger.js
var import_react74 = __toESM(require_react(), 1);
var useChainOfThoughtAccordionTrigger = () => {
  const aui = useAui();
  const collapsed = useAuiState(({ chainOfThought }) => chainOfThought.collapsed);
  const callback = (0, import_react74.useCallback)(() => {
    aui.chainOfThought().setCollapsed(!collapsed);
  }, [aui, collapsed]);
  return callback;
};
var ChainOfThoughtPrimitiveAccordionTrigger = createActionButton("ChainOfThoughtPrimitive.AccordionTrigger", useChainOfThoughtAccordionTrigger);

// node_modules/@assistant-ui/react/dist/primitives/chainOfThought/ChainOfThoughtParts.js
var import_jsx_runtime51 = __toESM(require_jsx_runtime(), 1);
var import_react75 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/context/providers/ChainOfThoughtPartByIndexProvider.js
var import_jsx_runtime50 = __toESM(require_jsx_runtime(), 1);
var ChainOfThoughtPartByIndexProvider = ({ index: index3, children }) => {
  const aui = useAui({
    part: Derived({
      source: "chainOfThought",
      query: { type: "index", index: index3 },
      get: (aui2) => aui2.chainOfThought().part({ index: index3 })
    })
  });
  return (0, import_jsx_runtime50.jsx)(AuiProvider, { value: aui, children });
};

// node_modules/@assistant-ui/react/dist/primitives/chainOfThought/ChainOfThoughtParts.js
var ChainOfThoughtPrimitiveParts = ({ components }) => {
  var _a3;
  const partsLength = useAuiState(({ chainOfThought }) => chainOfThought.parts.length);
  const messageComponents = (0, import_react75.useMemo)(() => {
    var _a4;
    return {
      Reasoning: components == null ? void 0 : components.Reasoning,
      tools: {
        Fallback: (_a4 = components == null ? void 0 : components.tools) == null ? void 0 : _a4.Fallback
      }
    };
  }, [components == null ? void 0 : components.Reasoning, (_a3 = components == null ? void 0 : components.tools) == null ? void 0 : _a3.Fallback]);
  const Layout = components == null ? void 0 : components.Layout;
  const elements = (0, import_react75.useMemo)(() => {
    return Array.from({ length: partsLength }, (_, index3) => (0, import_jsx_runtime51.jsx)(ChainOfThoughtPartByIndexProvider, { index: index3, children: Layout ? (0, import_jsx_runtime51.jsx)(Layout, { children: (0, import_jsx_runtime51.jsx)(MessagePartComponent, { components: messageComponents }) }) : (0, import_jsx_runtime51.jsx)(MessagePartComponent, { components: messageComponents }) }, index3));
  }, [partsLength, messageComponents, Layout]);
  return (0, import_jsx_runtime51.jsx)(import_jsx_runtime51.Fragment, { children: elements });
};
ChainOfThoughtPrimitiveParts.displayName = "ChainOfThoughtPrimitive.Parts";

// node_modules/@assistant-ui/react/dist/primitives/composer/index.js
var composer_exports = {};
__export(composer_exports, {
  AddAttachment: () => ComposerPrimitiveAddAttachment,
  AttachmentByIndex: () => ComposerPrimitiveAttachmentByIndex,
  AttachmentDropzone: () => ComposerPrimitiveAttachmentDropzone,
  Attachments: () => ComposerPrimitiveAttachments,
  Cancel: () => ComposerPrimitiveCancel,
  Dictate: () => ComposerPrimitiveDictate,
  DictationTranscript: () => ComposerPrimitiveDictationTranscript,
  If: () => ComposerPrimitiveIf,
  Input: () => ComposerPrimitiveInput,
  Root: () => ComposerPrimitiveRoot,
  Send: () => ComposerPrimitiveSend,
  StopDictation: () => ComposerPrimitiveStopDictation
});

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerRoot.js
var import_jsx_runtime52 = __toESM(require_jsx_runtime(), 1);
var import_react77 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerSend.js
var import_react76 = __toESM(require_react(), 1);
var useComposerSend = () => {
  const aui = useAui();
  const disabled = useAuiState((s) => s.thread.isRunning || !s.composer.isEditing || s.composer.isEmpty);
  const callback = (0, import_react76.useCallback)(() => {
    aui.composer().send();
  }, [aui]);
  if (disabled)
    return null;
  return callback;
};
var ComposerPrimitiveSend = createActionButton("ComposerPrimitive.Send", useComposerSend);

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerRoot.js
var ComposerPrimitiveRoot = (0, import_react77.forwardRef)(({ onSubmit, ...rest }, forwardedRef) => {
  const send = useComposerSend();
  const handleSubmit = (e) => {
    e.preventDefault();
    if (!send)
      return;
    send();
  };
  return (0, import_jsx_runtime52.jsx)(Primitive.form, { ...rest, ref: forwardedRef, onSubmit: composeEventHandlers(onSubmit, handleSubmit) });
});
ComposerPrimitiveRoot.displayName = "ComposerPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerInput.js
var import_jsx_runtime53 = __toESM(require_jsx_runtime(), 1);
var import_react82 = __toESM(require_react(), 1);

// node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(n) {
    for (var e = 1; e < arguments.length; e++) {
      var t = arguments[e];
      for (var r in t) ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends.apply(null, arguments);
}

// node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(r, e) {
  if (null == r) return {};
  var t = {};
  for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
    if (-1 !== e.indexOf(n)) continue;
    t[n] = r[n];
  }
  return t;
}

// node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js
var React7 = __toESM(require_react());

// node_modules/use-latest/dist/use-latest.esm.js
var import_react79 = __toESM(require_react());

// node_modules/use-isomorphic-layout-effect/dist/use-isomorphic-layout-effect.browser.esm.js
var import_react78 = __toESM(require_react());
var index = import_react78.useLayoutEffect;

// node_modules/use-latest/dist/use-latest.esm.js
var useLatest = function useLatest2(value) {
  var ref = import_react79.default.useRef(value);
  index(function() {
    ref.current = value;
  });
  return ref;
};

// node_modules/use-composed-ref/dist/use-composed-ref.esm.js
var import_react80 = __toESM(require_react());
var updateRef = function updateRef2(ref, value) {
  if (typeof ref === "function") {
    ref(value);
    return;
  }
  ref.current = value;
};
var useComposedRef = function useComposedRef2(libRef, userRef) {
  var prevUserRef = import_react80.default.useRef();
  return import_react80.default.useCallback(function(instance) {
    libRef.current = instance;
    if (prevUserRef.current) {
      updateRef(prevUserRef.current, null);
    }
    prevUserRef.current = userRef;
    if (!userRef) {
      return;
    }
    updateRef(userRef, instance);
  }, [userRef]);
};

// node_modules/react-textarea-autosize/dist/react-textarea-autosize.browser.development.esm.js
var HIDDEN_TEXTAREA_STYLE = {
  "min-height": "0",
  "max-height": "none",
  height: "0",
  visibility: "hidden",
  overflow: "hidden",
  position: "absolute",
  "z-index": "-1000",
  top: "0",
  right: "0",
  display: "block"
};
var forceHiddenStyles = function forceHiddenStyles2(node) {
  Object.keys(HIDDEN_TEXTAREA_STYLE).forEach(function(key) {
    node.style.setProperty(key, HIDDEN_TEXTAREA_STYLE[key], "important");
  });
};
var forceHiddenStyles$1 = forceHiddenStyles;
var hiddenTextarea = null;
var getHeight = function getHeight2(node, sizingData) {
  var height = node.scrollHeight;
  if (sizingData.sizingStyle.boxSizing === "border-box") {
    return height + sizingData.borderSize;
  }
  return height - sizingData.paddingSize;
};
function calculateNodeHeight(sizingData, value, minRows, maxRows) {
  if (minRows === void 0) {
    minRows = 1;
  }
  if (maxRows === void 0) {
    maxRows = Infinity;
  }
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement("textarea");
    hiddenTextarea.setAttribute("tabindex", "-1");
    hiddenTextarea.setAttribute("aria-hidden", "true");
    forceHiddenStyles$1(hiddenTextarea);
  }
  if (hiddenTextarea.parentNode === null) {
    document.body.appendChild(hiddenTextarea);
  }
  var paddingSize = sizingData.paddingSize, borderSize = sizingData.borderSize, sizingStyle = sizingData.sizingStyle;
  var boxSizing = sizingStyle.boxSizing;
  Object.keys(sizingStyle).forEach(function(_key) {
    var key = _key;
    hiddenTextarea.style[key] = sizingStyle[key];
  });
  forceHiddenStyles$1(hiddenTextarea);
  hiddenTextarea.value = value;
  var height = getHeight(hiddenTextarea, sizingData);
  hiddenTextarea.value = value;
  height = getHeight(hiddenTextarea, sizingData);
  hiddenTextarea.value = "x";
  var rowHeight = hiddenTextarea.scrollHeight - paddingSize;
  var minHeight = rowHeight * minRows;
  if (boxSizing === "border-box") {
    minHeight = minHeight + paddingSize + borderSize;
  }
  height = Math.max(minHeight, height);
  var maxHeight = rowHeight * maxRows;
  if (boxSizing === "border-box") {
    maxHeight = maxHeight + paddingSize + borderSize;
  }
  height = Math.min(maxHeight, height);
  return [height, rowHeight];
}
var noop = function noop2() {
};
var pick2 = function pick3(props, obj) {
  return props.reduce(function(acc, prop) {
    acc[prop] = obj[prop];
    return acc;
  }, {});
};
var SIZING_STYLE = [
  "borderBottomWidth",
  "borderLeftWidth",
  "borderRightWidth",
  "borderTopWidth",
  "boxSizing",
  "fontFamily",
  "fontSize",
  "fontStyle",
  "fontWeight",
  "letterSpacing",
  "lineHeight",
  "paddingBottom",
  "paddingLeft",
  "paddingRight",
  "paddingTop",
  // non-standard
  "tabSize",
  "textIndent",
  // non-standard
  "textRendering",
  "textTransform",
  "width",
  "wordBreak",
  "wordSpacing",
  "scrollbarGutter"
];
var isIE = !!document.documentElement.currentStyle;
var getSizingData = function getSizingData2(node) {
  var style = window.getComputedStyle(node);
  if (style === null) {
    return null;
  }
  var sizingStyle = pick2(SIZING_STYLE, style);
  var boxSizing = sizingStyle.boxSizing;
  if (boxSizing === "") {
    return null;
  }
  if (isIE && boxSizing === "border-box") {
    sizingStyle.width = parseFloat(sizingStyle.width) + parseFloat(sizingStyle.borderRightWidth) + parseFloat(sizingStyle.borderLeftWidth) + parseFloat(sizingStyle.paddingRight) + parseFloat(sizingStyle.paddingLeft) + "px";
  }
  var paddingSize = parseFloat(sizingStyle.paddingBottom) + parseFloat(sizingStyle.paddingTop);
  var borderSize = parseFloat(sizingStyle.borderBottomWidth) + parseFloat(sizingStyle.borderTopWidth);
  return {
    sizingStyle,
    paddingSize,
    borderSize
  };
};
var getSizingData$1 = getSizingData;
function useListener(target, type, listener) {
  var latestListener = useLatest(listener);
  React7.useLayoutEffect(function() {
    var handler = function handler2(ev) {
      return latestListener.current(ev);
    };
    if (!target) {
      return;
    }
    target.addEventListener(type, handler);
    return function() {
      return target.removeEventListener(type, handler);
    };
  }, []);
}
var useFormResetListener = function useFormResetListener2(libRef, listener) {
  useListener(document.body, "reset", function(ev) {
    if (libRef.current.form === ev.target) {
      listener(ev);
    }
  });
};
var useWindowResizeListener = function useWindowResizeListener2(listener) {
  useListener(window, "resize", listener);
};
var useFontsLoadedListener = function useFontsLoadedListener2(listener) {
  useListener(document.fonts, "loadingdone", listener);
};
var _excluded = ["cacheMeasurements", "maxRows", "minRows", "onChange", "onHeightChange"];
var TextareaAutosize = function TextareaAutosize2(_ref, userRef) {
  var cacheMeasurements = _ref.cacheMeasurements, maxRows = _ref.maxRows, minRows = _ref.minRows, _ref$onChange = _ref.onChange, onChange = _ref$onChange === void 0 ? noop : _ref$onChange, _ref$onHeightChange = _ref.onHeightChange, onHeightChange = _ref$onHeightChange === void 0 ? noop : _ref$onHeightChange, props = _objectWithoutPropertiesLoose(_ref, _excluded);
  if (props.style) {
    if ("maxHeight" in props.style) {
      throw new Error("Using `style.maxHeight` for <TextareaAutosize/> is not supported. Please use `maxRows`.");
    }
    if ("minHeight" in props.style) {
      throw new Error("Using `style.minHeight` for <TextareaAutosize/> is not supported. Please use `minRows`.");
    }
  }
  var isControlled = props.value !== void 0;
  var libRef = React7.useRef(null);
  var ref = useComposedRef(libRef, userRef);
  var heightRef = React7.useRef(0);
  var measurementsCacheRef = React7.useRef();
  var resizeTextarea = function resizeTextarea2() {
    var node = libRef.current;
    var nodeSizingData = cacheMeasurements && measurementsCacheRef.current ? measurementsCacheRef.current : getSizingData$1(node);
    if (!nodeSizingData) {
      return;
    }
    measurementsCacheRef.current = nodeSizingData;
    var _calculateNodeHeight = calculateNodeHeight(nodeSizingData, node.value || node.placeholder || "x", minRows, maxRows), height = _calculateNodeHeight[0], rowHeight = _calculateNodeHeight[1];
    if (heightRef.current !== height) {
      heightRef.current = height;
      node.style.setProperty("height", height + "px", "important");
      onHeightChange(height, {
        rowHeight
      });
    }
  };
  var handleChange = function handleChange2(event) {
    if (!isControlled) {
      resizeTextarea();
    }
    onChange(event);
  };
  {
    React7.useLayoutEffect(resizeTextarea);
    useFormResetListener(libRef, function() {
      if (!isControlled) {
        var currentValue = libRef.current.value;
        requestAnimationFrame(function() {
          var node = libRef.current;
          if (node && currentValue !== node.value) {
            resizeTextarea();
          }
        });
      }
    });
    useWindowResizeListener(resizeTextarea);
    useFontsLoadedListener(resizeTextarea);
    return React7.createElement("textarea", _extends({}, props, {
      onChange: handleChange,
      ref
    }));
  }
};
var index2 = React7.forwardRef(TextareaAutosize);

// node_modules/@assistant-ui/react/dist/utils/hooks/useOnScrollToBottom.js
var import_react81 = __toESM(require_react(), 1);
var useOnScrollToBottom = (callback) => {
  const callbackRef = useCallbackRef(callback);
  const onScrollToBottom = useThreadViewport((vp) => vp.onScrollToBottom);
  (0, import_react81.useEffect)(() => {
    return onScrollToBottom(callbackRef);
  }, [onScrollToBottom, callbackRef]);
};

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerInput.js
var ComposerPrimitiveInput = (0, import_react82.forwardRef)(({ autoFocus = false, asChild, disabled: disabledProp, onChange, onKeyDown, onPaste, submitOnEnter = true, cancelOnEscape = true, unstable_focusOnRunStart = true, unstable_focusOnScrollToBottom = true, unstable_focusOnThreadSwitched = true, addAttachmentOnPaste = true, ...rest }, forwardedRef) => {
  const aui = useAui();
  const value = useAuiState(({ composer }) => {
    if (!composer.isEditing)
      return "";
    return composer.text;
  });
  const Component = asChild ? Slot : index2;
  const isDisabled = useAuiState(({ thread, composer }) => {
    var _a3;
    return thread.isDisabled || ((_a3 = composer.dictation) == null ? void 0 : _a3.inputDisabled);
  }) || disabledProp;
  const textareaRef = (0, import_react82.useRef)(null);
  const ref = useComposedRefs(forwardedRef, textareaRef);
  useEscapeKeydown((e) => {
    var _a3;
    if (!cancelOnEscape)
      return;
    if (!((_a3 = textareaRef.current) == null ? void 0 : _a3.contains(e.target)))
      return;
    const composer = aui.composer();
    if (composer.getState().canCancel) {
      composer.cancel();
      e.preventDefault();
    }
  });
  const handleKeyPress = (e) => {
    var _a3, _b;
    if (isDisabled || !submitOnEnter)
      return;
    if (e.nativeEvent.isComposing)
      return;
    if (e.key === "Enter" && e.shiftKey === false) {
      const isRunning = aui.thread().getState().isRunning;
      if (!isRunning) {
        e.preventDefault();
        (_b = (_a3 = textareaRef.current) == null ? void 0 : _a3.closest("form")) == null ? void 0 : _b.requestSubmit();
      }
    }
  };
  const handlePaste = async (e) => {
    var _a3;
    if (!addAttachmentOnPaste)
      return;
    const threadCapabilities = aui.thread().getState().capabilities;
    const files = Array.from(((_a3 = e.clipboardData) == null ? void 0 : _a3.files) || []);
    if (threadCapabilities.attachments && files.length > 0) {
      try {
        e.preventDefault();
        await Promise.all(files.map((file2) => aui.composer().addAttachment(file2)));
      } catch (error48) {
        console.error("Error adding attachment:", error48);
      }
    }
  };
  const autoFocusEnabled = autoFocus && !isDisabled;
  const focus = (0, import_react82.useCallback)(() => {
    const textarea = textareaRef.current;
    if (!textarea || !autoFocusEnabled)
      return;
    textarea.focus({ preventScroll: true });
    textarea.setSelectionRange(textarea.value.length, textarea.value.length);
  }, [autoFocusEnabled]);
  (0, import_react82.useEffect)(() => focus(), [focus]);
  useOnScrollToBottom(() => {
    if (aui.composer().getState().type === "thread" && unstable_focusOnScrollToBottom) {
      focus();
    }
  });
  (0, import_react82.useEffect)(() => {
    if (aui.composer().getState().type !== "thread" || !unstable_focusOnRunStart)
      return void 0;
    return aui.on("thread.runStart", focus);
  }, [unstable_focusOnRunStart, focus, aui]);
  (0, import_react82.useEffect)(() => {
    if (aui.composer().getState().type !== "thread" || !unstable_focusOnThreadSwitched)
      return void 0;
    return aui.on("threadListItem.switchedTo", focus);
  }, [unstable_focusOnThreadSwitched, focus, aui]);
  return (0, import_jsx_runtime53.jsx)(Component, { name: "input", value, ...rest, ref, disabled: isDisabled, onChange: composeEventHandlers(onChange, (e) => {
    if (!aui.composer().getState().isEditing)
      return;
    flushResourcesSync(() => {
      aui.composer().setText(e.target.value);
    });
  }), onKeyDown: composeEventHandlers(onKeyDown, handleKeyPress), onPaste: composeEventHandlers(onPaste, handlePaste) });
});
ComposerPrimitiveInput.displayName = "ComposerPrimitive.Input";

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerCancel.js
var import_react83 = __toESM(require_react(), 1);
var useComposerCancel = () => {
  const aui = useAui();
  const disabled = useAuiState(({ composer }) => !composer.canCancel);
  const callback = (0, import_react83.useCallback)(() => {
    aui.composer().cancel();
  }, [aui]);
  if (disabled)
    return null;
  return callback;
};
var ComposerPrimitiveCancel = createActionButton("ComposerPrimitive.Cancel", useComposerCancel);

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerAddAttachment.js
var import_react84 = __toESM(require_react(), 1);
var useComposerAddAttachment = ({ multiple = true } = {}) => {
  const disabled = useAuiState(({ composer }) => !composer.isEditing);
  const aui = useAui();
  const callback = (0, import_react84.useCallback)(() => {
    const input = document.createElement("input");
    input.type = "file";
    input.multiple = multiple;
    input.hidden = true;
    const attachmentAccept = aui.composer().getState().attachmentAccept;
    if (attachmentAccept !== "*") {
      input.accept = attachmentAccept;
    }
    document.body.appendChild(input);
    input.onchange = (e) => {
      const fileList = e.target.files;
      if (!fileList)
        return;
      for (const file2 of fileList) {
        aui.composer().addAttachment(file2);
      }
      document.body.removeChild(input);
    };
    input.oncancel = () => {
      if (!input.files || input.files.length === 0) {
        document.body.removeChild(input);
      }
    };
    input.click();
  }, [aui, multiple]);
  if (disabled)
    return null;
  return callback;
};
var ComposerPrimitiveAddAttachment = createActionButton("ComposerPrimitive.AddAttachment", useComposerAddAttachment, ["multiple"]);

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerAttachments.js
var import_jsx_runtime54 = __toESM(require_jsx_runtime(), 1);
var import_react85 = __toESM(require_react(), 1);
var getComponent2 = (components, attachment) => {
  const type = attachment.type;
  switch (type) {
    case "image":
      return (components == null ? void 0 : components.Image) ?? (components == null ? void 0 : components.Attachment);
    case "document":
      return (components == null ? void 0 : components.Document) ?? (components == null ? void 0 : components.Attachment);
    case "file":
      return (components == null ? void 0 : components.File) ?? (components == null ? void 0 : components.Attachment);
    default:
      const _exhaustiveCheck = type;
      throw new Error(`Unknown attachment type: ${_exhaustiveCheck}`);
  }
};
var AttachmentComponent2 = ({ components }) => {
  const attachment = useAuiState(({ attachment: attachment2 }) => attachment2);
  if (!attachment)
    return null;
  const Component = getComponent2(components, attachment);
  if (!Component)
    return null;
  return (0, import_jsx_runtime54.jsx)(Component, {});
};
var ComposerPrimitiveAttachmentByIndex = (0, import_react85.memo)(({ index: index3, components }) => {
  return (0, import_jsx_runtime54.jsx)(ComposerAttachmentByIndexProvider, { index: index3, children: (0, import_jsx_runtime54.jsx)(AttachmentComponent2, { components }) });
}, (prev, next) => {
  var _a3, _b, _c, _d, _e, _f, _g, _h;
  return prev.index === next.index && ((_a3 = prev.components) == null ? void 0 : _a3.Image) === ((_b = next.components) == null ? void 0 : _b.Image) && ((_c = prev.components) == null ? void 0 : _c.Document) === ((_d = next.components) == null ? void 0 : _d.Document) && ((_e = prev.components) == null ? void 0 : _e.File) === ((_f = next.components) == null ? void 0 : _f.File) && ((_g = prev.components) == null ? void 0 : _g.Attachment) === ((_h = next.components) == null ? void 0 : _h.Attachment);
});
ComposerPrimitiveAttachmentByIndex.displayName = "ComposerPrimitive.AttachmentByIndex";
var ComposerPrimitiveAttachments = ({ components }) => {
  const attachmentsCount = useAuiState((s) => s.composer.attachments.length);
  const attachmentElements = (0, import_react85.useMemo)(() => {
    return Array.from({ length: attachmentsCount }, (_, index3) => (0, import_jsx_runtime54.jsx)(ComposerPrimitiveAttachmentByIndex, { index: index3, components }, index3));
  }, [attachmentsCount, components]);
  return attachmentElements;
};
ComposerPrimitiveAttachments.displayName = "ComposerPrimitive.Attachments";

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerAttachmentDropzone.js
var import_jsx_runtime55 = __toESM(require_jsx_runtime(), 1);
var import_react86 = __toESM(require_react(), 1);
var ComposerPrimitiveAttachmentDropzone = (0, import_react86.forwardRef)(({ disabled, asChild = false, children, ...rest }, ref) => {
  const [isDragging, setIsDragging] = (0, import_react86.useState)(false);
  const aui = useAui();
  const handleDragEnterCapture = (0, import_react86.useCallback)((e) => {
    if (disabled)
      return;
    e.preventDefault();
    setIsDragging(true);
  }, [disabled]);
  const handleDragOverCapture = (0, import_react86.useCallback)((e) => {
    if (disabled)
      return;
    e.preventDefault();
    if (!isDragging)
      setIsDragging(true);
  }, [disabled, isDragging]);
  const handleDragLeaveCapture = (0, import_react86.useCallback)((e) => {
    if (disabled)
      return;
    e.preventDefault();
    const next = e.relatedTarget;
    if (next && e.currentTarget.contains(next)) {
      return;
    }
    setIsDragging(false);
  }, [disabled]);
  const handleDrop = (0, import_react86.useCallback)(async (e) => {
    if (disabled)
      return;
    e.preventDefault();
    setIsDragging(false);
    for (const file2 of e.dataTransfer.files) {
      try {
        await aui.composer().addAttachment(file2);
      } catch (error48) {
        console.error("Failed to add attachment:", error48);
      }
    }
  }, [disabled, aui]);
  const dragProps = {
    onDragEnterCapture: handleDragEnterCapture,
    onDragOverCapture: handleDragOverCapture,
    onDragLeaveCapture: handleDragLeaveCapture,
    onDropCapture: handleDrop
  };
  const Comp = asChild ? Slot : "div";
  return (0, import_jsx_runtime55.jsx)(Comp, { ...isDragging ? { "data-dragging": "true" } : null, ref, ...dragProps, ...rest, children });
});
ComposerPrimitiveAttachmentDropzone.displayName = "ComposerPrimitive.AttachmentDropzone";

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerDictate.js
var import_react87 = __toESM(require_react(), 1);
var useComposerDictate = () => {
  const aui = useAui();
  const disabled = useAuiState(({ thread, composer }) => composer.dictation != null || !thread.capabilities.dictation || !composer.isEditing);
  const callback = (0, import_react87.useCallback)(() => {
    aui.composer().startDictation();
  }, [aui]);
  if (disabled)
    return null;
  return callback;
};
var ComposerPrimitiveDictate = createActionButton("ComposerPrimitive.Dictate", useComposerDictate);

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerStopDictation.js
var import_react88 = __toESM(require_react(), 1);
var useComposerStopDictation = () => {
  const aui = useAui();
  const isDictating = useAuiState(({ composer }) => composer.dictation != null);
  const callback = (0, import_react88.useCallback)(() => {
    aui.composer().stopDictation();
  }, [aui]);
  if (!isDictating)
    return null;
  return callback;
};
var ComposerPrimitiveStopDictation = createActionButton("ComposerPrimitive.StopDictation", useComposerStopDictation);

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerDictationTranscript.js
var import_jsx_runtime56 = __toESM(require_jsx_runtime(), 1);
var import_react89 = __toESM(require_react(), 1);
var ComposerPrimitiveDictationTranscript = (0, import_react89.forwardRef)(({ children, ...props }, forwardRef45) => {
  const transcript = useAuiState(({ composer }) => {
    var _a3;
    return (_a3 = composer.dictation) == null ? void 0 : _a3.transcript;
  });
  if (!transcript)
    return null;
  return (0, import_jsx_runtime56.jsx)(Primitive.span, { ...props, ref: forwardRef45, children: children ?? transcript });
});
ComposerPrimitiveDictationTranscript.displayName = "ComposerPrimitive.DictationTranscript";

// node_modules/@assistant-ui/react/dist/primitives/composer/ComposerIf.js
var useComposerIf = (props) => {
  return useAuiState(({ composer }) => {
    if (props.editing === true && !composer.isEditing)
      return false;
    if (props.editing === false && composer.isEditing)
      return false;
    const isDictating = composer.dictation != null;
    if (props.dictation === true && !isDictating)
      return false;
    if (props.dictation === false && isDictating)
      return false;
    return true;
  });
};
var ComposerPrimitiveIf = ({ children, ...query }) => {
  const result = useComposerIf(query);
  return result ? children : null;
};
ComposerPrimitiveIf.displayName = "ComposerPrimitive.If";

// node_modules/@assistant-ui/react/dist/primitives/messagePart/index.js
var messagePart_exports = {};
__export(messagePart_exports, {
  Image: () => MessagePartPrimitiveImage,
  InProgress: () => MessagePartPrimitiveInProgress,
  Text: () => MessagePartPrimitiveText
});

// node_modules/@assistant-ui/react/dist/primitives/error/index.js
var error_exports = {};
__export(error_exports, {
  Message: () => ErrorPrimitiveMessage,
  Root: () => ErrorPrimitiveRoot
});

// node_modules/@assistant-ui/react/dist/primitives/error/ErrorRoot.js
var import_jsx_runtime57 = __toESM(require_jsx_runtime(), 1);
var import_react90 = __toESM(require_react(), 1);
var ErrorPrimitiveRoot = (0, import_react90.forwardRef)((props, forwardRef45) => {
  return (0, import_jsx_runtime57.jsx)(Primitive.div, { role: "alert", ...props, ref: forwardRef45 });
});
ErrorPrimitiveRoot.displayName = "ErrorPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/error/ErrorMessage.js
var import_jsx_runtime58 = __toESM(require_jsx_runtime(), 1);
var import_react91 = __toESM(require_react(), 1);
var ErrorPrimitiveMessage = (0, import_react91.forwardRef)(({ children, ...props }, forwardRef45) => {
  const error48 = useAuiState(({ message }) => {
    var _a3;
    return ((_a3 = message.status) == null ? void 0 : _a3.type) === "incomplete" && message.status.reason === "error" ? message.status.error : void 0;
  });
  if (error48 === void 0)
    return null;
  return (0, import_jsx_runtime58.jsx)(Primitive.span, { ...props, ref: forwardRef45, children: children ?? String(error48) });
});
ErrorPrimitiveMessage.displayName = "ErrorPrimitive.Message";

// node_modules/@assistant-ui/react/dist/primitives/thread/index.js
var thread_exports = {};
__export(thread_exports, {
  Empty: () => ThreadPrimitiveEmpty,
  If: () => ThreadPrimitiveIf,
  MessageByIndex: () => ThreadPrimitiveMessageByIndex,
  Messages: () => ThreadPrimitiveMessages,
  Root: () => ThreadPrimitiveRoot,
  ScrollToBottom: () => ThreadPrimitiveScrollToBottom,
  Suggestion: () => ThreadPrimitiveSuggestion,
  SuggestionByIndex: () => ThreadPrimitiveSuggestionByIndex,
  Suggestions: () => ThreadPrimitiveSuggestions,
  Viewport: () => ThreadPrimitiveViewport,
  ViewportFooter: () => ThreadPrimitiveViewportFooter,
  ViewportProvider: () => ThreadPrimitiveViewportProvider,
  ViewportSlack: () => ThreadPrimitiveViewportSlack
});

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadRoot.js
var import_jsx_runtime59 = __toESM(require_jsx_runtime(), 1);
var import_react92 = __toESM(require_react(), 1);
var ThreadPrimitiveRoot = (0, import_react92.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime59.jsx)(Primitive.div, { ...props, ref });
});
ThreadPrimitiveRoot.displayName = "ThreadPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadEmpty.js
var ThreadPrimitiveEmpty = ({ children }) => {
  const empty = useAuiState(({ thread }) => thread.messages.length === 0 && !thread.isLoading);
  return empty ? children : null;
};
ThreadPrimitiveEmpty.displayName = "ThreadPrimitive.Empty";

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadIf.js
var useThreadIf = (props) => {
  return useAuiState(({ thread }) => {
    if (props.empty === true && !thread.isEmpty)
      return false;
    if (props.empty === false && thread.isEmpty)
      return false;
    if (props.running === true && !thread.isRunning)
      return false;
    if (props.running === false && thread.isRunning)
      return false;
    if (props.disabled === true && !thread.isDisabled)
      return false;
    if (props.disabled === false && thread.isDisabled)
      return false;
    return true;
  });
};
var ThreadPrimitiveIf = ({ children, ...query }) => {
  const result = useThreadIf(query);
  return result ? children : null;
};
ThreadPrimitiveIf.displayName = "ThreadPrimitive.If";

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadViewport.js
var import_jsx_runtime60 = __toESM(require_jsx_runtime(), 1);
var import_react95 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/primitives/thread/useThreadViewportAutoScroll.js
var import_react94 = __toESM(require_react(), 1);

// node_modules/@assistant-ui/react/dist/utils/hooks/useOnResizeContent.js
var import_react93 = __toESM(require_react(), 1);
var useOnResizeContent = (callback) => {
  const callbackRef = useCallbackRef(callback);
  const refCallback = (0, import_react93.useCallback)((el) => {
    const resizeObserver = new ResizeObserver(() => {
      callbackRef();
    });
    const mutationObserver = new MutationObserver((mutations) => {
      const hasRelevantMutation = mutations.some((m) => m.type !== "attributes" || m.attributeName !== "style");
      if (hasRelevantMutation) {
        callbackRef();
      }
    });
    resizeObserver.observe(el);
    mutationObserver.observe(el, {
      childList: true,
      subtree: true,
      attributes: true,
      characterData: true
    });
    return () => {
      resizeObserver.disconnect();
      mutationObserver.disconnect();
    };
  }, [callbackRef]);
  return useManagedRef(refCallback);
};

// node_modules/@assistant-ui/react/dist/primitives/thread/useThreadViewportAutoScroll.js
var useThreadViewportAutoScroll = ({ autoScroll, scrollToBottomOnRunStart = true, scrollToBottomOnInitialize = true, scrollToBottomOnThreadSwitch = true }) => {
  const divRef = (0, import_react94.useRef)(null);
  const threadViewportStore = useThreadViewportStore();
  if (autoScroll === void 0) {
    autoScroll = threadViewportStore.getState().turnAnchor !== "top";
  }
  const lastScrollTop = (0, import_react94.useRef)(0);
  const scrollingToBottomBehaviorRef = (0, import_react94.useRef)(null);
  const scrollToBottom = (0, import_react94.useCallback)((behavior) => {
    const div = divRef.current;
    if (!div)
      return;
    scrollingToBottomBehaviorRef.current = behavior;
    div.scrollTo({ top: div.scrollHeight, behavior });
  }, []);
  const handleScroll = () => {
    const div = divRef.current;
    if (!div)
      return;
    const isAtBottom = threadViewportStore.getState().isAtBottom;
    const newIsAtBottom = Math.abs(div.scrollHeight - div.scrollTop - div.clientHeight) < 1 || div.scrollHeight <= div.clientHeight;
    if (!newIsAtBottom && lastScrollTop.current < div.scrollTop) {
    } else {
      if (newIsAtBottom) {
        scrollingToBottomBehaviorRef.current = null;
      }
      const shouldUpdate = newIsAtBottom || scrollingToBottomBehaviorRef.current === null;
      if (shouldUpdate && newIsAtBottom !== isAtBottom) {
        writableStore(threadViewportStore).setState({
          isAtBottom: newIsAtBottom
        });
      }
    }
    lastScrollTop.current = div.scrollTop;
  };
  const resizeRef = useOnResizeContent(() => {
    const scrollBehavior = scrollingToBottomBehaviorRef.current;
    if (scrollBehavior) {
      scrollToBottom(scrollBehavior);
    } else if (autoScroll && threadViewportStore.getState().isAtBottom) {
      scrollToBottom("instant");
    }
    handleScroll();
  });
  const scrollRef = useManagedRef((el) => {
    el.addEventListener("scroll", handleScroll);
    return () => {
      el.removeEventListener("scroll", handleScroll);
    };
  });
  useOnScrollToBottom(({ behavior }) => {
    scrollToBottom(behavior);
  });
  useAuiEvent("thread.runStart", () => {
    if (!scrollToBottomOnRunStart)
      return;
    scrollingToBottomBehaviorRef.current = "auto";
    requestAnimationFrame(() => {
      scrollToBottom("auto");
    });
  });
  useAuiEvent("thread.initialize", () => {
    if (!scrollToBottomOnInitialize)
      return;
    scrollingToBottomBehaviorRef.current = "instant";
    requestAnimationFrame(() => {
      scrollToBottom("instant");
    });
  });
  useAuiEvent("threadListItem.switchedTo", () => {
    if (!scrollToBottomOnThreadSwitch)
      return;
    scrollingToBottomBehaviorRef.current = "instant";
    requestAnimationFrame(() => {
      scrollToBottom("instant");
    });
  });
  const autoScrollRef = useComposedRefs(resizeRef, scrollRef, divRef);
  return autoScrollRef;
};

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadViewport.js
var useViewportSizeRef = () => {
  const register = useThreadViewport((s) => s.registerViewport);
  const getHeight3 = (0, import_react95.useCallback)((el) => el.clientHeight, []);
  return useSizeHandle(register, getHeight3);
};
var ThreadPrimitiveViewportScrollable = (0, import_react95.forwardRef)(({ autoScroll, scrollToBottomOnRunStart, scrollToBottomOnInitialize, scrollToBottomOnThreadSwitch, children, ...rest }, forwardedRef) => {
  const autoScrollRef = useThreadViewportAutoScroll({
    autoScroll,
    scrollToBottomOnRunStart,
    scrollToBottomOnInitialize,
    scrollToBottomOnThreadSwitch
  });
  const viewportSizeRef = useViewportSizeRef();
  const ref = useComposedRefs(forwardedRef, autoScrollRef, viewportSizeRef);
  return (0, import_jsx_runtime60.jsx)(Primitive.div, { ...rest, ref, children });
});
ThreadPrimitiveViewportScrollable.displayName = "ThreadPrimitive.ViewportScrollable";
var ThreadPrimitiveViewport = (0, import_react95.forwardRef)(({ turnAnchor, ...props }, ref) => {
  return (0, import_jsx_runtime60.jsx)(ThreadPrimitiveViewportProvider, { options: { turnAnchor }, children: (0, import_jsx_runtime60.jsx)(ThreadPrimitiveViewportScrollable, { ...props, ref }) });
});
ThreadPrimitiveViewport.displayName = "ThreadPrimitive.Viewport";

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadViewportFooter.js
var import_jsx_runtime61 = __toESM(require_jsx_runtime(), 1);
var import_react96 = __toESM(require_react(), 1);
var ThreadPrimitiveViewportFooter = (0, import_react96.forwardRef)((props, forwardedRef) => {
  const register = useThreadViewport((s) => s.registerContentInset);
  const getHeight3 = (0, import_react96.useCallback)((el) => {
    const marginTop = parseFloat(getComputedStyle(el).marginTop) || 0;
    return el.offsetHeight + marginTop;
  }, []);
  const resizeRef = useSizeHandle(register, getHeight3);
  const ref = useComposedRefs(forwardedRef, resizeRef);
  return (0, import_jsx_runtime61.jsx)(Primitive.div, { ...props, ref });
});
ThreadPrimitiveViewportFooter.displayName = "ThreadPrimitive.ViewportFooter";

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadMessages.js
var import_jsx_runtime62 = __toESM(require_jsx_runtime(), 1);
var import_react97 = __toESM(require_react(), 1);
var isComponentsSame = (prev, next) => {
  return prev.Message === next.Message && prev.EditComposer === next.EditComposer && prev.UserEditComposer === next.UserEditComposer && prev.AssistantEditComposer === next.AssistantEditComposer && prev.SystemEditComposer === next.SystemEditComposer && prev.UserMessage === next.UserMessage && prev.AssistantMessage === next.AssistantMessage && prev.SystemMessage === next.SystemMessage;
};
var DEFAULT_SYSTEM_MESSAGE = () => null;
var getComponent3 = (components, role, isEditing) => {
  switch (role) {
    case "user":
      if (isEditing) {
        return components.UserEditComposer ?? components.EditComposer ?? components.UserMessage ?? components.Message;
      } else {
        return components.UserMessage ?? components.Message;
      }
    case "assistant":
      if (isEditing) {
        return components.AssistantEditComposer ?? components.EditComposer ?? components.AssistantMessage ?? components.Message;
      } else {
        return components.AssistantMessage ?? components.Message;
      }
    case "system":
      if (isEditing) {
        return components.SystemEditComposer ?? components.EditComposer ?? components.SystemMessage ?? components.Message;
      } else {
        return components.SystemMessage ?? DEFAULT_SYSTEM_MESSAGE;
      }
    default:
      const _exhaustiveCheck = role;
      throw new Error(`Unknown message role: ${_exhaustiveCheck}`);
  }
};
var ThreadMessageComponent = ({ components }) => {
  const role = useAuiState(({ message }) => message.role);
  const isEditing = useAuiState(({ message }) => message.composer.isEditing);
  const Component = getComponent3(components, role, isEditing);
  return (0, import_jsx_runtime62.jsx)(Component, {});
};
var ThreadPrimitiveMessageByIndex = (0, import_react97.memo)(({ index: index3, components }) => {
  return (0, import_jsx_runtime62.jsx)(MessageByIndexProvider, { index: index3, children: (0, import_jsx_runtime62.jsx)(ThreadMessageComponent, { components }) });
}, (prev, next) => prev.index === next.index && isComponentsSame(prev.components, next.components));
ThreadPrimitiveMessageByIndex.displayName = "ThreadPrimitive.MessageByIndex";
var ThreadPrimitiveMessagesImpl = ({ components }) => {
  const messagesLength = useAuiState(({ thread }) => thread.messages.length);
  const messageElements = (0, import_react97.useMemo)(() => {
    if (messagesLength === 0)
      return null;
    return Array.from({ length: messagesLength }, (_, index3) => (0, import_jsx_runtime62.jsx)(ThreadPrimitiveMessageByIndex, { index: index3, components }, index3));
  }, [messagesLength, components]);
  return messageElements;
};
ThreadPrimitiveMessagesImpl.displayName = "ThreadPrimitive.Messages";
var ThreadPrimitiveMessages = (0, import_react97.memo)(ThreadPrimitiveMessagesImpl, (prev, next) => isComponentsSame(prev.components, next.components));

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadScrollToBottom.js
var import_react98 = __toESM(require_react(), 1);
var useThreadScrollToBottom = ({ behavior } = {}) => {
  const isAtBottom = useThreadViewport((s) => s.isAtBottom);
  const threadViewportStore = useThreadViewportStore();
  const handleScrollToBottom = (0, import_react98.useCallback)(() => {
    threadViewportStore.getState().scrollToBottom({ behavior });
  }, [threadViewportStore, behavior]);
  if (isAtBottom)
    return null;
  return handleScrollToBottom;
};
var ThreadPrimitiveScrollToBottom = createActionButton("ThreadPrimitive.ScrollToBottom", useThreadScrollToBottom, ["behavior"]);

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadSuggestion.js
var import_react99 = __toESM(require_react(), 1);
var useThreadSuggestion = ({ prompt, send, clearComposer = true, autoSend, method: _method }) => {
  const aui = useAui();
  const disabled = useAuiState(({ thread }) => thread.isDisabled);
  const resolvedSend = send ?? autoSend ?? false;
  const callback = (0, import_react99.useCallback)(() => {
    const isRunning = aui.thread().getState().isRunning;
    if (resolvedSend && !isRunning) {
      aui.thread().append(prompt);
      if (clearComposer) {
        aui.composer().setText("");
      }
    } else {
      if (clearComposer) {
        aui.composer().setText(prompt);
      } else {
        const currentText = aui.composer().getState().text;
        aui.composer().setText(currentText.trim() ? `${currentText} ${prompt}` : prompt);
      }
    }
  }, [aui, resolvedSend, clearComposer, prompt]);
  if (disabled)
    return null;
  return callback;
};
var ThreadPrimitiveSuggestion = createActionButton("ThreadPrimitive.Suggestion", useThreadSuggestion, ["prompt", "send", "clearComposer", "autoSend", "method"]);

// node_modules/@assistant-ui/react/dist/primitives/thread/ThreadSuggestions.js
var import_jsx_runtime63 = __toESM(require_jsx_runtime(), 1);
var import_react100 = __toESM(require_react(), 1);
var SuggestionComponent = ({ components }) => {
  const Component = components.Suggestion;
  return (0, import_jsx_runtime63.jsx)(Component, {});
};
var ThreadPrimitiveSuggestionByIndex = (0, import_react100.memo)(({ index: index3, components }) => {
  return (0, import_jsx_runtime63.jsx)(SuggestionByIndexProvider, { index: index3, children: (0, import_jsx_runtime63.jsx)(SuggestionComponent, { components }) });
}, (prev, next) => prev.index === next.index && prev.components.Suggestion === next.components.Suggestion);
ThreadPrimitiveSuggestionByIndex.displayName = "ThreadPrimitive.SuggestionByIndex";
var ThreadPrimitiveSuggestionsImpl = ({ components }) => {
  const suggestionsLength = useAuiState(({ suggestions }) => suggestions.suggestions.length);
  const suggestionElements = (0, import_react100.useMemo)(() => {
    if (suggestionsLength === 0)
      return null;
    return Array.from({ length: suggestionsLength }, (_, index3) => (0, import_jsx_runtime63.jsx)(ThreadPrimitiveSuggestionByIndex, { index: index3, components }, index3));
  }, [suggestionsLength, components]);
  return suggestionElements;
};
ThreadPrimitiveSuggestionsImpl.displayName = "ThreadPrimitive.Suggestions";
var ThreadPrimitiveSuggestions = (0, import_react100.memo)(ThreadPrimitiveSuggestionsImpl, (prev, next) => prev.components.Suggestion === next.components.Suggestion);

// node_modules/@assistant-ui/react/dist/primitives/suggestion/index.js
var suggestion_exports = {};
__export(suggestion_exports, {
  Description: () => SuggestionPrimitiveDescription,
  Title: () => SuggestionPrimitiveTitle,
  Trigger: () => SuggestionPrimitiveTrigger
});

// node_modules/@assistant-ui/react/dist/primitives/suggestion/SuggestionTitle.js
var import_jsx_runtime64 = __toESM(require_jsx_runtime(), 1);
var import_react101 = __toESM(require_react(), 1);
var SuggestionPrimitiveTitle = (0, import_react101.forwardRef)((props, ref) => {
  const title = useAuiState(({ suggestion }) => suggestion.title);
  return (0, import_jsx_runtime64.jsx)(Primitive.span, { ...props, ref, children: props.children ?? title });
});
SuggestionPrimitiveTitle.displayName = "SuggestionPrimitive.Title";

// node_modules/@assistant-ui/react/dist/primitives/suggestion/SuggestionDescription.js
var import_jsx_runtime65 = __toESM(require_jsx_runtime(), 1);
var import_react102 = __toESM(require_react(), 1);
var SuggestionPrimitiveDescription = (0, import_react102.forwardRef)((props, ref) => {
  const label = useAuiState(({ suggestion }) => suggestion.label);
  return (0, import_jsx_runtime65.jsx)(Primitive.span, { ...props, ref, children: props.children ?? label });
});
SuggestionPrimitiveDescription.displayName = "SuggestionPrimitive.Description";

// node_modules/@assistant-ui/react/dist/primitives/suggestion/SuggestionTrigger.js
var import_react103 = __toESM(require_react(), 1);
var useSuggestionTrigger = ({ send, clearComposer = true }) => {
  const aui = useAui();
  const disabled = useAuiState(({ thread }) => thread.isDisabled);
  const prompt = useAuiState(({ suggestion }) => suggestion.prompt);
  const resolvedSend = send ?? false;
  const callback = (0, import_react103.useCallback)(() => {
    const isRunning = aui.thread().getState().isRunning;
    if (resolvedSend && !isRunning) {
      aui.thread().append(prompt);
      if (clearComposer) {
        aui.composer().setText("");
      }
    } else {
      if (clearComposer) {
        aui.composer().setText(prompt);
      } else {
        const currentText = aui.composer().getState().text;
        aui.composer().setText(currentText.trim() ? `${currentText} ${prompt}` : prompt);
      }
    }
  }, [aui, resolvedSend, clearComposer, prompt]);
  if (disabled)
    return null;
  return callback;
};
var SuggestionPrimitiveTrigger = createActionButton("SuggestionPrimitive.Trigger", useSuggestionTrigger, ["send", "clearComposer"]);

// node_modules/@assistant-ui/react/dist/primitives/threadList/index.js
var threadList_exports = {};
__export(threadList_exports, {
  ItemByIndex: () => ThreadListPrimitiveItemByIndex,
  Items: () => ThreadListPrimitiveItems,
  New: () => ThreadListPrimitiveNew,
  Root: () => ThreadListPrimitiveRoot
});

// node_modules/@assistant-ui/react/dist/primitives/threadList/ThreadListNew.js
var import_jsx_runtime66 = __toESM(require_jsx_runtime(), 1);
var import_react104 = __toESM(require_react(), 1);
var ThreadListPrimitiveNew = (0, import_react104.forwardRef)(({ onClick, disabled, ...props }, forwardedRef) => {
  const isMain = useAuiState(({ threads }) => threads.newThreadId === threads.mainThreadId);
  const aui = useAui();
  return (0, import_jsx_runtime66.jsx)(Primitive.button, { type: "button", ...isMain ? { "data-active": "true", "aria-current": "true" } : null, ...props, ref: forwardedRef, disabled, onClick: composeEventHandlers(onClick, () => {
    aui.threads().switchToNewThread();
  }) });
});
ThreadListPrimitiveNew.displayName = "ThreadListPrimitive.New";

// node_modules/@assistant-ui/react/dist/primitives/threadList/ThreadListItems.js
var import_jsx_runtime67 = __toESM(require_jsx_runtime(), 1);
var import_react105 = __toESM(require_react(), 1);
var ThreadListPrimitiveItemByIndex = (0, import_react105.memo)(({ index: index3, archived = false, components }) => {
  const ThreadListItemComponent = components.ThreadListItem;
  return (0, import_jsx_runtime67.jsx)(ThreadListItemByIndexProvider, { index: index3, archived, children: (0, import_jsx_runtime67.jsx)(ThreadListItemComponent, {}) });
}, (prev, next) => prev.index === next.index && prev.archived === next.archived && prev.components.ThreadListItem === next.components.ThreadListItem);
ThreadListPrimitiveItemByIndex.displayName = "ThreadListPrimitive.ItemByIndex";
var ThreadListPrimitiveItems = ({ archived = false, components }) => {
  const contentLength = useAuiState(({ threads }) => archived ? threads.archivedThreadIds.length : threads.threadIds.length);
  const listElements = (0, import_react105.useMemo)(() => {
    return Array.from({ length: contentLength }, (_, index3) => (0, import_jsx_runtime67.jsx)(ThreadListPrimitiveItemByIndex, { index: index3, archived, components }, index3));
  }, [contentLength, archived, components]);
  return listElements;
};
ThreadListPrimitiveItems.displayName = "ThreadListPrimitive.Items";

// node_modules/@assistant-ui/react/dist/primitives/threadList/ThreadListRoot.js
var import_jsx_runtime68 = __toESM(require_jsx_runtime(), 1);
var import_react106 = __toESM(require_react(), 1);
var ThreadListPrimitiveRoot = (0, import_react106.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime68.jsx)(Primitive.div, { ...props, ref });
});
ThreadListPrimitiveRoot.displayName = "ThreadListPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/threadListItem/index.js
var threadListItem_exports = {};
__export(threadListItem_exports, {
  Archive: () => ThreadListItemPrimitiveArchive,
  Delete: () => ThreadListItemPrimitiveDelete,
  Root: () => ThreadListItemPrimitiveRoot,
  Title: () => ThreadListItemPrimitiveTitle,
  Trigger: () => ThreadListItemPrimitiveTrigger,
  Unarchive: () => ThreadListItemPrimitiveUnarchive
});

// node_modules/@assistant-ui/react/dist/primitives/threadListItem/ThreadListItemRoot.js
var import_jsx_runtime69 = __toESM(require_jsx_runtime(), 1);
var import_react107 = __toESM(require_react(), 1);
var ThreadListItemPrimitiveRoot = (0, import_react107.forwardRef)((props, ref) => {
  const isMain = useAuiState(({ threads, threadListItem }) => threads.mainThreadId === threadListItem.id);
  return (0, import_jsx_runtime69.jsx)(Primitive.div, { ...isMain ? { "data-active": "true", "aria-current": "true" } : null, ...props, ref });
});
ThreadListItemPrimitiveRoot.displayName = "ThreadListItemPrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/threadListItem/ThreadListItemArchive.js
var import_react108 = __toESM(require_react(), 1);
var useThreadListItemArchive = () => {
  const aui = useAui();
  return (0, import_react108.useCallback)(() => {
    aui.threadListItem().archive();
  }, [aui]);
};
var ThreadListItemPrimitiveArchive = createActionButton("ThreadListItemPrimitive.Archive", useThreadListItemArchive);

// node_modules/@assistant-ui/react/dist/primitives/threadListItem/ThreadListItemUnarchive.js
var import_react109 = __toESM(require_react(), 1);
var useThreadListItemUnarchive = () => {
  const aui = useAui();
  return (0, import_react109.useCallback)(() => {
    aui.threadListItem().unarchive();
  }, [aui]);
};
var ThreadListItemPrimitiveUnarchive = createActionButton("ThreadListItemPrimitive.Unarchive", useThreadListItemUnarchive);

// node_modules/@assistant-ui/react/dist/primitives/threadListItem/ThreadListItemDelete.js
var import_react110 = __toESM(require_react(), 1);
var useThreadListItemDelete = () => {
  const aui = useAui();
  return (0, import_react110.useCallback)(() => {
    aui.threadListItem().delete();
  }, [aui]);
};
var ThreadListItemPrimitiveDelete = createActionButton("ThreadListItemPrimitive.Delete", useThreadListItemDelete);

// node_modules/@assistant-ui/react/dist/primitives/threadListItem/ThreadListItemTrigger.js
var import_react111 = __toESM(require_react(), 1);
var useThreadListItemTrigger = () => {
  const aui = useAui();
  return (0, import_react111.useCallback)(() => {
    aui.threadListItem().switchTo();
  }, [aui]);
};
var ThreadListItemPrimitiveTrigger = createActionButton("ThreadListItemPrimitive.Trigger", useThreadListItemTrigger);

// node_modules/@assistant-ui/react/dist/primitives/threadListItem/ThreadListItemTitle.js
var import_jsx_runtime70 = __toESM(require_jsx_runtime(), 1);
var ThreadListItemPrimitiveTitle = ({ fallback }) => {
  const title = useAuiState(({ threadListItem }) => threadListItem.title);
  return (0, import_jsx_runtime70.jsx)(import_jsx_runtime70.Fragment, { children: title || fallback });
};
ThreadListItemPrimitiveTitle.displayName = "ThreadListItemPrimitive.Title";

// node_modules/@assistant-ui/react/dist/primitives/threadListItemMore/index.js
var threadListItemMore_exports = {};
__export(threadListItemMore_exports, {
  Content: () => ThreadListItemMorePrimitiveContent,
  Item: () => ThreadListItemMorePrimitiveItem,
  Root: () => ThreadListItemMorePrimitiveRoot,
  Separator: () => ThreadListItemMorePrimitiveSeparator,
  Trigger: () => ThreadListItemMorePrimitiveTrigger
});

// node_modules/@assistant-ui/react/dist/primitives/threadListItemMore/ThreadListItemMoreRoot.js
var import_jsx_runtime71 = __toESM(require_jsx_runtime(), 1);

// node_modules/@assistant-ui/react/dist/primitives/threadListItemMore/scope.js
var useDropdownMenuScope2 = createDropdownMenuScope();

// node_modules/@assistant-ui/react/dist/primitives/threadListItemMore/ThreadListItemMoreRoot.js
var ThreadListItemMorePrimitiveRoot = ({ __scopeThreadListItemMore, ...rest }) => {
  const scope = useDropdownMenuScope2(__scopeThreadListItemMore);
  return (0, import_jsx_runtime71.jsx)(Root2, { ...scope, ...rest });
};
ThreadListItemMorePrimitiveRoot.displayName = "ThreadListItemMorePrimitive.Root";

// node_modules/@assistant-ui/react/dist/primitives/threadListItemMore/ThreadListItemMoreTrigger.js
var import_jsx_runtime72 = __toESM(require_jsx_runtime(), 1);
var import_react112 = __toESM(require_react(), 1);
var ThreadListItemMorePrimitiveTrigger = (0, import_react112.forwardRef)(({ __scopeThreadListItemMore, ...rest }, ref) => {
  const scope = useDropdownMenuScope2(__scopeThreadListItemMore);
  return (0, import_jsx_runtime72.jsx)(Trigger, { ...scope, ...rest, ref });
});
ThreadListItemMorePrimitiveTrigger.displayName = "ThreadListItemMorePrimitive.Trigger";

// node_modules/@assistant-ui/react/dist/primitives/threadListItemMore/ThreadListItemMoreContent.js
var import_jsx_runtime73 = __toESM(require_jsx_runtime(), 1);
var import_react113 = __toESM(require_react(), 1);
var ThreadListItemMorePrimitiveContent = (0, import_react113.forwardRef)(({ __scopeThreadListItemMore, portalProps, sideOffset = 4, ...props }, forwardedRef) => {
  const scope = useDropdownMenuScope2(__scopeThreadListItemMore);
  return (0, import_jsx_runtime73.jsx)(Portal2, { ...scope, ...portalProps, children: (0, import_jsx_runtime73.jsx)(Content2, { ...scope, ...props, ref: forwardedRef, sideOffset }) });
});
ThreadListItemMorePrimitiveContent.displayName = "ThreadListItemMorePrimitive.Content";

// node_modules/@assistant-ui/react/dist/primitives/threadListItemMore/ThreadListItemMoreItem.js
var import_jsx_runtime74 = __toESM(require_jsx_runtime(), 1);
var import_react114 = __toESM(require_react(), 1);
var ThreadListItemMorePrimitiveItem = (0, import_react114.forwardRef)(({ __scopeThreadListItemMore, ...rest }, ref) => {
  const scope = useDropdownMenuScope2(__scopeThreadListItemMore);
  return (0, import_jsx_runtime74.jsx)(Item2, { ...scope, ...rest, ref });
});
ThreadListItemMorePrimitiveItem.displayName = "ThreadListItemMorePrimitive.Item";

// node_modules/@assistant-ui/react/dist/primitives/threadListItemMore/ThreadListItemMoreSeparator.js
var import_jsx_runtime75 = __toESM(require_jsx_runtime(), 1);
var import_react115 = __toESM(require_react(), 1);
var ThreadListItemMorePrimitiveSeparator = (0, import_react115.forwardRef)(({ __scopeThreadListItemMore, ...rest }, ref) => {
  const scope = useDropdownMenuScope2(__scopeThreadListItemMore);
  return (0, import_jsx_runtime75.jsx)(Separator2, { ...scope, ...rest, ref });
});
ThreadListItemMorePrimitiveSeparator.displayName = "ThreadListItemMorePrimitive.Separator";

// node_modules/@assistant-ui/react/dist/primitives/messagePart/useMessagePartReasoning.js
var useMessagePartReasoning = () => {
  const text = useAuiState(({ part }) => {
    if (part.type !== "reasoning")
      throw new Error("MessagePartReasoning can only be used inside reasoning message parts.");
    return part;
  });
  return text;
};

// node_modules/@assistant-ui/react/dist/primitives/messagePart/useMessagePartSource.js
var useMessagePartSource = () => {
  const source = useAuiState(({ part }) => {
    if (part.type !== "source")
      throw new Error("MessagePartSource can only be used inside source message parts.");
    return part;
  });
  return source;
};

// node_modules/@assistant-ui/react/dist/primitives/messagePart/useMessagePartFile.js
var useMessagePartFile = () => {
  const file2 = useAuiState(({ part }) => {
    if (part.type !== "file")
      throw new Error("MessagePartFile can only be used inside file message parts.");
    return part;
  });
  return file2;
};

// node_modules/@assistant-ui/react/dist/primitives/messagePart/useMessagePartData.js
var useMessagePartData = (name) => {
  const part = useAuiState(({ part: part2 }) => {
    if (part2.type !== "data") {
      return null;
    }
    return part2;
  });
  if (!part) {
    return null;
  }
  if (name && part.name !== name) {
    return null;
  }
  return part;
};

// node_modules/@assistant-ui/react/dist/primitives/reasoning/useScrollLock.js
var import_react116 = __toESM(require_react(), 1);
var useScrollLock = (animatedElementRef, animationDuration) => {
  const scrollContainerRef = (0, import_react116.useRef)(null);
  const cleanupRef = (0, import_react116.useRef)(null);
  (0, import_react116.useEffect)(() => {
    return () => {
      var _a3;
      (_a3 = cleanupRef.current) == null ? void 0 : _a3.call(cleanupRef);
    };
  }, []);
  const lockScroll = (0, import_react116.useCallback)(() => {
    var _a3;
    (_a3 = cleanupRef.current) == null ? void 0 : _a3.call(cleanupRef);
    (function findScrollableAncestor() {
      if (scrollContainerRef.current || !animatedElementRef.current)
        return;
      let el = animatedElementRef.current;
      while (el) {
        const { overflowY } = getComputedStyle(el);
        if (overflowY === "scroll" || overflowY === "auto") {
          scrollContainerRef.current = el;
          break;
        }
        el = el.parentElement;
      }
    })();
    const scrollContainer = scrollContainerRef.current;
    if (!scrollContainer)
      return;
    const scrollPosition = scrollContainer.scrollTop;
    const scrollbarWidth = scrollContainer.style.scrollbarWidth;
    scrollContainer.style.scrollbarWidth = "none";
    const resetPosition = () => scrollContainer.scrollTop = scrollPosition;
    scrollContainer.addEventListener("scroll", resetPosition);
    const timeoutId = setTimeout(() => {
      scrollContainer.removeEventListener("scroll", resetPosition);
      scrollContainer.style.scrollbarWidth = scrollbarWidth;
      cleanupRef.current = null;
    }, animationDuration);
    cleanupRef.current = () => {
      clearTimeout(timeoutId);
      scrollContainer.removeEventListener("scroll", resetPosition);
      scrollContainer.style.scrollbarWidth = scrollbarWidth;
    };
  }, [animationDuration, animatedElementRef]);
  return lockScroll;
};

// node_modules/@assistant-ui/react/dist/client/ExternalThread.js
var MessageClient2 = resource(({ message, index: index3, onEdit, onReload }) => {
  const [isCopied, setIsCopied] = tapState(false);
  const [isHovering, setIsHovering] = tapState(false);
  const [isEditing, setIsEditing] = tapState(false);
  const partClients = tapClientLookup(() => message.content.map((part, idx) => withKey(idx, PartResource({ part }))), [message.content]);
  const attachmentClients = tapClientLookup(() => (message.attachments ?? []).map((attachment) => withKey(attachment.id, AttachmentResource({
    attachment,
    onRemove: () => {
    }
  }))), [message.attachments]);
  const handleBeginEdit = () => {
    setIsEditing(true);
  };
  const handleCancelEdit = () => {
    setIsEditing(false);
  };
  const handleSendEdit = (msg) => {
    onEdit == null ? void 0 : onEdit({
      ...msg,
      parentId: message.id,
      sourceId: message.id
    });
    setIsEditing(false);
  };
  const composerClient = tapClientResource(ComposerClientResource({
    type: "edit",
    isEditing,
    canCancel: true,
    onCancel: handleCancelEdit,
    onBeginEdit: handleBeginEdit,
    onSend: handleSendEdit,
    message
  }));
  const state = tapMemo(() => {
    return {
      ...message,
      attachments: message.attachments ?? [],
      parentId: null,
      isLast: false,
      // Will be set by thread
      branchNumber: 1,
      branchCount: 1,
      speech: void 0,
      submittedFeedback: void 0,
      parts: partClients.state,
      isCopied,
      isHovering,
      index: index3,
      composer: composerClient.state
    };
  }, [
    message,
    isCopied,
    isHovering,
    index3,
    composerClient.state,
    partClients.state
  ]);
  return {
    state,
    methods: {
      getState: () => state,
      composer: composerClient.methods,
      reload: () => {
        onReload == null ? void 0 : onReload();
      },
      speak: () => {
      },
      stopSpeaking: () => {
      },
      submitFeedback: () => {
      },
      switchToBranch: () => {
      },
      getCopyText: () => message.content.map((c) => "text" in c ? c.text : "").join(""),
      part: (selector) => {
        if ("index" in selector) {
          return partClients.get(selector);
        }
        const partIndex = state.parts.findIndex((p) => p.type === "tool-call" && p.toolCallId === selector.toolCallId);
        return partClients.get({ index: partIndex });
      },
      attachment: (selector) => {
        if ("id" in selector) {
          return attachmentClients.get({ key: selector.id });
        }
        return attachmentClients.get(selector);
      },
      setIsCopied,
      setIsHovering
    }
  };
});
var PartResource = resource(({ part }) => {
  const state = tapMemo(() => ({
    ...part,
    status: { type: "complete" }
  }), [part]);
  return {
    state,
    methods: {
      getState: () => state,
      addToolResult: () => {
      },
      resumeToolCall: () => {
      }
    }
  };
});
var AttachmentResource = resource(({ attachment, onRemove }) => {
  return {
    state: attachment,
    methods: {
      getState: () => attachment,
      remove: async () => {
        onRemove == null ? void 0 : onRemove();
      }
    }
  };
});
var ComposerClientResource = resource(({ type, isEditing, canCancel, onCancel, onBeginEdit, onSend, message }) => {
  const [text, setText] = tapState("");
  const [role, setRole] = tapState("user");
  const [runConfig, setRunConfig] = tapState({});
  const [attachments, setAttachments] = tapState([]);
  const updateFromMessage = tapEffectEvent(() => {
    if (message) {
      const textParts = message.content.filter((part) => part.type === "text");
      const messageText = textParts.map((part) => "text" in part ? part.text : "").join("\n\n");
      setText(messageText);
      setRole(message.role);
      setAttachments(message.attachments ?? []);
    }
  });
  tapEffect(() => {
    if (isEditing) {
      updateFromMessage();
    }
  }, [isEditing]);
  const attachmentClients = tapClientLookup(() => attachments.map((attachment, idx) => withKey(attachment.id, AttachmentResource({
    attachment,
    onRemove: () => {
      setAttachments(attachments.filter((_, i) => i !== idx));
    }
  }))), [attachments]);
  const state = tapMemo(() => ({
    text,
    role,
    attachments: attachmentClients.state,
    runConfig,
    isEditing,
    canCancel,
    attachmentAccept: "*",
    isEmpty: !text.trim() && !attachments.length,
    type,
    dictation: void 0
  }), [
    text,
    role,
    attachmentClients.state,
    runConfig,
    isEditing,
    canCancel,
    type,
    attachments.length
  ]);
  return {
    state,
    methods: {
      getState: () => state,
      setText,
      setRole,
      setRunConfig,
      addAttachment: async (file2) => {
        const newAttachment = {
          id: Math.random().toString(36).substring(7),
          type: "file",
          name: file2.name,
          contentType: file2.type,
          file: file2,
          status: { type: "complete" },
          content: []
        };
        setAttachments([...attachments, newAttachment]);
      },
      clearAttachments: async () => {
        setAttachments([]);
      },
      attachment: (selector) => {
        if ("id" in selector) {
          return attachmentClients.get({ key: selector.id });
        }
        return attachmentClients.get(selector);
      },
      reset: async () => {
        setText("");
        setRole("user");
        setRunConfig({});
        setAttachments([]);
      },
      send: () => {
        const message2 = {
          role,
          content: text ? [{ type: "text", text }] : [],
          attachments,
          createdAt: /* @__PURE__ */ new Date(),
          runConfig
        };
        onSend == null ? void 0 : onSend(message2);
        setText("");
        setAttachments([]);
      },
      cancel: onCancel,
      beginEdit: () => {
        onBeginEdit == null ? void 0 : onBeginEdit();
      },
      startDictation: () => {
      },
      stopDictation: () => {
      }
    }
  };
});
var ExternalThread = resource(({ messages, isRunning = false, onNew, onEdit, onReload, onStartRun, onCancel }) => {
  const handleReload = (messageId) => {
    const messageIndex = messages.findIndex((m) => m.id === messageId);
    if (messageIndex === -1)
      return;
    const parentId = messageIndex > 0 ? messages[messageIndex - 1].id : null;
    onReload == null ? void 0 : onReload(parentId);
  };
  const messageClients = tapClientLookup(() => messages.map((msg, index3) => {
    const props = {
      message: msg,
      index: index3,
      onReload: () => handleReload(msg.id)
    };
    if (onEdit)
      props.onEdit = onEdit;
    return withKey(msg.id, MessageClient2(props));
  }), [messages, onEdit]);
  const handleCancelRun = () => {
    onCancel == null ? void 0 : onCancel();
  };
  const handleSendNew = (message) => {
    onNew == null ? void 0 : onNew(message);
  };
  const composerClient = tapClientResource(ComposerClientResource({
    type: "thread",
    isEditing: true,
    canCancel: isRunning,
    onCancel: handleCancelRun,
    onSend: handleSendNew
  }));
  const state = tapMemo(() => {
    const messageStates = messageClients.state.map((s, idx, arr) => ({
      ...s,
      isLast: idx === arr.length - 1
    }));
    return {
      isEmpty: messages.length === 0,
      isDisabled: false,
      isLoading: false,
      isRunning,
      capabilities: {
        edit: false,
        reload: false,
        cancel: isRunning,
        speech: false,
        attachments: false,
        feedback: false,
        switchToBranch: false,
        switchBranchDuringRun: false,
        unstable_copy: false,
        dictation: false
      },
      messages: messageStates,
      state: {},
      suggestions: [],
      extras: void 0,
      speech: void 0,
      composer: composerClient.state
    };
  }, [messages, isRunning, messageClients.state, composerClient.state]);
  return {
    state,
    methods: {
      getState: () => state,
      composer: composerClient.methods,
      append: (message) => {
        onNew == null ? void 0 : onNew(message);
      },
      startRun: () => {
        onStartRun == null ? void 0 : onStartRun();
      },
      unstable_resumeRun: () => {
      },
      cancelRun: handleCancelRun,
      getModelContext: () => ({ tools: {}, config: {} }),
      export: () => ({ messages: [] }),
      import: () => {
      },
      reset: () => {
      },
      message: (selector) => {
        if ("id" in selector) {
          return messageClients.get({ key: selector.id });
        }
        return messageClients.get(selector);
      },
      stopSpeaking: () => {
      },
      startVoice: async () => {
      },
      stopVoice: async () => {
      }
    }
  };
});
attachDefaultPeers(ExternalThread, {
  modelContext: ModelContext(),
  tools: Tools({}),
  suggestions: Suggestions(),
  composer: Derived({
    source: "thread",
    query: {},
    get: (aui) => aui.thread().composer
  })
});

// node_modules/@assistant-ui/react/dist/client/InMemoryThreadList.js
var ThreadListItemClient2 = resource((props) => {
  const { data, onSwitchTo, onArchive, onUnarchive, onDelete } = props;
  const state = tapMemo(() => ({
    id: data.id,
    remoteId: void 0,
    externalId: void 0,
    title: data.title,
    status: data.status
  }), [data.id, data.title, data.status]);
  return {
    state,
    methods: {
      getState: () => state,
      switchTo: onSwitchTo,
      rename: () => {
      },
      archive: onArchive,
      unarchive: onUnarchive,
      delete: onDelete,
      generateTitle: () => {
      },
      initialize: async () => ({ remoteId: data.id, externalId: void 0 }),
      detach: () => {
      }
    }
  };
});
var InMemoryThreadList = resource((props) => {
  const { thread: threadFactory, onSwitchToThread, onSwitchToNewThread } = props;
  const [mainThreadId, setMainThreadId] = tapState("main");
  const [threads, setThreads] = tapState(() => [
    { id: "main", title: "Main Thread", status: "regular" }
  ]);
  const handleSwitchToThread = (threadId) => {
    setMainThreadId(threadId);
    onSwitchToThread == null ? void 0 : onSwitchToThread(threadId);
  };
  const handleArchive = (threadId) => {
    setThreads((prev) => prev.map((t) => t.id === threadId ? { ...t, status: "archived" } : t));
  };
  const handleUnarchive = (threadId) => {
    setThreads((prev) => prev.map((t) => t.id === threadId ? { ...t, status: "regular" } : t));
  };
  const handleDelete = (threadId) => {
    var _a3;
    setThreads((prev) => prev.filter((t) => t.id !== threadId));
    if (mainThreadId === threadId) {
      const remaining = threads.filter((t) => t.id !== threadId);
      setMainThreadId(((_a3 = remaining[0]) == null ? void 0 : _a3.id) || "main");
    }
  };
  const handleSwitchToNewThread = () => {
    const newId = `thread-${Date.now()}`;
    setThreads((prev) => [
      ...prev,
      { id: newId, title: "New Thread", status: "regular" }
    ]);
    setMainThreadId(newId);
    onSwitchToNewThread == null ? void 0 : onSwitchToNewThread();
  };
  const threadListItems = tapClientLookup(() => threads.map((t) => withKey(t.id, ThreadListItemClient2({
    data: t,
    onSwitchTo: () => handleSwitchToThread(t.id),
    onArchive: () => handleArchive(t.id),
    onUnarchive: () => handleUnarchive(t.id),
    onDelete: () => handleDelete(t.id)
  }))), [threads]);
  const mainThreadClient = tapClientResource(threadFactory(mainThreadId));
  const state = tapMemo(() => {
    const regularThreads = threads.filter((t) => t.status === "regular");
    const archivedThreads = threads.filter((t) => t.status === "archived");
    const mainThreadState = mainThreadClient.state;
    return {
      mainThreadId,
      newThreadId: null,
      isLoading: false,
      threadIds: regularThreads.map((t) => t.id),
      archivedThreadIds: archivedThreads.map((t) => t.id),
      threadItems: threadListItems.state,
      main: mainThreadState
    };
  }, [mainThreadId, threads, threadListItems.state, mainThreadClient.state]);
  return {
    state,
    methods: {
      getState: () => state,
      switchToThread: handleSwitchToThread,
      switchToNewThread: handleSwitchToNewThread,
      item: (selector) => {
        if (selector === "main") {
          const index3 = threads.findIndex((t) => t.id === mainThreadId);
          return threadListItems.get({ index: index3 === -1 ? 0 : index3 });
        }
        if ("id" in selector) {
          const index3 = threads.findIndex((t) => t.id === selector.id);
          return threadListItems.get({ index: index3 });
        }
        return threadListItems.get(selector);
      },
      thread: () => mainThreadClient.methods
    }
  };
});
attachDefaultPeers(InMemoryThreadList, {
  thread: Derived({
    source: "threads",
    query: { type: "main" },
    get: (aui) => aui.threads().thread("main")
  }),
  threadListItem: Derived({
    source: "threads",
    query: { type: "main" },
    get: (aui) => aui.threads().item("main")
  }),
  composer: Derived({
    source: "thread",
    query: {},
    get: (aui) => aui.threads().thread("main").composer
  }),
  modelContext: ModelContext(),
  tools: Tools({}),
  suggestions: Suggestions()
});

export {
  AuiProvider,
  useAui,
  useAuiState,
  useAuiEvent,
  AuiIf,
  ExportedMessageRepository,
  getExternalStoreMessage,
  getExternalStoreMessages,
  toToolsJSONSchema,
  SimpleImageAttachmentAdapter,
  SimpleTextAttachmentAdapter,
  CompositeAttachmentAdapter,
  CloudFileAttachmentAdapter,
  WebSpeechSynthesisAdapter,
  WebSpeechDictationAdapter,
  RuntimeAdapterProvider,
  useRuntimeAdapters,
  useExternalStoreRuntime,
  InMemoryThreadListAdapter,
  useAssistantTransportSendCommand,
  useAssistantTransportState,
  useAssistantTransportRuntime,
  convertExternalMessages,
  useExternalMessageConverter,
  createMessageConverter,
  AssistantCloud,
  useCloudThreadListAdapter,
  useLocalRuntime,
  internal_exports,
  ModelContext,
  useAssistantTool,
  makeAssistantTool,
  useAssistantToolUI,
  makeAssistantToolUI,
  useAssistantInstructions,
  useInlineRender,
  tool,
  makeAssistantVisible,
  Tools,
  Suggestions,
  ModelContextRegistry,
  FRAME_MESSAGE_CHANNEL,
  AssistantFrameHost,
  AssistantFrameProvider,
  useAssistantFrameHost,
  useThreadViewport,
  useThreadViewportStore,
  DevToolsHooks,
  DevToolsProviderApi,
  AssistantRuntimeProvider,
  ThreadListItemByIndexProvider,
  ThreadListItemRuntimeProvider,
  MessageByIndexProvider,
  SuggestionByIndexProvider,
  PartByIndexProvider,
  MessageAttachmentByIndexProvider,
  ComposerAttachmentByIndexProvider,
  TextMessagePartProvider,
  MessageProvider,
  useRemoteThreadListRuntime,
  useCloudThreadListRuntime,
  useAssistantRuntime,
  useThreadList,
  useAttachmentRuntime,
  useThreadComposerAttachmentRuntime,
  useEditComposerAttachmentRuntime,
  useMessageAttachmentRuntime,
  useAttachment,
  useThreadComposerAttachment,
  useEditComposerAttachment,
  useMessageAttachment,
  useComposerRuntime,
  useComposer,
  useMessageRuntime,
  useMessage,
  useEditComposer,
  useMessagePartRuntime,
  useMessagePart,
  useThreadRuntime,
  useThread,
  useThreadComposer,
  useThreadModelContext,
  useThreadListItemRuntime,
  useThreadListItem,
  actionBar_exports,
  actionBarMore_exports,
  assistantModal_exports,
  attachment_exports,
  ChainOfThoughtClient,
  useMessagePartText,
  useMessagePartImage,
  message_exports,
  branchPicker_exports,
  chainOfThought_exports,
  composer_exports,
  messagePart_exports,
  error_exports,
  useThreadViewportAutoScroll,
  thread_exports,
  suggestion_exports,
  threadList_exports,
  threadListItem_exports,
  threadListItemMore_exports,
  useMessagePartReasoning,
  useMessagePartSource,
  useMessagePartFile,
  useMessagePartData,
  useScrollLock,
  ExternalThread,
  InMemoryThreadList
};
//# sourceMappingURL=chunk-4AE6EZKI.js.map
